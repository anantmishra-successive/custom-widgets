import { c as Py } from "../../chunks/runtime.js";
import { WebChartTypes as b, defaultPieFromFieldsName as tt, defaultPieFromFieldsValue as Rt, WebChartTemporalBinningTypes as wi, WebChartSortOrderKinds as ri, WebChartDataTransformations as Vt, WebChartOrderDataByTypes as en, WebChartStackedKinds as Ie, WebChartStatisticType as X, WebChartTemporalBinningUnits as Q, RESTFieldType as fr, WebChartNullPolicyTypes as on, WebChartTimeAggregationTypes as Yt, StatisticsDefaults as mr, WebChartLabelBehavior as De, RESTRendererType as qt, RESTSymbolType as re, RESTSimpleLineSymbolStyle as xt, RESTSimpleMarkerSymbolStyle as Xt, RESTSimpleFillSymbolStyle as Ot, RESTVerticalAlignment as ce, RESTHorizontalAlignment as he, RESTFontDecoration as ll, WebChartLegendPositions as me, OverlayTerms as ze, SizePolicyScaleTypes as $a, WebChartRadarChartAxisLabelsOrientation as Pd, WebChartLineSmoothedKinds as Rd, WebChartAxisTypes as Nn, WebChartVersionStatus as Ry } from "@arcgis/charts-spec";
import { LitElement as Vy, createEvent as ni, safeClassMap as Vd } from "@arcgis/lumina";
import Ey from "html2canvas";
import Wy from "jszip";
import { html as zy } from "lit";
import { createRef as Hy, ref as Ed } from "lit-html/directives/ref.js";
import { cloneDeep as Ee, isArray as ac, isEmpty as tn, isEqual as Di, sortBy as Wd, debounce as at } from "lodash-es";
import { color as No, percent as Ni, LinePattern as Nf, RectanglePattern as qy, p50 as Re, p0 as St, p100 as ct, Label as Pa, Rectangle as nc, DateFormatter as Gy, NumberFormatter as Mf, Timezone as Yy, Series as oc, Container as Mn, Legend as $f, Scrollbar as Il, SerialChart as Wn, Tooltip as Kn, Template as Jn, Graphics as ga, Bullet as za, RoundedRectangle as Mo, Slice as zn, DataItem as Xy, Modal as Uy, addLicense as jy, registry as _y, Root as Zy } from "@amcharts/amcharts5";
import { PieChart as sn, PieSeries as Jt } from "@amcharts/amcharts5/percent.js";
import { AxisRendererCircular as ta, RadarCursor as Pf, ClockHand as Ol, RadarChart as Ra, AxisRendererRadial as Qy, RadarLineSeries as sc } from "@amcharts/amcharts5/radar.js";
import { XYChart as Te, AxisRendererX as li, LineSeries as Ae, DateAxis as nt, XYCursor as Rf, StepLineSeries as gr, CandlestickSeries as bn, ValueAxis as We, ColumnSeries as Ft, XYSeries as rc, CategoryAxis as jt, AxisRendererY as rn, AxisBullet as Ky } from "@amcharts/amcharts5/xy.js";
import { c as $o } from "../../chunks/index.js";
import { aW as ln, cs as L, k as H, c2 as Ri, bO as we, Y as Si, s as Vi, M as ot, cf as hr, aU as eo, z as pt, m as ci, l as ei, aJ as to, V as Ut, L as Oa, c9 as Ve, cd as be, h as Lt, ck as Jy, c3 as di, c5 as ti, H as Y, e as Ze, x as oe, co as Vf, bS as ia, D as de, bD as eb, bR as Gt, A as lc, bl as aa, bt as Xe, t as Hn, b as ha, q as ko, c6 as zd, aK as Uo, i as pr, a_ as At, W as jo, r as _o, c8 as Ba, bk as Zo, bx as tb, bJ as ib, aX as nn, K as ab, b1 as cc, b8 as Ef, bi as nb, b9 as ob, bH as Po, bI as yr, bg as sb, ce as cl, bM as rb, aY as lb, bh as cb, N as db, n as cn, bc as Wf, bn as dc, bo as ub, J as fb, I as Hd, bp as zf, bj as mb, b4 as gb, b6 as uc, b7 as br, P as io, au as Hs, O as Qo, c0 as G, bm as hb, cb as Hf, B as fc, cj as rt, c7 as qf, a6 as mc, a8 as Gf, ai as Yf, ah as gc, a7 as Sr, ct as Ue, cv as Ro, ch as qs, aG as Xf, bC as la, bZ as Uf, G as xr, F as pb, a3 as Cr, aq as jf, ae as hc, ag as _f, af as Zf, E as Qf, bQ as Gs, aZ as qn, v as pc, aN as Kf, S as yb, X as bb, y as Sb, bq as xb, c4 as qd, bN as Gd, o as Fo, g as Cb, ci as vb, C as Fb, cl as Lb, a as Ab, bT as Tb } from "../../chunks/interfaces.js";
import { A as ne, C as dl, L as Ds, d as Ns, e as Ms, S as $s, V as Ao, b as Yd, E as bs, a as wb } from "../../chunks/index2.js";
import "@arcgis/core/core/promiseUtils.js";
import kb from "@arcgis/core/request.js";
import "@arcgis/core/geometry/support/jsonUtils.js";
import "@arcgis/core/rest/support/AttributeBinsQuery.js";
import "@arcgis/core/rest/support/Query.js";
import "@arcgis/core/rest/support/StatisticDefinition.js";
import "@arcgis/core/time/TimeExtent.js";
import { b as Ys, d as $n, c as Jf, q as em, s as ul, t as Ib, r as Ob, h as Xi, u as vr } from "../../chunks/index4.js";
import { g as z } from "../../chunks/series-types.js";
import { extent as Bb, mean as Db, max as Nb, min as Mb, sum as $b, rollup as Pb, range as Rb } from "d3-array";
import * as Vb from "@arcgis/core/renderers/support/jsonUtils.js";
import * as fl from "@arcgis/core/symbols/support/symbolUtils.js";
import Eb from "@arcgis/core/Graphic.js";
import { C as k, D as Wb, t as Xd, b as Ud, m as zb } from "../../chunks/web-component-utils.js";
import Hb from "@arcgis/core/layers/support/FeatureFilter.js";
import qb from "@arcgis/core/Map.js";
import Gb from "@arcgis/core/smartMapping/statistics/histogram.js";
import Yb from "@arcgis/core/smartMapping/statistics/summaryStatistics.js";
import Xb from "@arcgis/core/views/MapView.js";
import { linearRegression as Ub, linearRegressionLine as jb, rSquared as _b } from "simple-statistics";
import { v5 as Xs } from "uuid";
import Zb from "@amcharts/amcharts5/themes/Animated.js";
import Qb from "@amcharts/amcharts5/themes/Responsive.js";
import { LineSeriesDataItem as Ha, XYChart as fe, DateAxis as Ge, ValueAxis as Ne, CategoryAxis as kt, CategoryAxisDataItem as Gn, DateAxisDataItem as Fr, PieChart as Me, AxisFill as Kb, AxisFillCircular as Jb, SerialChart as tm, LineSeries as ye, ColumnSeries as it, GaugeChart as zt, Cursor as eS, AxisLabel as yc, ColumnSeriesDataItem as Ko, CandlestickSeries as ut, StepLineSeries as _t, PieSeries as xi, XYSeries as ca, LegendDataItem as qa, CandlestickSeriesDataItem as tS, PieSeriesDataItem as ji, Legend as iS, Series as aS, XYCursor as im, AxisRendererX as oi, AxisLabelCircular as bc, AxisRendererCircular as Lr, ValueAxisDataItem as Sc, AxisRendererY as Yn, ClockHand as nS } from "@amcharts/amcharts4/charts.js";
import { Exporting as oS } from "@amcharts/amcharts5/plugins/exporting.js";
import { isLight as sS } from "@amcharts/amcharts5/.internal/core/util/Utils.js";
import { curveLinearClosed as rS, curveLinear as lS, curveCardinal as cS, curveBumpY as dS, curveBumpX as uS } from "d3-shape";
import { DateFormatter as am, NumberFormatter as nm, Group as fS, Color as Us, percent as Ct, LinePattern as om, RectPattern as sm, Label as Vo, DropShadowFilter as mS, Sprite as xc, color as Ar, utils as rm, Polygon as lm, Container as Cc, Tooltip as cm, MouseCursorStyle as ki, RoundedRectangle as gS, Percent as js, Slice as dm, options as Io, useTheme as hS, unuseTheme as pS, create as vc } from "@amcharts/amcharts4/core.js";
import jd from "@amcharts/amcharts4/themes/animated.js";
import "@amcharts/amcharts4/.internal/charts/axes/Axis.js";
import { isLight as yS } from "@amcharts/amcharts4/.internal/core/utils/Colors.js";
import { Scrollbar as _d } from "@amcharts/amcharts4/.internal/core/elements/Scrollbar.js";
import { u as Zd } from "../../chunks/useT9n.js";
import { f as bS } from "../../chunks/interfaces2.js";
import { i as Qd, a as SS, b as xS } from "../../chunks/type-guards.js";
import { u as CS, o as vS } from "../../chunks/action-bar-utils.js";
import * as sa from "@arcgis/core/core/reactiveUtils.js";
import { html as ml } from "lit-html";
import { css as FS } from "@lit/reactive-element/css-tag.js";
/*! All material copyright Esri, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.33/esri/copyright.txt for details.
v4.33.19 */
var Ss = { exports: {} }, gl, Kd;
function LS() {
  if (Kd) return gl;
  Kd = 1;
  function t(e) {
    var i = new e(), a = i;
    function n() {
      var s = i;
      return s.next ? i = s.next : (i = new e(), a = i), s.next = null, s;
    }
    function o(s) {
      a.next = s, a = s;
    }
    return {
      get: n,
      release: o
    };
  }
  return gl = t, gl;
}
var Jd;
function AS() {
  if (Jd) return Ss.exports;
  Jd = 1;
  var t = LS();
  function e(o, s, r) {
    if (typeof o == "function" && (r = s, s = o, o = null), r < 1)
      throw new Error("fastqueue concurrency must be greater than 1");
    var l = t(a), c = null, d = null, u = 0, f = null, m = {
      push: F,
      drain: i,
      saturated: i,
      pause: y,
      paused: !1,
      concurrency: r,
      running: g,
      resume: x,
      idle: C,
      length: p,
      getQueue: S,
      unshift: v,
      empty: i,
      kill: w,
      killAndDrain: O,
      error: I
    };
    return m;
    function g() {
      return u;
    }
    function y() {
      m.paused = !0;
    }
    function p() {
      for (var N = c, M = 0; N; )
        N = N.next, M++;
      return M;
    }
    function S() {
      for (var N = c, M = []; N; )
        M.push(N.value), N = N.next;
      return M;
    }
    function x() {
      if (m.paused) {
        m.paused = !1;
        for (var N = 0; N < m.concurrency; N++)
          u++, A();
      }
    }
    function C() {
      return u === 0 && m.length() === 0;
    }
    function F(N, M) {
      var P = l.get();
      P.context = o, P.release = A, P.value = N, P.callback = M || i, P.errorHandler = f, u === m.concurrency || m.paused ? d ? (d.next = P, d = P) : (c = P, d = P, m.saturated()) : (u++, s.call(o, P.value, P.worked));
    }
    function v(N, M) {
      var P = l.get();
      P.context = o, P.release = A, P.value = N, P.callback = M || i, u === m.concurrency || m.paused ? c ? (P.next = c, c = P) : (c = P, d = P, m.saturated()) : (u++, s.call(o, P.value, P.worked));
    }
    function A(N) {
      N && l.release(N);
      var M = c;
      M ? m.paused ? u-- : (d === c && (d = null), c = M.next, M.next = null, s.call(o, M.value, M.worked), d === null && m.empty()) : --u === 0 && m.drain();
    }
    function w() {
      c = null, d = null, m.drain = i;
    }
    function O() {
      c = null, d = null, m.drain(), m.drain = i;
    }
    function I(N) {
      f = N;
    }
  }
  function i() {
  }
  function a() {
    this.value = null, this.callback = i, this.next = null, this.release = i, this.context = null, this.errorHandler = null;
    var o = this;
    this.worked = function(r, l) {
      var c = o.callback, d = o.errorHandler, u = o.value;
      o.value = null, o.callback = i, o.errorHandler && d(r, u), c.call(o.context, r, l), o.release(o);
    };
  }
  function n(o, s, r) {
    typeof o == "function" && (r = s, s = o, o = null);
    function l(y, p) {
      s.call(this, y).then(function(S) {
        p(null, S);
      }, p);
    }
    var c = e(o, l, r), d = c.push, u = c.unshift;
    return c.push = f, c.unshift = m, c.drained = g, c;
    function f(y) {
      var p = new Promise(function(S, x) {
        d(y, function(C, F) {
          if (C) {
            x(C);
            return;
          }
          S(F);
        });
      });
      return p.catch(i), p;
    }
    function m(y) {
      var p = new Promise(function(S, x) {
        u(y, function(C, F) {
          if (C) {
            x(C);
            return;
          }
          S(F);
        });
      });
      return p.catch(i), p;
    }
    function g() {
      var y = c.drain, p = new Promise(function(S) {
        c.drain = function() {
          y(), S();
        };
      });
      return p;
    }
  }
  return Ss.exports = e, Ss.exports.promise = n, Ss.exports;
}
var TS = AS();
const Fa = {
  Show: "show",
  Hide: "hide",
  NotifyPanel: "notifyPanel",
  DisableInteractions: "disable-interactions",
  Chart: "chart"
};
async function Ga(t, e) {
  const i = e.errors[t];
  throw new ln(e.modalHeaders.error, i ?? e.errors.simpleError);
}
function ii(t) {
  return t.axes?.[0]?.valueFormat?.type;
}
function _i(t) {
  return t.intlOptions;
}
function Pe(t) {
  return t?.type === b.NumberAxisFormat;
}
function ao(t) {
  return Pe(t) && t.intlOptions?.style === "percent";
}
function Ya(t) {
  return t?.type === b.CategoryAxisFormat;
}
function mi(t) {
  return t?.type === b.DateAxisFormat;
}
function um(t) {
  const { oldConfig: e, newConfig: i, rotationChanged: a } = t;
  return a ? [!0, !0] : [
    e.horizontalAxisLabelsBehavior !== i.horizontalAxisLabelsBehavior,
    e.verticalAxisLabelsBehavior !== i.verticalAxisLabelsBehavior
  ];
}
function wS(t) {
  return Pe(t?.[1]?.valueFormat) && (t?.[2]?.valueFormat === void 0 || Pe(t[2].valueFormat));
}
function kS(t) {
  return Pe(t?.[1]?.valueFormat) && (t?.[2]?.valueFormat === void 0 || Pe(t[2].valueFormat));
}
function IS(t) {
  return (Ya(t?.[0]?.valueFormat) || mi(t?.[0]?.valueFormat)) && Pe(t?.[1]?.valueFormat) && (t?.[2]?.valueFormat === void 0 || Pe(t[2].valueFormat));
}
function OS(t) {
  return (Ya(t?.[0]?.valueFormat) || mi(t?.[0]?.valueFormat)) && Pe(t?.[1]?.valueFormat);
}
function BS(t) {
  return Pe(t?.[0]?.valueFormat) && Pe(t?.[1]?.valueFormat);
}
function DS(t) {
  return Pe(t?.[0]?.valueFormat) && Pe(t?.[1]?.valueFormat);
}
function NS(t) {
  return Pe(t?.[0]?.valueFormat);
}
async function Xa(t) {
  const { chartType: e, axesConfig: i, errorStrings: a } = t;
  let n, o;
  switch (e) {
    case b.GaugeSeries:
      n = NS, o = "invalidValueFormatForGauge";
      break;
    case b.ScatterSeries:
      n = BS, o = "invalidValueFormatForScatterplot";
      break;
    case b.HistogramSeries:
      n = DS, o = "invalidValueFormatForHistogram";
      break;
    case b.LineSeries:
      n = wS, o = "invalidValueFormatForLineChart";
      break;
    case b.BarSeries:
      n = kS, o = "invalidValueFormatForBarChart";
      break;
    case b.ComboLineAndBarSeries:
      n = OS, o = "invalidValueFormatForComboBarLineChart";
      break;
    case b.BoxPlotSeries:
      n = IS, o = "invalidValueFormatForBoxPlot";
      break;
  }
  n !== void 0 && o !== void 0 && (n(i) || await Ga(o, a));
}
function Tr(t) {
  const { isXAxis: e, chartType: i, valueFormat: a, isAxisForHistogramOverlaySeries: n } = t;
  return e && (Ya(a) || i === b.HistogramSeries && !n || i === b.BarSeries && Pe(a));
}
function Jo(t) {
  const { chartConfig: e, isSecondValueAxis: i, seriesIds: a } = t;
  let n = a;
  return e.axes?.length === 3 && (n = e.series.map((o) => {
    let s = "";
    return (a === void 0 || a.includes(o.id)) && (i === !0 && "assignToSecondValueAxis" in o && o.assignToSecondValueAxis === !0 || i !== !0 && (!("assignToSecondValueAxis" in o) || o.assignToSecondValueAxis !== !0)) && ({ id: s } = o), s;
  }).filter((o) => o !== "")), n;
}
function MS(t, e) {
  return t[0].dataTransformationType !== e[0].dataTransformationType;
}
function $S(t, e) {
  return t[0].binCount !== e[0].binCount;
}
function fm(t, e) {
  let i = !0;
  const a = z(t?.series), n = z(e?.series);
  return a !== n && (i = a === b.ComboLineAndBarSeries && (n === b.BarSeries || n === b.LineSeries) || n === b.ComboLineAndBarSeries && (a === b.BarSeries || a === b.LineSeries) || a === b.BarSeries && n === b.LineSeries || a === b.LineSeries && n === b.BarSeries), i;
}
function Bl(t, e) {
  return t !== void 0 && e !== void 0 && e > 0;
}
function PS(t) {
  const { chartConfig: e, queryObject: i, chartData: a } = t;
  let n = [];
  const o = H(e.series), s = Ri(e), r = we(i), l = e.chartRenderer ?? r?.renderer?.toJSON();
  return n = e.series.map((c, d) => {
    const u = z([c]);
    let f;
    return (u === b.BarSeries || u === b.LineSeries || u === b.RadarSeries) && (c.type === b.BarSeries ? f = c.fillSymbol?.color : (c.type === b.RadarSeries || c.type === b.LineSeries) && (f = c.lineSymbol?.color), s ? f = Wt({
      dataItem: a[0],
      seriesConfig: c,
      chartSubType: o,
      colorMatch: s,
      rendererType: l?.type
    })?.color : f === void 0 && (f = Si({ colorIndex: d }))), f;
  }).filter((c) => c !== void 0), n;
}
function dn(t) {
  return t !== L.PieNoAggregation && t !== L.BarAndLineNoAggregation && t !== L.BarAndLineSplitByNoAggregation;
}
function RS(t) {
  const e = H(t.series);
  return e === L.BarAndLineFromFields || e === L.PieFromFields || e === L.BoxPlotMonoField || e === L.BoxPlotMultiFields || e === L.BoxPlotMonoFieldAndSplitBy || e === L.BoxPlotMultiFieldsAndSplitBy;
}
function qe(t) {
  return t && "showMean" in t && typeof t.showMean == "boolean" ? t.showMean : !1;
}
function Mi(t) {
  return t && "showOutliers" in t && typeof t.showOutliers == "boolean" ? t.showOutliers : void 0;
}
function _s() {
  return `{name} {${k.originalCategoryValue}} {dateY} {valueX} {dateX} {valueY}`;
}
function VS(t) {
  let e;
  return t?.[0] !== void 0 && (e = t.reduce(
    (i, a) => ({
      ...i,
      xmin: Math.min(i.xmin, a.xmin),
      xmax: Math.max(i.xmax, a.xmax),
      ymin: Math.min(i.ymin, a.ymin),
      ymax: Math.max(i.ymax, a.ymax)
    }),
    t[0]
  )), e;
}
function Zt(t) {
  const { value: e, dataContext: i, specificField: a, preferLabel: n, keepNullValues: o = !1, useRendererLabel: s = !1 } = t;
  let r = e;
  const { originalCategoryValue: l, originalDateValue: c, typeOrDomainIdValue: d } = k;
  if (i !== void 0) {
    const u = s ? pF(i) : void 0;
    a !== void 0 && i[a] !== void 0 ? r = i[a] : u !== void 0 ? r = u : n === !1 && i[d] !== void 0 ? r = i[d] : i[c] !== void 0 ? r = i[c] : i[l] !== void 0 ? r = i[l] : i[tt] !== void 0 && (r = i[tt]), !o && r === null && (r = "null");
  }
  return r;
}
function $i(t) {
  return t?.[k.typeOrDomainIdValue] !== void 0 ? t?.[k.typeOrDomainIdValue] : t?.[k.originalCategoryValue];
}
function Zs(t) {
  const {
    arrayToSort: e,
    orderBy: i,
    sortingField: a,
    forceAscendingOrder: n,
    isNonAggregated: o,
    sortByCategory: s,
    preferLabel: r,
    isPieOrByFieldsChart: l
  } = t;
  if (e !== void 0 && e.length > 1) {
    const c = i === ri.Descending && n !== !0;
    e.sort((d, u) => {
      let f = 0, m = d[a];
      s === !0 && !l && (m = Zt({
        value: `${d[a]?.toString()}`,
        dataContext: d,
        preferLabel: r
      }));
      let g = u[a];
      return s === !0 && !l && (g = Zt({
        value: `${u[a]?.toString()}`,
        dataContext: u,
        preferLabel: r
      })), o === !0 && c && s === !0 && (m = Number.isNaN(Number.parseFloat(`${m?.toString()}`)) ? m : Number.parseFloat(m), g = Number.isNaN(Number.parseFloat(`${g?.toString()}`)) ? g : Number.parseFloat(g)), s === !0 && (d[k.originalCategoryValue] === null || m === null) || d[Ut.defaultGroupOfSlicesId] === !0 ? f = 1 : s === !0 && (u[k.originalCategoryValue] === null || g === null) || u[Ut.defaultGroupOfSlicesId] === !0 ? f = -1 : typeof m == "string" && typeof g == "string" ? (f = m.localeCompare(g, void 0, { numeric: !0 }), c && (f *= -1)) : m === void 0 ? f = c ? -1 : 1 : g === void 0 ? f = c ? 1 : -1 : m !== null && g !== null && (m > g ? f = c ? -1 : 1 : m < g && (f = c ? 1 : -1)), f;
    });
  }
}
function ES(t) {
  const { arrayToSort: e, orderBy: i, sortingField: a, fieldList: n, isByFieldsChart: o, preferLabel: s } = t;
  e !== void 0 && e.length > 1 && !be(a) && i !== void 0 && i.length > 0 && e.sort((r, l) => {
    let c = r[a];
    s && o && typeof c == "string" && (c = Ve(n, c));
    let d = i.indexOf(c?.toString() ?? "");
    d === -1 && (d = i.length);
    let u = l[a];
    s && o && typeof u == "string" && (u = Ve(n, u));
    let f = i.indexOf(u?.toString() ?? "");
    return f === -1 && (f = i.length), d - f;
  });
}
function mm(t, e) {
  const i = t;
  if (e?.[0] !== void 0 && H(e) === L.PieFromFields) {
    const { x: a, y: n } = e[0];
    (ac(t) ? i : i.dataItems).forEach((r) => (tt in r && a !== tt && (r[a] = r[a] !== void 0 ? r[a] : r[tt], delete r[tt]), Rt in r && n !== Rt && (r[n] = r[n] !== void 0 ? r[n] : r[Rt], delete r[Rt]), r));
  }
  return i;
}
function gm(t, e) {
  const i = z(e);
  let a = t;
  const n = e?.[0];
  if ((i === b.PieSeries || i === b.BoxPlotSeries || i === b.LineSeries || i === b.RadarSeries || i === b.BarSeries || i === b.ComboLineAndBarSeries) && n !== void 0) {
    const o = ac(t);
    let s = o ? t : t.dataItems;
    if (t !== void 0) {
      const { originalCategoryValue: r, originalDateValue: l, xAxisField: c, typeOrDomainIdValue: d } = k, { x: u } = n;
      s = s.map((f) => {
        let m = f[u];
        f[d] !== void 0 ? m = f[d] : f[l] !== void 0 ? m = f[l] : f[r] !== void 0 && (m = f[r]);
        const g = { ...f, [u]: m };
        return delete g[l], delete g[d], delete g[r], delete g[c], g;
      }), o ? a = s : "dataItems" in a && (a.dataItems = s);
    }
  }
  return a;
}
function Dl(t) {
  const e = { ...t };
  delete e[k.technicalSortingFieldBySum], delete e[k.technicalSortingFieldByPercent], delete e[k.pieChart.technicalFieldSlicePercent], delete e[k.pieChart.technicalFieldGroupedSlices], delete e[k.typeOrDomainFieldName], delete e[k.lastTemporalBin], delete e[k.originalServerBinningRange], delete e[ot.uniqueIdsName], Object.keys(e).filter(
    (n) => n.includes(k.rendererSymbolField)
  ).forEach((n) => delete e[n]);
  const a = hr(e);
  return a.isInItem && delete e[a.expr ?? ""], e;
}
function WS(t, e) {
  let i = t;
  const a = z(e);
  let n = Vi(i);
  if (n !== void 0)
    switch (a) {
      case b.ComboLineAndBarSeries:
      case b.BarSeries:
      case b.LineSeries:
      case b.RadarSeries:
      case b.PieSeries:
        {
          n = n.map(Dl), i = { dataItems: n };
          const { timeIntervalInfo: o } = t ?? {};
          tn(o) || (i.timeIntervalInfo = o);
        }
        break;
      case b.ScatterSeries:
        i = {
          ...i,
          dataItems: n.map(Dl)
        };
        break;
    }
  return i;
}
function Fc(t) {
  const { data: e, seriesConfig: i } = t;
  let a = Ee(e);
  return a !== void 0 && (a = gm(a, i), a = WS(a, i), a = mm(a, i)), a;
}
function Lc(t) {
  const { statsMap: e, dataContext: i, chartLimits: a } = t;
  let n = !1;
  if (e !== void 0) {
    const { maxScatterPointsBeforeAggregation: o } = to(a), { queryNumberOfFeatures: s } = k.scatterplotAggregationFields;
    n = (e.get(s) ?? Number.NaN) >= o;
  } else i !== void 0 && (n = k.scatterplotAggregationFields.dataContextXMinField in i);
  return n;
}
function zS(t) {
  let e = !0;
  const i = z(t.series);
  if (i === b.BarSeries || i === b.LineSeries || i === b.ComboLineAndBarSeries) {
    const a = H(t.series);
    e = a !== L.BarAndLineNoAggregation && a !== L.BarAndLineSplitByNoAggregation;
  }
  return e;
}
function HS(t) {
  return H(t.series) !== L.PieNoAggregation;
}
function Ac(t) {
  const { dataContext: e, chartConfig: i, chartLimits: a } = t;
  let n = !0;
  if (i !== void 0)
    switch (z(i.series)) {
      case b.BarSeries:
      case b.LineSeries:
      case b.ComboLineAndBarSeries:
        n = zS(i);
        break;
      case b.ScatterSeries:
        n = Lc({ dataContext: e, chartLimits: a });
        break;
      case b.PieSeries:
        n = HS(i);
        break;
    }
  return n;
}
function qS(t, e) {
  let i = t;
  switch (e) {
    case Vt.Log:
      i = `log(${t})`;
      break;
    case Vt.Sqrt:
      i = `power(CAST(${t} AS FLOAT),0.5)`;
      break;
  }
  return i;
}
function Xn(t) {
  let e = new Date(t).valueOf();
  return Number.isNaN(e) || (e = new Intl.DateTimeFormat("en-US", k.dateFormatUTC).format(t).replace(",", "")), e;
}
function Qs(t) {
  const { dataToConvert: e, x: i, y: a, fieldList: n } = t, o = [], s = e[Oa];
  return Object.entries(e).forEach(([r]) => {
    if (r !== "" && r !== Oa && r in e) {
      const l = {
        [i]: Ve(n, r),
        [a]: e[r],
        [k.xAxisField]: r,
        [k.originalCategoryValue]: r
      };
      s !== void 0 && (l[Oa] = s), e[`${k.rendererSymbolField}_${r}`] !== void 0 && (l[k.rendererSymbolField] = e[`${k.rendererSymbolField}_${r}`]), o.push(l);
    }
  }), o;
}
function GS(t, e) {
  return JSON.stringify(t.series[0]?.valueConversion) !== JSON.stringify(e.series[0]?.valueConversion);
}
function hm(t, e) {
  return (t.colorMatch ?? !1) !== (e.colorMatch ?? !1);
}
function Nl(t) {
  const { oldConfig: e, newConfig: i } = t;
  let a = !1;
  const n = e.series[0], o = i.series[0], s = z(e.series), r = z(i.series);
  if (s === b.PieSeries && r === b.PieSeries) {
    const { slices: l, sliceGrouping: c } = n, { slices: d, sliceGrouping: u } = o, f = l?.map((p) => ({
      sliceId: p.sliceId,
      label: p.label
    })), m = d?.map((p) => ({
      sliceId: p.sliceId,
      label: p.label
    })), g = c?.label, y = u?.label;
    a = JSON.stringify(f) !== JSON.stringify(m) || JSON.stringify(g) !== JSON.stringify(y);
  }
  return a;
}
function eu(t, e) {
  return e.length !== t.length;
}
function YS(t) {
  const { oldSeries: e, newConfig: i, oldTimeIntervalInfo: a, setTimeBinningInfoWhenNotProvided: n } = t, o = i.series?.[0];
  let s = !1, r = !1, l = !1;
  if (ci(o) && ei({
    seriesConfig: o,
    xAxisValueFormatType: ii(i),
    setTimeBinningInfoWhenNotProvided: n
  })) {
    const d = e[0].temporalBinning, u = o.temporalBinning;
    d?.type !== u?.type ? s = !0 : d?.type === wi.FixedDateBased && u?.type === wi.FixedDateBased ? s = a?.size !== u?.size || d?.timeAggregationType !== u?.timeAggregationType || d?.trimIncompleteTimeInterval !== u?.trimIncompleteTimeInterval || d?.nullPolicy !== u?.nullPolicy : d?.type === wi.CalendarBased && u?.type === wi.CalendarBased && (s = JSON.stringify(d) !== JSON.stringify(u)), r = a?.unit !== u?.unit, l = n === !0 && (u?.size ?? 0) <= 0;
  }
  return { timeBinningChanged: s, timeIntervalUnitChanged: r, newTimeBinningWillBeCalculated: l };
}
function XS(t) {
  const { oldConfig: e, newConfig: i, behaviorAfterLimit: a } = t, n = e.series, o = i.series;
  let s = !1, r = !1;
  (a === eo.RenderUpToTheLimit || e.orderOptions?.data === void 0 || i.orderOptions?.data === void 0) && (r = !Di(e.orderOptions?.orderByFields, i.orderOptions?.orderByFields));
  const l = Wd(
    n.map((d) => d.query),
    ["where", "outStatistics[0].outStatisticFieldName", "outStatistics[0].onStatisticField"]
  ), c = Wd(
    o.map((d) => d.query),
    ["where", "outStatistics[0].outStatisticFieldName", "outStatistics[0].onStatisticField"]
  );
  return s = !Di(l, c), s || r;
}
function US(t, e) {
  let i = !1;
  if (e[0].x !== t[0].x)
    i = !0;
  else {
    const a = z(t);
    if (a !== b.HistogramSeries && a !== b.GaugeSeries) {
      const n = pt(t).sort(), o = pt(e).sort();
      i = JSON.stringify(n) !== JSON.stringify(o);
    }
  }
  return i;
}
function jS(t, e) {
  return (t ?? !1) !== (e?.filterBySelection ?? !1);
}
function _S(t) {
  const { currentSelectionOIDs: e, options: i } = t;
  let a = !1;
  return i?.filterBySelection === !0 && (a = !Di(e, i?.selectionData?.selectionOIDs)), a;
}
function ZS(t, e) {
  return JSON.stringify(t.dataFilters) !== JSON.stringify(e.dataFilters);
}
function QS(t, e) {
  return ci(t.series[0]) && ci(e.series[0]) && (t.series[0].binTemporalData ?? k.binTemporalData) !== (e.series[0].binTemporalData ?? k.binTemporalData);
}
function KS(t, e) {
  return t?.length !== e?.length || t?.some((i, a) => {
    const n = Lt({ where: i?.query?.where }), o = Lt({ where: e?.[a]?.query?.where });
    return n !== o;
  });
}
function JS(t, e) {
  const i = pt(t), a = pt(e);
  return JSON.stringify(i) !== JSON.stringify(a);
}
function ex(t, e) {
  return qe(t) !== qe(e);
}
function tx(t, e) {
  const i = t.axes?.[0].valueFormat.type, a = e.axes?.[0].valueFormat.type, n = H(e.series), o = n === L.BarAndLineNoAggregation || n === L.BarAndLineSplitByNoAggregation, s = i === b.DateAxisFormat && a === b.NumberAxisFormat, r = i === b.NumberAxisFormat && a === b.DateAxisFormat;
  return i !== a && (o || s || r);
}
function wr(t) {
  const {
    forceDataUpdate: e,
    oldConfig: i,
    newConfig: a,
    options: n,
    formerFilterBySelection: o,
    timeIntervalInfo: s,
    currentSelectionOIDs: r
  } = t, { series: l } = a, { series: c } = i, d = z(l);
  let u = !1, f = !1, m = !1;
  const g = {
    common: {
      queryChanged: !1,
      xOrYChanged: !1,
      numberOfSeriesChanged: !1,
      configFiltersChanged: !1,
      filterBySelectionChanged: !1,
      dataForFilterBySelectionChanged: !1,
      binTemporalDataChanged: !1,
      timeBinningChanged: !1,
      timeIntervalUnitChanged: !1,
      newTimeBinningWillBeCalculated: !1,
      valueFormatChangeRequiresNewData: !1
    },
    histogram: { dataPropsChanged: !1 },
    gauge: { valueConversionChanged: !1 },
    boxPlot: { showMeanChanged: !1 }
  };
  switch (g.common.queryChanged = XS({
    oldConfig: i,
    newConfig: a,
    behaviorAfterLimit: n?.chartLimits?.behaviorAfterLimit
  }), g.common.configFiltersChanged = ZS(i, a), g.common.xOrYChanged = US(c, l), g.common.filterBySelectionChanged = jS(o, n), g.common.dataForFilterBySelectionChanged = _S({
    currentSelectionOIDs: r,
    options: n
  }), g.common.binTemporalDataChanged = QS(i, a), g.common.valueFormatChangeRequiresNewData = tx(
    i,
    a
  ), g.common = {
    ...g.common,
    ...YS({
      oldSeries: c,
      newConfig: a,
      oldTimeIntervalInfo: s,
      setTimeBinningInfoWhenNotProvided: n?.setTimeBinningInfoWhenNotProvided
    })
  }, f = Object.values(g.common).some((y) => y), d) {
    case b.HistogramSeries:
      g.histogram.dataPropsChanged = $S(c, l) || MS(c, l);
      break;
    case b.LineSeries:
    case b.BarSeries:
    case b.ComboLineAndBarSeries:
      g.common.numberOfSeriesChanged = eu(c, l);
      break;
    case b.BoxPlotSeries:
      g.common.numberOfSeriesChanged = eu(c, l), g.boxPlot.showMeanChanged = ex(i, a);
      break;
    case b.GaugeSeries:
      g.gauge.valueConversionChanged = GS(i, a);
      break;
  }
  return (g.gauge.valueConversionChanged || g.histogram.dataPropsChanged || g.common.numberOfSeriesChanged || g.common.binTemporalDataChanged || g.boxPlot.showMeanChanged) && (m = !0), u = e === !0 || f || m, { dataUpdateNeeded: u, updateNeededDetails: g };
}
function ix(t) {
  return t.common.timeIntervalUnitChanged || t.common.newTimeBinningWillBeCalculated || t.common.dataForFilterBySelectionChanged || t.common.filterBySelectionChanged || t.common.configFiltersChanged || t.common.numberOfSeriesChanged || t.common.queryChanged || t.common.xOrYChanged;
}
function ax(t, e) {
  let i = !0;
  if (t !== void 0 && t.length > 1 && !be(e)) {
    let a = 0, n = 0, o = 0;
    t.forEach((s) => {
      const r = s[e];
      !Jy(r) || r === 0 ? o += 1 : r > 0 ? a += 1 : n += 1;
    }), i = o === t.length || a >= 0 && n === 0 || a === 0 && n >= 0;
  }
  return i;
}
function xs(t) {
  const { countTotal: e, countPerSeries: i, numberOfSeries: a } = t;
  let n;
  const o = [];
  return typeof e == "number" && Number.isFinite(e) && o.push(e), typeof i == "number" && Number.isFinite(i) && o.push(i * a), o.length > 0 && (n = Math.min(...o)), n;
}
function pm(t, e) {
  let i;
  const {
    maxBarChartSeriesCount: a,
    maxBarUniqueSeriesCountTotal: n,
    maxBarTwoSeriesCountPerSeries: o,
    maxBarTwoSeriesCountTotal: s,
    maxBarThreePlusSeriesCountPerSeries: r,
    maxBarThreePlusSeriesCountTotal: l,
    maxLineChartSeriesCount: c,
    maxLineUniqueSeriesCountTotal: d,
    maxLineTwoSeriesCountPerSeries: u,
    maxLineTwoSeriesCountTotal: f,
    maxLineThreePlusSeriesCountPerSeries: m,
    maxLineThreePlusSeriesCountTotal: g,
    maxPieChartSliceCountTotal: y,
    maxGaugeByFeaturesLimit: p
  } = to(e), S = z(t.series), x = t.series.length === 0 ? 1 : t.series.length, C = H(t.series);
  switch (S) {
    case b.ComboLineAndBarSeries:
    case b.BarSeries:
      x <= a && (x === 1 ? i = n : x === 2 ? i = xs({
        countTotal: s,
        countPerSeries: o,
        numberOfSeries: x
      }) : x > 2 && (i = xs({
        countTotal: l,
        countPerSeries: r,
        numberOfSeries: x
      })));
      break;
    case b.LineSeries:
      x <= c && (x === 1 ? i = d : x === 2 ? i = xs({
        countTotal: f,
        countPerSeries: u,
        numberOfSeries: x
      }) : x > 2 && (i = xs({
        countTotal: g,
        countPerSeries: m,
        numberOfSeries: x
      })));
      break;
    case b.PieSeries:
      i = y;
      break;
    case b.GaugeSeries:
      i = p;
      break;
    case b.ScatterSeries:
    // handled through the aggregation feature
    case b.HistogramSeries:
    // handled through the number of bins
    case b.BoxPlotSeries:
  }
  return (C === L.BarAndLineNoAggregation || C === L.BarAndLineMultiFields) && i !== void 0 && (i = Math.ceil(i / x)), i;
}
function Ks(t, e) {
  let i = t;
  if (Number.isFinite(t)) {
    const { factor: a, offset: n } = e ?? {};
    Number.isFinite(a) && (i *= a), Number.isFinite(n) && (i += n);
  }
  return i;
}
function nx(t) {
  let e = !1;
  if (t !== void 0) {
    const i = t.replace(" ", ""), a = /^%(0*100{1,1}\.?((?:\.)0*)?$)|(^%0*\d{0,2}\.?((?:\.)\d*)?)$/u, n = /^(0*100{1,1}\.?((?:\.)0*)?%$)|(^0*\d{0,2}\.?((?:\.)\d*)?%)$/u;
    e = a.test(i) || n.test(i);
  }
  return e;
}
function kr(t) {
  let e;
  if (nx(t)) {
    const i = /%(\d{1,3}(.\d+)?)$/u, a = /(\d{1,3}(.\d+)?)%$/u, n = t.replace(" ", ""), o = i.exec(n)?.[1] ?? a.exec(n)?.[1];
    o !== void 0 && (e = Number(o));
  }
  return e;
}
const Ei = {
  DataProcessComplete: "arcgisChartsJSDataProcessComplete",
  DataFetchComplete: "arcgisChartsJSDataFetchComplete",
  LegendItemVisibilityChange: "arcgisChartsJSLegendItemVisibilityChange",
  UpdateComplete: "arcgisChartsJSUpdateComplete",
  RenderingComplete: "arcgisChartsJSRenderingComplete",
  SeriesColorsChange: "arcgisChartsJSSeriesColorChange",
  AxesMinMaxChange: "arcgisChartsJSAxesMinMaxChange",
  SelectionComplete: "arcgisChartsJSSelectionComplete",
  TooManySelectedElements: "arcgisChartsJSTooManySelectedElements",
  BadDataWarningRaise: "arcgisChartsJSBadDataWarningRaise",
  SeriesOrder: "arcgisChartsJSSeriesOrder"
};
function Wi(t) {
  return {
    detail: t,
    composed: !0,
    cancelable: !0,
    bubbles: !0
  };
}
function un(t) {
  const { data: e, seriesConfig: i, htmlContainer: a } = t;
  if (a && e) {
    const n = Fc({ data: e, seriesConfig: i });
    a.dispatchEvent(
      new window.CustomEvent(Ei.DataProcessComplete, Wi(n))
    );
  }
}
function ym(t) {
  const { data: e, chartConfig: i, htmlContainer: a } = t;
  if (a && e) {
    const n = fF(e, i);
    a.dispatchEvent(new window.CustomEvent(Ei.DataFetchComplete, Wi(n)));
  }
}
function bm(t, e) {
  e && e.dispatchEvent(
    new window.CustomEvent(Ei.LegendItemVisibilityChange, Wi(t))
  );
}
function Ua(t, e) {
  e && e.dispatchEvent(new window.CustomEvent(Ei.UpdateComplete, Wi(t)));
}
function no(t) {
  t && t.dispatchEvent(new window.CustomEvent(Ei.RenderingComplete, Wi()));
}
function oo(t) {
  const { data: e, seriesConfig: i, htmlContainer: a } = t;
  if (a) {
    const n = e;
    let o = Ee(e.selectionItems);
    o && (o = gm(o, i), o = o.map(Dl), o = mm(o, i), n.selectionItems = o), a.dispatchEvent(new window.CustomEvent(Ei.SelectionComplete, Wi(n)));
  }
}
function Sm(t) {
  t && t.dispatchEvent(new window.CustomEvent(Ei.TooManySelectedElements, Wi()));
}
function zi(t) {
  const { data: e, htmlContainer: i, chartId: a, colorMatchApplied: n } = t;
  i && i.dispatchEvent(
    new window.CustomEvent(
      Ei.SeriesColorsChange,
      Wi({
        chartId: a,
        data: e,
        colorMatchApplied: n
      })
    )
  );
}
function xm(t, e) {
  e && e.dispatchEvent(new window.CustomEvent(Ei.AxesMinMaxChange, Wi(t)));
}
function Cm(t, e) {
  e && e.dispatchEvent(new window.CustomEvent(Ei.BadDataWarningRaise, Wi(t)));
}
function ox(t) {
  const { data: e, htmlContainer: i } = t;
  i && e && i.dispatchEvent(new window.CustomEvent(Ei.SeriesOrder, Wi(e)));
}
function vm(t, e) {
  let i, a, n, o;
  return ci(t.series[0]) && t.series[0].temporalBinning?.type === wi.FixedDateBased && (i = t.series[0].temporalBinning.unit, n = t.series[0].temporalBinning.size), ci(e.series[0]) && e.series[0].temporalBinning?.type === wi.FixedDateBased && (a = e.series[0].temporalBinning.unit, o = e.series[0].temporalBinning.size), Bl(i, n) && !Bl(a, o);
}
function sx(t, e) {
  return t.axes?.length === 3 && e.axes?.length === 2 || t.axes?.length === 2 && e.axes?.length === 3;
}
function rx(t, e) {
  return JSON.stringify(t.series.map((i) => i.assignToSecondValueAxis ?? !1)) !== JSON.stringify(e.series.map((i) => i.assignToSecondValueAxis ?? !1));
}
function lx(t, e) {
  const i = t.axes?.map((n) => n?.guides?.map((o) => o?.above === !0)), a = e.axes?.map((n) => n?.guides?.map((o) => o?.above === !0));
  return JSON.stringify(i) !== JSON.stringify(a);
}
function Fm(t, e) {
  return di(t) !== di(e);
}
function Tc(t) {
  return z(t.series) !== b.BoxPlotSeries ? k.xAxisField : t.series[0].x;
}
function cx(t) {
  const e = ti(t);
  return e === Ie.Stacked || e === Ie.Stacked100;
}
function dx(t, e) {
  return (t.showOutliers ?? k.boxPlot.boxPlotOutliersVisibility) !== (e.showOutliers ?? k.boxPlot.boxPlotOutliersVisibility);
}
function ux(t, e) {
  return (t.standardizeValues ?? k.boxPlot.boxPlotStandardizeValuesVisibility) !== (e.standardizeValues ?? k.boxPlot.boxPlotStandardizeValuesVisibility);
}
function wc(t, e) {
  return JSON.stringify(t.chartRenderer) !== JSON.stringify(e.chartRenderer);
}
function fx(t, e) {
  const i = t.axes?.[0].valueFormat.type === b.DateAxisFormat ? t.axes[0].valueFormat.intlOptions.timeZone : void 0, a = e.axes?.[0].valueFormat.type === b.DateAxisFormat ? e.axes[0].valueFormat.intlOptions.timeZone : void 0;
  return i !== a;
}
function mx(t, e) {
  return t.series.map((i) => i.name).join() !== e.series.map((i) => i.name).join();
}
function gx(t, e) {
  const i = t.orderOptions?.series, a = e.orderOptions?.series, n = (i?.orderBy ?? ri.Ascending) !== (a?.orderBy ?? ri.Ascending), o = (i?.preferLabel ?? !0) !== (a?.preferLabel ?? !0);
  return n || o;
}
function Lm(t, e) {
  return gx(t, e) || mx(t, e);
}
function hx(t) {
  const e = H(t.series);
  let i;
  if (t.orderOptions?.data !== void 0) {
    let a = t.orderOptions?.data?.orderType ?? en.Category, n = t.orderOptions?.data?.orderBy;
    if (a === en.Category)
      a = t.series[0].x;
    else {
      a === en.Mean ? a = Y.Average : a === en.Median && (a = Y.Median);
      const o = e === L.BoxPlotMultiFieldsAndCategory && typeof t.series[0].y == "string" ? t.series[0].y : void 0, s = Ze(t.series[0].query?.where), r = Lt({
        where: t.series[0].query?.where
      });
      a = oe({
        key: a,
        y: o,
        chartSubType: e,
        splitBy: s,
        splitByValue: r
      }), Array.isArray(n) && (n = ri.Ascending);
    }
    i = {
      sortingField: a,
      orderBy: n ?? ri.Ascending
    };
  }
  return i;
}
function px(t) {
  const e = t.series[0], { x: i, y: a } = e, n = H(t.series) === L.PieFromFields;
  let o, s = "", r;
  if (t.orderOptions?.data !== void 0 && (s = t.orderOptions?.data?.orderType ?? en.Category, r = t.orderOptions?.data?.orderBy, s === en.Category ? s = n ? tt : i : s = n ? Rt : [a].flat()[0]), s !== void 0 && s !== "") {
    const l = ti(t);
    if (z(t.series) !== b.PieSeries && s !== i && t.series?.length > 1)
      switch (l) {
        case Ie.Stacked:
          s = k.technicalSortingFieldBySum;
          break;
        case Ie.Stacked100:
          s = k.technicalSortingFieldByPercent;
          break;
        case Ie.Side:
          typeof a == "string" && (s = a);
          break;
      }
    o = {
      sortingField: s,
      orderBy: r ?? ri.Ascending
    };
  }
  return o;
}
function Ml(t) {
  let e;
  if (t?.orderOptions?.data && t.series?.length > 0) {
    switch (z(t.series)) {
      case b.BoxPlotSeries:
        e = hx(t);
        break;
      case b.LineSeries:
      case b.BarSeries:
      case b.PieSeries:
        e = px(t);
        break;
    }
    e && t.orderOptions?.data?.preferLabel !== void 0 && (e.preferLabel = t.orderOptions.data.preferLabel);
  }
  return e;
}
function kc(t) {
  const { oldConfig: e, newConfig: i, dataUpdateNeeded: a } = t, n = H(i.series);
  let o = !1, s = !1;
  if (n !== L.BoxPlotMonoField && n !== L.BoxPlotMonoFieldAndSplitBy && i.orderOptions?.data !== void 0) {
    const r = Ml(e), l = Ml(i);
    s = e.orderOptions?.data?.orderType !== i.orderOptions?.data?.orderType || r?.sortingField !== l?.sortingField || r?.orderBy !== l?.orderBy || (r?.preferLabel ?? !0) !== (l?.preferLabel ?? !0), o = s || a;
  }
  return o;
}
function Am(t, e) {
  const i = [], a = /* @__PURE__ */ new Map(), n = /* @__PURE__ */ new Map();
  return t.forEach((o, s) => n.set(o.id, s)), e.forEach((o, s) => {
    let r = n.get(o.id);
    if (r !== void 0) {
      const l = /* @__PURE__ */ new Set();
      for (; a.has(r) && !l.has(r); )
        l.add(r), r = a.get(r) ?? r;
      r !== s && (i.push([r, s]), a.set(s, r));
    }
  }), i;
}
function Ir(t, e) {
  const i = Ee(t);
  if (i && i.series.length > 1) {
    const { preferLabel: a, orderBy: n } = i.orderOptions?.series ?? {};
    if (n !== void 0) {
      let o;
      if (a === !1) {
        const s = H(i.series);
        o = Vf(s) ? "splitByValue" : "name";
      } else
        o = "name";
      i.series.sort((s, r) => {
        let l, c;
        o === "splitByValue" ? (l = Lt({ where: s.query?.where }) ?? "", c = Lt({ where: r.query?.where }) ?? "") : (l = s.name, c = r.name);
        const [d, u] = n.toUpperCase() === ri.Descending ? [c, l] : [l, c];
        return typeof d == "string" && typeof u == "string" ? d.localeCompare(u) : Number(d) - Number(u);
      });
    }
  }
  return ox({
    data: i?.series.map((a) => a.id),
    htmlContainer: e
  }), i;
}
function Or(t) {
  const e = { ...t };
  return t.showMean === !0 && (e.series = [e.series[0]], e.series[0].query?.where !== void 0 && delete e.series[0].query.where), e;
}
function Tm(t) {
  const { dataInfo: e, chartType: i, subError: a } = t;
  switch (e.valid = !1, i) {
    case b.BarSeries:
    case b.ComboLineAndBarSeries:
      e.invalidType = de.BarElementExceedsLimit;
      break;
    case b.LineSeries:
      e.invalidType = de.LineChartExceedsLimit;
      break;
    case b.PieSeries:
      e.invalidType = de.PieChartExceedsLimit;
      break;
    case b.GaugeSeries:
      e.invalidType = de.GaugeExceedsLimit;
      break;
    case b.BoxPlotSeries:
      a?.outlierLimit === !0 ? e.invalidType = de.BoxPlotOutliersExceedsLimit : e.invalidType = de.BoxPlotExceedsLimit;
      break;
  }
}
function yx(t, e) {
  t.valid = !1, t.invalidType = e;
}
async function wm(t) {
  const {
    invalidType: e,
    chartLimits: i,
    elementCount: a,
    seriesCount: n,
    queryObject: o,
    filterBySelection: s,
    formatLocale: r = ia().formatLocale,
    isTemporalLineChart: l,
    errorStrings: c
  } = t;
  let d = c.errors.defaultInvalidChart, u;
  const f = new Intl.NumberFormat(r), m = to(i), { maxCategoryCount: g } = m;
  let y = c.modalHeaders.invalidChart;
  switch (e) {
    case de.BarElementExceedsLimit: {
      y = c.modalHeaders.tooManyFeatures;
      let S = Number.NaN, x = Number.NaN, C = "";
      n !== void 0 && (n <= m.maxBarChartSeriesCount ? n === 1 ? (C = c.errors.uniqueSeriesBarCountCannotExceedLimit, S = m.maxBarUniqueSeriesCountTotal) : n === 2 ? (C = c.errors.twoSeriesBarCountCannotExceedLimit, S = m.maxBarTwoSeriesCountTotal, x = m.maxBarTwoSeriesCountPerSeries) : n > 2 && (C = c.errors.threePlusSeriesBarCountCannotExceedLimit, S = m.maxBarThreePlusSeriesCountTotal, x = m.maxBarThreePlusSeriesCountPerSeries) : (C = c.errors.barSeriesCountCannotExceedLimit, x = m.maxBarChartSeriesCount));
      const F = f.format(S), v = f.format(x), A = a !== void 0 ? f.format(a) : "";
      d = Gt(C, {
        totalLimit: F,
        seriesLimit: v,
        elementCount: A
      }), u = {
        actualCount: a ?? Number.NaN,
        totalLimit: S,
        seriesLimit: x
      };
      break;
    }
    case de.LineChartExceedsLimit:
      {
        y = c.modalHeaders.tooManyFeatures;
        let S = Number.NaN, x = Number.NaN, C = "";
        n !== void 0 && (n <= m.maxLineChartSeriesCount ? n === 1 ? (C = l ? c.errors.uniqueTemporalSeriesLineCountCannotExceedLimit : c.errors.uniqueSeriesLineCountCannotExceedLimit, S = m.maxLineUniqueSeriesCountTotal) : n === 2 ? (C = l ? c.errors.twoTemporalSeriesLineCountCannotExceedLimit : c.errors.twoSeriesLineCountCannotExceedLimit, S = m.maxLineTwoSeriesCountTotal, x = m.maxLineTwoSeriesCountPerSeries) : n > 2 && (C = l ? c.errors.threePlusTemporalSeriesLineCountCannotExceedLimit : c.errors.threePlusSeriesLineCountCannotExceedLimit, S = m.maxLineThreePlusSeriesCountTotal, x = m.maxLineThreePlusSeriesCountPerSeries) : (C = c.errors.lineSeriesCountCannotExceedLimit, x = m.maxLineChartSeriesCount));
        const F = f.format(S), v = f.format(x), A = a !== void 0 ? f.format(a) : "";
        d = Gt(C, {
          elementCount: A,
          seriesLimit: v,
          totalLimit: F
        }), u = {
          actualCount: a ?? Number.NaN,
          totalLimit: S,
          seriesLimit: x
        };
      }
      break;
    case de.BoxPlotExceedsLimit:
      {
        y = c.modalHeaders.tooManyFeatures;
        let S = Number.NaN, x = Number.NaN, C = "";
        n !== void 0 && (n <= m.maxBoxPlotSeriesCount ? n === 1 ? (C = c.errors.uniqueSeriesBoxCountCannotExceedLimit, S = m.maxBoxUniqueSeriesCountTotal) : n === 2 ? (C = c.errors.twoSeriesBoxCountCannotExceedLimit, S = m.maxBoxTwoSeriesCountTotal, x = m.maxBoxTwoSeriesCountPerSeries) : n > 2 && (C = c.errors.threePlusBoxLineCountCannotExceedLimit, S = m.maxBoxThreePlusSeriesCountTotal, x = m.maxBoxThreePlusSeriesCountPerSeries) : (C = c.errors.boxSeriesCountCannotExceedLimit, x = m.maxBoxPlotSeriesCount));
        const F = f.format(S), v = f.format(x), A = a !== void 0 ? f.format(a) : "";
        d = Gt(C, {
          elementCount: A,
          seriesLimit: v,
          totalLimit: F
        }), u = {
          actualCount: a ?? Number.NaN,
          totalLimit: S,
          seriesLimit: x
        };
      }
      break;
    case de.BoxPlotOutliersExceedsLimit:
      {
        y = c.modalHeaders.tooManyFeatures;
        const S = c.errors.boxSeriesOutlierCannotExceedLimit, x = m.maxBoxPlotOutlierLimit, C = f.format(x);
        d = Gt(S, {
          totalLimit: C
        }), u = { actualCount: a ?? Number.NaN, totalLimit: x };
      }
      break;
    case de.PieChartExceedsLimit:
      {
        y = c.modalHeaders.tooManyFeatures;
        const S = c.errors.pieChartSlicesCannotExceedLimit, x = m.maxPieChartSliceCountTotal, C = f.format(x), F = a !== void 0 ? f.format(a) : "";
        d = Gt(S, {
          sliceCount: F,
          totalLimit: C
        }), u = {
          actualCount: a ?? Number.NaN,
          totalLimit: x
        };
      }
      break;
    case de.GaugeExceedsLimit:
      {
        y = c.modalHeaders.tooManyFeatures;
        const S = c.errors.gaugeCannotExceedLimit, x = m.maxGaugeByFeaturesLimit, C = f.format(x), F = a !== void 0 ? f.format(a) : "";
        d = Gt(S, {
          featureCount: F,
          totalLimit: C
        }), u = {
          actualCount: a ?? Number.NaN,
          totalLimit: x
        };
      }
      break;
    case de.PieChartMixOfNegativePositiveSlices:
      y = c.modalHeaders.cannotCombineNegativeAndPositiveSlices, d = c.errors.pieChartCannotHaveMixtureOfPositiveAndNegativeSlices;
      break;
    case de.NegativeValueInSqrtCalculation:
      y = c.modalHeaders.invalidData, d = c.errors.negativeValueInDataForSqrtTransformation;
      break;
    case de.NegativeValueInLogCalculation:
      y = c.modalHeaders.invalidData, d = c.errors.negativeValueInDataForLogTransformation;
      break;
    case de.HistogramEmptyField:
      d = c.errors.histogramEmptyField;
      break;
    case de.EmptyDataSet:
      y = c.modalHeaders.noDataAvailable, s === !0 ? d = c.errors.noDataFBSMessage : eb(o) ? d = c.errors.noDataFBEMessage : d = c.errors.noDataMessage;
      break;
    case de.NegativeValueInXAxisLogScale:
      d = c.errors.logarithmicXAxisNotPossible;
      break;
    case de.NegativeValueInYAxisLogScale:
      d = c.errors.logarithmicYAxisNotPossible;
      break;
    case de.BadData:
  }
  if (d === c.errors.defaultInvalidChart && (e === de.BarElementExceedsLimit || e === de.LineChartExceedsLimit || e === de.PieChartExceedsLimit || e === de.GaugeExceedsLimit || e === de.BoxPlotExceedsLimit) && typeof a == "number" && typeof n == "number" && a / n > g) {
    const S = a / n;
    d = Gt(c.errors.categoryCountCannotExceedLimit, {
      categoryCount: f.format(S),
      maxCategoryCount: f.format(g)
    });
  }
  return {
    keyword: e ?? de.BadData,
    header: y,
    message: d,
    params: u
  };
}
function Un(t, e) {
  return `${e}_${t}`;
}
function $l(t) {
  const { value: e, mean: i, stdDev: a } = t;
  return (e - i) / a;
}
function Ic(t) {
  const { dataItem: e, chartSubType: i, y: a, splitByValue: n, meanPerField: o, stdDevPerField: s } = t, r = e;
  let l = {
    chartSubType: i,
    y: a,
    splitByValue: n
  };
  const c = oe({
    ...l,
    key: Y.Average
  }), d = oe({
    ...l,
    key: Y.StandardDeviation
  }), u = o ?? Number(e[c]), f = s ?? Number(e[d]);
  return Number.isFinite(u) && Number.isFinite(f) && Object.values(Y).forEach((m) => {
    const g = oe({
      key: m,
      y: a,
      chartSubType: i,
      splitByValue: n
    }), y = e[g];
    if (y != null) {
      let p = Number(y);
      if (Number.isFinite(p)) {
        l = {
          ...l,
          key: m,
          showOutliers: !1,
          standardizeValues: !0
        };
        let S = oe(l);
        if (r[S] = $l({ mean: u, stdDev: f, value: p }), m === Y.Min || m === Y.Max) {
          l = {
            ...l,
            key: m,
            showOutliers: !0,
            standardizeValues: !0
          }, S = oe(l), l = {
            ...l,
            standardizeValues: !1,
            splitByValue: n
          };
          const x = oe(l);
          p = Number(e[x]), Number.isFinite(p) && (r[S] = $l({
            mean: u,
            stdDev: f,
            value: p
          }));
        }
      }
    }
  }), r;
}
function bx(t) {
  const { data: e, yList: i, calculateZScore: a = !1 } = t, n = e[0], o = /* @__PURE__ */ new Map();
  return i.forEach((r) => {
    let l = {};
    Object.keys(n).forEach((c) => {
      c.startsWith(r) ? l[c.replace(`${r}_`, "")] = n[c] : c.includes(k.rendererSymbolField) && (l[c] = n[c]), l[k.boxPlot.boxPlotCategory] = r, a && (l = Ic({
        dataItem: l,
        chartSubType: L.BoxPlotMultiFields
      }));
    }), o.set(r, l);
  }), Array.from(o.values());
}
function Sx(t) {
  const { data: e, splitByField: i, y: a } = t, n = {
    [k.boxPlot.boxPlotCategory]: a
  };
  return e.forEach((s) => {
    const r = s[i];
    r !== void 0 && Object.keys(s).forEach((l) => {
      l === k.rendererSymbolField ? n[`${l}_${r?.toString()}`] = s[l] : l === k.boxPlot.boxPlotMeanLineMarkerId ? n[l] = s[l] : n[`${r?.toString()}_${l}`] = s[l];
    });
  }), [n];
}
function xx(t) {
  const { splitByField: e, data: i, yList: a, calculateZScore: n = !1, meanAndStdDevPerField: o } = t, s = /* @__PURE__ */ new Map();
  return i.forEach((l) => {
    const c = l[e];
    a.forEach((d) => {
      let u = {
        [k.boxPlot.boxPlotCategory]: d
      };
      Object.entries(l).forEach(([f, m]) => {
        f.startsWith(`${d}_`) ? u[`${c}_${f.replace(`${d}_`, "")}`] = m : f.includes(k.rendererSymbolField) ? u[`${f}_${c}`] = m : f === k.boxPlot.boxPlotMeanLineMarkerId && (u[f] = l[f]);
      }), n && (u = Ic({
        dataItem: u,
        chartSubType: L.BoxPlotMultiFieldsAndSplitBy,
        splitByValue: c,
        meanPerField: o?.[Un(d, X.Average)],
        stdDevPerField: o?.[Un(d, X.StandardDeviation)]
      })), s.set(d, {
        ...s.get(d) ?? {},
        ...u
      });
    });
  }), Array.from(s.values());
}
function Cx(t) {
  const { data: e, yList: i, calculateZScore: a = !1, meanAndStdDevPerField: n } = t, o = e;
  return a && o.forEach((s) => {
    i.forEach((r) => {
      Ic({
        dataItem: s,
        chartSubType: L.BoxPlotMultiFieldsAndCategory,
        y: r,
        meanPerField: n?.[Un(r, X.Average)],
        stdDevPerField: n?.[Un(r, X.StandardDeviation)]
      });
    });
  }), o;
}
function vx(t) {
  const { splitByField: e, x: i, data: a } = t, n = /* @__PURE__ */ new Map();
  return a.forEach((s) => {
    const r = s[i], l = { [i]: r }, c = s[e];
    Object.entries(s).forEach(([d, u]) => {
      if (d.includes(k.rendererSymbolField))
        l[`${k.rendererSymbolField}_${c?.toString()}`] = u;
      else if (d === k.boxPlot.boxPlotMeanLineMarkerId)
        l[d] = s[d];
      else if (d !== e && d !== i) {
        const f = d !== k.xAxisField && d !== k.originalCategoryValue ? `${c?.toString()}_${d}` : d;
        l[f] = u;
      }
    }), n.set(r, {
      ...n.get(r) ?? {},
      ...l
    });
  }), Array.from(n.values());
}
function Fx(t, e) {
  const { series: i } = t, a = i[0], { y: n } = a, o = H(t.series), s = {
    y: o === L.BoxPlotMultiFieldsAndCategory ? n : void 0,
    chartSubType: o
  }, r = t.series.map((l) => {
    let c = Lt({
      where: l.query?.where,
      normalize: !1,
      escape: !0
    });
    return c !== null && `${c}`.startsWith("'") && `${c}`.endsWith("'") && (c = c.substring(1, c.length - 1)), c;
  });
  r.length === 0 && r.push(" "), e.forEach((l) => {
    r.forEach((c) => {
      s.splitByValue = c;
      const d = oe({
        ...s,
        key: Y.Min,
        showOutliers: !0
      }), u = oe({
        ...s,
        key: Y.Min,
        showOutliers: !1
      }), f = oe({
        ...s,
        key: Y.Max,
        showOutliers: !0
      }), m = oe({
        ...s,
        key: Y.Max,
        showOutliers: !1
      });
      l[f] === void 0 && l[m] !== void 0 && (l[f] = l[m]), l[d] === void 0 && l[u] !== void 0 && (l[d] = l[u]);
    });
  });
}
function Lx(t, e) {
  let i, a;
  const n = t[e[Y.IQR]], o = t[e[Y.FirstQuartile]], s = t[e[Y.ThirdQuartile]];
  return Number.isFinite(n) && Number.isFinite(o) && Number.isFinite(s) && (i = o - n * 1.5, a = s + n * 1.5), { outlierMinThreshold: i, outlierMaxThreshold: a };
}
function tu(t) {
  const { yField: e, xField: i, xValue: a, splitByField: n, splitByValue: o, outlierMaxThreshold: s, outlierMinThreshold: r, target: l } = t;
  let c;
  if (i !== void 0 && a !== void 0) {
    const m = typeof a != "string" ? a : `'${zd(a)}'`;
    c = `${i}=${m.toString()}`;
  }
  let d;
  if (n !== void 0 && o !== void 0) {
    const m = typeof o != "string" ? o : `'${zd(o)}'`;
    d = `${n}=${m.toString()}`;
  }
  let u;
  return l === "outliers" && r !== s ? u = `(${e}<${r} OR ${e}>${s})` : l === "alternativeData" && (r === s ? u = `(${e}=${r})` : u = `(${e}>=${r} AND ${e}<=${s})`), [c, d, u].filter((m) => m !== void 0).join(" AND ");
}
function km(t) {
  const { data: e, yField: i, x: a, chartSubType: n, splitByField: o } = t, s = n === L.BoxPlotMonoField || n === L.BoxPlotMonoFieldAndCategory || n === L.BoxPlotMonoFieldAndSplitBy || n === L.BoxPlotMonoFieldAndCategoryAndSplitBy ? void 0 : i, r = ko(s), l = [], c = [], { maxOperandsPerWhereClause: d } = Uo();
  let u = [], f = [], m = 1;
  return e.forEach((g, y) => {
    const { outlierMinThreshold: p, outlierMaxThreshold: S } = Lx(g, r);
    if (typeof p == "number" && typeof S == "number") {
      const x = {
        yField: i,
        outlierMinThreshold: p,
        outlierMaxThreshold: S
      };
      (n === L.BoxPlotMonoFieldAndCategory || n === L.BoxPlotMultiFieldsAndCategory || n === L.BoxPlotMonoFieldAndCategoryAndSplitBy) && a !== void 0 && a in g && (x.xField = a, x.xValue = Zt({
        value: g[a],
        dataContext: g,
        keepNullValues: !0,
        specificField: k.typeOrDomainIdValue
      })), (n === L.BoxPlotMonoFieldAndSplitBy || n === L.BoxPlotMultiFieldsAndSplitBy || n === L.BoxPlotMonoFieldAndCategoryAndSplitBy) && o !== void 0 && o in g && (x.splitByField = o, x.splitByValue = g[o]), u.push(tu({ ...x, target: "outliers" })), f.push(tu({ ...x, target: "alternativeData" })), (m % d === 0 || y === e.length - 1) && (l.push(Xe(u, "OR")), c.push(Xe(f, "OR")), u = [], f = []);
    }
    m += 1;
  }), { outliersFilterBatches: l, dataWithoutOutliersFilterBatches: c };
}
function Ax(t) {
  const { data: e, outlierDataItem: i, chartSubType: a, x: n, y: o, meanAndStdDevPerField: s, splitByField: r } = t;
  let l = s?.[Un(o, X.Average)], c = s?.[Un(o, X.StandardDeviation)];
  if (l === void 0 && c === void 0)
    switch (a) {
      case L.BoxPlotMultiFields: {
        const d = ko(o), u = e[0];
        l = Number(u[d[Y.Average]]), c = Number(u[d[Y.StandardDeviation]]);
        break;
      }
      case L.BoxPlotMultiFieldsAndCategory: {
        const d = e.find((u) => u[n] === i[n]);
        if (d !== void 0) {
          const u = ko(o);
          l = Number(d[u[Y.Average]]), c = Number(d[u[Y.StandardDeviation]]);
        }
        break;
      }
      case L.BoxPlotMultiFieldsAndSplitBy: {
        const d = e.find((u) => u[r] === i[r]);
        if (d !== void 0) {
          const u = ko(o);
          l = Number(d[u[Y.Average]]), c = Number(d[u[Y.StandardDeviation]]);
        }
        break;
      }
    }
  return { mean: l, stdDev: c };
}
async function Tx(t) {
  const { seriesConfig: e, data: i, uniqueQuery: a, queryObject: n, meanAndStdDevPerField: o, abortKey: s } = t, r = H(e), l = e[0], { x: c } = l, d = Ze(l.query?.where), u = we(n), f = pt(e), m = [];
  for (let p = 0; p < f.length; p += 1) {
    const S = f[p], { outliersFilterBatches: x } = km({
      data: i,
      yField: S,
      x: c,
      chartSubType: r,
      splitByField: d
    });
    for (let C = 0; C < x.length; C += 1) {
      const F = x[C];
      if (F !== "") {
        const v = [];
        c !== k.boxPlot.boxPlotCategory && v.push(c), v.push(S), d !== "" && v.push(d), v.push(u.objectIdField);
        const A = {
          ...a,
          where: Xe([a.where, F]),
          groupByFieldsForStatistics: void 0,
          outStatistics: void 0,
          orderByFields: void 0,
          num: void 0,
          outFields: v
        };
        m.push(
          aa({
            queryObject: n,
            queryConfig: A,
            featureCount: 1,
            // TODO: pre-count to trigger batching
            abortKey: s
          })
        );
      }
    }
  }
  const g = await Promise.all(m), y = /* @__PURE__ */ new Map();
  for (let p = 0; p < g.length; p += 1) {
    const S = g[p], x = f[p];
    S.forEach((C) => {
      const F = { ...C.attributes };
      if (F[x] !== void 0) {
        c === k.boxPlot.boxPlotCategory && (F[k.boxPlot.boxPlotCategory] = x);
        let v = {
          key: Y.Outlier,
          chartSubType: r
        };
        switch (r) {
          case L.BoxPlotMonoFieldAndSplitBy:
          case L.BoxPlotMultiFieldsAndSplitBy:
          case L.BoxPlotMonoFieldAndCategoryAndSplitBy:
            v = {
              ...v,
              splitByValue: F[d]
            };
            break;
          case L.BoxPlotMultiFieldsAndCategory:
            v = {
              ...v,
              y: x
            };
            break;
        }
        const A = oe(v), w = F[x];
        F[A] = w;
        const O = `${F[c]}-${F[d]}-${w}`, I = y.get(O);
        if (F[ot.uniqueIdsName] = [
          ...I?.[ot.uniqueIdsName] ?? [],
          F[u.objectIdField]
        ], delete F[u.objectIdField], Hn(r)) {
          const N = oe({
            ...v,
            standardizeValues: !0
          }), { mean: M, stdDev: P } = Ax({
            data: i,
            outlierDataItem: F,
            chartSubType: r,
            x: c,
            y: x,
            splitByField: d,
            meanAndStdDevPerField: o
          });
          M !== void 0 && P !== void 0 && (F[N] = $l({
            value: w,
            mean: M,
            stdDev: P
          }));
        }
        delete F[x], F[k.boxPlot.boxPlotOutlierId] = !0, y.set(O, F);
      }
    });
  }
  return Array.from(y.values());
}
async function wx(t) {
  const { data: e, queryObject: i, uniqueQuery: a, elementCount: n, chartConfig: o, chartLimits: s, abortKey: r } = t;
  let l = [];
  const { series: c, showMean: d } = o, u = lc({ showMean: d, seriesConfig: c }), f = H(c), m = ha(o), { x: g } = m, y = Ze(m.query?.where), p = [];
  for (let x = 0; x < u.length; x += 1) {
    const C = u[x], { dataWithoutOutliersFilterBatches: F } = km({
      data: e,
      yField: C,
      x: g,
      chartSubType: f,
      splitByField: y
    });
    for (let v = 0; v < F.length; v += 1) {
      const A = F[v], w = {
        ...a,
        where: Xe([a.where, A])
      };
      w.outStatistics !== void 0 && (w.outStatistics = w.outStatistics?.filter(
        (O) => (O.statisticType === X.Minimum || O.statisticType === X.Maximum) && O.onStatisticField === C
      ).map((O) => ({
        ...O,
        outStatisticFieldName: `${O.outStatisticFieldName}${k.boxPlot.boxPlotOutliersSuffix}`
      }))), p.push(
        Rr({
          queryObject: i,
          uniqueQuery: w,
          chartConfig: o,
          elementCount: n,
          isTimeBinningSeries: !1,
          showMean: d,
          chartLimits: s,
          abortKey: r
        })
      );
    }
  }
  const S = await Promise.all(p);
  for (let x = 0; x < S.length; x += 1)
    l.push(...S[x]);
  return f !== L.BoxPlotMonoFieldAndCategoryAndSplitBy && (l = ns({
    data: l,
    x: y !== void 0 && y !== "" ? y : g
  })), l;
}
async function kx(t) {
  const { queryObject: e, uniqueQuery: i, chartConfig: a, abortKey: n } = t;
  let o;
  const { series: s, showMean: r } = a, l = H(s);
  if (l === L.BoxPlotMultiFieldsAndCategory || l === L.BoxPlotMultiFieldsAndSplitBy) {
    const c = lc({ showMean: r, seriesConfig: s }), d = {
      ...i
    };
    delete d.outStatistics, delete d.groupByFieldsForStatistics, delete d.orderByFields;
    const u = [];
    for (let m = 0; m < c.length; m += 1) {
      const g = c[m];
      u.push(
        {
          statisticType: X.Average,
          onStatisticField: g,
          outStatisticFieldName: `${X.Average}_${g}`
        },
        {
          statisticType: X.StandardDeviation,
          onStatisticField: g,
          outStatisticFieldName: `${X.StandardDeviation}_${g}`
        }
      );
    }
    d.outStatistics = u;
    const f = await aa({
      queryObject: e,
      queryConfig: d,
      featureCount: 1,
      abortKey: n
    });
    f.length > 0 && (o = f[0].attributes);
  }
  return o;
}
function Ix(t) {
  const { data: e, additionalData: i, chartConfig: a } = t, n = a.series[0], { x: o } = n, s = Ze(n.query?.where);
  return e.map((r) => {
    let l = r;
    const c = i.find(
      (d) => d[o] === r[o] && (s === "" ? !0 : d[s] === r[s])
    );
    return c !== void 0 && (l = { ...r, ...c }), l;
  });
}
function Im(t) {
  const { chartConfig: e, data: i, calculateZScore: a = !1, meanAndStdDevPerField: n } = t, { series: o, showMean: s } = e, r = ha(e), l = H(e.series), { x: c } = r, d = lc({ showMean: s, seriesConfig: o });
  let u = i;
  if ((r.type === b.LineSeries || r.type === b.BoxPlotSeries) && i?.[0] !== void 0) {
    const f = Ze(r.query?.where);
    switch (l) {
      case L.BoxPlotMonoField:
        u[0][k.boxPlot.boxPlotCategory] = d[0];
        break;
      case L.BoxPlotMultiFields:
        u = bx({
          data: i,
          yList: d,
          calculateZScore: a
        });
        break;
      case L.BoxPlotMonoFieldAndSplitBy:
        u = Sx({
          data: i,
          splitByField: f,
          y: d[0]
          // there's only one `y` value for that query type
        });
        break;
      case L.BoxPlotMultiFieldsAndSplitBy:
        u = xx({
          splitByField: f,
          data: i,
          yList: d,
          meanAndStdDevPerField: n,
          calculateZScore: a
        });
        break;
      case L.BoxPlotMultiFieldsAndCategory:
        u = Cx({
          data: i,
          yList: d,
          meanAndStdDevPerField: n,
          calculateZScore: a
        });
        break;
      case L.BoxPlotMonoFieldAndCategoryAndSplitBy:
        u = vx({
          splitByField: f,
          x: c,
          data: i
        });
        break;
      case L.BoxPlotMonoFieldAndCategory:
    }
  }
  return Fx(e, u), u;
}
async function Ox(t) {
  const { data: e, queryObject: i, uniqueQuery: a, fetchFullBoxPlotData: n, chartConfig: o, elementCount: s, chartLimits: r, abortKey: l } = t;
  let c = e, d = [];
  if (c !== void 0) {
    const { series: u } = o, f = await kx({
      queryObject: i,
      uniqueQuery: a,
      chartConfig: o,
      abortKey: l
    });
    if (n !== !1) {
      d = await Tx({
        queryObject: i,
        uniqueQuery: a,
        seriesConfig: u,
        data: c,
        abortKey: l
      });
      const m = await wx({
        queryObject: i,
        uniqueQuery: a,
        elementCount: s,
        data: e,
        chartConfig: o,
        chartLimits: r,
        abortKey: l
      });
      c = Ix({
        data: c,
        additionalData: m,
        chartConfig: o
      });
    }
    c = Im({
      chartConfig: o,
      data: c,
      meanAndStdDevPerField: f,
      calculateZScore: !0
    });
  }
  return { dataItems: c, outliers: d };
}
class Sn extends Error {
}
class Bx extends Sn {
  constructor(e) {
    super(`Invalid DateTime: ${e.toMessage()}`);
  }
}
class Dx extends Sn {
  constructor(e) {
    super(`Invalid Interval: ${e.toMessage()}`);
  }
}
class Nx extends Sn {
  constructor(e) {
    super(`Invalid Duration: ${e.toMessage()}`);
  }
}
class Dn extends Sn {
}
class Om extends Sn {
  constructor(e) {
    super(`Invalid unit ${e}`);
  }
}
class It extends Sn {
}
class La extends Sn {
  constructor() {
    super("Zone is an abstract class");
  }
}
const _ = "numeric", Pi = "short", si = "long", Js = {
  year: _,
  month: _,
  day: _
}, Bm = {
  year: _,
  month: Pi,
  day: _
}, Mx = {
  year: _,
  month: Pi,
  day: _,
  weekday: Pi
}, Dm = {
  year: _,
  month: si,
  day: _
}, Nm = {
  year: _,
  month: si,
  day: _,
  weekday: si
}, Mm = {
  hour: _,
  minute: _
}, $m = {
  hour: _,
  minute: _,
  second: _
}, Pm = {
  hour: _,
  minute: _,
  second: _,
  timeZoneName: Pi
}, Rm = {
  hour: _,
  minute: _,
  second: _,
  timeZoneName: si
}, Vm = {
  hour: _,
  minute: _,
  hourCycle: "h23"
}, Em = {
  hour: _,
  minute: _,
  second: _,
  hourCycle: "h23"
}, Wm = {
  hour: _,
  minute: _,
  second: _,
  hourCycle: "h23",
  timeZoneName: Pi
}, zm = {
  hour: _,
  minute: _,
  second: _,
  hourCycle: "h23",
  timeZoneName: si
}, Hm = {
  year: _,
  month: _,
  day: _,
  hour: _,
  minute: _
}, qm = {
  year: _,
  month: _,
  day: _,
  hour: _,
  minute: _,
  second: _
}, Gm = {
  year: _,
  month: Pi,
  day: _,
  hour: _,
  minute: _
}, Ym = {
  year: _,
  month: Pi,
  day: _,
  hour: _,
  minute: _,
  second: _
}, $x = {
  year: _,
  month: Pi,
  day: _,
  weekday: Pi,
  hour: _,
  minute: _
}, Xm = {
  year: _,
  month: si,
  day: _,
  hour: _,
  minute: _,
  timeZoneName: Pi
}, Um = {
  year: _,
  month: si,
  day: _,
  hour: _,
  minute: _,
  second: _,
  timeZoneName: Pi
}, jm = {
  year: _,
  month: si,
  day: _,
  weekday: si,
  hour: _,
  minute: _,
  timeZoneName: si
}, _m = {
  year: _,
  month: si,
  day: _,
  weekday: si,
  hour: _,
  minute: _,
  second: _,
  timeZoneName: si
};
class es {
  /**
   * The type of zone
   * @abstract
   * @type {string}
   */
  get type() {
    throw new La();
  }
  /**
   * The name of this zone.
   * @abstract
   * @type {string}
   */
  get name() {
    throw new La();
  }
  /**
   * The IANA name of this zone.
   * Defaults to `name` if not overwritten by a subclass.
   * @abstract
   * @type {string}
   */
  get ianaName() {
    return this.name;
  }
  /**
   * Returns whether the offset is known to be fixed for the whole year.
   * @abstract
   * @type {boolean}
   */
  get isUniversal() {
    throw new La();
  }
  /**
   * Returns the offset's common name (such as EST) at the specified timestamp
   * @abstract
   * @param {number} ts - Epoch milliseconds for which to get the name
   * @param {Object} opts - Options to affect the format
   * @param {string} opts.format - What style of offset to return. Accepts 'long' or 'short'.
   * @param {string} opts.locale - What locale to return the offset name in.
   * @return {string}
   */
  offsetName(e, i) {
    throw new La();
  }
  /**
   * Returns the offset's value as a string
   * @abstract
   * @param {number} ts - Epoch milliseconds for which to get the offset
   * @param {string} format - What style of offset to return.
   *                          Accepts 'narrow', 'short', or 'techie'. Returning '+6', '+06:00', or '+0600' respectively
   * @return {string}
   */
  formatOffset(e, i) {
    throw new La();
  }
  /**
   * Return the offset in minutes for this zone at the specified timestamp.
   * @abstract
   * @param {number} ts - Epoch milliseconds for which to compute the offset
   * @return {number}
   */
  offset(e) {
    throw new La();
  }
  /**
   * Return whether this Zone is equal to another zone
   * @abstract
   * @param {Zone} otherZone - the zone to compare
   * @return {boolean}
   */
  equals(e) {
    throw new La();
  }
  /**
   * Return whether this Zone is valid.
   * @abstract
   * @type {boolean}
   */
  get isValid() {
    throw new La();
  }
}
let hl = null;
class Br extends es {
  /**
   * Get a singleton instance of the local zone
   * @return {SystemZone}
   */
  static get instance() {
    return hl === null && (hl = new Br()), hl;
  }
  /** @override **/
  get type() {
    return "system";
  }
  /** @override **/
  get name() {
    return new Intl.DateTimeFormat().resolvedOptions().timeZone;
  }
  /** @override **/
  get isUniversal() {
    return !1;
  }
  /** @override **/
  offsetName(e, { format: i, locale: a }) {
    return ng(e, i, a);
  }
  /** @override **/
  formatOffset(e, i) {
    return Oo(this.offset(e), i);
  }
  /** @override **/
  offset(e) {
    return -new Date(e).getTimezoneOffset();
  }
  /** @override **/
  equals(e) {
    return e.type === "system";
  }
  /** @override **/
  get isValid() {
    return !0;
  }
}
let Ps = {};
function Px(t) {
  return Ps[t] || (Ps[t] = new Intl.DateTimeFormat("en-US", {
    hour12: !1,
    timeZone: t,
    year: "numeric",
    month: "2-digit",
    day: "2-digit",
    hour: "2-digit",
    minute: "2-digit",
    second: "2-digit",
    era: "short"
  })), Ps[t];
}
const Rx = {
  year: 0,
  month: 1,
  day: 2,
  era: 3,
  hour: 4,
  minute: 5,
  second: 6
};
function Vx(t, e) {
  const i = t.format(e).replace(/\u200E/g, ""), a = /(\d+)\/(\d+)\/(\d+) (AD|BC),? (\d+):(\d+):(\d+)/.exec(i), [, n, o, s, r, l, c, d] = a;
  return [s, n, o, r, l, c, d];
}
function Ex(t, e) {
  const i = t.formatToParts(e), a = [];
  for (let n = 0; n < i.length; n++) {
    const { type: o, value: s } = i[n], r = Rx[o];
    o === "era" ? a[r] = s : ae(r) || (a[r] = parseInt(s, 10));
  }
  return a;
}
let Cs = {};
class da extends es {
  /**
   * @param {string} name - Zone name
   * @return {IANAZone}
   */
  static create(e) {
    return Cs[e] || (Cs[e] = new da(e)), Cs[e];
  }
  /**
   * Reset local caches. Should only be necessary in testing scenarios.
   * @return {void}
   */
  static resetCache() {
    Cs = {}, Ps = {};
  }
  /**
   * Returns whether the provided string is a valid specifier. This only checks the string's format, not that the specifier identifies a known zone; see isValidZone for that.
   * @param {string} s - The string to check validity on
   * @example IANAZone.isValidSpecifier("America/New_York") //=> true
   * @example IANAZone.isValidSpecifier("Sport~~blorp") //=> false
   * @deprecated For backward compatibility, this forwards to isValidZone, better use `isValidZone()` directly instead.
   * @return {boolean}
   */
  static isValidSpecifier(e) {
    return this.isValidZone(e);
  }
  /**
   * Returns whether the provided string identifies a real zone
   * @param {string} zone - The string to check
   * @example IANAZone.isValidZone("America/New_York") //=> true
   * @example IANAZone.isValidZone("Fantasia/Castle") //=> false
   * @example IANAZone.isValidZone("Sport~~blorp") //=> false
   * @return {boolean}
   */
  static isValidZone(e) {
    if (!e)
      return !1;
    try {
      return new Intl.DateTimeFormat("en-US", { timeZone: e }).format(), !0;
    } catch {
      return !1;
    }
  }
  constructor(e) {
    super(), this.zoneName = e, this.valid = da.isValidZone(e);
  }
  /**
   * The type of zone. `iana` for all instances of `IANAZone`.
   * @override
   * @type {string}
   */
  get type() {
    return "iana";
  }
  /**
   * The name of this zone (i.e. the IANA zone name).
   * @override
   * @type {string}
   */
  get name() {
    return this.zoneName;
  }
  /**
   * Returns whether the offset is known to be fixed for the whole year:
   * Always returns false for all IANA zones.
   * @override
   * @type {boolean}
   */
  get isUniversal() {
    return !1;
  }
  /**
   * Returns the offset's common name (such as EST) at the specified timestamp
   * @override
   * @param {number} ts - Epoch milliseconds for which to get the name
   * @param {Object} opts - Options to affect the format
   * @param {string} opts.format - What style of offset to return. Accepts 'long' or 'short'.
   * @param {string} opts.locale - What locale to return the offset name in.
   * @return {string}
   */
  offsetName(e, { format: i, locale: a }) {
    return ng(e, i, a, this.name);
  }
  /**
   * Returns the offset's value as a string
   * @override
   * @param {number} ts - Epoch milliseconds for which to get the offset
   * @param {string} format - What style of offset to return.
   *                          Accepts 'narrow', 'short', or 'techie'. Returning '+6', '+06:00', or '+0600' respectively
   * @return {string}
   */
  formatOffset(e, i) {
    return Oo(this.offset(e), i);
  }
  /**
   * Return the offset in minutes for this zone at the specified timestamp.
   * @override
   * @param {number} ts - Epoch milliseconds for which to compute the offset
   * @return {number}
   */
  offset(e) {
    const i = new Date(e);
    if (isNaN(i)) return NaN;
    const a = Px(this.name);
    let [n, o, s, r, l, c, d] = a.formatToParts ? Ex(a, i) : Vx(a, i);
    r === "BC" && (n = -Math.abs(n) + 1);
    const f = Nr({
      year: n,
      month: o,
      day: s,
      hour: l === 24 ? 0 : l,
      minute: c,
      second: d,
      millisecond: 0
    });
    let m = +i;
    const g = m % 1e3;
    return m -= g >= 0 ? g : 1e3 + g, (f - m) / (60 * 1e3);
  }
  /**
   * Return whether this Zone is equal to another zone
   * @override
   * @param {Zone} otherZone - the zone to compare
   * @return {boolean}
   */
  equals(e) {
    return e.type === "iana" && e.name === this.name;
  }
  /**
   * Return whether this Zone is valid.
   * @override
   * @type {boolean}
   */
  get isValid() {
    return this.valid;
  }
}
let iu = {};
function Wx(t, e = {}) {
  const i = JSON.stringify([t, e]);
  let a = iu[i];
  return a || (a = new Intl.ListFormat(t, e), iu[i] = a), a;
}
let Pl = {};
function Rl(t, e = {}) {
  const i = JSON.stringify([t, e]);
  let a = Pl[i];
  return a || (a = new Intl.DateTimeFormat(t, e), Pl[i] = a), a;
}
let Vl = {};
function zx(t, e = {}) {
  const i = JSON.stringify([t, e]);
  let a = Vl[i];
  return a || (a = new Intl.NumberFormat(t, e), Vl[i] = a), a;
}
let El = {};
function Hx(t, e = {}) {
  const { base: i, ...a } = e, n = JSON.stringify([t, a]);
  let o = El[n];
  return o || (o = new Intl.RelativeTimeFormat(t, e), El[n] = o), o;
}
let To = null;
function qx() {
  return To || (To = new Intl.DateTimeFormat().resolvedOptions().locale, To);
}
let au = {};
function Gx(t) {
  let e = au[t];
  if (!e) {
    const i = new Intl.Locale(t);
    e = "getWeekInfo" in i ? i.getWeekInfo() : i.weekInfo, au[t] = e;
  }
  return e;
}
function Yx(t) {
  const e = t.indexOf("-x-");
  e !== -1 && (t = t.substring(0, e));
  const i = t.indexOf("-u-");
  if (i === -1)
    return [t];
  {
    let a, n;
    try {
      a = Rl(t).resolvedOptions(), n = t;
    } catch {
      const l = t.substring(0, i);
      a = Rl(l).resolvedOptions(), n = l;
    }
    const { numberingSystem: o, calendar: s } = a;
    return [n, o, s];
  }
}
function Xx(t, e, i) {
  return (i || e) && (t.includes("-u-") || (t += "-u"), i && (t += `-ca-${i}`), e && (t += `-nu-${e}`)), t;
}
function Ux(t) {
  const e = [];
  for (let i = 1; i <= 12; i++) {
    const a = K.utc(2009, i, 1);
    e.push(t(a));
  }
  return e;
}
function jx(t) {
  const e = [];
  for (let i = 1; i <= 7; i++) {
    const a = K.utc(2016, 11, 13 + i);
    e.push(t(a));
  }
  return e;
}
function vs(t, e, i, a) {
  const n = t.listingMode();
  return n === "error" ? null : n === "en" ? i(e) : a(e);
}
function _x(t) {
  return t.numberingSystem && t.numberingSystem !== "latn" ? !1 : t.numberingSystem === "latn" || !t.locale || t.locale.startsWith("en") || new Intl.DateTimeFormat(t.intl).resolvedOptions().numberingSystem === "latn";
}
class Zx {
  constructor(e, i, a) {
    this.padTo = a.padTo || 0, this.floor = a.floor || !1;
    const { padTo: n, floor: o, ...s } = a;
    if (!i || Object.keys(s).length > 0) {
      const r = { useGrouping: !1, ...a };
      a.padTo > 0 && (r.minimumIntegerDigits = a.padTo), this.inf = zx(e, r);
    }
  }
  format(e) {
    if (this.inf) {
      const i = this.floor ? Math.floor(e) : e;
      return this.inf.format(i);
    } else {
      const i = this.floor ? Math.floor(e) : Mc(e, 3);
      return lt(i, this.padTo);
    }
  }
}
class Qx {
  constructor(e, i, a) {
    this.opts = a, this.originalZone = void 0;
    let n;
    if (this.opts.timeZone)
      this.dt = e;
    else if (e.zone.type === "fixed") {
      const s = -1 * (e.offset / 60), r = s >= 0 ? `Etc/GMT+${s}` : `Etc/GMT${s}`;
      e.offset !== 0 && da.create(r).valid ? (n = r, this.dt = e) : (n = "UTC", this.dt = e.offset === 0 ? e : e.setZone("UTC").plus({ minutes: e.offset }), this.originalZone = e.zone);
    } else e.zone.type === "system" ? this.dt = e : e.zone.type === "iana" ? (this.dt = e, n = e.zone.name) : (n = "UTC", this.dt = e.setZone("UTC").plus({ minutes: e.offset }), this.originalZone = e.zone);
    const o = { ...this.opts };
    o.timeZone = o.timeZone || n, this.dtf = Rl(i, o);
  }
  format() {
    return this.originalZone ? this.formatToParts().map(({ value: e }) => e).join("") : this.dtf.format(this.dt.toJSDate());
  }
  formatToParts() {
    const e = this.dtf.formatToParts(this.dt.toJSDate());
    return this.originalZone ? e.map((i) => {
      if (i.type === "timeZoneName") {
        const a = this.originalZone.offsetName(this.dt.ts, {
          locale: this.dt.locale,
          format: this.opts.timeZoneName
        });
        return {
          ...i,
          value: a
        };
      } else
        return i;
    }) : e;
  }
  resolvedOptions() {
    return this.dtf.resolvedOptions();
  }
}
class Kx {
  constructor(e, i, a) {
    this.opts = { style: "long", ...a }, !i && ig() && (this.rtf = Hx(e, a));
  }
  format(e, i) {
    return this.rtf ? this.rtf.format(e, i) : CC(i, e, this.opts.numeric, this.opts.style !== "long");
  }
  formatToParts(e, i) {
    return this.rtf ? this.rtf.formatToParts(e, i) : [];
  }
}
const Jx = {
  firstDay: 1,
  minimalDays: 4,
  weekend: [6, 7]
};
class ke {
  static fromOpts(e) {
    return ke.create(
      e.locale,
      e.numberingSystem,
      e.outputCalendar,
      e.weekSettings,
      e.defaultToEN
    );
  }
  static create(e, i, a, n, o = !1) {
    const s = e || Je.defaultLocale, r = s || (o ? "en-US" : qx()), l = i || Je.defaultNumberingSystem, c = a || Je.defaultOutputCalendar, d = Wl(n) || Je.defaultWeekSettings;
    return new ke(r, l, c, d, s);
  }
  static resetCache() {
    To = null, Pl = {}, Vl = {}, El = {};
  }
  static fromObject({ locale: e, numberingSystem: i, outputCalendar: a, weekSettings: n } = {}) {
    return ke.create(e, i, a, n);
  }
  constructor(e, i, a, n, o) {
    const [s, r, l] = Yx(e);
    this.locale = s, this.numberingSystem = i || r || null, this.outputCalendar = a || l || null, this.weekSettings = n, this.intl = Xx(this.locale, this.numberingSystem, this.outputCalendar), this.weekdaysCache = { format: {}, standalone: {} }, this.monthsCache = { format: {}, standalone: {} }, this.meridiemCache = null, this.eraCache = {}, this.specifiedLocale = o, this.fastNumbersCached = null;
  }
  get fastNumbers() {
    return this.fastNumbersCached == null && (this.fastNumbersCached = _x(this)), this.fastNumbersCached;
  }
  listingMode() {
    const e = this.isEnglish(), i = (this.numberingSystem === null || this.numberingSystem === "latn") && (this.outputCalendar === null || this.outputCalendar === "gregory");
    return e && i ? "en" : "intl";
  }
  clone(e) {
    return !e || Object.getOwnPropertyNames(e).length === 0 ? this : ke.create(
      e.locale || this.specifiedLocale,
      e.numberingSystem || this.numberingSystem,
      e.outputCalendar || this.outputCalendar,
      Wl(e.weekSettings) || this.weekSettings,
      e.defaultToEN || !1
    );
  }
  redefaultToEN(e = {}) {
    return this.clone({ ...e, defaultToEN: !0 });
  }
  redefaultToSystem(e = {}) {
    return this.clone({ ...e, defaultToEN: !1 });
  }
  months(e, i = !1) {
    return vs(this, e, rg, () => {
      const a = i ? { month: e, day: "numeric" } : { month: e }, n = i ? "format" : "standalone";
      return this.monthsCache[n][e] || (this.monthsCache[n][e] = Ux((o) => this.extract(o, a, "month"))), this.monthsCache[n][e];
    });
  }
  weekdays(e, i = !1) {
    return vs(this, e, dg, () => {
      const a = i ? { weekday: e, year: "numeric", month: "long", day: "numeric" } : { weekday: e }, n = i ? "format" : "standalone";
      return this.weekdaysCache[n][e] || (this.weekdaysCache[n][e] = jx(
        (o) => this.extract(o, a, "weekday")
      )), this.weekdaysCache[n][e];
    });
  }
  meridiems() {
    return vs(
      this,
      void 0,
      () => ug,
      () => {
        if (!this.meridiemCache) {
          const e = { hour: "numeric", hourCycle: "h12" };
          this.meridiemCache = [K.utc(2016, 11, 13, 9), K.utc(2016, 11, 13, 19)].map(
            (i) => this.extract(i, e, "dayperiod")
          );
        }
        return this.meridiemCache;
      }
    );
  }
  eras(e) {
    return vs(this, e, fg, () => {
      const i = { era: e };
      return this.eraCache[e] || (this.eraCache[e] = [K.utc(-40, 1, 1), K.utc(2017, 1, 1)].map(
        (a) => this.extract(a, i, "era")
      )), this.eraCache[e];
    });
  }
  extract(e, i, a) {
    const n = this.dtFormatter(e, i), o = n.formatToParts(), s = o.find((r) => r.type.toLowerCase() === a);
    return s ? s.value : null;
  }
  numberFormatter(e = {}) {
    return new Zx(this.intl, e.forceSimple || this.fastNumbers, e);
  }
  dtFormatter(e, i = {}) {
    return new Qx(e, this.intl, i);
  }
  relFormatter(e = {}) {
    return new Kx(this.intl, this.isEnglish(), e);
  }
  listFormatter(e = {}) {
    return Wx(this.intl, e);
  }
  isEnglish() {
    return this.locale === "en" || this.locale.toLowerCase() === "en-us" || new Intl.DateTimeFormat(this.intl).resolvedOptions().locale.startsWith("en-us");
  }
  getWeekSettings() {
    return this.weekSettings ? this.weekSettings : ag() ? Gx(this.locale) : Jx;
  }
  getStartOfWeek() {
    return this.getWeekSettings().firstDay;
  }
  getMinDaysInFirstWeek() {
    return this.getWeekSettings().minimalDays;
  }
  getWeekendDays() {
    return this.getWeekSettings().weekend;
  }
  equals(e) {
    return this.locale === e.locale && this.numberingSystem === e.numberingSystem && this.outputCalendar === e.outputCalendar;
  }
  toString() {
    return `Locale(${this.locale}, ${this.numberingSystem}, ${this.outputCalendar})`;
  }
}
let pl = null;
class Et extends es {
  /**
   * Get a singleton instance of UTC
   * @return {FixedOffsetZone}
   */
  static get utcInstance() {
    return pl === null && (pl = new Et(0)), pl;
  }
  /**
   * Get an instance with a specified offset
   * @param {number} offset - The offset in minutes
   * @return {FixedOffsetZone}
   */
  static instance(e) {
    return e === 0 ? Et.utcInstance : new Et(e);
  }
  /**
   * Get an instance of FixedOffsetZone from a UTC offset string, like "UTC+6"
   * @param {string} s - The offset string to parse
   * @example FixedOffsetZone.parseSpecifier("UTC+6")
   * @example FixedOffsetZone.parseSpecifier("UTC+06")
   * @example FixedOffsetZone.parseSpecifier("UTC-6:00")
   * @return {FixedOffsetZone}
   */
  static parseSpecifier(e) {
    if (e) {
      const i = e.match(/^utc(?:([+-]\d{1,2})(?::(\d{2}))?)?$/i);
      if (i)
        return new Et(Mr(i[1], i[2]));
    }
    return null;
  }
  constructor(e) {
    super(), this.fixed = e;
  }
  /**
   * The type of zone. `fixed` for all instances of `FixedOffsetZone`.
   * @override
   * @type {string}
   */
  get type() {
    return "fixed";
  }
  /**
   * The name of this zone.
   * All fixed zones' names always start with "UTC" (plus optional offset)
   * @override
   * @type {string}
   */
  get name() {
    return this.fixed === 0 ? "UTC" : `UTC${Oo(this.fixed, "narrow")}`;
  }
  /**
   * The IANA name of this zone, i.e. `Etc/UTC` or `Etc/GMT+/-nn`
   *
   * @override
   * @type {string}
   */
  get ianaName() {
    return this.fixed === 0 ? "Etc/UTC" : `Etc/GMT${Oo(-this.fixed, "narrow")}`;
  }
  /**
   * Returns the offset's common name at the specified timestamp.
   *
   * For fixed offset zones this equals to the zone name.
   * @override
   */
  offsetName() {
    return this.name;
  }
  /**
   * Returns the offset's value as a string
   * @override
   * @param {number} ts - Epoch milliseconds for which to get the offset
   * @param {string} format - What style of offset to return.
   *                          Accepts 'narrow', 'short', or 'techie'. Returning '+6', '+06:00', or '+0600' respectively
   * @return {string}
   */
  formatOffset(e, i) {
    return Oo(this.fixed, i);
  }
  /**
   * Returns whether the offset is known to be fixed for the whole year:
   * Always returns true for all fixed offset zones.
   * @override
   * @type {boolean}
   */
  get isUniversal() {
    return !0;
  }
  /**
   * Return the offset in minutes for this zone at the specified timestamp.
   *
   * For fixed offset zones, this is constant and does not depend on a timestamp.
   * @override
   * @return {number}
   */
  offset() {
    return this.fixed;
  }
  /**
   * Return whether this Zone is equal to another zone (i.e. also fixed and same offset)
   * @override
   * @param {Zone} otherZone - the zone to compare
   * @return {boolean}
   */
  equals(e) {
    return e.type === "fixed" && e.fixed === this.fixed;
  }
  /**
   * Return whether this Zone is valid:
   * All fixed offset zones are valid.
   * @override
   * @type {boolean}
   */
  get isValid() {
    return !0;
  }
}
class eC extends es {
  constructor(e) {
    super(), this.zoneName = e;
  }
  /** @override **/
  get type() {
    return "invalid";
  }
  /** @override **/
  get name() {
    return this.zoneName;
  }
  /** @override **/
  get isUniversal() {
    return !1;
  }
  /** @override **/
  offsetName() {
    return null;
  }
  /** @override **/
  formatOffset() {
    return "";
  }
  /** @override **/
  offset() {
    return NaN;
  }
  /** @override **/
  equals() {
    return !1;
  }
  /** @override **/
  get isValid() {
    return !1;
  }
}
function ka(t, e) {
  if (ae(t) || t === null)
    return e;
  if (t instanceof es)
    return t;
  if (sC(t)) {
    const i = t.toLowerCase();
    return i === "default" ? e : i === "local" || i === "system" ? Br.instance : i === "utc" || i === "gmt" ? Et.utcInstance : Et.parseSpecifier(i) || da.create(t);
  } else return Da(t) ? Et.instance(t) : typeof t == "object" && "offset" in t && typeof t.offset == "function" ? t : new eC(t);
}
const Oc = {
  arab: "[٠-٩]",
  arabext: "[۰-۹]",
  bali: "[᭐-᭙]",
  beng: "[০-৯]",
  deva: "[०-९]",
  fullwide: "[０-９]",
  gujr: "[૦-૯]",
  hanidec: "[〇|一|二|三|四|五|六|七|八|九]",
  khmr: "[០-៩]",
  knda: "[೦-೯]",
  laoo: "[໐-໙]",
  limb: "[᥆-᥏]",
  mlym: "[൦-൯]",
  mong: "[᠐-᠙]",
  mymr: "[၀-၉]",
  orya: "[୦-୯]",
  tamldec: "[௦-௯]",
  telu: "[౦-౯]",
  thai: "[๐-๙]",
  tibt: "[༠-༩]",
  latn: "\\d"
}, nu = {
  arab: [1632, 1641],
  arabext: [1776, 1785],
  bali: [6992, 7001],
  beng: [2534, 2543],
  deva: [2406, 2415],
  fullwide: [65296, 65303],
  gujr: [2790, 2799],
  khmr: [6112, 6121],
  knda: [3302, 3311],
  laoo: [3792, 3801],
  limb: [6470, 6479],
  mlym: [3430, 3439],
  mong: [6160, 6169],
  mymr: [4160, 4169],
  orya: [2918, 2927],
  tamldec: [3046, 3055],
  telu: [3174, 3183],
  thai: [3664, 3673],
  tibt: [3872, 3881]
}, tC = Oc.hanidec.replace(/[\[|\]]/g, "").split("");
function iC(t) {
  let e = parseInt(t, 10);
  if (isNaN(e)) {
    e = "";
    for (let i = 0; i < t.length; i++) {
      const a = t.charCodeAt(i);
      if (t[i].search(Oc.hanidec) !== -1)
        e += tC.indexOf(t[i]);
      else
        for (const n in nu) {
          const [o, s] = nu[n];
          a >= o && a <= s && (e += a - o);
        }
    }
    return parseInt(e, 10);
  } else
    return e;
}
let On = {};
function aC() {
  On = {};
}
function Ai({ numberingSystem: t }, e = "") {
  const i = t || "latn";
  return On[i] || (On[i] = {}), On[i][e] || (On[i][e] = new RegExp(`${Oc[i]}${e}`)), On[i][e];
}
let ou = () => Date.now(), su = "system", ru = null, lu = null, cu = null, du = 60, uu, fu = null;
class Je {
  /**
   * Get the callback for returning the current timestamp.
   * @type {function}
   */
  static get now() {
    return ou;
  }
  /**
   * Set the callback for returning the current timestamp.
   * The function should return a number, which will be interpreted as an Epoch millisecond count
   * @type {function}
   * @example Settings.now = () => Date.now() + 3000 // pretend it is 3 seconds in the future
   * @example Settings.now = () => 0 // always pretend it's Jan 1, 1970 at midnight in UTC time
   */
  static set now(e) {
    ou = e;
  }
  /**
   * Set the default time zone to create DateTimes in. Does not affect existing instances.
   * Use the value "system" to reset this value to the system's time zone.
   * @type {string}
   */
  static set defaultZone(e) {
    su = e;
  }
  /**
   * Get the default time zone object currently used to create DateTimes. Does not affect existing instances.
   * The default value is the system's time zone (the one set on the machine that runs this code).
   * @type {Zone}
   */
  static get defaultZone() {
    return ka(su, Br.instance);
  }
  /**
   * Get the default locale to create DateTimes with. Does not affect existing instances.
   * @type {string}
   */
  static get defaultLocale() {
    return ru;
  }
  /**
   * Set the default locale to create DateTimes with. Does not affect existing instances.
   * @type {string}
   */
  static set defaultLocale(e) {
    ru = e;
  }
  /**
   * Get the default numbering system to create DateTimes with. Does not affect existing instances.
   * @type {string}
   */
  static get defaultNumberingSystem() {
    return lu;
  }
  /**
   * Set the default numbering system to create DateTimes with. Does not affect existing instances.
   * @type {string}
   */
  static set defaultNumberingSystem(e) {
    lu = e;
  }
  /**
   * Get the default output calendar to create DateTimes with. Does not affect existing instances.
   * @type {string}
   */
  static get defaultOutputCalendar() {
    return cu;
  }
  /**
   * Set the default output calendar to create DateTimes with. Does not affect existing instances.
   * @type {string}
   */
  static set defaultOutputCalendar(e) {
    cu = e;
  }
  /**
   * @typedef {Object} WeekSettings
   * @property {number} firstDay
   * @property {number} minimalDays
   * @property {number[]} weekend
   */
  /**
   * @return {WeekSettings|null}
   */
  static get defaultWeekSettings() {
    return fu;
  }
  /**
   * Allows overriding the default locale week settings, i.e. the start of the week, the weekend and
   * how many days are required in the first week of a year.
   * Does not affect existing instances.
   *
   * @param {WeekSettings|null} weekSettings
   */
  static set defaultWeekSettings(e) {
    fu = Wl(e);
  }
  /**
   * Get the cutoff year for whether a 2-digit year string is interpreted in the current or previous century. Numbers higher than the cutoff will be considered to mean 19xx and numbers lower or equal to the cutoff will be considered 20xx.
   * @type {number}
   */
  static get twoDigitCutoffYear() {
    return du;
  }
  /**
   * Set the cutoff year for whether a 2-digit year string is interpreted in the current or previous century. Numbers higher than the cutoff will be considered to mean 19xx and numbers lower or equal to the cutoff will be considered 20xx.
   * @type {number}
   * @example Settings.twoDigitCutoffYear = 0 // all 'yy' are interpreted as 20th century
   * @example Settings.twoDigitCutoffYear = 99 // all 'yy' are interpreted as 21st century
   * @example Settings.twoDigitCutoffYear = 50 // '49' -> 2049; '50' -> 1950
   * @example Settings.twoDigitCutoffYear = 1950 // interpreted as 50
   * @example Settings.twoDigitCutoffYear = 2050 // ALSO interpreted as 50
   */
  static set twoDigitCutoffYear(e) {
    du = e % 100;
  }
  /**
   * Get whether Luxon will throw when it encounters invalid DateTimes, Durations, or Intervals
   * @type {boolean}
   */
  static get throwOnInvalid() {
    return uu;
  }
  /**
   * Set whether Luxon will throw when it encounters invalid DateTimes, Durations, or Intervals
   * @type {boolean}
   */
  static set throwOnInvalid(e) {
    uu = e;
  }
  /**
   * Reset Luxon's global caches. Should only be necessary in testing scenarios.
   * @return {void}
   */
  static resetCaches() {
    ke.resetCache(), da.resetCache(), K.resetCache(), aC();
  }
}
class Ii {
  constructor(e, i) {
    this.reason = e, this.explanation = i;
  }
  toMessage() {
    return this.explanation ? `${this.reason}: ${this.explanation}` : this.reason;
  }
}
const Zm = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334], Qm = [0, 31, 60, 91, 121, 152, 182, 213, 244, 274, 305, 335];
function yi(t, e) {
  return new Ii(
    "unit out of range",
    `you specified ${e} (of type ${typeof e}) as a ${t}, which is invalid`
  );
}
function Bc(t, e, i) {
  const a = new Date(Date.UTC(t, e - 1, i));
  t < 100 && t >= 0 && a.setUTCFullYear(a.getUTCFullYear() - 1900);
  const n = a.getUTCDay();
  return n === 0 ? 7 : n;
}
function Km(t, e, i) {
  return i + (ts(t) ? Qm : Zm)[e - 1];
}
function Jm(t, e) {
  const i = ts(t) ? Qm : Zm, a = i.findIndex((o) => o < e), n = e - i[a];
  return { month: a + 1, day: n };
}
function Dc(t, e) {
  return (t - e + 7) % 7 + 1;
}
function er(t, e = 4, i = 1) {
  const { year: a, month: n, day: o } = t, s = Km(a, n, o), r = Dc(Bc(a, n, o), i);
  let l = Math.floor((s - r + 14 - e) / 7), c;
  return l < 1 ? (c = a - 1, l = Eo(c, e, i)) : l > Eo(a, e, i) ? (c = a + 1, l = 1) : c = a, { weekYear: c, weekNumber: l, weekday: r, ...$r(t) };
}
function mu(t, e = 4, i = 1) {
  const { weekYear: a, weekNumber: n, weekday: o } = t, s = Dc(Bc(a, 1, e), i), r = Pn(a);
  let l = n * 7 + o - s - 7 + e, c;
  l < 1 ? (c = a - 1, l += Pn(c)) : l > r ? (c = a + 1, l -= Pn(a)) : c = a;
  const { month: d, day: u } = Jm(c, l);
  return { year: c, month: d, day: u, ...$r(t) };
}
function yl(t) {
  const { year: e, month: i, day: a } = t, n = Km(e, i, a);
  return { year: e, ordinal: n, ...$r(t) };
}
function gu(t) {
  const { year: e, ordinal: i } = t, { month: a, day: n } = Jm(e, i);
  return { year: e, month: a, day: n, ...$r(t) };
}
function hu(t, e) {
  if (!ae(t.localWeekday) || !ae(t.localWeekNumber) || !ae(t.localWeekYear)) {
    if (!ae(t.weekday) || !ae(t.weekNumber) || !ae(t.weekYear))
      throw new Dn(
        "Cannot mix locale-based week fields with ISO-based week fields"
      );
    return ae(t.localWeekday) || (t.weekday = t.localWeekday), ae(t.localWeekNumber) || (t.weekNumber = t.localWeekNumber), ae(t.localWeekYear) || (t.weekYear = t.localWeekYear), delete t.localWeekday, delete t.localWeekNumber, delete t.localWeekYear, {
      minDaysInFirstWeek: e.getMinDaysInFirstWeek(),
      startOfWeek: e.getStartOfWeek()
    };
  } else
    return { minDaysInFirstWeek: 4, startOfWeek: 1 };
}
function nC(t, e = 4, i = 1) {
  const a = Dr(t.weekYear), n = bi(
    t.weekNumber,
    1,
    Eo(t.weekYear, e, i)
  ), o = bi(t.weekday, 1, 7);
  return a ? n ? o ? !1 : yi("weekday", t.weekday) : yi("week", t.weekNumber) : yi("weekYear", t.weekYear);
}
function oC(t) {
  const e = Dr(t.year), i = bi(t.ordinal, 1, Pn(t.year));
  return e ? i ? !1 : yi("ordinal", t.ordinal) : yi("year", t.year);
}
function eg(t) {
  const e = Dr(t.year), i = bi(t.month, 1, 12), a = bi(t.day, 1, tr(t.year, t.month));
  return e ? i ? a ? !1 : yi("day", t.day) : yi("month", t.month) : yi("year", t.year);
}
function tg(t) {
  const { hour: e, minute: i, second: a, millisecond: n } = t, o = bi(e, 0, 23) || e === 24 && i === 0 && a === 0 && n === 0, s = bi(i, 0, 59), r = bi(a, 0, 59), l = bi(n, 0, 999);
  return o ? s ? r ? l ? !1 : yi("millisecond", n) : yi("second", a) : yi("minute", i) : yi("hour", e);
}
function ae(t) {
  return typeof t > "u";
}
function Da(t) {
  return typeof t == "number";
}
function Dr(t) {
  return typeof t == "number" && t % 1 === 0;
}
function sC(t) {
  return typeof t == "string";
}
function rC(t) {
  return Object.prototype.toString.call(t) === "[object Date]";
}
function ig() {
  try {
    return typeof Intl < "u" && !!Intl.RelativeTimeFormat;
  } catch {
    return !1;
  }
}
function ag() {
  try {
    return typeof Intl < "u" && !!Intl.Locale && ("weekInfo" in Intl.Locale.prototype || "getWeekInfo" in Intl.Locale.prototype);
  } catch {
    return !1;
  }
}
function lC(t) {
  return Array.isArray(t) ? t : [t];
}
function pu(t, e, i) {
  if (t.length !== 0)
    return t.reduce((a, n) => {
      const o = [e(n), n];
      return a && i(a[0], o[0]) === a[0] ? a : o;
    }, null)[1];
}
function cC(t, e) {
  return e.reduce((i, a) => (i[a] = t[a], i), {});
}
function jn(t, e) {
  return Object.prototype.hasOwnProperty.call(t, e);
}
function Wl(t) {
  if (t == null)
    return null;
  if (typeof t != "object")
    throw new It("Week settings must be an object");
  if (!bi(t.firstDay, 1, 7) || !bi(t.minimalDays, 1, 7) || !Array.isArray(t.weekend) || t.weekend.some((e) => !bi(e, 1, 7)))
    throw new It("Invalid week settings");
  return {
    firstDay: t.firstDay,
    minimalDays: t.minimalDays,
    weekend: Array.from(t.weekend)
  };
}
function bi(t, e, i) {
  return Dr(t) && t >= e && t <= i;
}
function dC(t, e) {
  return t - e * Math.floor(t / e);
}
function lt(t, e = 2) {
  const i = t < 0;
  let a;
  return i ? a = "-" + ("" + -t).padStart(e, "0") : a = ("" + t).padStart(e, "0"), a;
}
function wa(t) {
  if (!(ae(t) || t === null || t === ""))
    return parseInt(t, 10);
}
function Ka(t) {
  if (!(ae(t) || t === null || t === ""))
    return parseFloat(t);
}
function Nc(t) {
  if (!(ae(t) || t === null || t === "")) {
    const e = parseFloat("0." + t) * 1e3;
    return Math.floor(e);
  }
}
function Mc(t, e, i = !1) {
  const a = 10 ** e;
  return (i ? Math.trunc : Math.round)(t * a) / a;
}
function ts(t) {
  return t % 4 === 0 && (t % 100 !== 0 || t % 400 === 0);
}
function Pn(t) {
  return ts(t) ? 366 : 365;
}
function tr(t, e) {
  const i = dC(e - 1, 12) + 1, a = t + (e - i) / 12;
  return i === 2 ? ts(a) ? 29 : 28 : [31, null, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31][i - 1];
}
function Nr(t) {
  let e = Date.UTC(
    t.year,
    t.month - 1,
    t.day,
    t.hour,
    t.minute,
    t.second,
    t.millisecond
  );
  return t.year < 100 && t.year >= 0 && (e = new Date(e), e.setUTCFullYear(t.year, t.month - 1, t.day)), +e;
}
function yu(t, e, i) {
  return -Dc(Bc(t, 1, e), i) + e - 1;
}
function Eo(t, e = 4, i = 1) {
  const a = yu(t, e, i), n = yu(t + 1, e, i);
  return (Pn(t) - a + n) / 7;
}
function zl(t) {
  return t > 99 ? t : t > Je.twoDigitCutoffYear ? 1900 + t : 2e3 + t;
}
function ng(t, e, i, a = null) {
  const n = new Date(t), o = {
    hourCycle: "h23",
    year: "numeric",
    month: "2-digit",
    day: "2-digit",
    hour: "2-digit",
    minute: "2-digit"
  };
  a && (o.timeZone = a);
  const s = { timeZoneName: e, ...o }, r = new Intl.DateTimeFormat(i, s).formatToParts(n).find((l) => l.type.toLowerCase() === "timezonename");
  return r ? r.value : null;
}
function Mr(t, e) {
  let i = parseInt(t, 10);
  Number.isNaN(i) && (i = 0);
  const a = parseInt(e, 10) || 0, n = i < 0 || Object.is(i, -0) ? -a : a;
  return i * 60 + n;
}
function og(t) {
  const e = Number(t);
  if (typeof t == "boolean" || t === "" || Number.isNaN(e))
    throw new It(`Invalid unit value ${t}`);
  return e;
}
function ir(t, e) {
  const i = {};
  for (const a in t)
    if (jn(t, a)) {
      const n = t[a];
      if (n == null) continue;
      i[e(a)] = og(n);
    }
  return i;
}
function Oo(t, e) {
  const i = Math.trunc(Math.abs(t / 60)), a = Math.trunc(Math.abs(t % 60)), n = t >= 0 ? "+" : "-";
  switch (e) {
    case "short":
      return `${n}${lt(i, 2)}:${lt(a, 2)}`;
    case "narrow":
      return `${n}${i}${a > 0 ? `:${a}` : ""}`;
    case "techie":
      return `${n}${lt(i, 2)}${lt(a, 2)}`;
    default:
      throw new RangeError(`Value format ${e} is out of range for property format`);
  }
}
function $r(t) {
  return cC(t, ["hour", "minute", "second", "millisecond"]);
}
const uC = [
  "January",
  "February",
  "March",
  "April",
  "May",
  "June",
  "July",
  "August",
  "September",
  "October",
  "November",
  "December"
], sg = [
  "Jan",
  "Feb",
  "Mar",
  "Apr",
  "May",
  "Jun",
  "Jul",
  "Aug",
  "Sep",
  "Oct",
  "Nov",
  "Dec"
], fC = ["J", "F", "M", "A", "M", "J", "J", "A", "S", "O", "N", "D"];
function rg(t) {
  switch (t) {
    case "narrow":
      return [...fC];
    case "short":
      return [...sg];
    case "long":
      return [...uC];
    case "numeric":
      return ["1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12"];
    case "2-digit":
      return ["01", "02", "03", "04", "05", "06", "07", "08", "09", "10", "11", "12"];
    default:
      return null;
  }
}
const lg = [
  "Monday",
  "Tuesday",
  "Wednesday",
  "Thursday",
  "Friday",
  "Saturday",
  "Sunday"
], cg = ["Mon", "Tue", "Wed", "Thu", "Fri", "Sat", "Sun"], mC = ["M", "T", "W", "T", "F", "S", "S"];
function dg(t) {
  switch (t) {
    case "narrow":
      return [...mC];
    case "short":
      return [...cg];
    case "long":
      return [...lg];
    case "numeric":
      return ["1", "2", "3", "4", "5", "6", "7"];
    default:
      return null;
  }
}
const ug = ["AM", "PM"], gC = ["Before Christ", "Anno Domini"], hC = ["BC", "AD"], pC = ["B", "A"];
function fg(t) {
  switch (t) {
    case "narrow":
      return [...pC];
    case "short":
      return [...hC];
    case "long":
      return [...gC];
    default:
      return null;
  }
}
function yC(t) {
  return ug[t.hour < 12 ? 0 : 1];
}
function bC(t, e) {
  return dg(e)[t.weekday - 1];
}
function SC(t, e) {
  return rg(e)[t.month - 1];
}
function xC(t, e) {
  return fg(e)[t.year < 0 ? 0 : 1];
}
function CC(t, e, i = "always", a = !1) {
  const n = {
    years: ["year", "yr."],
    quarters: ["quarter", "qtr."],
    months: ["month", "mo."],
    weeks: ["week", "wk."],
    days: ["day", "day", "days"],
    hours: ["hour", "hr."],
    minutes: ["minute", "min."],
    seconds: ["second", "sec."]
  }, o = ["hours", "minutes", "seconds"].indexOf(t) === -1;
  if (i === "auto" && o) {
    const u = t === "days";
    switch (e) {
      case 1:
        return u ? "tomorrow" : `next ${n[t][0]}`;
      case -1:
        return u ? "yesterday" : `last ${n[t][0]}`;
      case 0:
        return u ? "today" : `this ${n[t][0]}`;
    }
  }
  const s = Object.is(e, -0) || e < 0, r = Math.abs(e), l = r === 1, c = n[t], d = a ? l ? c[1] : c[2] || c[1] : l ? n[t][0] : t;
  return s ? `${r} ${d} ago` : `in ${r} ${d}`;
}
function bu(t, e) {
  let i = "";
  for (const a of t)
    a.literal ? i += a.val : i += e(a.val);
  return i;
}
const vC = {
  D: Js,
  DD: Bm,
  DDD: Dm,
  DDDD: Nm,
  t: Mm,
  tt: $m,
  ttt: Pm,
  tttt: Rm,
  T: Vm,
  TT: Em,
  TTT: Wm,
  TTTT: zm,
  f: Hm,
  ff: Gm,
  fff: Xm,
  ffff: jm,
  F: qm,
  FF: Ym,
  FFF: Um,
  FFFF: _m
};
class Bt {
  static create(e, i = {}) {
    return new Bt(e, i);
  }
  static parseFormat(e) {
    let i = null, a = "", n = !1;
    const o = [];
    for (let s = 0; s < e.length; s++) {
      const r = e.charAt(s);
      r === "'" ? (a.length > 0 && o.push({ literal: n || /^\s+$/.test(a), val: a }), i = null, a = "", n = !n) : n || r === i ? a += r : (a.length > 0 && o.push({ literal: /^\s+$/.test(a), val: a }), a = r, i = r);
    }
    return a.length > 0 && o.push({ literal: n || /^\s+$/.test(a), val: a }), o;
  }
  static macroTokenToFormatOpts(e) {
    return vC[e];
  }
  constructor(e, i) {
    this.opts = i, this.loc = e, this.systemLoc = null;
  }
  formatWithSystemDefault(e, i) {
    return this.systemLoc === null && (this.systemLoc = this.loc.redefaultToSystem()), this.systemLoc.dtFormatter(e, { ...this.opts, ...i }).format();
  }
  dtFormatter(e, i = {}) {
    return this.loc.dtFormatter(e, { ...this.opts, ...i });
  }
  formatDateTime(e, i) {
    return this.dtFormatter(e, i).format();
  }
  formatDateTimeParts(e, i) {
    return this.dtFormatter(e, i).formatToParts();
  }
  formatInterval(e, i) {
    return this.dtFormatter(e.start, i).dtf.formatRange(e.start.toJSDate(), e.end.toJSDate());
  }
  resolvedOptions(e, i) {
    return this.dtFormatter(e, i).resolvedOptions();
  }
  num(e, i = 0) {
    if (this.opts.forceSimple)
      return lt(e, i);
    const a = { ...this.opts };
    return i > 0 && (a.padTo = i), this.loc.numberFormatter(a).format(e);
  }
  formatDateTimeFromString(e, i) {
    const a = this.loc.listingMode() === "en", n = this.loc.outputCalendar && this.loc.outputCalendar !== "gregory", o = (m, g) => this.loc.extract(e, m, g), s = (m) => e.isOffsetFixed && e.offset === 0 && m.allowZ ? "Z" : e.isValid ? e.zone.formatOffset(e.ts, m.format) : "", r = () => a ? yC(e) : o({ hour: "numeric", hourCycle: "h12" }, "dayperiod"), l = (m, g) => a ? SC(e, m) : o(g ? { month: m } : { month: m, day: "numeric" }, "month"), c = (m, g) => a ? bC(e, m) : o(
      g ? { weekday: m } : { weekday: m, month: "long", day: "numeric" },
      "weekday"
    ), d = (m) => {
      const g = Bt.macroTokenToFormatOpts(m);
      return g ? this.formatWithSystemDefault(e, g) : m;
    }, u = (m) => a ? xC(e, m) : o({ era: m }, "era"), f = (m) => {
      switch (m) {
        // ms
        case "S":
          return this.num(e.millisecond);
        case "u":
        // falls through
        case "SSS":
          return this.num(e.millisecond, 3);
        // seconds
        case "s":
          return this.num(e.second);
        case "ss":
          return this.num(e.second, 2);
        // fractional seconds
        case "uu":
          return this.num(Math.floor(e.millisecond / 10), 2);
        case "uuu":
          return this.num(Math.floor(e.millisecond / 100));
        // minutes
        case "m":
          return this.num(e.minute);
        case "mm":
          return this.num(e.minute, 2);
        // hours
        case "h":
          return this.num(e.hour % 12 === 0 ? 12 : e.hour % 12);
        case "hh":
          return this.num(e.hour % 12 === 0 ? 12 : e.hour % 12, 2);
        case "H":
          return this.num(e.hour);
        case "HH":
          return this.num(e.hour, 2);
        // offset
        case "Z":
          return s({ format: "narrow", allowZ: this.opts.allowZ });
        case "ZZ":
          return s({ format: "short", allowZ: this.opts.allowZ });
        case "ZZZ":
          return s({ format: "techie", allowZ: this.opts.allowZ });
        case "ZZZZ":
          return e.zone.offsetName(e.ts, { format: "short", locale: this.loc.locale });
        case "ZZZZZ":
          return e.zone.offsetName(e.ts, { format: "long", locale: this.loc.locale });
        // zone
        case "z":
          return e.zoneName;
        // meridiems
        case "a":
          return r();
        // dates
        case "d":
          return n ? o({ day: "numeric" }, "day") : this.num(e.day);
        case "dd":
          return n ? o({ day: "2-digit" }, "day") : this.num(e.day, 2);
        // weekdays - standalone
        case "c":
          return this.num(e.weekday);
        case "ccc":
          return c("short", !0);
        case "cccc":
          return c("long", !0);
        case "ccccc":
          return c("narrow", !0);
        // weekdays - format
        case "E":
          return this.num(e.weekday);
        case "EEE":
          return c("short", !1);
        case "EEEE":
          return c("long", !1);
        case "EEEEE":
          return c("narrow", !1);
        // months - standalone
        case "L":
          return n ? o({ month: "numeric", day: "numeric" }, "month") : this.num(e.month);
        case "LL":
          return n ? o({ month: "2-digit", day: "numeric" }, "month") : this.num(e.month, 2);
        case "LLL":
          return l("short", !0);
        case "LLLL":
          return l("long", !0);
        case "LLLLL":
          return l("narrow", !0);
        // months - format
        case "M":
          return n ? o({ month: "numeric" }, "month") : this.num(e.month);
        case "MM":
          return n ? o({ month: "2-digit" }, "month") : this.num(e.month, 2);
        case "MMM":
          return l("short", !1);
        case "MMMM":
          return l("long", !1);
        case "MMMMM":
          return l("narrow", !1);
        // years
        case "y":
          return n ? o({ year: "numeric" }, "year") : this.num(e.year);
        case "yy":
          return n ? o({ year: "2-digit" }, "year") : this.num(e.year.toString().slice(-2), 2);
        case "yyyy":
          return n ? o({ year: "numeric" }, "year") : this.num(e.year, 4);
        case "yyyyyy":
          return n ? o({ year: "numeric" }, "year") : this.num(e.year, 6);
        // eras
        case "G":
          return u("short");
        case "GG":
          return u("long");
        case "GGGGG":
          return u("narrow");
        case "kk":
          return this.num(e.weekYear.toString().slice(-2), 2);
        case "kkkk":
          return this.num(e.weekYear, 4);
        case "W":
          return this.num(e.weekNumber);
        case "WW":
          return this.num(e.weekNumber, 2);
        case "n":
          return this.num(e.localWeekNumber);
        case "nn":
          return this.num(e.localWeekNumber, 2);
        case "ii":
          return this.num(e.localWeekYear.toString().slice(-2), 2);
        case "iiii":
          return this.num(e.localWeekYear, 4);
        case "o":
          return this.num(e.ordinal);
        case "ooo":
          return this.num(e.ordinal, 3);
        case "q":
          return this.num(e.quarter);
        case "qq":
          return this.num(e.quarter, 2);
        case "X":
          return this.num(Math.floor(e.ts / 1e3));
        case "x":
          return this.num(e.ts);
        default:
          return d(m);
      }
    };
    return bu(Bt.parseFormat(i), f);
  }
  formatDurationFromString(e, i) {
    const a = (l) => {
      switch (l[0]) {
        case "S":
          return "millisecond";
        case "s":
          return "second";
        case "m":
          return "minute";
        case "h":
          return "hour";
        case "d":
          return "day";
        case "w":
          return "week";
        case "M":
          return "month";
        case "y":
          return "year";
        default:
          return null;
      }
    }, n = (l) => (c) => {
      const d = a(c);
      return d ? this.num(l.get(d), c.length) : c;
    }, o = Bt.parseFormat(i), s = o.reduce(
      (l, { literal: c, val: d }) => c ? l : l.concat(d),
      []
    ), r = e.shiftTo(...s.map(a).filter((l) => l));
    return bu(o, n(r));
  }
}
const mg = /[A-Za-z_+-]{1,256}(?::?\/[A-Za-z0-9_+-]{1,256}(?:\/[A-Za-z0-9_+-]{1,256})?)?/;
function so(...t) {
  const e = t.reduce((i, a) => i + a.source, "");
  return RegExp(`^${e}$`);
}
function ro(...t) {
  return (e) => t.reduce(
    ([i, a, n], o) => {
      const [s, r, l] = o(e, n);
      return [{ ...i, ...s }, r || a, l];
    },
    [{}, null, 1]
  ).slice(0, 2);
}
function lo(t, ...e) {
  if (t == null)
    return [null, null];
  for (const [i, a] of e) {
    const n = i.exec(t);
    if (n)
      return a(n);
  }
  return [null, null];
}
function gg(...t) {
  return (e, i) => {
    const a = {};
    let n;
    for (n = 0; n < t.length; n++)
      a[t[n]] = wa(e[i + n]);
    return [a, null, i + n];
  };
}
const hg = /(?:(Z)|([+-]\d\d)(?::?(\d\d))?)/, FC = `(?:${hg.source}?(?:\\[(${mg.source})\\])?)?`, $c = /(\d\d)(?::?(\d\d)(?::?(\d\d)(?:[.,](\d{1,30}))?)?)?/, pg = RegExp(`${$c.source}${FC}`), Pc = RegExp(`(?:T${pg.source})?`), LC = /([+-]\d{6}|\d{4})(?:-?(\d\d)(?:-?(\d\d))?)?/, AC = /(\d{4})-?W(\d\d)(?:-?(\d))?/, TC = /(\d{4})-?(\d{3})/, wC = gg("weekYear", "weekNumber", "weekDay"), kC = gg("year", "ordinal"), IC = /(\d{4})-(\d\d)-(\d\d)/, yg = RegExp(
  `${$c.source} ?(?:${hg.source}|(${mg.source}))?`
), OC = RegExp(`(?: ${yg.source})?`);
function Rn(t, e, i) {
  const a = t[e];
  return ae(a) ? i : wa(a);
}
function BC(t, e) {
  return [{
    year: Rn(t, e),
    month: Rn(t, e + 1, 1),
    day: Rn(t, e + 2, 1)
  }, null, e + 3];
}
function co(t, e) {
  return [{
    hours: Rn(t, e, 0),
    minutes: Rn(t, e + 1, 0),
    seconds: Rn(t, e + 2, 0),
    milliseconds: Nc(t[e + 3])
  }, null, e + 4];
}
function is(t, e) {
  const i = !t[e] && !t[e + 1], a = Mr(t[e + 1], t[e + 2]), n = i ? null : Et.instance(a);
  return [{}, n, e + 3];
}
function as(t, e) {
  const i = t[e] ? da.create(t[e]) : null;
  return [{}, i, e + 1];
}
const DC = RegExp(`^T?${$c.source}$`), NC = /^-?P(?:(?:(-?\d{1,20}(?:\.\d{1,20})?)Y)?(?:(-?\d{1,20}(?:\.\d{1,20})?)M)?(?:(-?\d{1,20}(?:\.\d{1,20})?)W)?(?:(-?\d{1,20}(?:\.\d{1,20})?)D)?(?:T(?:(-?\d{1,20}(?:\.\d{1,20})?)H)?(?:(-?\d{1,20}(?:\.\d{1,20})?)M)?(?:(-?\d{1,20})(?:[.,](-?\d{1,20}))?S)?)?)$/;
function MC(t) {
  const [e, i, a, n, o, s, r, l, c] = t, d = e[0] === "-", u = l && l[0] === "-", f = (m, g = !1) => m !== void 0 && (g || m && d) ? -m : m;
  return [
    {
      years: f(Ka(i)),
      months: f(Ka(a)),
      weeks: f(Ka(n)),
      days: f(Ka(o)),
      hours: f(Ka(s)),
      minutes: f(Ka(r)),
      seconds: f(Ka(l), l === "-0"),
      milliseconds: f(Nc(c), u)
    }
  ];
}
const $C = {
  GMT: 0,
  EDT: -4 * 60,
  EST: -5 * 60,
  CDT: -5 * 60,
  CST: -6 * 60,
  MDT: -6 * 60,
  MST: -7 * 60,
  PDT: -7 * 60,
  PST: -8 * 60
};
function Rc(t, e, i, a, n, o, s) {
  const r = {
    year: e.length === 2 ? zl(wa(e)) : wa(e),
    month: sg.indexOf(i) + 1,
    day: wa(a),
    hour: wa(n),
    minute: wa(o)
  };
  return s && (r.second = wa(s)), t && (r.weekday = t.length > 3 ? lg.indexOf(t) + 1 : cg.indexOf(t) + 1), r;
}
const PC = /^(?:(Mon|Tue|Wed|Thu|Fri|Sat|Sun),\s)?(\d{1,2})\s(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s(\d{2,4})\s(\d\d):(\d\d)(?::(\d\d))?\s(?:(UT|GMT|[ECMP][SD]T)|([Zz])|(?:([+-]\d\d)(\d\d)))$/;
function RC(t) {
  const [
    ,
    e,
    i,
    a,
    n,
    o,
    s,
    r,
    l,
    c,
    d,
    u
  ] = t, f = Rc(e, n, a, i, o, s, r);
  let m;
  return l ? m = $C[l] : c ? m = 0 : m = Mr(d, u), [f, new Et(m)];
}
function VC(t) {
  return t.replace(/\([^()]*\)|[\n\t]/g, " ").replace(/(\s\s+)/g, " ").trim();
}
const EC = /^(Mon|Tue|Wed|Thu|Fri|Sat|Sun), (\d\d) (Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) (\d{4}) (\d\d):(\d\d):(\d\d) GMT$/, WC = /^(Monday|Tuesday|Wednesday|Thursday|Friday|Saturday|Sunday), (\d\d)-(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)-(\d\d) (\d\d):(\d\d):(\d\d) GMT$/, zC = /^(Mon|Tue|Wed|Thu|Fri|Sat|Sun) (Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) ( \d|\d\d) (\d\d):(\d\d):(\d\d) (\d{4})$/;
function Su(t) {
  const [, e, i, a, n, o, s, r] = t;
  return [Rc(e, n, a, i, o, s, r), Et.utcInstance];
}
function HC(t) {
  const [, e, i, a, n, o, s, r] = t;
  return [Rc(e, r, i, a, n, o, s), Et.utcInstance];
}
const qC = so(LC, Pc), GC = so(AC, Pc), YC = so(TC, Pc), XC = so(pg), bg = ro(
  BC,
  co,
  is,
  as
), UC = ro(
  wC,
  co,
  is,
  as
), jC = ro(
  kC,
  co,
  is,
  as
), _C = ro(
  co,
  is,
  as
);
function ZC(t) {
  return lo(
    t,
    [qC, bg],
    [GC, UC],
    [YC, jC],
    [XC, _C]
  );
}
function QC(t) {
  return lo(VC(t), [PC, RC]);
}
function KC(t) {
  return lo(
    t,
    [EC, Su],
    [WC, Su],
    [zC, HC]
  );
}
function JC(t) {
  return lo(t, [NC, MC]);
}
const ev = ro(co);
function tv(t) {
  return lo(t, [DC, ev]);
}
const iv = so(IC, OC), av = so(yg), nv = ro(
  co,
  is,
  as
);
function ov(t) {
  return lo(
    t,
    [iv, bg],
    [av, nv]
  );
}
const xu = "Invalid Duration", Sg = {
  weeks: {
    days: 7,
    hours: 7 * 24,
    minutes: 7 * 24 * 60,
    seconds: 7 * 24 * 60 * 60,
    milliseconds: 7 * 24 * 60 * 60 * 1e3
  },
  days: {
    hours: 24,
    minutes: 24 * 60,
    seconds: 24 * 60 * 60,
    milliseconds: 24 * 60 * 60 * 1e3
  },
  hours: { minutes: 60, seconds: 60 * 60, milliseconds: 60 * 60 * 1e3 },
  minutes: { seconds: 60, milliseconds: 60 * 1e3 },
  seconds: { milliseconds: 1e3 }
}, sv = {
  years: {
    quarters: 4,
    months: 12,
    weeks: 52,
    days: 365,
    hours: 365 * 24,
    minutes: 365 * 24 * 60,
    seconds: 365 * 24 * 60 * 60,
    milliseconds: 365 * 24 * 60 * 60 * 1e3
  },
  quarters: {
    months: 3,
    weeks: 13,
    days: 91,
    hours: 91 * 24,
    minutes: 91 * 24 * 60,
    seconds: 91 * 24 * 60 * 60,
    milliseconds: 91 * 24 * 60 * 60 * 1e3
  },
  months: {
    weeks: 4,
    days: 30,
    hours: 30 * 24,
    minutes: 30 * 24 * 60,
    seconds: 30 * 24 * 60 * 60,
    milliseconds: 30 * 24 * 60 * 60 * 1e3
  },
  ...Sg
}, hi = 146097 / 400, wn = 146097 / 4800, rv = {
  years: {
    quarters: 4,
    months: 12,
    weeks: hi / 7,
    days: hi,
    hours: hi * 24,
    minutes: hi * 24 * 60,
    seconds: hi * 24 * 60 * 60,
    milliseconds: hi * 24 * 60 * 60 * 1e3
  },
  quarters: {
    months: 3,
    weeks: hi / 28,
    days: hi / 4,
    hours: hi * 24 / 4,
    minutes: hi * 24 * 60 / 4,
    seconds: hi * 24 * 60 * 60 / 4,
    milliseconds: hi * 24 * 60 * 60 * 1e3 / 4
  },
  months: {
    weeks: wn / 7,
    days: wn,
    hours: wn * 24,
    minutes: wn * 24 * 60,
    seconds: wn * 24 * 60 * 60,
    milliseconds: wn * 24 * 60 * 60 * 1e3
  },
  ...Sg
}, an = [
  "years",
  "quarters",
  "months",
  "weeks",
  "days",
  "hours",
  "minutes",
  "seconds",
  "milliseconds"
], lv = an.slice(0).reverse();
function Aa(t, e, i = !1) {
  const a = {
    values: i ? e.values : { ...t.values, ...e.values || {} },
    loc: t.loc.clone(e.loc),
    conversionAccuracy: e.conversionAccuracy || t.conversionAccuracy,
    matrix: e.matrix || t.matrix
  };
  return new xe(a);
}
function xg(t, e) {
  let i = e.milliseconds ?? 0;
  for (const a of lv.slice(1))
    e[a] && (i += e[a] * t[a].milliseconds);
  return i;
}
function Cu(t, e) {
  const i = xg(t, e) < 0 ? -1 : 1;
  an.reduceRight((a, n) => {
    if (ae(e[n]))
      return a;
    if (a) {
      const o = e[a] * i, s = t[n][a], r = Math.floor(o / s);
      e[n] += r * i, e[a] -= r * s * i;
    }
    return n;
  }, null), an.reduce((a, n) => {
    if (ae(e[n]))
      return a;
    if (a) {
      const o = e[a] % 1;
      e[a] -= o, e[n] += o * t[a][n];
    }
    return n;
  }, null);
}
function cv(t) {
  const e = {};
  for (const [i, a] of Object.entries(t))
    a !== 0 && (e[i] = a);
  return e;
}
class xe {
  /**
   * @private
   */
  constructor(e) {
    const i = e.conversionAccuracy === "longterm" || !1;
    let a = i ? rv : sv;
    e.matrix && (a = e.matrix), this.values = e.values, this.loc = e.loc || ke.create(), this.conversionAccuracy = i ? "longterm" : "casual", this.invalid = e.invalid || null, this.matrix = a, this.isLuxonDuration = !0;
  }
  /**
   * Create Duration from a number of milliseconds.
   * @param {number} count of milliseconds
   * @param {Object} opts - options for parsing
   * @param {string} [opts.locale='en-US'] - the locale to use
   * @param {string} opts.numberingSystem - the numbering system to use
   * @param {string} [opts.conversionAccuracy='casual'] - the conversion system to use
   * @return {Duration}
   */
  static fromMillis(e, i) {
    return xe.fromObject({ milliseconds: e }, i);
  }
  /**
   * Create a Duration from a JavaScript object with keys like 'years' and 'hours'.
   * If this object is empty then a zero milliseconds duration is returned.
   * @param {Object} obj - the object to create the DateTime from
   * @param {number} obj.years
   * @param {number} obj.quarters
   * @param {number} obj.months
   * @param {number} obj.weeks
   * @param {number} obj.days
   * @param {number} obj.hours
   * @param {number} obj.minutes
   * @param {number} obj.seconds
   * @param {number} obj.milliseconds
   * @param {Object} [opts=[]] - options for creating this Duration
   * @param {string} [opts.locale='en-US'] - the locale to use
   * @param {string} opts.numberingSystem - the numbering system to use
   * @param {string} [opts.conversionAccuracy='casual'] - the preset conversion system to use
   * @param {string} [opts.matrix=Object] - the custom conversion system to use
   * @return {Duration}
   */
  static fromObject(e, i = {}) {
    if (e == null || typeof e != "object")
      throw new It(
        `Duration.fromObject: argument expected to be an object, got ${e === null ? "null" : typeof e}`
      );
    return new xe({
      values: ir(e, xe.normalizeUnit),
      loc: ke.fromObject(i),
      conversionAccuracy: i.conversionAccuracy,
      matrix: i.matrix
    });
  }
  /**
   * Create a Duration from DurationLike.
   *
   * @param {Object | number | Duration} durationLike
   * One of:
   * - object with keys like 'years' and 'hours'.
   * - number representing milliseconds
   * - Duration instance
   * @return {Duration}
   */
  static fromDurationLike(e) {
    if (Da(e))
      return xe.fromMillis(e);
    if (xe.isDuration(e))
      return e;
    if (typeof e == "object")
      return xe.fromObject(e);
    throw new It(
      `Unknown duration argument ${e} of type ${typeof e}`
    );
  }
  /**
   * Create a Duration from an ISO 8601 duration string.
   * @param {string} text - text to parse
   * @param {Object} opts - options for parsing
   * @param {string} [opts.locale='en-US'] - the locale to use
   * @param {string} opts.numberingSystem - the numbering system to use
   * @param {string} [opts.conversionAccuracy='casual'] - the preset conversion system to use
   * @param {string} [opts.matrix=Object] - the preset conversion system to use
   * @see https://en.wikipedia.org/wiki/ISO_8601#Durations
   * @example Duration.fromISO('P3Y6M1W4DT12H30M5S').toObject() //=> { years: 3, months: 6, weeks: 1, days: 4, hours: 12, minutes: 30, seconds: 5 }
   * @example Duration.fromISO('PT23H').toObject() //=> { hours: 23 }
   * @example Duration.fromISO('P5Y3M').toObject() //=> { years: 5, months: 3 }
   * @return {Duration}
   */
  static fromISO(e, i) {
    const [a] = JC(e);
    return a ? xe.fromObject(a, i) : xe.invalid("unparsable", `the input "${e}" can't be parsed as ISO 8601`);
  }
  /**
   * Create a Duration from an ISO 8601 time string.
   * @param {string} text - text to parse
   * @param {Object} opts - options for parsing
   * @param {string} [opts.locale='en-US'] - the locale to use
   * @param {string} opts.numberingSystem - the numbering system to use
   * @param {string} [opts.conversionAccuracy='casual'] - the preset conversion system to use
   * @param {string} [opts.matrix=Object] - the conversion system to use
   * @see https://en.wikipedia.org/wiki/ISO_8601#Times
   * @example Duration.fromISOTime('11:22:33.444').toObject() //=> { hours: 11, minutes: 22, seconds: 33, milliseconds: 444 }
   * @example Duration.fromISOTime('11:00').toObject() //=> { hours: 11, minutes: 0, seconds: 0 }
   * @example Duration.fromISOTime('T11:00').toObject() //=> { hours: 11, minutes: 0, seconds: 0 }
   * @example Duration.fromISOTime('1100').toObject() //=> { hours: 11, minutes: 0, seconds: 0 }
   * @example Duration.fromISOTime('T1100').toObject() //=> { hours: 11, minutes: 0, seconds: 0 }
   * @return {Duration}
   */
  static fromISOTime(e, i) {
    const [a] = tv(e);
    return a ? xe.fromObject(a, i) : xe.invalid("unparsable", `the input "${e}" can't be parsed as ISO 8601`);
  }
  /**
   * Create an invalid Duration.
   * @param {string} reason - simple string of why this datetime is invalid. Should not contain parameters or anything else data-dependent
   * @param {string} [explanation=null] - longer explanation, may include parameters and other useful debugging information
   * @return {Duration}
   */
  static invalid(e, i = null) {
    if (!e)
      throw new It("need to specify a reason the Duration is invalid");
    const a = e instanceof Ii ? e : new Ii(e, i);
    if (Je.throwOnInvalid)
      throw new Nx(a);
    return new xe({ invalid: a });
  }
  /**
   * @private
   */
  static normalizeUnit(e) {
    const i = {
      year: "years",
      years: "years",
      quarter: "quarters",
      quarters: "quarters",
      month: "months",
      months: "months",
      week: "weeks",
      weeks: "weeks",
      day: "days",
      days: "days",
      hour: "hours",
      hours: "hours",
      minute: "minutes",
      minutes: "minutes",
      second: "seconds",
      seconds: "seconds",
      millisecond: "milliseconds",
      milliseconds: "milliseconds"
    }[e && e.toLowerCase()];
    if (!i) throw new Om(e);
    return i;
  }
  /**
   * Check if an object is a Duration. Works across context boundaries
   * @param {object} o
   * @return {boolean}
   */
  static isDuration(e) {
    return e && e.isLuxonDuration || !1;
  }
  /**
   * Get  the locale of a Duration, such 'en-GB'
   * @type {string}
   */
  get locale() {
    return this.isValid ? this.loc.locale : null;
  }
  /**
   * Get the numbering system of a Duration, such 'beng'. The numbering system is used when formatting the Duration
   *
   * @type {string}
   */
  get numberingSystem() {
    return this.isValid ? this.loc.numberingSystem : null;
  }
  /**
   * Returns a string representation of this Duration formatted according to the specified format string. You may use these tokens:
   * * `S` for milliseconds
   * * `s` for seconds
   * * `m` for minutes
   * * `h` for hours
   * * `d` for days
   * * `w` for weeks
   * * `M` for months
   * * `y` for years
   * Notes:
   * * Add padding by repeating the token, e.g. "yy" pads the years to two digits, "hhhh" pads the hours out to four digits
   * * Tokens can be escaped by wrapping with single quotes.
   * * The duration will be converted to the set of units in the format string using {@link Duration#shiftTo} and the Durations's conversion accuracy setting.
   * @param {string} fmt - the format string
   * @param {Object} opts - options
   * @param {boolean} [opts.floor=true] - floor numerical values
   * @example Duration.fromObject({ years: 1, days: 6, seconds: 2 }).toFormat("y d s") //=> "1 6 2"
   * @example Duration.fromObject({ years: 1, days: 6, seconds: 2 }).toFormat("yy dd sss") //=> "01 06 002"
   * @example Duration.fromObject({ years: 1, days: 6, seconds: 2 }).toFormat("M S") //=> "12 518402000"
   * @return {string}
   */
  toFormat(e, i = {}) {
    const a = {
      ...i,
      floor: i.round !== !1 && i.floor !== !1
    };
    return this.isValid ? Bt.create(this.loc, a).formatDurationFromString(this, e) : xu;
  }
  /**
   * Returns a string representation of a Duration with all units included.
   * To modify its behavior, use `listStyle` and any Intl.NumberFormat option, though `unitDisplay` is especially relevant.
   * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Intl/NumberFormat/NumberFormat#options
   * @param {Object} opts - Formatting options. Accepts the same keys as the options parameter of the native `Intl.NumberFormat` constructor, as well as `listStyle`.
   * @param {string} [opts.listStyle='narrow'] - How to format the merged list. Corresponds to the `style` property of the options parameter of the native `Intl.ListFormat` constructor.
   * @example
   * ```js
   * var dur = Duration.fromObject({ days: 1, hours: 5, minutes: 6 })
   * dur.toHuman() //=> '1 day, 5 hours, 6 minutes'
   * dur.toHuman({ listStyle: "long" }) //=> '1 day, 5 hours, and 6 minutes'
   * dur.toHuman({ unitDisplay: "short" }) //=> '1 day, 5 hr, 6 min'
   * ```
   */
  toHuman(e = {}) {
    if (!this.isValid) return xu;
    const i = an.map((a) => {
      const n = this.values[a];
      return ae(n) ? null : this.loc.numberFormatter({ style: "unit", unitDisplay: "long", ...e, unit: a.slice(0, -1) }).format(n);
    }).filter((a) => a);
    return this.loc.listFormatter({ type: "conjunction", style: e.listStyle || "narrow", ...e }).format(i);
  }
  /**
   * Returns a JavaScript object with this Duration's values.
   * @example Duration.fromObject({ years: 1, days: 6, seconds: 2 }).toObject() //=> { years: 1, days: 6, seconds: 2 }
   * @return {Object}
   */
  toObject() {
    return this.isValid ? { ...this.values } : {};
  }
  /**
   * Returns an ISO 8601-compliant string representation of this Duration.
   * @see https://en.wikipedia.org/wiki/ISO_8601#Durations
   * @example Duration.fromObject({ years: 3, seconds: 45 }).toISO() //=> 'P3YT45S'
   * @example Duration.fromObject({ months: 4, seconds: 45 }).toISO() //=> 'P4MT45S'
   * @example Duration.fromObject({ months: 5 }).toISO() //=> 'P5M'
   * @example Duration.fromObject({ minutes: 5 }).toISO() //=> 'PT5M'
   * @example Duration.fromObject({ milliseconds: 6 }).toISO() //=> 'PT0.006S'
   * @return {string}
   */
  toISO() {
    if (!this.isValid) return null;
    let e = "P";
    return this.years !== 0 && (e += this.years + "Y"), (this.months !== 0 || this.quarters !== 0) && (e += this.months + this.quarters * 3 + "M"), this.weeks !== 0 && (e += this.weeks + "W"), this.days !== 0 && (e += this.days + "D"), (this.hours !== 0 || this.minutes !== 0 || this.seconds !== 0 || this.milliseconds !== 0) && (e += "T"), this.hours !== 0 && (e += this.hours + "H"), this.minutes !== 0 && (e += this.minutes + "M"), (this.seconds !== 0 || this.milliseconds !== 0) && (e += Mc(this.seconds + this.milliseconds / 1e3, 3) + "S"), e === "P" && (e += "T0S"), e;
  }
  /**
   * Returns an ISO 8601-compliant string representation of this Duration, formatted as a time of day.
   * Note that this will return null if the duration is invalid, negative, or equal to or greater than 24 hours.
   * @see https://en.wikipedia.org/wiki/ISO_8601#Times
   * @param {Object} opts - options
   * @param {boolean} [opts.suppressMilliseconds=false] - exclude milliseconds from the format if they're 0
   * @param {boolean} [opts.suppressSeconds=false] - exclude seconds from the format if they're 0
   * @param {boolean} [opts.includePrefix=false] - include the `T` prefix
   * @param {string} [opts.format='extended'] - choose between the basic and extended format
   * @example Duration.fromObject({ hours: 11 }).toISOTime() //=> '11:00:00.000'
   * @example Duration.fromObject({ hours: 11 }).toISOTime({ suppressMilliseconds: true }) //=> '11:00:00'
   * @example Duration.fromObject({ hours: 11 }).toISOTime({ suppressSeconds: true }) //=> '11:00'
   * @example Duration.fromObject({ hours: 11 }).toISOTime({ includePrefix: true }) //=> 'T11:00:00.000'
   * @example Duration.fromObject({ hours: 11 }).toISOTime({ format: 'basic' }) //=> '110000.000'
   * @return {string}
   */
  toISOTime(e = {}) {
    if (!this.isValid) return null;
    const i = this.toMillis();
    return i < 0 || i >= 864e5 ? null : (e = {
      suppressMilliseconds: !1,
      suppressSeconds: !1,
      includePrefix: !1,
      format: "extended",
      ...e,
      includeOffset: !1
    }, K.fromMillis(i, { zone: "UTC" }).toISOTime(e));
  }
  /**
   * Returns an ISO 8601 representation of this Duration appropriate for use in JSON.
   * @return {string}
   */
  toJSON() {
    return this.toISO();
  }
  /**
   * Returns an ISO 8601 representation of this Duration appropriate for use in debugging.
   * @return {string}
   */
  toString() {
    return this.toISO();
  }
  /**
   * Returns a string representation of this Duration appropriate for the REPL.
   * @return {string}
   */
  [Symbol.for("nodejs.util.inspect.custom")]() {
    return this.isValid ? `Duration { values: ${JSON.stringify(this.values)} }` : `Duration { Invalid, reason: ${this.invalidReason} }`;
  }
  /**
   * Returns an milliseconds value of this Duration.
   * @return {number}
   */
  toMillis() {
    return this.isValid ? xg(this.matrix, this.values) : NaN;
  }
  /**
   * Returns an milliseconds value of this Duration. Alias of {@link toMillis}
   * @return {number}
   */
  valueOf() {
    return this.toMillis();
  }
  /**
   * Make this Duration longer by the specified amount. Return a newly-constructed Duration.
   * @param {Duration|Object|number} duration - The amount to add. Either a Luxon Duration, a number of milliseconds, the object argument to Duration.fromObject()
   * @return {Duration}
   */
  plus(e) {
    if (!this.isValid) return this;
    const i = xe.fromDurationLike(e), a = {};
    for (const n of an)
      (jn(i.values, n) || jn(this.values, n)) && (a[n] = i.get(n) + this.get(n));
    return Aa(this, { values: a }, !0);
  }
  /**
   * Make this Duration shorter by the specified amount. Return a newly-constructed Duration.
   * @param {Duration|Object|number} duration - The amount to subtract. Either a Luxon Duration, a number of milliseconds, the object argument to Duration.fromObject()
   * @return {Duration}
   */
  minus(e) {
    if (!this.isValid) return this;
    const i = xe.fromDurationLike(e);
    return this.plus(i.negate());
  }
  /**
   * Scale this Duration by the specified amount. Return a newly-constructed Duration.
   * @param {function} fn - The function to apply to each unit. Arity is 1 or 2: the value of the unit and, optionally, the unit name. Must return a number.
   * @example Duration.fromObject({ hours: 1, minutes: 30 }).mapUnits(x => x * 2) //=> { hours: 2, minutes: 60 }
   * @example Duration.fromObject({ hours: 1, minutes: 30 }).mapUnits((x, u) => u === "hours" ? x * 2 : x) //=> { hours: 2, minutes: 30 }
   * @return {Duration}
   */
  mapUnits(e) {
    if (!this.isValid) return this;
    const i = {};
    for (const a of Object.keys(this.values))
      i[a] = og(e(this.values[a], a));
    return Aa(this, { values: i }, !0);
  }
  /**
   * Get the value of unit.
   * @param {string} unit - a unit such as 'minute' or 'day'
   * @example Duration.fromObject({years: 2, days: 3}).get('years') //=> 2
   * @example Duration.fromObject({years: 2, days: 3}).get('months') //=> 0
   * @example Duration.fromObject({years: 2, days: 3}).get('days') //=> 3
   * @return {number}
   */
  get(e) {
    return this[xe.normalizeUnit(e)];
  }
  /**
   * "Set" the values of specified units. Return a newly-constructed Duration.
   * @param {Object} values - a mapping of units to numbers
   * @example dur.set({ years: 2017 })
   * @example dur.set({ hours: 8, minutes: 30 })
   * @return {Duration}
   */
  set(e) {
    if (!this.isValid) return this;
    const i = { ...this.values, ...ir(e, xe.normalizeUnit) };
    return Aa(this, { values: i });
  }
  /**
   * "Set" the locale and/or numberingSystem.  Returns a newly-constructed Duration.
   * @example dur.reconfigure({ locale: 'en-GB' })
   * @return {Duration}
   */
  reconfigure({ locale: e, numberingSystem: i, conversionAccuracy: a, matrix: n } = {}) {
    const s = { loc: this.loc.clone({ locale: e, numberingSystem: i }), matrix: n, conversionAccuracy: a };
    return Aa(this, s);
  }
  /**
   * Return the length of the duration in the specified unit.
   * @param {string} unit - a unit such as 'minutes' or 'days'
   * @example Duration.fromObject({years: 1}).as('days') //=> 365
   * @example Duration.fromObject({years: 1}).as('months') //=> 12
   * @example Duration.fromObject({hours: 60}).as('days') //=> 2.5
   * @return {number}
   */
  as(e) {
    return this.isValid ? this.shiftTo(e).get(e) : NaN;
  }
  /**
   * Reduce this Duration to its canonical representation in its current units.
   * Assuming the overall value of the Duration is positive, this means:
   * - excessive values for lower-order units are converted to higher-order units (if possible, see first and second example)
   * - negative lower-order units are converted to higher order units (there must be such a higher order unit, otherwise
   *   the overall value would be negative, see third example)
   * - fractional values for higher-order units are converted to lower-order units (if possible, see fourth example)
   *
   * If the overall value is negative, the result of this method is equivalent to `this.negate().normalize().negate()`.
   * @example Duration.fromObject({ years: 2, days: 5000 }).normalize().toObject() //=> { years: 15, days: 255 }
   * @example Duration.fromObject({ days: 5000 }).normalize().toObject() //=> { days: 5000 }
   * @example Duration.fromObject({ hours: 12, minutes: -45 }).normalize().toObject() //=> { hours: 11, minutes: 15 }
   * @example Duration.fromObject({ years: 2.5, days: 0, hours: 0 }).normalize().toObject() //=> { years: 2, days: 182, hours: 12 }
   * @return {Duration}
   */
  normalize() {
    if (!this.isValid) return this;
    const e = this.toObject();
    return Cu(this.matrix, e), Aa(this, { values: e }, !0);
  }
  /**
   * Rescale units to its largest representation
   * @example Duration.fromObject({ milliseconds: 90000 }).rescale().toObject() //=> { minutes: 1, seconds: 30 }
   * @return {Duration}
   */
  rescale() {
    if (!this.isValid) return this;
    const e = cv(this.normalize().shiftToAll().toObject());
    return Aa(this, { values: e }, !0);
  }
  /**
   * Convert this Duration into its representation in a different set of units.
   * @example Duration.fromObject({ hours: 1, seconds: 30 }).shiftTo('minutes', 'milliseconds').toObject() //=> { minutes: 60, milliseconds: 30000 }
   * @return {Duration}
   */
  shiftTo(...e) {
    if (!this.isValid) return this;
    if (e.length === 0)
      return this;
    e = e.map((s) => xe.normalizeUnit(s));
    const i = {}, a = {}, n = this.toObject();
    let o;
    for (const s of an)
      if (e.indexOf(s) >= 0) {
        o = s;
        let r = 0;
        for (const c in a)
          r += this.matrix[c][s] * a[c], a[c] = 0;
        Da(n[s]) && (r += n[s]);
        const l = Math.trunc(r);
        i[s] = l, a[s] = (r * 1e3 - l * 1e3) / 1e3;
      } else Da(n[s]) && (a[s] = n[s]);
    for (const s in a)
      a[s] !== 0 && (i[o] += s === o ? a[s] : a[s] / this.matrix[o][s]);
    return Cu(this.matrix, i), Aa(this, { values: i }, !0);
  }
  /**
   * Shift this Duration to all available units.
   * Same as shiftTo("years", "months", "weeks", "days", "hours", "minutes", "seconds", "milliseconds")
   * @return {Duration}
   */
  shiftToAll() {
    return this.isValid ? this.shiftTo(
      "years",
      "months",
      "weeks",
      "days",
      "hours",
      "minutes",
      "seconds",
      "milliseconds"
    ) : this;
  }
  /**
   * Return the negative of this Duration.
   * @example Duration.fromObject({ hours: 1, seconds: 30 }).negate().toObject() //=> { hours: -1, seconds: -30 }
   * @return {Duration}
   */
  negate() {
    if (!this.isValid) return this;
    const e = {};
    for (const i of Object.keys(this.values))
      e[i] = this.values[i] === 0 ? 0 : -this.values[i];
    return Aa(this, { values: e }, !0);
  }
  /**
   * Get the years.
   * @type {number}
   */
  get years() {
    return this.isValid ? this.values.years || 0 : NaN;
  }
  /**
   * Get the quarters.
   * @type {number}
   */
  get quarters() {
    return this.isValid ? this.values.quarters || 0 : NaN;
  }
  /**
   * Get the months.
   * @type {number}
   */
  get months() {
    return this.isValid ? this.values.months || 0 : NaN;
  }
  /**
   * Get the weeks
   * @type {number}
   */
  get weeks() {
    return this.isValid ? this.values.weeks || 0 : NaN;
  }
  /**
   * Get the days.
   * @type {number}
   */
  get days() {
    return this.isValid ? this.values.days || 0 : NaN;
  }
  /**
   * Get the hours.
   * @type {number}
   */
  get hours() {
    return this.isValid ? this.values.hours || 0 : NaN;
  }
  /**
   * Get the minutes.
   * @type {number}
   */
  get minutes() {
    return this.isValid ? this.values.minutes || 0 : NaN;
  }
  /**
   * Get the seconds.
   * @return {number}
   */
  get seconds() {
    return this.isValid ? this.values.seconds || 0 : NaN;
  }
  /**
   * Get the milliseconds.
   * @return {number}
   */
  get milliseconds() {
    return this.isValid ? this.values.milliseconds || 0 : NaN;
  }
  /**
   * Returns whether the Duration is invalid. Invalid durations are returned by diff operations
   * on invalid DateTimes or Intervals.
   * @return {boolean}
   */
  get isValid() {
    return this.invalid === null;
  }
  /**
   * Returns an error code if this Duration became invalid, or null if the Duration is valid
   * @return {string}
   */
  get invalidReason() {
    return this.invalid ? this.invalid.reason : null;
  }
  /**
   * Returns an explanation of why this Duration became invalid, or null if the Duration is valid
   * @type {string}
   */
  get invalidExplanation() {
    return this.invalid ? this.invalid.explanation : null;
  }
  /**
   * Equality check
   * Two Durations are equal iff they have the same units and the same values for each unit.
   * @param {Duration} other
   * @return {boolean}
   */
  equals(e) {
    if (!this.isValid || !e.isValid || !this.loc.equals(e.loc))
      return !1;
    function i(a, n) {
      return a === void 0 || a === 0 ? n === void 0 || n === 0 : a === n;
    }
    for (const a of an)
      if (!i(this.values[a], e.values[a]))
        return !1;
    return !0;
  }
}
const kn = "Invalid Interval";
function dv(t, e) {
  return !t || !t.isValid ? Ke.invalid("missing or invalid start") : !e || !e.isValid ? Ke.invalid("missing or invalid end") : e < t ? Ke.invalid(
    "end before start",
    `The end of an interval must be after its start, but you had start=${t.toISO()} and end=${e.toISO()}`
  ) : null;
}
class Ke {
  /**
   * @private
   */
  constructor(e) {
    this.s = e.start, this.e = e.end, this.invalid = e.invalid || null, this.isLuxonInterval = !0;
  }
  /**
   * Create an invalid Interval.
   * @param {string} reason - simple string of why this Interval is invalid. Should not contain parameters or anything else data-dependent
   * @param {string} [explanation=null] - longer explanation, may include parameters and other useful debugging information
   * @return {Interval}
   */
  static invalid(e, i = null) {
    if (!e)
      throw new It("need to specify a reason the Interval is invalid");
    const a = e instanceof Ii ? e : new Ii(e, i);
    if (Je.throwOnInvalid)
      throw new Dx(a);
    return new Ke({ invalid: a });
  }
  /**
   * Create an Interval from a start DateTime and an end DateTime. Inclusive of the start but not the end.
   * @param {DateTime|Date|Object} start
   * @param {DateTime|Date|Object} end
   * @return {Interval}
   */
  static fromDateTimes(e, i) {
    const a = Lo(e), n = Lo(i), o = dv(a, n);
    return o ?? new Ke({
      start: a,
      end: n
    });
  }
  /**
   * Create an Interval from a start DateTime and a Duration to extend to.
   * @param {DateTime|Date|Object} start
   * @param {Duration|Object|number} duration - the length of the Interval.
   * @return {Interval}
   */
  static after(e, i) {
    const a = xe.fromDurationLike(i), n = Lo(e);
    return Ke.fromDateTimes(n, n.plus(a));
  }
  /**
   * Create an Interval from an end DateTime and a Duration to extend backwards to.
   * @param {DateTime|Date|Object} end
   * @param {Duration|Object|number} duration - the length of the Interval.
   * @return {Interval}
   */
  static before(e, i) {
    const a = xe.fromDurationLike(i), n = Lo(e);
    return Ke.fromDateTimes(n.minus(a), n);
  }
  /**
   * Create an Interval from an ISO 8601 string.
   * Accepts `<start>/<end>`, `<start>/<duration>`, and `<duration>/<end>` formats.
   * @param {string} text - the ISO string to parse
   * @param {Object} [opts] - options to pass {@link DateTime#fromISO} and optionally {@link Duration#fromISO}
   * @see https://en.wikipedia.org/wiki/ISO_8601#Time_intervals
   * @return {Interval}
   */
  static fromISO(e, i) {
    const [a, n] = (e || "").split("/", 2);
    if (a && n) {
      let o, s;
      try {
        o = K.fromISO(a, i), s = o.isValid;
      } catch {
        s = !1;
      }
      let r, l;
      try {
        r = K.fromISO(n, i), l = r.isValid;
      } catch {
        l = !1;
      }
      if (s && l)
        return Ke.fromDateTimes(o, r);
      if (s) {
        const c = xe.fromISO(n, i);
        if (c.isValid)
          return Ke.after(o, c);
      } else if (l) {
        const c = xe.fromISO(a, i);
        if (c.isValid)
          return Ke.before(r, c);
      }
    }
    return Ke.invalid("unparsable", `the input "${e}" can't be parsed as ISO 8601`);
  }
  /**
   * Check if an object is an Interval. Works across context boundaries
   * @param {object} o
   * @return {boolean}
   */
  static isInterval(e) {
    return e && e.isLuxonInterval || !1;
  }
  /**
   * Returns the start of the Interval
   * @type {DateTime}
   */
  get start() {
    return this.isValid ? this.s : null;
  }
  /**
   * Returns the end of the Interval
   * @type {DateTime}
   */
  get end() {
    return this.isValid ? this.e : null;
  }
  /**
   * Returns whether this Interval's end is at least its start, meaning that the Interval isn't 'backwards'.
   * @type {boolean}
   */
  get isValid() {
    return this.invalidReason === null;
  }
  /**
   * Returns an error code if this Interval is invalid, or null if the Interval is valid
   * @type {string}
   */
  get invalidReason() {
    return this.invalid ? this.invalid.reason : null;
  }
  /**
   * Returns an explanation of why this Interval became invalid, or null if the Interval is valid
   * @type {string}
   */
  get invalidExplanation() {
    return this.invalid ? this.invalid.explanation : null;
  }
  /**
   * Returns the length of the Interval in the specified unit.
   * @param {string} unit - the unit (such as 'hours' or 'days') to return the length in.
   * @return {number}
   */
  length(e = "milliseconds") {
    return this.isValid ? this.toDuration(e).get(e) : NaN;
  }
  /**
   * Returns the count of minutes, hours, days, months, or years included in the Interval, even in part.
   * Unlike {@link Interval#length} this counts sections of the calendar, not periods of time, e.g. specifying 'day'
   * asks 'what dates are included in this interval?', not 'how many days long is this interval?'
   * @param {string} [unit='milliseconds'] - the unit of time to count.
   * @param {Object} opts - options
   * @param {boolean} [opts.useLocaleWeeks=false] - If true, use weeks based on the locale, i.e. use the locale-dependent start of the week; this operation will always use the locale of the start DateTime
   * @return {number}
   */
  count(e = "milliseconds", i) {
    if (!this.isValid) return NaN;
    const a = this.start.startOf(e, i);
    let n;
    return i?.useLocaleWeeks ? n = this.end.reconfigure({ locale: a.locale }) : n = this.end, n = n.startOf(e, i), Math.floor(n.diff(a, e).get(e)) + (n.valueOf() !== this.end.valueOf());
  }
  /**
   * Returns whether this Interval's start and end are both in the same unit of time
   * @param {string} unit - the unit of time to check sameness on
   * @return {boolean}
   */
  hasSame(e) {
    return this.isValid ? this.isEmpty() || this.e.minus(1).hasSame(this.s, e) : !1;
  }
  /**
   * Return whether this Interval has the same start and end DateTimes.
   * @return {boolean}
   */
  isEmpty() {
    return this.s.valueOf() === this.e.valueOf();
  }
  /**
   * Return whether this Interval's start is after the specified DateTime.
   * @param {DateTime} dateTime
   * @return {boolean}
   */
  isAfter(e) {
    return this.isValid ? this.s > e : !1;
  }
  /**
   * Return whether this Interval's end is before the specified DateTime.
   * @param {DateTime} dateTime
   * @return {boolean}
   */
  isBefore(e) {
    return this.isValid ? this.e <= e : !1;
  }
  /**
   * Return whether this Interval contains the specified DateTime.
   * @param {DateTime} dateTime
   * @return {boolean}
   */
  contains(e) {
    return this.isValid ? this.s <= e && this.e > e : !1;
  }
  /**
   * "Sets" the start and/or end dates. Returns a newly-constructed Interval.
   * @param {Object} values - the values to set
   * @param {DateTime} values.start - the starting DateTime
   * @param {DateTime} values.end - the ending DateTime
   * @return {Interval}
   */
  set({ start: e, end: i } = {}) {
    return this.isValid ? Ke.fromDateTimes(e || this.s, i || this.e) : this;
  }
  /**
   * Split this Interval at each of the specified DateTimes
   * @param {...DateTime} dateTimes - the unit of time to count.
   * @return {Array}
   */
  splitAt(...e) {
    if (!this.isValid) return [];
    const i = e.map(Lo).filter((s) => this.contains(s)).sort((s, r) => s.toMillis() - r.toMillis()), a = [];
    let { s: n } = this, o = 0;
    for (; n < this.e; ) {
      const s = i[o] || this.e, r = +s > +this.e ? this.e : s;
      a.push(Ke.fromDateTimes(n, r)), n = r, o += 1;
    }
    return a;
  }
  /**
   * Split this Interval into smaller Intervals, each of the specified length.
   * Left over time is grouped into a smaller interval
   * @param {Duration|Object|number} duration - The length of each resulting interval.
   * @return {Array}
   */
  splitBy(e) {
    const i = xe.fromDurationLike(e);
    if (!this.isValid || !i.isValid || i.as("milliseconds") === 0)
      return [];
    let { s: a } = this, n = 1, o;
    const s = [];
    for (; a < this.e; ) {
      const r = this.start.plus(i.mapUnits((l) => l * n));
      o = +r > +this.e ? this.e : r, s.push(Ke.fromDateTimes(a, o)), a = o, n += 1;
    }
    return s;
  }
  /**
   * Split this Interval into the specified number of smaller intervals.
   * @param {number} numberOfParts - The number of Intervals to divide the Interval into.
   * @return {Array}
   */
  divideEqually(e) {
    return this.isValid ? this.splitBy(this.length() / e).slice(0, e) : [];
  }
  /**
   * Return whether this Interval overlaps with the specified Interval
   * @param {Interval} other
   * @return {boolean}
   */
  overlaps(e) {
    return this.e > e.s && this.s < e.e;
  }
  /**
   * Return whether this Interval's end is adjacent to the specified Interval's start.
   * @param {Interval} other
   * @return {boolean}
   */
  abutsStart(e) {
    return this.isValid ? +this.e == +e.s : !1;
  }
  /**
   * Return whether this Interval's start is adjacent to the specified Interval's end.
   * @param {Interval} other
   * @return {boolean}
   */
  abutsEnd(e) {
    return this.isValid ? +e.e == +this.s : !1;
  }
  /**
   * Returns true if this Interval fully contains the specified Interval, specifically if the intersect (of this Interval and the other Interval) is equal to the other Interval; false otherwise.
   * @param {Interval} other
   * @return {boolean}
   */
  engulfs(e) {
    return this.isValid ? this.s <= e.s && this.e >= e.e : !1;
  }
  /**
   * Return whether this Interval has the same start and end as the specified Interval.
   * @param {Interval} other
   * @return {boolean}
   */
  equals(e) {
    return !this.isValid || !e.isValid ? !1 : this.s.equals(e.s) && this.e.equals(e.e);
  }
  /**
   * Return an Interval representing the intersection of this Interval and the specified Interval.
   * Specifically, the resulting Interval has the maximum start time and the minimum end time of the two Intervals.
   * Returns null if the intersection is empty, meaning, the intervals don't intersect.
   * @param {Interval} other
   * @return {Interval}
   */
  intersection(e) {
    if (!this.isValid) return this;
    const i = this.s > e.s ? this.s : e.s, a = this.e < e.e ? this.e : e.e;
    return i >= a ? null : Ke.fromDateTimes(i, a);
  }
  /**
   * Return an Interval representing the union of this Interval and the specified Interval.
   * Specifically, the resulting Interval has the minimum start time and the maximum end time of the two Intervals.
   * @param {Interval} other
   * @return {Interval}
   */
  union(e) {
    if (!this.isValid) return this;
    const i = this.s < e.s ? this.s : e.s, a = this.e > e.e ? this.e : e.e;
    return Ke.fromDateTimes(i, a);
  }
  /**
   * Merge an array of Intervals into a equivalent minimal set of Intervals.
   * Combines overlapping and adjacent Intervals.
   * @param {Array} intervals
   * @return {Array}
   */
  static merge(e) {
    const [i, a] = e.sort((n, o) => n.s - o.s).reduce(
      ([n, o], s) => o ? o.overlaps(s) || o.abutsStart(s) ? [n, o.union(s)] : [n.concat([o]), s] : [n, s],
      [[], null]
    );
    return a && i.push(a), i;
  }
  /**
   * Return an array of Intervals representing the spans of time that only appear in one of the specified Intervals.
   * @param {Array} intervals
   * @return {Array}
   */
  static xor(e) {
    let i = null, a = 0;
    const n = [], o = e.map((l) => [
      { time: l.s, type: "s" },
      { time: l.e, type: "e" }
    ]), s = Array.prototype.concat(...o), r = s.sort((l, c) => l.time - c.time);
    for (const l of r)
      a += l.type === "s" ? 1 : -1, a === 1 ? i = l.time : (i && +i != +l.time && n.push(Ke.fromDateTimes(i, l.time)), i = null);
    return Ke.merge(n);
  }
  /**
   * Return an Interval representing the span of time in this Interval that doesn't overlap with any of the specified Intervals.
   * @param {...Interval} intervals
   * @return {Array}
   */
  difference(...e) {
    return Ke.xor([this].concat(e)).map((i) => this.intersection(i)).filter((i) => i && !i.isEmpty());
  }
  /**
   * Returns a string representation of this Interval appropriate for debugging.
   * @return {string}
   */
  toString() {
    return this.isValid ? `[${this.s.toISO()} – ${this.e.toISO()})` : kn;
  }
  /**
   * Returns a string representation of this Interval appropriate for the REPL.
   * @return {string}
   */
  [Symbol.for("nodejs.util.inspect.custom")]() {
    return this.isValid ? `Interval { start: ${this.s.toISO()}, end: ${this.e.toISO()} }` : `Interval { Invalid, reason: ${this.invalidReason} }`;
  }
  /**
   * Returns a localized string representing this Interval. Accepts the same options as the
   * Intl.DateTimeFormat constructor and any presets defined by Luxon, such as
   * {@link DateTime.DATE_FULL} or {@link DateTime.TIME_SIMPLE}. The exact behavior of this method
   * is browser-specific, but in general it will return an appropriate representation of the
   * Interval in the assigned locale. Defaults to the system's locale if no locale has been
   * specified.
   * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DateTimeFormat
   * @param {Object} [formatOpts=DateTime.DATE_SHORT] - Either a DateTime preset or
   * Intl.DateTimeFormat constructor options.
   * @param {Object} opts - Options to override the configuration of the start DateTime.
   * @example Interval.fromISO('2022-11-07T09:00Z/2022-11-08T09:00Z').toLocaleString(); //=> 11/7/2022 – 11/8/2022
   * @example Interval.fromISO('2022-11-07T09:00Z/2022-11-08T09:00Z').toLocaleString(DateTime.DATE_FULL); //=> November 7 – 8, 2022
   * @example Interval.fromISO('2022-11-07T09:00Z/2022-11-08T09:00Z').toLocaleString(DateTime.DATE_FULL, { locale: 'fr-FR' }); //=> 7–8 novembre 2022
   * @example Interval.fromISO('2022-11-07T17:00Z/2022-11-07T19:00Z').toLocaleString(DateTime.TIME_SIMPLE); //=> 6:00 – 8:00 PM
   * @example Interval.fromISO('2022-11-07T17:00Z/2022-11-07T19:00Z').toLocaleString({ weekday: 'short', month: 'short', day: '2-digit', hour: '2-digit', minute: '2-digit' }); //=> Mon, Nov 07, 6:00 – 8:00 p
   * @return {string}
   */
  toLocaleString(e = Js, i = {}) {
    return this.isValid ? Bt.create(this.s.loc.clone(i), e).formatInterval(this) : kn;
  }
  /**
   * Returns an ISO 8601-compliant string representation of this Interval.
   * @see https://en.wikipedia.org/wiki/ISO_8601#Time_intervals
   * @param {Object} opts - The same options as {@link DateTime#toISO}
   * @return {string}
   */
  toISO(e) {
    return this.isValid ? `${this.s.toISO(e)}/${this.e.toISO(e)}` : kn;
  }
  /**
   * Returns an ISO 8601-compliant string representation of date of this Interval.
   * The time components are ignored.
   * @see https://en.wikipedia.org/wiki/ISO_8601#Time_intervals
   * @return {string}
   */
  toISODate() {
    return this.isValid ? `${this.s.toISODate()}/${this.e.toISODate()}` : kn;
  }
  /**
   * Returns an ISO 8601-compliant string representation of time of this Interval.
   * The date components are ignored.
   * @see https://en.wikipedia.org/wiki/ISO_8601#Time_intervals
   * @param {Object} opts - The same options as {@link DateTime#toISO}
   * @return {string}
   */
  toISOTime(e) {
    return this.isValid ? `${this.s.toISOTime(e)}/${this.e.toISOTime(e)}` : kn;
  }
  /**
   * Returns a string representation of this Interval formatted according to the specified format
   * string. **You may not want this.** See {@link Interval#toLocaleString} for a more flexible
   * formatting tool.
   * @param {string} dateFormat - The format string. This string formats the start and end time.
   * See {@link DateTime#toFormat} for details.
   * @param {Object} opts - Options.
   * @param {string} [opts.separator =  ' – '] - A separator to place between the start and end
   * representations.
   * @return {string}
   */
  toFormat(e, { separator: i = " – " } = {}) {
    return this.isValid ? `${this.s.toFormat(e)}${i}${this.e.toFormat(e)}` : kn;
  }
  /**
   * Return a Duration representing the time spanned by this interval.
   * @param {string|string[]} [unit=['milliseconds']] - the unit or units (such as 'hours' or 'days') to include in the duration.
   * @param {Object} opts - options that affect the creation of the Duration
   * @param {string} [opts.conversionAccuracy='casual'] - the conversion system to use
   * @example Interval.fromDateTimes(dt1, dt2).toDuration().toObject() //=> { milliseconds: 88489257 }
   * @example Interval.fromDateTimes(dt1, dt2).toDuration('days').toObject() //=> { days: 1.0241812152777778 }
   * @example Interval.fromDateTimes(dt1, dt2).toDuration(['hours', 'minutes']).toObject() //=> { hours: 24, minutes: 34.82095 }
   * @example Interval.fromDateTimes(dt1, dt2).toDuration(['hours', 'minutes', 'seconds']).toObject() //=> { hours: 24, minutes: 34, seconds: 49.257 }
   * @example Interval.fromDateTimes(dt1, dt2).toDuration('seconds').toObject() //=> { seconds: 88489.257 }
   * @return {Duration}
   */
  toDuration(e, i) {
    return this.isValid ? this.e.diff(this.s, e, i) : xe.invalid(this.invalidReason);
  }
  /**
   * Run mapFn on the interval start and end, returning a new Interval from the resulting DateTimes
   * @param {function} mapFn
   * @return {Interval}
   * @example Interval.fromDateTimes(dt1, dt2).mapEndpoints(endpoint => endpoint.toUTC())
   * @example Interval.fromDateTimes(dt1, dt2).mapEndpoints(endpoint => endpoint.plus({ hours: 2 }))
   */
  mapEndpoints(e) {
    return Ke.fromDateTimes(e(this.s), e(this.e));
  }
}
class Fs {
  /**
   * Return whether the specified zone contains a DST.
   * @param {string|Zone} [zone='local'] - Zone to check. Defaults to the environment's local zone.
   * @return {boolean}
   */
  static hasDST(e = Je.defaultZone) {
    const i = K.now().setZone(e).set({ month: 12 });
    return !e.isUniversal && i.offset !== i.set({ month: 6 }).offset;
  }
  /**
   * Return whether the specified zone is a valid IANA specifier.
   * @param {string} zone - Zone to check
   * @return {boolean}
   */
  static isValidIANAZone(e) {
    return da.isValidZone(e);
  }
  /**
   * Converts the input into a {@link Zone} instance.
   *
   * * If `input` is already a Zone instance, it is returned unchanged.
   * * If `input` is a string containing a valid time zone name, a Zone instance
   *   with that name is returned.
   * * If `input` is a string that doesn't refer to a known time zone, a Zone
   *   instance with {@link Zone#isValid} == false is returned.
   * * If `input is a number, a Zone instance with the specified fixed offset
   *   in minutes is returned.
   * * If `input` is `null` or `undefined`, the default zone is returned.
   * @param {string|Zone|number} [input] - the value to be converted
   * @return {Zone}
   */
  static normalizeZone(e) {
    return ka(e, Je.defaultZone);
  }
  /**
   * Get the weekday on which the week starts according to the given locale.
   * @param {Object} opts - options
   * @param {string} [opts.locale] - the locale code
   * @param {string} [opts.locObj=null] - an existing locale object to use
   * @returns {number} the start of the week, 1 for Monday through 7 for Sunday
   */
  static getStartOfWeek({ locale: e = null, locObj: i = null } = {}) {
    return (i || ke.create(e)).getStartOfWeek();
  }
  /**
   * Get the minimum number of days necessary in a week before it is considered part of the next year according
   * to the given locale.
   * @param {Object} opts - options
   * @param {string} [opts.locale] - the locale code
   * @param {string} [opts.locObj=null] - an existing locale object to use
   * @returns {number}
   */
  static getMinimumDaysInFirstWeek({ locale: e = null, locObj: i = null } = {}) {
    return (i || ke.create(e)).getMinDaysInFirstWeek();
  }
  /**
   * Get the weekdays, which are considered the weekend according to the given locale
   * @param {Object} opts - options
   * @param {string} [opts.locale] - the locale code
   * @param {string} [opts.locObj=null] - an existing locale object to use
   * @returns {number[]} an array of weekdays, 1 for Monday through 7 for Sunday
   */
  static getWeekendWeekdays({ locale: e = null, locObj: i = null } = {}) {
    return (i || ke.create(e)).getWeekendDays().slice();
  }
  /**
   * Return an array of standalone month names.
   * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DateTimeFormat
   * @param {string} [length='long'] - the length of the month representation, such as "numeric", "2-digit", "narrow", "short", "long"
   * @param {Object} opts - options
   * @param {string} [opts.locale] - the locale code
   * @param {string} [opts.numberingSystem=null] - the numbering system
   * @param {string} [opts.locObj=null] - an existing locale object to use
   * @param {string} [opts.outputCalendar='gregory'] - the calendar
   * @example Info.months()[0] //=> 'January'
   * @example Info.months('short')[0] //=> 'Jan'
   * @example Info.months('numeric')[0] //=> '1'
   * @example Info.months('short', { locale: 'fr-CA' } )[0] //=> 'janv.'
   * @example Info.months('numeric', { locale: 'ar' })[0] //=> '١'
   * @example Info.months('long', { outputCalendar: 'islamic' })[0] //=> 'Rabiʻ I'
   * @return {Array}
   */
  static months(e = "long", { locale: i = null, numberingSystem: a = null, locObj: n = null, outputCalendar: o = "gregory" } = {}) {
    return (n || ke.create(i, a, o)).months(e);
  }
  /**
   * Return an array of format month names.
   * Format months differ from standalone months in that they're meant to appear next to the day of the month. In some languages, that
   * changes the string.
   * See {@link Info#months}
   * @param {string} [length='long'] - the length of the month representation, such as "numeric", "2-digit", "narrow", "short", "long"
   * @param {Object} opts - options
   * @param {string} [opts.locale] - the locale code
   * @param {string} [opts.numberingSystem=null] - the numbering system
   * @param {string} [opts.locObj=null] - an existing locale object to use
   * @param {string} [opts.outputCalendar='gregory'] - the calendar
   * @return {Array}
   */
  static monthsFormat(e = "long", { locale: i = null, numberingSystem: a = null, locObj: n = null, outputCalendar: o = "gregory" } = {}) {
    return (n || ke.create(i, a, o)).months(e, !0);
  }
  /**
   * Return an array of standalone week names.
   * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DateTimeFormat
   * @param {string} [length='long'] - the length of the weekday representation, such as "narrow", "short", "long".
   * @param {Object} opts - options
   * @param {string} [opts.locale] - the locale code
   * @param {string} [opts.numberingSystem=null] - the numbering system
   * @param {string} [opts.locObj=null] - an existing locale object to use
   * @example Info.weekdays()[0] //=> 'Monday'
   * @example Info.weekdays('short')[0] //=> 'Mon'
   * @example Info.weekdays('short', { locale: 'fr-CA' })[0] //=> 'lun.'
   * @example Info.weekdays('short', { locale: 'ar' })[0] //=> 'الاثنين'
   * @return {Array}
   */
  static weekdays(e = "long", { locale: i = null, numberingSystem: a = null, locObj: n = null } = {}) {
    return (n || ke.create(i, a, null)).weekdays(e);
  }
  /**
   * Return an array of format week names.
   * Format weekdays differ from standalone weekdays in that they're meant to appear next to more date information. In some languages, that
   * changes the string.
   * See {@link Info#weekdays}
   * @param {string} [length='long'] - the length of the month representation, such as "narrow", "short", "long".
   * @param {Object} opts - options
   * @param {string} [opts.locale=null] - the locale code
   * @param {string} [opts.numberingSystem=null] - the numbering system
   * @param {string} [opts.locObj=null] - an existing locale object to use
   * @return {Array}
   */
  static weekdaysFormat(e = "long", { locale: i = null, numberingSystem: a = null, locObj: n = null } = {}) {
    return (n || ke.create(i, a, null)).weekdays(e, !0);
  }
  /**
   * Return an array of meridiems.
   * @param {Object} opts - options
   * @param {string} [opts.locale] - the locale code
   * @example Info.meridiems() //=> [ 'AM', 'PM' ]
   * @example Info.meridiems({ locale: 'my' }) //=> [ 'နံနက်', 'ညနေ' ]
   * @return {Array}
   */
  static meridiems({ locale: e = null } = {}) {
    return ke.create(e).meridiems();
  }
  /**
   * Return an array of eras, such as ['BC', 'AD']. The locale can be specified, but the calendar system is always Gregorian.
   * @param {string} [length='short'] - the length of the era representation, such as "short" or "long".
   * @param {Object} opts - options
   * @param {string} [opts.locale] - the locale code
   * @example Info.eras() //=> [ 'BC', 'AD' ]
   * @example Info.eras('long') //=> [ 'Before Christ', 'Anno Domini' ]
   * @example Info.eras('long', { locale: 'fr' }) //=> [ 'avant Jésus-Christ', 'après Jésus-Christ' ]
   * @return {Array}
   */
  static eras(e = "short", { locale: i = null } = {}) {
    return ke.create(i, null, "gregory").eras(e);
  }
  /**
   * Return the set of available features in this environment.
   * Some features of Luxon are not available in all environments. For example, on older browsers, relative time formatting support is not available. Use this function to figure out if that's the case.
   * Keys:
   * * `relative`: whether this environment supports relative time formatting
   * * `localeWeek`: whether this environment supports different weekdays for the start of the week based on the locale
   * @example Info.features() //=> { relative: false, localeWeek: true }
   * @return {Object}
   */
  static features() {
    return { relative: ig(), localeWeek: ag() };
  }
}
function vu(t, e) {
  const i = (n) => n.toUTC(0, { keepLocalTime: !0 }).startOf("day").valueOf(), a = i(e) - i(t);
  return Math.floor(xe.fromMillis(a).as("days"));
}
function uv(t, e, i) {
  const a = [
    ["years", (l, c) => c.year - l.year],
    ["quarters", (l, c) => c.quarter - l.quarter + (c.year - l.year) * 4],
    ["months", (l, c) => c.month - l.month + (c.year - l.year) * 12],
    [
      "weeks",
      (l, c) => {
        const d = vu(l, c);
        return (d - d % 7) / 7;
      }
    ],
    ["days", vu]
  ], n = {}, o = t;
  let s, r;
  for (const [l, c] of a)
    i.indexOf(l) >= 0 && (s = l, n[l] = c(t, e), r = o.plus(n), r > e ? (n[l]--, t = o.plus(n), t > e && (r = t, n[l]--, t = o.plus(n))) : t = r);
  return [t, n, r, s];
}
function fv(t, e, i, a) {
  let [n, o, s, r] = uv(t, e, i);
  const l = e - n, c = i.filter(
    (u) => ["hours", "minutes", "seconds", "milliseconds"].indexOf(u) >= 0
  );
  c.length === 0 && (s < e && (s = n.plus({ [r]: 1 })), s !== n && (o[r] = (o[r] || 0) + l / (s - n)));
  const d = xe.fromObject(o, a);
  return c.length > 0 ? xe.fromMillis(l, a).shiftTo(...c).plus(d) : d;
}
const mv = "missing Intl.DateTimeFormat.formatToParts support";
function Fe(t, e = (i) => i) {
  return { regex: t, deser: ([i]) => e(iC(i)) };
}
const gv = " ", Cg = `[ ${gv}]`, vg = new RegExp(Cg, "g");
function hv(t) {
  return t.replace(/\./g, "\\.?").replace(vg, Cg);
}
function Fu(t) {
  return t.replace(/\./g, "").replace(vg, " ").toLowerCase();
}
function Ti(t, e) {
  return t === null ? null : {
    regex: RegExp(t.map(hv).join("|")),
    deser: ([i]) => t.findIndex((a) => Fu(i) === Fu(a)) + e
  };
}
function Lu(t, e) {
  return { regex: t, deser: ([, i, a]) => Mr(i, a), groups: e };
}
function Ls(t) {
  return { regex: t, deser: ([e]) => e };
}
function pv(t) {
  return t.replace(/[\-\[\]{}()*+?.,\\\^$|#\s]/g, "\\$&");
}
function yv(t, e) {
  const i = Ai(e), a = Ai(e, "{2}"), n = Ai(e, "{3}"), o = Ai(e, "{4}"), s = Ai(e, "{6}"), r = Ai(e, "{1,2}"), l = Ai(e, "{1,3}"), c = Ai(e, "{1,6}"), d = Ai(e, "{1,9}"), u = Ai(e, "{2,4}"), f = Ai(e, "{4,6}"), m = (p) => ({ regex: RegExp(pv(p.val)), deser: ([S]) => S, literal: !0 }), y = ((p) => {
    if (t.literal)
      return m(p);
    switch (p.val) {
      // era
      case "G":
        return Ti(e.eras("short"), 0);
      case "GG":
        return Ti(e.eras("long"), 0);
      // years
      case "y":
        return Fe(c);
      case "yy":
        return Fe(u, zl);
      case "yyyy":
        return Fe(o);
      case "yyyyy":
        return Fe(f);
      case "yyyyyy":
        return Fe(s);
      // months
      case "M":
        return Fe(r);
      case "MM":
        return Fe(a);
      case "MMM":
        return Ti(e.months("short", !0), 1);
      case "MMMM":
        return Ti(e.months("long", !0), 1);
      case "L":
        return Fe(r);
      case "LL":
        return Fe(a);
      case "LLL":
        return Ti(e.months("short", !1), 1);
      case "LLLL":
        return Ti(e.months("long", !1), 1);
      // dates
      case "d":
        return Fe(r);
      case "dd":
        return Fe(a);
      // ordinals
      case "o":
        return Fe(l);
      case "ooo":
        return Fe(n);
      // time
      case "HH":
        return Fe(a);
      case "H":
        return Fe(r);
      case "hh":
        return Fe(a);
      case "h":
        return Fe(r);
      case "mm":
        return Fe(a);
      case "m":
        return Fe(r);
      case "q":
        return Fe(r);
      case "qq":
        return Fe(a);
      case "s":
        return Fe(r);
      case "ss":
        return Fe(a);
      case "S":
        return Fe(l);
      case "SSS":
        return Fe(n);
      case "u":
        return Ls(d);
      case "uu":
        return Ls(r);
      case "uuu":
        return Fe(i);
      // meridiem
      case "a":
        return Ti(e.meridiems(), 0);
      // weekYear (k)
      case "kkkk":
        return Fe(o);
      case "kk":
        return Fe(u, zl);
      // weekNumber (W)
      case "W":
        return Fe(r);
      case "WW":
        return Fe(a);
      // weekdays
      case "E":
      case "c":
        return Fe(i);
      case "EEE":
        return Ti(e.weekdays("short", !1), 1);
      case "EEEE":
        return Ti(e.weekdays("long", !1), 1);
      case "ccc":
        return Ti(e.weekdays("short", !0), 1);
      case "cccc":
        return Ti(e.weekdays("long", !0), 1);
      // offset/zone
      case "Z":
      case "ZZ":
        return Lu(new RegExp(`([+-]${r.source})(?::(${a.source}))?`), 2);
      case "ZZZ":
        return Lu(new RegExp(`([+-]${r.source})(${a.source})?`), 2);
      // we don't support ZZZZ (PST) or ZZZZZ (Pacific Standard Time) in parsing
      // because we don't have any way to figure out what they are
      case "z":
        return Ls(/[a-z_+-/]{1,256}?/i);
      // this special-case "token" represents a place where a macro-token expanded into a white-space literal
      // in this case we accept any non-newline white-space
      case " ":
        return Ls(/[^\S\n\r]/);
      default:
        return m(p);
    }
  })(t) || {
    invalidReason: mv
  };
  return y.token = t, y;
}
const bv = {
  year: {
    "2-digit": "yy",
    numeric: "yyyyy"
  },
  month: {
    numeric: "M",
    "2-digit": "MM",
    short: "MMM",
    long: "MMMM"
  },
  day: {
    numeric: "d",
    "2-digit": "dd"
  },
  weekday: {
    short: "EEE",
    long: "EEEE"
  },
  dayperiod: "a",
  dayPeriod: "a",
  hour12: {
    numeric: "h",
    "2-digit": "hh"
  },
  hour24: {
    numeric: "H",
    "2-digit": "HH"
  },
  minute: {
    numeric: "m",
    "2-digit": "mm"
  },
  second: {
    numeric: "s",
    "2-digit": "ss"
  },
  timeZoneName: {
    long: "ZZZZZ",
    short: "ZZZ"
  }
};
function Sv(t, e, i) {
  const { type: a, value: n } = t;
  if (a === "literal") {
    const l = /^\s+$/.test(n);
    return {
      literal: !l,
      val: l ? " " : n
    };
  }
  const o = e[a];
  let s = a;
  a === "hour" && (e.hour12 != null ? s = e.hour12 ? "hour12" : "hour24" : e.hourCycle != null ? e.hourCycle === "h11" || e.hourCycle === "h12" ? s = "hour12" : s = "hour24" : s = i.hour12 ? "hour12" : "hour24");
  let r = bv[s];
  if (typeof r == "object" && (r = r[o]), r)
    return {
      literal: !1,
      val: r
    };
}
function xv(t) {
  return [`^${t.map((i) => i.regex).reduce((i, a) => `${i}(${a.source})`, "")}$`, t];
}
function Cv(t, e, i) {
  const a = t.match(e);
  if (a) {
    const n = {};
    let o = 1;
    for (const s in i)
      if (jn(i, s)) {
        const r = i[s], l = r.groups ? r.groups + 1 : 1;
        !r.literal && r.token && (n[r.token.val[0]] = r.deser(a.slice(o, o + l))), o += l;
      }
    return [a, n];
  } else
    return [a, {}];
}
function vv(t) {
  const e = (o) => {
    switch (o) {
      case "S":
        return "millisecond";
      case "s":
        return "second";
      case "m":
        return "minute";
      case "h":
      case "H":
        return "hour";
      case "d":
        return "day";
      case "o":
        return "ordinal";
      case "L":
      case "M":
        return "month";
      case "y":
        return "year";
      case "E":
      case "c":
        return "weekday";
      case "W":
        return "weekNumber";
      case "k":
        return "weekYear";
      case "q":
        return "quarter";
      default:
        return null;
    }
  };
  let i = null, a;
  return ae(t.z) || (i = da.create(t.z)), ae(t.Z) || (i || (i = new Et(t.Z)), a = t.Z), ae(t.q) || (t.M = (t.q - 1) * 3 + 1), ae(t.h) || (t.h < 12 && t.a === 1 ? t.h += 12 : t.h === 12 && t.a === 0 && (t.h = 0)), t.G === 0 && t.y && (t.y = -t.y), ae(t.u) || (t.S = Nc(t.u)), [Object.keys(t).reduce((o, s) => {
    const r = e(s);
    return r && (o[r] = t[s]), o;
  }, {}), i, a];
}
let bl = null;
function Fv() {
  return bl || (bl = K.fromMillis(1555555555555)), bl;
}
function Lv(t, e) {
  if (t.literal)
    return t;
  const i = Bt.macroTokenToFormatOpts(t.val), a = Tg(i, e);
  return a == null || a.includes(void 0) ? t : a;
}
function Fg(t, e) {
  return Array.prototype.concat(...t.map((i) => Lv(i, e)));
}
class Lg {
  constructor(e, i) {
    if (this.locale = e, this.format = i, this.tokens = Fg(Bt.parseFormat(i), e), this.units = this.tokens.map((a) => yv(a, e)), this.disqualifyingUnit = this.units.find((a) => a.invalidReason), !this.disqualifyingUnit) {
      const [a, n] = xv(this.units);
      this.regex = RegExp(a, "i"), this.handlers = n;
    }
  }
  explainFromTokens(e) {
    if (this.isValid) {
      const [i, a] = Cv(e, this.regex, this.handlers), [n, o, s] = a ? vv(a) : [null, null, void 0];
      if (jn(a, "a") && jn(a, "H"))
        throw new Dn(
          "Can't include meridiem when specifying 24-hour format"
        );
      return {
        input: e,
        tokens: this.tokens,
        regex: this.regex,
        rawMatches: i,
        matches: a,
        result: n,
        zone: o,
        specificOffset: s
      };
    } else
      return { input: e, tokens: this.tokens, invalidReason: this.invalidReason };
  }
  get isValid() {
    return !this.disqualifyingUnit;
  }
  get invalidReason() {
    return this.disqualifyingUnit ? this.disqualifyingUnit.invalidReason : null;
  }
}
function Ag(t, e, i) {
  return new Lg(t, i).explainFromTokens(e);
}
function Av(t, e, i) {
  const { result: a, zone: n, specificOffset: o, invalidReason: s } = Ag(t, e, i);
  return [a, n, o, s];
}
function Tg(t, e) {
  if (!t)
    return null;
  const a = Bt.create(e, t).dtFormatter(Fv()), n = a.formatToParts(), o = a.resolvedOptions();
  return n.map((s) => Sv(s, t, o));
}
const Sl = "Invalid DateTime", Tv = 864e13;
function wo(t) {
  return new Ii("unsupported zone", `the zone "${t.name}" is not supported`);
}
function xl(t) {
  return t.weekData === null && (t.weekData = er(t.c)), t.weekData;
}
function Cl(t) {
  return t.localWeekData === null && (t.localWeekData = er(
    t.c,
    t.loc.getMinDaysInFirstWeek(),
    t.loc.getStartOfWeek()
  )), t.localWeekData;
}
function Ja(t, e) {
  const i = {
    ts: t.ts,
    zone: t.zone,
    c: t.c,
    o: t.o,
    loc: t.loc,
    invalid: t.invalid
  };
  return new K({ ...i, ...e, old: i });
}
function wg(t, e, i) {
  let a = t - e * 60 * 1e3;
  const n = i.offset(a);
  if (e === n)
    return [a, e];
  a -= (n - e) * 60 * 1e3;
  const o = i.offset(a);
  return n === o ? [a, n] : [t - Math.min(n, o) * 60 * 1e3, Math.max(n, o)];
}
function As(t, e) {
  t += e * 60 * 1e3;
  const i = new Date(t);
  return {
    year: i.getUTCFullYear(),
    month: i.getUTCMonth() + 1,
    day: i.getUTCDate(),
    hour: i.getUTCHours(),
    minute: i.getUTCMinutes(),
    second: i.getUTCSeconds(),
    millisecond: i.getUTCMilliseconds()
  };
}
function Rs(t, e, i) {
  return wg(Nr(t), e, i);
}
function Au(t, e) {
  const i = t.o, a = t.c.year + Math.trunc(e.years), n = t.c.month + Math.trunc(e.months) + Math.trunc(e.quarters) * 3, o = {
    ...t.c,
    year: a,
    month: n,
    day: Math.min(t.c.day, tr(a, n)) + Math.trunc(e.days) + Math.trunc(e.weeks) * 7
  }, s = xe.fromObject({
    years: e.years - Math.trunc(e.years),
    quarters: e.quarters - Math.trunc(e.quarters),
    months: e.months - Math.trunc(e.months),
    weeks: e.weeks - Math.trunc(e.weeks),
    days: e.days - Math.trunc(e.days),
    hours: e.hours,
    minutes: e.minutes,
    seconds: e.seconds,
    milliseconds: e.milliseconds
  }).as("milliseconds"), r = Nr(o);
  let [l, c] = wg(r, i, t.zone);
  return s !== 0 && (l += s, c = t.zone.offset(l)), { ts: l, o: c };
}
function In(t, e, i, a, n, o) {
  const { setZone: s, zone: r } = i;
  if (t && Object.keys(t).length !== 0 || e) {
    const l = e || r, c = K.fromObject(t, {
      ...i,
      zone: l,
      specificOffset: o
    });
    return s ? c : c.setZone(r);
  } else
    return K.invalid(
      new Ii("unparsable", `the input "${n}" can't be parsed as ${a}`)
    );
}
function Ts(t, e, i = !0) {
  return t.isValid ? Bt.create(ke.create("en-US"), {
    allowZ: i,
    forceSimple: !0
  }).formatDateTimeFromString(t, e) : null;
}
function vl(t, e) {
  const i = t.c.year > 9999 || t.c.year < 0;
  let a = "";
  return i && t.c.year >= 0 && (a += "+"), a += lt(t.c.year, i ? 6 : 4), e ? (a += "-", a += lt(t.c.month), a += "-", a += lt(t.c.day)) : (a += lt(t.c.month), a += lt(t.c.day)), a;
}
function Tu(t, e, i, a, n, o) {
  let s = lt(t.c.hour);
  return e ? (s += ":", s += lt(t.c.minute), (t.c.millisecond !== 0 || t.c.second !== 0 || !i) && (s += ":")) : s += lt(t.c.minute), (t.c.millisecond !== 0 || t.c.second !== 0 || !i) && (s += lt(t.c.second), (t.c.millisecond !== 0 || !a) && (s += ".", s += lt(t.c.millisecond, 3))), n && (t.isOffsetFixed && t.offset === 0 && !o ? s += "Z" : t.o < 0 ? (s += "-", s += lt(Math.trunc(-t.o / 60)), s += ":", s += lt(Math.trunc(-t.o % 60))) : (s += "+", s += lt(Math.trunc(t.o / 60)), s += ":", s += lt(Math.trunc(t.o % 60)))), o && (s += "[" + t.zone.ianaName + "]"), s;
}
const kg = {
  month: 1,
  day: 1,
  hour: 0,
  minute: 0,
  second: 0,
  millisecond: 0
}, wv = {
  weekNumber: 1,
  weekday: 1,
  hour: 0,
  minute: 0,
  second: 0,
  millisecond: 0
}, kv = {
  ordinal: 1,
  hour: 0,
  minute: 0,
  second: 0,
  millisecond: 0
}, Ig = ["year", "month", "day", "hour", "minute", "second", "millisecond"], Iv = [
  "weekYear",
  "weekNumber",
  "weekday",
  "hour",
  "minute",
  "second",
  "millisecond"
], Ov = ["year", "ordinal", "hour", "minute", "second", "millisecond"];
function Bv(t) {
  const e = {
    year: "year",
    years: "year",
    month: "month",
    months: "month",
    day: "day",
    days: "day",
    hour: "hour",
    hours: "hour",
    minute: "minute",
    minutes: "minute",
    quarter: "quarter",
    quarters: "quarter",
    second: "second",
    seconds: "second",
    millisecond: "millisecond",
    milliseconds: "millisecond",
    weekday: "weekday",
    weekdays: "weekday",
    weeknumber: "weekNumber",
    weeksnumber: "weekNumber",
    weeknumbers: "weekNumber",
    weekyear: "weekYear",
    weekyears: "weekYear",
    ordinal: "ordinal"
  }[t.toLowerCase()];
  if (!e) throw new Om(t);
  return e;
}
function wu(t) {
  switch (t.toLowerCase()) {
    case "localweekday":
    case "localweekdays":
      return "localWeekday";
    case "localweeknumber":
    case "localweeknumbers":
      return "localWeekNumber";
    case "localweekyear":
    case "localweekyears":
      return "localWeekYear";
    default:
      return Bv(t);
  }
}
function Dv(t) {
  return Es[t] || (Vs === void 0 && (Vs = Je.now()), Es[t] = t.offset(Vs)), Es[t];
}
function ku(t, e) {
  const i = ka(e.zone, Je.defaultZone);
  if (!i.isValid)
    return K.invalid(wo(i));
  const a = ke.fromObject(e);
  let n, o;
  if (ae(t.year))
    n = Je.now();
  else {
    for (const l of Ig)
      ae(t[l]) && (t[l] = kg[l]);
    const s = eg(t) || tg(t);
    if (s)
      return K.invalid(s);
    const r = Dv(i);
    [n, o] = Rs(t, r, i);
  }
  return new K({ ts: n, zone: i, loc: a, o });
}
function Iu(t, e, i) {
  const a = ae(i.round) ? !0 : i.round, n = (s, r) => (s = Mc(s, a || i.calendary ? 0 : 2, !0), e.loc.clone(i).relFormatter(i).format(s, r)), o = (s) => i.calendary ? e.hasSame(t, s) ? 0 : e.startOf(s).diff(t.startOf(s), s).get(s) : e.diff(t, s).get(s);
  if (i.unit)
    return n(o(i.unit), i.unit);
  for (const s of i.units) {
    const r = o(s);
    if (Math.abs(r) >= 1)
      return n(r, s);
  }
  return n(t > e ? -0 : 0, i.units[i.units.length - 1]);
}
function Ou(t) {
  let e = {}, i;
  return t.length > 0 && typeof t[t.length - 1] == "object" ? (e = t[t.length - 1], i = Array.from(t).slice(0, t.length - 1)) : i = Array.from(t), [e, i];
}
let Vs, Es = {};
class K {
  /**
   * @access private
   */
  constructor(e) {
    const i = e.zone || Je.defaultZone;
    let a = e.invalid || (Number.isNaN(e.ts) ? new Ii("invalid input") : null) || (i.isValid ? null : wo(i));
    this.ts = ae(e.ts) ? Je.now() : e.ts;
    let n = null, o = null;
    if (!a)
      if (e.old && e.old.ts === this.ts && e.old.zone.equals(i))
        [n, o] = [e.old.c, e.old.o];
      else {
        const r = Da(e.o) && !e.old ? e.o : i.offset(this.ts);
        n = As(this.ts, r), a = Number.isNaN(n.year) ? new Ii("invalid input") : null, n = a ? null : n, o = a ? null : r;
      }
    this._zone = i, this.loc = e.loc || ke.create(), this.invalid = a, this.weekData = null, this.localWeekData = null, this.c = n, this.o = o, this.isLuxonDateTime = !0;
  }
  // CONSTRUCT
  /**
   * Create a DateTime for the current instant, in the system's time zone.
   *
   * Use Settings to override these default values if needed.
   * @example DateTime.now().toISO() //~> now in the ISO format
   * @return {DateTime}
   */
  static now() {
    return new K({});
  }
  /**
   * Create a local DateTime
   * @param {number} [year] - The calendar year. If omitted (as in, call `local()` with no arguments), the current time will be used
   * @param {number} [month=1] - The month, 1-indexed
   * @param {number} [day=1] - The day of the month, 1-indexed
   * @param {number} [hour=0] - The hour of the day, in 24-hour time
   * @param {number} [minute=0] - The minute of the hour, meaning a number between 0 and 59
   * @param {number} [second=0] - The second of the minute, meaning a number between 0 and 59
   * @param {number} [millisecond=0] - The millisecond of the second, meaning a number between 0 and 999
   * @example DateTime.local()                                  //~> now
   * @example DateTime.local({ zone: "America/New_York" })      //~> now, in US east coast time
   * @example DateTime.local(2017)                              //~> 2017-01-01T00:00:00
   * @example DateTime.local(2017, 3)                           //~> 2017-03-01T00:00:00
   * @example DateTime.local(2017, 3, 12, { locale: "fr" })     //~> 2017-03-12T00:00:00, with a French locale
   * @example DateTime.local(2017, 3, 12, 5)                    //~> 2017-03-12T05:00:00
   * @example DateTime.local(2017, 3, 12, 5, { zone: "utc" })   //~> 2017-03-12T05:00:00, in UTC
   * @example DateTime.local(2017, 3, 12, 5, 45)                //~> 2017-03-12T05:45:00
   * @example DateTime.local(2017, 3, 12, 5, 45, 10)            //~> 2017-03-12T05:45:10
   * @example DateTime.local(2017, 3, 12, 5, 45, 10, 765)       //~> 2017-03-12T05:45:10.765
   * @return {DateTime}
   */
  static local() {
    const [e, i] = Ou(arguments), [a, n, o, s, r, l, c] = i;
    return ku({ year: a, month: n, day: o, hour: s, minute: r, second: l, millisecond: c }, e);
  }
  /**
   * Create a DateTime in UTC
   * @param {number} [year] - The calendar year. If omitted (as in, call `utc()` with no arguments), the current time will be used
   * @param {number} [month=1] - The month, 1-indexed
   * @param {number} [day=1] - The day of the month
   * @param {number} [hour=0] - The hour of the day, in 24-hour time
   * @param {number} [minute=0] - The minute of the hour, meaning a number between 0 and 59
   * @param {number} [second=0] - The second of the minute, meaning a number between 0 and 59
   * @param {number} [millisecond=0] - The millisecond of the second, meaning a number between 0 and 999
   * @param {Object} options - configuration options for the DateTime
   * @param {string} [options.locale] - a locale to set on the resulting DateTime instance
   * @param {string} [options.outputCalendar] - the output calendar to set on the resulting DateTime instance
   * @param {string} [options.numberingSystem] - the numbering system to set on the resulting DateTime instance
   * @param {string} [options.weekSettings] - the week settings to set on the resulting DateTime instance
   * @example DateTime.utc()                                              //~> now
   * @example DateTime.utc(2017)                                          //~> 2017-01-01T00:00:00Z
   * @example DateTime.utc(2017, 3)                                       //~> 2017-03-01T00:00:00Z
   * @example DateTime.utc(2017, 3, 12)                                   //~> 2017-03-12T00:00:00Z
   * @example DateTime.utc(2017, 3, 12, 5)                                //~> 2017-03-12T05:00:00Z
   * @example DateTime.utc(2017, 3, 12, 5, 45)                            //~> 2017-03-12T05:45:00Z
   * @example DateTime.utc(2017, 3, 12, 5, 45, { locale: "fr" })          //~> 2017-03-12T05:45:00Z with a French locale
   * @example DateTime.utc(2017, 3, 12, 5, 45, 10)                        //~> 2017-03-12T05:45:10Z
   * @example DateTime.utc(2017, 3, 12, 5, 45, 10, 765, { locale: "fr" }) //~> 2017-03-12T05:45:10.765Z with a French locale
   * @return {DateTime}
   */
  static utc() {
    const [e, i] = Ou(arguments), [a, n, o, s, r, l, c] = i;
    return e.zone = Et.utcInstance, ku({ year: a, month: n, day: o, hour: s, minute: r, second: l, millisecond: c }, e);
  }
  /**
   * Create a DateTime from a JavaScript Date object. Uses the default zone.
   * @param {Date} date - a JavaScript Date object
   * @param {Object} options - configuration options for the DateTime
   * @param {string|Zone} [options.zone='local'] - the zone to place the DateTime into
   * @return {DateTime}
   */
  static fromJSDate(e, i = {}) {
    const a = rC(e) ? e.valueOf() : NaN;
    if (Number.isNaN(a))
      return K.invalid("invalid input");
    const n = ka(i.zone, Je.defaultZone);
    return n.isValid ? new K({
      ts: a,
      zone: n,
      loc: ke.fromObject(i)
    }) : K.invalid(wo(n));
  }
  /**
   * Create a DateTime from a number of milliseconds since the epoch (meaning since 1 January 1970 00:00:00 UTC). Uses the default zone.
   * @param {number} milliseconds - a number of milliseconds since 1970 UTC
   * @param {Object} options - configuration options for the DateTime
   * @param {string|Zone} [options.zone='local'] - the zone to place the DateTime into
   * @param {string} [options.locale] - a locale to set on the resulting DateTime instance
   * @param {string} options.outputCalendar - the output calendar to set on the resulting DateTime instance
   * @param {string} options.numberingSystem - the numbering system to set on the resulting DateTime instance
   * @param {string} options.weekSettings - the week settings to set on the resulting DateTime instance
   * @return {DateTime}
   */
  static fromMillis(e, i = {}) {
    if (Da(e))
      return e < -864e13 || e > Tv ? K.invalid("Timestamp out of range") : new K({
        ts: e,
        zone: ka(i.zone, Je.defaultZone),
        loc: ke.fromObject(i)
      });
    throw new It(
      `fromMillis requires a numerical input, but received a ${typeof e} with value ${e}`
    );
  }
  /**
   * Create a DateTime from a number of seconds since the epoch (meaning since 1 January 1970 00:00:00 UTC). Uses the default zone.
   * @param {number} seconds - a number of seconds since 1970 UTC
   * @param {Object} options - configuration options for the DateTime
   * @param {string|Zone} [options.zone='local'] - the zone to place the DateTime into
   * @param {string} [options.locale] - a locale to set on the resulting DateTime instance
   * @param {string} options.outputCalendar - the output calendar to set on the resulting DateTime instance
   * @param {string} options.numberingSystem - the numbering system to set on the resulting DateTime instance
   * @param {string} options.weekSettings - the week settings to set on the resulting DateTime instance
   * @return {DateTime}
   */
  static fromSeconds(e, i = {}) {
    if (Da(e))
      return new K({
        ts: e * 1e3,
        zone: ka(i.zone, Je.defaultZone),
        loc: ke.fromObject(i)
      });
    throw new It("fromSeconds requires a numerical input");
  }
  /**
   * Create a DateTime from a JavaScript object with keys like 'year' and 'hour' with reasonable defaults.
   * @param {Object} obj - the object to create the DateTime from
   * @param {number} obj.year - a year, such as 1987
   * @param {number} obj.month - a month, 1-12
   * @param {number} obj.day - a day of the month, 1-31, depending on the month
   * @param {number} obj.ordinal - day of the year, 1-365 or 366
   * @param {number} obj.weekYear - an ISO week year
   * @param {number} obj.weekNumber - an ISO week number, between 1 and 52 or 53, depending on the year
   * @param {number} obj.weekday - an ISO weekday, 1-7, where 1 is Monday and 7 is Sunday
   * @param {number} obj.localWeekYear - a week year, according to the locale
   * @param {number} obj.localWeekNumber - a week number, between 1 and 52 or 53, depending on the year, according to the locale
   * @param {number} obj.localWeekday - a weekday, 1-7, where 1 is the first and 7 is the last day of the week, according to the locale
   * @param {number} obj.hour - hour of the day, 0-23
   * @param {number} obj.minute - minute of the hour, 0-59
   * @param {number} obj.second - second of the minute, 0-59
   * @param {number} obj.millisecond - millisecond of the second, 0-999
   * @param {Object} opts - options for creating this DateTime
   * @param {string|Zone} [opts.zone='local'] - interpret the numbers in the context of a particular zone. Can take any value taken as the first argument to setZone()
   * @param {string} [opts.locale='system\'s locale'] - a locale to set on the resulting DateTime instance
   * @param {string} opts.outputCalendar - the output calendar to set on the resulting DateTime instance
   * @param {string} opts.numberingSystem - the numbering system to set on the resulting DateTime instance
   * @param {string} opts.weekSettings - the week settings to set on the resulting DateTime instance
   * @example DateTime.fromObject({ year: 1982, month: 5, day: 25}).toISODate() //=> '1982-05-25'
   * @example DateTime.fromObject({ year: 1982 }).toISODate() //=> '1982-01-01'
   * @example DateTime.fromObject({ hour: 10, minute: 26, second: 6 }) //~> today at 10:26:06
   * @example DateTime.fromObject({ hour: 10, minute: 26, second: 6 }, { zone: 'utc' }),
   * @example DateTime.fromObject({ hour: 10, minute: 26, second: 6 }, { zone: 'local' })
   * @example DateTime.fromObject({ hour: 10, minute: 26, second: 6 }, { zone: 'America/New_York' })
   * @example DateTime.fromObject({ weekYear: 2016, weekNumber: 2, weekday: 3 }).toISODate() //=> '2016-01-13'
   * @example DateTime.fromObject({ localWeekYear: 2022, localWeekNumber: 1, localWeekday: 1 }, { locale: "en-US" }).toISODate() //=> '2021-12-26'
   * @return {DateTime}
   */
  static fromObject(e, i = {}) {
    e = e || {};
    const a = ka(i.zone, Je.defaultZone);
    if (!a.isValid)
      return K.invalid(wo(a));
    const n = ke.fromObject(i), o = ir(e, wu), { minDaysInFirstWeek: s, startOfWeek: r } = hu(o, n), l = Je.now(), c = ae(i.specificOffset) ? a.offset(l) : i.specificOffset, d = !ae(o.ordinal), u = !ae(o.year), f = !ae(o.month) || !ae(o.day), m = u || f, g = o.weekYear || o.weekNumber;
    if ((m || d) && g)
      throw new Dn(
        "Can't mix weekYear/weekNumber units with year/month/day or ordinals"
      );
    if (f && d)
      throw new Dn("Can't mix ordinal dates with month/day");
    const y = g || o.weekday && !m;
    let p, S, x = As(l, c);
    y ? (p = Iv, S = wv, x = er(x, s, r)) : d ? (p = Ov, S = kv, x = yl(x)) : (p = Ig, S = kg);
    let C = !1;
    for (const N of p) {
      const M = o[N];
      ae(M) ? C ? o[N] = S[N] : o[N] = x[N] : C = !0;
    }
    const F = y ? nC(o, s, r) : d ? oC(o) : eg(o), v = F || tg(o);
    if (v)
      return K.invalid(v);
    const A = y ? mu(o, s, r) : d ? gu(o) : o, [w, O] = Rs(A, c, a), I = new K({
      ts: w,
      zone: a,
      o: O,
      loc: n
    });
    return o.weekday && m && e.weekday !== I.weekday ? K.invalid(
      "mismatched weekday",
      `you can't specify both a weekday of ${o.weekday} and a date of ${I.toISO()}`
    ) : I.isValid ? I : K.invalid(I.invalid);
  }
  /**
   * Create a DateTime from an ISO 8601 string
   * @param {string} text - the ISO string
   * @param {Object} opts - options to affect the creation
   * @param {string|Zone} [opts.zone='local'] - use this zone if no offset is specified in the input string itself. Will also convert the time to this zone
   * @param {boolean} [opts.setZone=false] - override the zone with a fixed-offset zone specified in the string itself, if it specifies one
   * @param {string} [opts.locale='system's locale'] - a locale to set on the resulting DateTime instance
   * @param {string} [opts.outputCalendar] - the output calendar to set on the resulting DateTime instance
   * @param {string} [opts.numberingSystem] - the numbering system to set on the resulting DateTime instance
   * @param {string} [opts.weekSettings] - the week settings to set on the resulting DateTime instance
   * @example DateTime.fromISO('2016-05-25T09:08:34.123')
   * @example DateTime.fromISO('2016-05-25T09:08:34.123+06:00')
   * @example DateTime.fromISO('2016-05-25T09:08:34.123+06:00', {setZone: true})
   * @example DateTime.fromISO('2016-05-25T09:08:34.123', {zone: 'utc'})
   * @example DateTime.fromISO('2016-W05-4')
   * @return {DateTime}
   */
  static fromISO(e, i = {}) {
    const [a, n] = ZC(e);
    return In(a, n, i, "ISO 8601", e);
  }
  /**
   * Create a DateTime from an RFC 2822 string
   * @param {string} text - the RFC 2822 string
   * @param {Object} opts - options to affect the creation
   * @param {string|Zone} [opts.zone='local'] - convert the time to this zone. Since the offset is always specified in the string itself, this has no effect on the interpretation of string, merely the zone the resulting DateTime is expressed in.
   * @param {boolean} [opts.setZone=false] - override the zone with a fixed-offset zone specified in the string itself, if it specifies one
   * @param {string} [opts.locale='system's locale'] - a locale to set on the resulting DateTime instance
   * @param {string} opts.outputCalendar - the output calendar to set on the resulting DateTime instance
   * @param {string} opts.numberingSystem - the numbering system to set on the resulting DateTime instance
   * @param {string} opts.weekSettings - the week settings to set on the resulting DateTime instance
   * @example DateTime.fromRFC2822('25 Nov 2016 13:23:12 GMT')
   * @example DateTime.fromRFC2822('Fri, 25 Nov 2016 13:23:12 +0600')
   * @example DateTime.fromRFC2822('25 Nov 2016 13:23 Z')
   * @return {DateTime}
   */
  static fromRFC2822(e, i = {}) {
    const [a, n] = QC(e);
    return In(a, n, i, "RFC 2822", e);
  }
  /**
   * Create a DateTime from an HTTP header date
   * @see https://www.w3.org/Protocols/rfc2616/rfc2616-sec3.html#sec3.3.1
   * @param {string} text - the HTTP header date
   * @param {Object} opts - options to affect the creation
   * @param {string|Zone} [opts.zone='local'] - convert the time to this zone. Since HTTP dates are always in UTC, this has no effect on the interpretation of string, merely the zone the resulting DateTime is expressed in.
   * @param {boolean} [opts.setZone=false] - override the zone with the fixed-offset zone specified in the string. For HTTP dates, this is always UTC, so this option is equivalent to setting the `zone` option to 'utc', but this option is included for consistency with similar methods.
   * @param {string} [opts.locale='system's locale'] - a locale to set on the resulting DateTime instance
   * @param {string} opts.outputCalendar - the output calendar to set on the resulting DateTime instance
   * @param {string} opts.numberingSystem - the numbering system to set on the resulting DateTime instance
   * @param {string} opts.weekSettings - the week settings to set on the resulting DateTime instance
   * @example DateTime.fromHTTP('Sun, 06 Nov 1994 08:49:37 GMT')
   * @example DateTime.fromHTTP('Sunday, 06-Nov-94 08:49:37 GMT')
   * @example DateTime.fromHTTP('Sun Nov  6 08:49:37 1994')
   * @return {DateTime}
   */
  static fromHTTP(e, i = {}) {
    const [a, n] = KC(e);
    return In(a, n, i, "HTTP", i);
  }
  /**
   * Create a DateTime from an input string and format string.
   * Defaults to en-US if no locale has been specified, regardless of the system's locale. For a table of tokens and their interpretations, see [here](https://moment.github.io/luxon/#/parsing?id=table-of-tokens).
   * @param {string} text - the string to parse
   * @param {string} fmt - the format the string is expected to be in (see the link below for the formats)
   * @param {Object} opts - options to affect the creation
   * @param {string|Zone} [opts.zone='local'] - use this zone if no offset is specified in the input string itself. Will also convert the DateTime to this zone
   * @param {boolean} [opts.setZone=false] - override the zone with a zone specified in the string itself, if it specifies one
   * @param {string} [opts.locale='en-US'] - a locale string to use when parsing. Will also set the DateTime to this locale
   * @param {string} opts.numberingSystem - the numbering system to use when parsing. Will also set the resulting DateTime to this numbering system
   * @param {string} opts.weekSettings - the week settings to set on the resulting DateTime instance
   * @param {string} opts.outputCalendar - the output calendar to set on the resulting DateTime instance
   * @return {DateTime}
   */
  static fromFormat(e, i, a = {}) {
    if (ae(e) || ae(i))
      throw new It("fromFormat requires an input string and a format");
    const { locale: n = null, numberingSystem: o = null } = a, s = ke.fromOpts({
      locale: n,
      numberingSystem: o,
      defaultToEN: !0
    }), [r, l, c, d] = Av(s, e, i);
    return d ? K.invalid(d) : In(r, l, a, `format ${i}`, e, c);
  }
  /**
   * @deprecated use fromFormat instead
   */
  static fromString(e, i, a = {}) {
    return K.fromFormat(e, i, a);
  }
  /**
   * Create a DateTime from a SQL date, time, or datetime
   * Defaults to en-US if no locale has been specified, regardless of the system's locale
   * @param {string} text - the string to parse
   * @param {Object} opts - options to affect the creation
   * @param {string|Zone} [opts.zone='local'] - use this zone if no offset is specified in the input string itself. Will also convert the DateTime to this zone
   * @param {boolean} [opts.setZone=false] - override the zone with a zone specified in the string itself, if it specifies one
   * @param {string} [opts.locale='en-US'] - a locale string to use when parsing. Will also set the DateTime to this locale
   * @param {string} opts.numberingSystem - the numbering system to use when parsing. Will also set the resulting DateTime to this numbering system
   * @param {string} opts.weekSettings - the week settings to set on the resulting DateTime instance
   * @param {string} opts.outputCalendar - the output calendar to set on the resulting DateTime instance
   * @example DateTime.fromSQL('2017-05-15')
   * @example DateTime.fromSQL('2017-05-15 09:12:34')
   * @example DateTime.fromSQL('2017-05-15 09:12:34.342')
   * @example DateTime.fromSQL('2017-05-15 09:12:34.342+06:00')
   * @example DateTime.fromSQL('2017-05-15 09:12:34.342 America/Los_Angeles')
   * @example DateTime.fromSQL('2017-05-15 09:12:34.342 America/Los_Angeles', { setZone: true })
   * @example DateTime.fromSQL('2017-05-15 09:12:34.342', { zone: 'America/Los_Angeles' })
   * @example DateTime.fromSQL('09:12:34.342')
   * @return {DateTime}
   */
  static fromSQL(e, i = {}) {
    const [a, n] = ov(e);
    return In(a, n, i, "SQL", e);
  }
  /**
   * Create an invalid DateTime.
   * @param {string} reason - simple string of why this DateTime is invalid. Should not contain parameters or anything else data-dependent.
   * @param {string} [explanation=null] - longer explanation, may include parameters and other useful debugging information
   * @return {DateTime}
   */
  static invalid(e, i = null) {
    if (!e)
      throw new It("need to specify a reason the DateTime is invalid");
    const a = e instanceof Ii ? e : new Ii(e, i);
    if (Je.throwOnInvalid)
      throw new Bx(a);
    return new K({ invalid: a });
  }
  /**
   * Check if an object is an instance of DateTime. Works across context boundaries
   * @param {object} o
   * @return {boolean}
   */
  static isDateTime(e) {
    return e && e.isLuxonDateTime || !1;
  }
  /**
   * Produce the format string for a set of options
   * @param formatOpts
   * @param localeOpts
   * @returns {string}
   */
  static parseFormatForOpts(e, i = {}) {
    const a = Tg(e, ke.fromObject(i));
    return a ? a.map((n) => n ? n.val : null).join("") : null;
  }
  /**
   * Produce the the fully expanded format token for the locale
   * Does NOT quote characters, so quoted tokens will not round trip correctly
   * @param fmt
   * @param localeOpts
   * @returns {string}
   */
  static expandFormat(e, i = {}) {
    return Fg(Bt.parseFormat(e), ke.fromObject(i)).map((n) => n.val).join("");
  }
  static resetCache() {
    Vs = void 0, Es = {};
  }
  // INFO
  /**
   * Get the value of unit.
   * @param {string} unit - a unit such as 'minute' or 'day'
   * @example DateTime.local(2017, 7, 4).get('month'); //=> 7
   * @example DateTime.local(2017, 7, 4).get('day'); //=> 4
   * @return {number}
   */
  get(e) {
    return this[e];
  }
  /**
   * Returns whether the DateTime is valid. Invalid DateTimes occur when:
   * * The DateTime was created from invalid calendar information, such as the 13th month or February 30
   * * The DateTime was created by an operation on another invalid date
   * @type {boolean}
   */
  get isValid() {
    return this.invalid === null;
  }
  /**
   * Returns an error code if this DateTime is invalid, or null if the DateTime is valid
   * @type {string}
   */
  get invalidReason() {
    return this.invalid ? this.invalid.reason : null;
  }
  /**
   * Returns an explanation of why this DateTime became invalid, or null if the DateTime is valid
   * @type {string}
   */
  get invalidExplanation() {
    return this.invalid ? this.invalid.explanation : null;
  }
  /**
   * Get the locale of a DateTime, such 'en-GB'. The locale is used when formatting the DateTime
   *
   * @type {string}
   */
  get locale() {
    return this.isValid ? this.loc.locale : null;
  }
  /**
   * Get the numbering system of a DateTime, such 'beng'. The numbering system is used when formatting the DateTime
   *
   * @type {string}
   */
  get numberingSystem() {
    return this.isValid ? this.loc.numberingSystem : null;
  }
  /**
   * Get the output calendar of a DateTime, such 'islamic'. The output calendar is used when formatting the DateTime
   *
   * @type {string}
   */
  get outputCalendar() {
    return this.isValid ? this.loc.outputCalendar : null;
  }
  /**
   * Get the time zone associated with this DateTime.
   * @type {Zone}
   */
  get zone() {
    return this._zone;
  }
  /**
   * Get the name of the time zone.
   * @type {string}
   */
  get zoneName() {
    return this.isValid ? this.zone.name : null;
  }
  /**
   * Get the year
   * @example DateTime.local(2017, 5, 25).year //=> 2017
   * @type {number}
   */
  get year() {
    return this.isValid ? this.c.year : NaN;
  }
  /**
   * Get the quarter
   * @example DateTime.local(2017, 5, 25).quarter //=> 2
   * @type {number}
   */
  get quarter() {
    return this.isValid ? Math.ceil(this.c.month / 3) : NaN;
  }
  /**
   * Get the month (1-12).
   * @example DateTime.local(2017, 5, 25).month //=> 5
   * @type {number}
   */
  get month() {
    return this.isValid ? this.c.month : NaN;
  }
  /**
   * Get the day of the month (1-30ish).
   * @example DateTime.local(2017, 5, 25).day //=> 25
   * @type {number}
   */
  get day() {
    return this.isValid ? this.c.day : NaN;
  }
  /**
   * Get the hour of the day (0-23).
   * @example DateTime.local(2017, 5, 25, 9).hour //=> 9
   * @type {number}
   */
  get hour() {
    return this.isValid ? this.c.hour : NaN;
  }
  /**
   * Get the minute of the hour (0-59).
   * @example DateTime.local(2017, 5, 25, 9, 30).minute //=> 30
   * @type {number}
   */
  get minute() {
    return this.isValid ? this.c.minute : NaN;
  }
  /**
   * Get the second of the minute (0-59).
   * @example DateTime.local(2017, 5, 25, 9, 30, 52).second //=> 52
   * @type {number}
   */
  get second() {
    return this.isValid ? this.c.second : NaN;
  }
  /**
   * Get the millisecond of the second (0-999).
   * @example DateTime.local(2017, 5, 25, 9, 30, 52, 654).millisecond //=> 654
   * @type {number}
   */
  get millisecond() {
    return this.isValid ? this.c.millisecond : NaN;
  }
  /**
   * Get the week year
   * @see https://en.wikipedia.org/wiki/ISO_week_date
   * @example DateTime.local(2014, 12, 31).weekYear //=> 2015
   * @type {number}
   */
  get weekYear() {
    return this.isValid ? xl(this).weekYear : NaN;
  }
  /**
   * Get the week number of the week year (1-52ish).
   * @see https://en.wikipedia.org/wiki/ISO_week_date
   * @example DateTime.local(2017, 5, 25).weekNumber //=> 21
   * @type {number}
   */
  get weekNumber() {
    return this.isValid ? xl(this).weekNumber : NaN;
  }
  /**
   * Get the day of the week.
   * 1 is Monday and 7 is Sunday
   * @see https://en.wikipedia.org/wiki/ISO_week_date
   * @example DateTime.local(2014, 11, 31).weekday //=> 4
   * @type {number}
   */
  get weekday() {
    return this.isValid ? xl(this).weekday : NaN;
  }
  /**
   * Returns true if this date is on a weekend according to the locale, false otherwise
   * @returns {boolean}
   */
  get isWeekend() {
    return this.isValid && this.loc.getWeekendDays().includes(this.weekday);
  }
  /**
   * Get the day of the week according to the locale.
   * 1 is the first day of the week and 7 is the last day of the week.
   * If the locale assigns Sunday as the first day of the week, then a date which is a Sunday will return 1,
   * @returns {number}
   */
  get localWeekday() {
    return this.isValid ? Cl(this).weekday : NaN;
  }
  /**
   * Get the week number of the week year according to the locale. Different locales assign week numbers differently,
   * because the week can start on different days of the week (see localWeekday) and because a different number of days
   * is required for a week to count as the first week of a year.
   * @returns {number}
   */
  get localWeekNumber() {
    return this.isValid ? Cl(this).weekNumber : NaN;
  }
  /**
   * Get the week year according to the locale. Different locales assign week numbers (and therefor week years)
   * differently, see localWeekNumber.
   * @returns {number}
   */
  get localWeekYear() {
    return this.isValid ? Cl(this).weekYear : NaN;
  }
  /**
   * Get the ordinal (meaning the day of the year)
   * @example DateTime.local(2017, 5, 25).ordinal //=> 145
   * @type {number|DateTime}
   */
  get ordinal() {
    return this.isValid ? yl(this.c).ordinal : NaN;
  }
  /**
   * Get the human readable short month name, such as 'Oct'.
   * Defaults to the system's locale if no locale has been specified
   * @example DateTime.local(2017, 10, 30).monthShort //=> Oct
   * @type {string}
   */
  get monthShort() {
    return this.isValid ? Fs.months("short", { locObj: this.loc })[this.month - 1] : null;
  }
  /**
   * Get the human readable long month name, such as 'October'.
   * Defaults to the system's locale if no locale has been specified
   * @example DateTime.local(2017, 10, 30).monthLong //=> October
   * @type {string}
   */
  get monthLong() {
    return this.isValid ? Fs.months("long", { locObj: this.loc })[this.month - 1] : null;
  }
  /**
   * Get the human readable short weekday, such as 'Mon'.
   * Defaults to the system's locale if no locale has been specified
   * @example DateTime.local(2017, 10, 30).weekdayShort //=> Mon
   * @type {string}
   */
  get weekdayShort() {
    return this.isValid ? Fs.weekdays("short", { locObj: this.loc })[this.weekday - 1] : null;
  }
  /**
   * Get the human readable long weekday, such as 'Monday'.
   * Defaults to the system's locale if no locale has been specified
   * @example DateTime.local(2017, 10, 30).weekdayLong //=> Monday
   * @type {string}
   */
  get weekdayLong() {
    return this.isValid ? Fs.weekdays("long", { locObj: this.loc })[this.weekday - 1] : null;
  }
  /**
   * Get the UTC offset of this DateTime in minutes
   * @example DateTime.now().offset //=> -240
   * @example DateTime.utc().offset //=> 0
   * @type {number}
   */
  get offset() {
    return this.isValid ? +this.o : NaN;
  }
  /**
   * Get the short human name for the zone's current offset, for example "EST" or "EDT".
   * Defaults to the system's locale if no locale has been specified
   * @type {string}
   */
  get offsetNameShort() {
    return this.isValid ? this.zone.offsetName(this.ts, {
      format: "short",
      locale: this.locale
    }) : null;
  }
  /**
   * Get the long human name for the zone's current offset, for example "Eastern Standard Time" or "Eastern Daylight Time".
   * Defaults to the system's locale if no locale has been specified
   * @type {string}
   */
  get offsetNameLong() {
    return this.isValid ? this.zone.offsetName(this.ts, {
      format: "long",
      locale: this.locale
    }) : null;
  }
  /**
   * Get whether this zone's offset ever changes, as in a DST.
   * @type {boolean}
   */
  get isOffsetFixed() {
    return this.isValid ? this.zone.isUniversal : null;
  }
  /**
   * Get whether the DateTime is in a DST.
   * @type {boolean}
   */
  get isInDST() {
    return this.isOffsetFixed ? !1 : this.offset > this.set({ month: 1, day: 1 }).offset || this.offset > this.set({ month: 5 }).offset;
  }
  /**
   * Get those DateTimes which have the same local time as this DateTime, but a different offset from UTC
   * in this DateTime's zone. During DST changes local time can be ambiguous, for example
   * `2023-10-29T02:30:00` in `Europe/Berlin` can have offset `+01:00` or `+02:00`.
   * This method will return both possible DateTimes if this DateTime's local time is ambiguous.
   * @returns {DateTime[]}
   */
  getPossibleOffsets() {
    if (!this.isValid || this.isOffsetFixed)
      return [this];
    const e = 864e5, i = 6e4, a = Nr(this.c), n = this.zone.offset(a - e), o = this.zone.offset(a + e), s = this.zone.offset(a - n * i), r = this.zone.offset(a - o * i);
    if (s === r)
      return [this];
    const l = a - s * i, c = a - r * i, d = As(l, s), u = As(c, r);
    return d.hour === u.hour && d.minute === u.minute && d.second === u.second && d.millisecond === u.millisecond ? [Ja(this, { ts: l }), Ja(this, { ts: c })] : [this];
  }
  /**
   * Returns true if this DateTime is in a leap year, false otherwise
   * @example DateTime.local(2016).isInLeapYear //=> true
   * @example DateTime.local(2013).isInLeapYear //=> false
   * @type {boolean}
   */
  get isInLeapYear() {
    return ts(this.year);
  }
  /**
   * Returns the number of days in this DateTime's month
   * @example DateTime.local(2016, 2).daysInMonth //=> 29
   * @example DateTime.local(2016, 3).daysInMonth //=> 31
   * @type {number}
   */
  get daysInMonth() {
    return tr(this.year, this.month);
  }
  /**
   * Returns the number of days in this DateTime's year
   * @example DateTime.local(2016).daysInYear //=> 366
   * @example DateTime.local(2013).daysInYear //=> 365
   * @type {number}
   */
  get daysInYear() {
    return this.isValid ? Pn(this.year) : NaN;
  }
  /**
   * Returns the number of weeks in this DateTime's year
   * @see https://en.wikipedia.org/wiki/ISO_week_date
   * @example DateTime.local(2004).weeksInWeekYear //=> 53
   * @example DateTime.local(2013).weeksInWeekYear //=> 52
   * @type {number}
   */
  get weeksInWeekYear() {
    return this.isValid ? Eo(this.weekYear) : NaN;
  }
  /**
   * Returns the number of weeks in this DateTime's local week year
   * @example DateTime.local(2020, 6, {locale: 'en-US'}).weeksInLocalWeekYear //=> 52
   * @example DateTime.local(2020, 6, {locale: 'de-DE'}).weeksInLocalWeekYear //=> 53
   * @type {number}
   */
  get weeksInLocalWeekYear() {
    return this.isValid ? Eo(
      this.localWeekYear,
      this.loc.getMinDaysInFirstWeek(),
      this.loc.getStartOfWeek()
    ) : NaN;
  }
  /**
   * Returns the resolved Intl options for this DateTime.
   * This is useful in understanding the behavior of formatting methods
   * @param {Object} opts - the same options as toLocaleString
   * @return {Object}
   */
  resolvedLocaleOptions(e = {}) {
    const { locale: i, numberingSystem: a, calendar: n } = Bt.create(
      this.loc.clone(e),
      e
    ).resolvedOptions(this);
    return { locale: i, numberingSystem: a, outputCalendar: n };
  }
  // TRANSFORM
  /**
   * "Set" the DateTime's zone to UTC. Returns a newly-constructed DateTime.
   *
   * Equivalent to {@link DateTime#setZone}('utc')
   * @param {number} [offset=0] - optionally, an offset from UTC in minutes
   * @param {Object} [opts={}] - options to pass to `setZone()`
   * @return {DateTime}
   */
  toUTC(e = 0, i = {}) {
    return this.setZone(Et.instance(e), i);
  }
  /**
   * "Set" the DateTime's zone to the host's local zone. Returns a newly-constructed DateTime.
   *
   * Equivalent to `setZone('local')`
   * @return {DateTime}
   */
  toLocal() {
    return this.setZone(Je.defaultZone);
  }
  /**
   * "Set" the DateTime's zone to specified zone. Returns a newly-constructed DateTime.
   *
   * By default, the setter keeps the underlying time the same (as in, the same timestamp), but the new instance will report different local times and consider DSTs when making computations, as with {@link DateTime#plus}. You may wish to use {@link DateTime#toLocal} and {@link DateTime#toUTC} which provide simple convenience wrappers for commonly used zones.
   * @param {string|Zone} [zone='local'] - a zone identifier. As a string, that can be any IANA zone supported by the host environment, or a fixed-offset name of the form 'UTC+3', or the strings 'local' or 'utc'. You may also supply an instance of a {@link DateTime#Zone} class.
   * @param {Object} opts - options
   * @param {boolean} [opts.keepLocalTime=false] - If true, adjust the underlying time so that the local time stays the same, but in the target zone. You should rarely need this.
   * @return {DateTime}
   */
  setZone(e, { keepLocalTime: i = !1, keepCalendarTime: a = !1 } = {}) {
    if (e = ka(e, Je.defaultZone), e.equals(this.zone))
      return this;
    if (e.isValid) {
      let n = this.ts;
      if (i || a) {
        const o = e.offset(this.ts), s = this.toObject();
        [n] = Rs(s, o, e);
      }
      return Ja(this, { ts: n, zone: e });
    } else
      return K.invalid(wo(e));
  }
  /**
   * "Set" the locale, numberingSystem, or outputCalendar. Returns a newly-constructed DateTime.
   * @param {Object} properties - the properties to set
   * @example DateTime.local(2017, 5, 25).reconfigure({ locale: 'en-GB' })
   * @return {DateTime}
   */
  reconfigure({ locale: e, numberingSystem: i, outputCalendar: a } = {}) {
    const n = this.loc.clone({ locale: e, numberingSystem: i, outputCalendar: a });
    return Ja(this, { loc: n });
  }
  /**
   * "Set" the locale. Returns a newly-constructed DateTime.
   * Just a convenient alias for reconfigure({ locale })
   * @example DateTime.local(2017, 5, 25).setLocale('en-GB')
   * @return {DateTime}
   */
  setLocale(e) {
    return this.reconfigure({ locale: e });
  }
  /**
   * "Set" the values of specified units. Returns a newly-constructed DateTime.
   * You can only set units with this method; for "setting" metadata, see {@link DateTime#reconfigure} and {@link DateTime#setZone}.
   *
   * This method also supports setting locale-based week units, i.e. `localWeekday`, `localWeekNumber` and `localWeekYear`.
   * They cannot be mixed with ISO-week units like `weekday`.
   * @param {Object} values - a mapping of units to numbers
   * @example dt.set({ year: 2017 })
   * @example dt.set({ hour: 8, minute: 30 })
   * @example dt.set({ weekday: 5 })
   * @example dt.set({ year: 2005, ordinal: 234 })
   * @return {DateTime}
   */
  set(e) {
    if (!this.isValid) return this;
    const i = ir(e, wu), { minDaysInFirstWeek: a, startOfWeek: n } = hu(i, this.loc), o = !ae(i.weekYear) || !ae(i.weekNumber) || !ae(i.weekday), s = !ae(i.ordinal), r = !ae(i.year), l = !ae(i.month) || !ae(i.day), c = r || l, d = i.weekYear || i.weekNumber;
    if ((c || s) && d)
      throw new Dn(
        "Can't mix weekYear/weekNumber units with year/month/day or ordinals"
      );
    if (l && s)
      throw new Dn("Can't mix ordinal dates with month/day");
    let u;
    o ? u = mu(
      { ...er(this.c, a, n), ...i },
      a,
      n
    ) : ae(i.ordinal) ? (u = { ...this.toObject(), ...i }, ae(i.day) && (u.day = Math.min(tr(u.year, u.month), u.day))) : u = gu({ ...yl(this.c), ...i });
    const [f, m] = Rs(u, this.o, this.zone);
    return Ja(this, { ts: f, o: m });
  }
  /**
   * Add a period of time to this DateTime and return the resulting DateTime
   *
   * Adding hours, minutes, seconds, or milliseconds increases the timestamp by the right number of milliseconds. Adding days, months, or years shifts the calendar, accounting for DSTs and leap years along the way. Thus, `dt.plus({ hours: 24 })` may result in a different time than `dt.plus({ days: 1 })` if there's a DST shift in between.
   * @param {Duration|Object|number} duration - The amount to add. Either a Luxon Duration, a number of milliseconds, the object argument to Duration.fromObject()
   * @example DateTime.now().plus(123) //~> in 123 milliseconds
   * @example DateTime.now().plus({ minutes: 15 }) //~> in 15 minutes
   * @example DateTime.now().plus({ days: 1 }) //~> this time tomorrow
   * @example DateTime.now().plus({ days: -1 }) //~> this time yesterday
   * @example DateTime.now().plus({ hours: 3, minutes: 13 }) //~> in 3 hr, 13 min
   * @example DateTime.now().plus(Duration.fromObject({ hours: 3, minutes: 13 })) //~> in 3 hr, 13 min
   * @return {DateTime}
   */
  plus(e) {
    if (!this.isValid) return this;
    const i = xe.fromDurationLike(e);
    return Ja(this, Au(this, i));
  }
  /**
   * Subtract a period of time to this DateTime and return the resulting DateTime
   * See {@link DateTime#plus}
   * @param {Duration|Object|number} duration - The amount to subtract. Either a Luxon Duration, a number of milliseconds, the object argument to Duration.fromObject()
   @return {DateTime}
   */
  minus(e) {
    if (!this.isValid) return this;
    const i = xe.fromDurationLike(e).negate();
    return Ja(this, Au(this, i));
  }
  /**
   * "Set" this DateTime to the beginning of a unit of time.
   * @param {string} unit - The unit to go to the beginning of. Can be 'year', 'quarter', 'month', 'week', 'day', 'hour', 'minute', 'second', or 'millisecond'.
   * @param {Object} opts - options
   * @param {boolean} [opts.useLocaleWeeks=false] - If true, use weeks based on the locale, i.e. use the locale-dependent start of the week
   * @example DateTime.local(2014, 3, 3).startOf('month').toISODate(); //=> '2014-03-01'
   * @example DateTime.local(2014, 3, 3).startOf('year').toISODate(); //=> '2014-01-01'
   * @example DateTime.local(2014, 3, 3).startOf('week').toISODate(); //=> '2014-03-03', weeks always start on Mondays
   * @example DateTime.local(2014, 3, 3, 5, 30).startOf('day').toISOTime(); //=> '00:00.000-05:00'
   * @example DateTime.local(2014, 3, 3, 5, 30).startOf('hour').toISOTime(); //=> '05:00:00.000-05:00'
   * @return {DateTime}
   */
  startOf(e, { useLocaleWeeks: i = !1 } = {}) {
    if (!this.isValid) return this;
    const a = {}, n = xe.normalizeUnit(e);
    switch (n) {
      case "years":
        a.month = 1;
      // falls through
      case "quarters":
      case "months":
        a.day = 1;
      // falls through
      case "weeks":
      case "days":
        a.hour = 0;
      // falls through
      case "hours":
        a.minute = 0;
      // falls through
      case "minutes":
        a.second = 0;
      // falls through
      case "seconds":
        a.millisecond = 0;
        break;
    }
    if (n === "weeks")
      if (i) {
        const o = this.loc.getStartOfWeek(), { weekday: s } = this;
        s < o && (a.weekNumber = this.weekNumber - 1), a.weekday = o;
      } else
        a.weekday = 1;
    if (n === "quarters") {
      const o = Math.ceil(this.month / 3);
      a.month = (o - 1) * 3 + 1;
    }
    return this.set(a);
  }
  /**
   * "Set" this DateTime to the end (meaning the last millisecond) of a unit of time
   * @param {string} unit - The unit to go to the end of. Can be 'year', 'quarter', 'month', 'week', 'day', 'hour', 'minute', 'second', or 'millisecond'.
   * @param {Object} opts - options
   * @param {boolean} [opts.useLocaleWeeks=false] - If true, use weeks based on the locale, i.e. use the locale-dependent start of the week
   * @example DateTime.local(2014, 3, 3).endOf('month').toISO(); //=> '2014-03-31T23:59:59.999-05:00'
   * @example DateTime.local(2014, 3, 3).endOf('year').toISO(); //=> '2014-12-31T23:59:59.999-05:00'
   * @example DateTime.local(2014, 3, 3).endOf('week').toISO(); // => '2014-03-09T23:59:59.999-05:00', weeks start on Mondays
   * @example DateTime.local(2014, 3, 3, 5, 30).endOf('day').toISO(); //=> '2014-03-03T23:59:59.999-05:00'
   * @example DateTime.local(2014, 3, 3, 5, 30).endOf('hour').toISO(); //=> '2014-03-03T05:59:59.999-05:00'
   * @return {DateTime}
   */
  endOf(e, i) {
    return this.isValid ? this.plus({ [e]: 1 }).startOf(e, i).minus(1) : this;
  }
  // OUTPUT
  /**
   * Returns a string representation of this DateTime formatted according to the specified format string.
   * **You may not want this.** See {@link DateTime#toLocaleString} for a more flexible formatting tool. For a table of tokens and their interpretations, see [here](https://moment.github.io/luxon/#/formatting?id=table-of-tokens).
   * Defaults to en-US if no locale has been specified, regardless of the system's locale.
   * @param {string} fmt - the format string
   * @param {Object} opts - opts to override the configuration options on this DateTime
   * @example DateTime.now().toFormat('yyyy LLL dd') //=> '2017 Apr 22'
   * @example DateTime.now().setLocale('fr').toFormat('yyyy LLL dd') //=> '2017 avr. 22'
   * @example DateTime.now().toFormat('yyyy LLL dd', { locale: "fr" }) //=> '2017 avr. 22'
   * @example DateTime.now().toFormat("HH 'hours and' mm 'minutes'") //=> '20 hours and 55 minutes'
   * @return {string}
   */
  toFormat(e, i = {}) {
    return this.isValid ? Bt.create(this.loc.redefaultToEN(i)).formatDateTimeFromString(this, e) : Sl;
  }
  /**
   * Returns a localized string representing this date. Accepts the same options as the Intl.DateTimeFormat constructor and any presets defined by Luxon, such as `DateTime.DATE_FULL` or `DateTime.TIME_SIMPLE`.
   * The exact behavior of this method is browser-specific, but in general it will return an appropriate representation
   * of the DateTime in the assigned locale.
   * Defaults to the system's locale if no locale has been specified
   * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DateTimeFormat
   * @param formatOpts {Object} - Intl.DateTimeFormat constructor options and configuration options
   * @param {Object} opts - opts to override the configuration options on this DateTime
   * @example DateTime.now().toLocaleString(); //=> 4/20/2017
   * @example DateTime.now().setLocale('en-gb').toLocaleString(); //=> '20/04/2017'
   * @example DateTime.now().toLocaleString(DateTime.DATE_FULL); //=> 'April 20, 2017'
   * @example DateTime.now().toLocaleString(DateTime.DATE_FULL, { locale: 'fr' }); //=> '28 août 2022'
   * @example DateTime.now().toLocaleString(DateTime.TIME_SIMPLE); //=> '11:32 AM'
   * @example DateTime.now().toLocaleString(DateTime.DATETIME_SHORT); //=> '4/20/2017, 11:32 AM'
   * @example DateTime.now().toLocaleString({ weekday: 'long', month: 'long', day: '2-digit' }); //=> 'Thursday, April 20'
   * @example DateTime.now().toLocaleString({ weekday: 'short', month: 'short', day: '2-digit', hour: '2-digit', minute: '2-digit' }); //=> 'Thu, Apr 20, 11:27 AM'
   * @example DateTime.now().toLocaleString({ hour: '2-digit', minute: '2-digit', hourCycle: 'h23' }); //=> '11:32'
   * @return {string}
   */
  toLocaleString(e = Js, i = {}) {
    return this.isValid ? Bt.create(this.loc.clone(i), e).formatDateTime(this) : Sl;
  }
  /**
   * Returns an array of format "parts", meaning individual tokens along with metadata. This is allows callers to post-process individual sections of the formatted output.
   * Defaults to the system's locale if no locale has been specified
   * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DateTimeFormat/formatToParts
   * @param opts {Object} - Intl.DateTimeFormat constructor options, same as `toLocaleString`.
   * @example DateTime.now().toLocaleParts(); //=> [
   *                                   //=>   { type: 'day', value: '25' },
   *                                   //=>   { type: 'literal', value: '/' },
   *                                   //=>   { type: 'month', value: '05' },
   *                                   //=>   { type: 'literal', value: '/' },
   *                                   //=>   { type: 'year', value: '1982' }
   *                                   //=> ]
   */
  toLocaleParts(e = {}) {
    return this.isValid ? Bt.create(this.loc.clone(e), e).formatDateTimeParts(this) : [];
  }
  /**
   * Returns an ISO 8601-compliant string representation of this DateTime
   * @param {Object} opts - options
   * @param {boolean} [opts.suppressMilliseconds=false] - exclude milliseconds from the format if they're 0
   * @param {boolean} [opts.suppressSeconds=false] - exclude seconds from the format if they're 0
   * @param {boolean} [opts.includeOffset=true] - include the offset, such as 'Z' or '-04:00'
   * @param {boolean} [opts.extendedZone=false] - add the time zone format extension
   * @param {string} [opts.format='extended'] - choose between the basic and extended format
   * @example DateTime.utc(1983, 5, 25).toISO() //=> '1982-05-25T00:00:00.000Z'
   * @example DateTime.now().toISO() //=> '2017-04-22T20:47:05.335-04:00'
   * @example DateTime.now().toISO({ includeOffset: false }) //=> '2017-04-22T20:47:05.335'
   * @example DateTime.now().toISO({ format: 'basic' }) //=> '20170422T204705.335-0400'
   * @return {string}
   */
  toISO({
    format: e = "extended",
    suppressSeconds: i = !1,
    suppressMilliseconds: a = !1,
    includeOffset: n = !0,
    extendedZone: o = !1
  } = {}) {
    if (!this.isValid)
      return null;
    const s = e === "extended";
    let r = vl(this, s);
    return r += "T", r += Tu(this, s, i, a, n, o), r;
  }
  /**
   * Returns an ISO 8601-compliant string representation of this DateTime's date component
   * @param {Object} opts - options
   * @param {string} [opts.format='extended'] - choose between the basic and extended format
   * @example DateTime.utc(1982, 5, 25).toISODate() //=> '1982-05-25'
   * @example DateTime.utc(1982, 5, 25).toISODate({ format: 'basic' }) //=> '19820525'
   * @return {string}
   */
  toISODate({ format: e = "extended" } = {}) {
    return this.isValid ? vl(this, e === "extended") : null;
  }
  /**
   * Returns an ISO 8601-compliant string representation of this DateTime's week date
   * @example DateTime.utc(1982, 5, 25).toISOWeekDate() //=> '1982-W21-2'
   * @return {string}
   */
  toISOWeekDate() {
    return Ts(this, "kkkk-'W'WW-c");
  }
  /**
   * Returns an ISO 8601-compliant string representation of this DateTime's time component
   * @param {Object} opts - options
   * @param {boolean} [opts.suppressMilliseconds=false] - exclude milliseconds from the format if they're 0
   * @param {boolean} [opts.suppressSeconds=false] - exclude seconds from the format if they're 0
   * @param {boolean} [opts.includeOffset=true] - include the offset, such as 'Z' or '-04:00'
   * @param {boolean} [opts.extendedZone=true] - add the time zone format extension
   * @param {boolean} [opts.includePrefix=false] - include the `T` prefix
   * @param {string} [opts.format='extended'] - choose between the basic and extended format
   * @example DateTime.utc().set({ hour: 7, minute: 34 }).toISOTime() //=> '07:34:19.361Z'
   * @example DateTime.utc().set({ hour: 7, minute: 34, seconds: 0, milliseconds: 0 }).toISOTime({ suppressSeconds: true }) //=> '07:34Z'
   * @example DateTime.utc().set({ hour: 7, minute: 34 }).toISOTime({ format: 'basic' }) //=> '073419.361Z'
   * @example DateTime.utc().set({ hour: 7, minute: 34 }).toISOTime({ includePrefix: true }) //=> 'T07:34:19.361Z'
   * @return {string}
   */
  toISOTime({
    suppressMilliseconds: e = !1,
    suppressSeconds: i = !1,
    includeOffset: a = !0,
    includePrefix: n = !1,
    extendedZone: o = !1,
    format: s = "extended"
  } = {}) {
    return this.isValid ? (n ? "T" : "") + Tu(
      this,
      s === "extended",
      i,
      e,
      a,
      o
    ) : null;
  }
  /**
   * Returns an RFC 2822-compatible string representation of this DateTime
   * @example DateTime.utc(2014, 7, 13).toRFC2822() //=> 'Sun, 13 Jul 2014 00:00:00 +0000'
   * @example DateTime.local(2014, 7, 13).toRFC2822() //=> 'Sun, 13 Jul 2014 00:00:00 -0400'
   * @return {string}
   */
  toRFC2822() {
    return Ts(this, "EEE, dd LLL yyyy HH:mm:ss ZZZ", !1);
  }
  /**
   * Returns a string representation of this DateTime appropriate for use in HTTP headers. The output is always expressed in GMT.
   * Specifically, the string conforms to RFC 1123.
   * @see https://www.w3.org/Protocols/rfc2616/rfc2616-sec3.html#sec3.3.1
   * @example DateTime.utc(2014, 7, 13).toHTTP() //=> 'Sun, 13 Jul 2014 00:00:00 GMT'
   * @example DateTime.utc(2014, 7, 13, 19).toHTTP() //=> 'Sun, 13 Jul 2014 19:00:00 GMT'
   * @return {string}
   */
  toHTTP() {
    return Ts(this.toUTC(), "EEE, dd LLL yyyy HH:mm:ss 'GMT'");
  }
  /**
   * Returns a string representation of this DateTime appropriate for use in SQL Date
   * @example DateTime.utc(2014, 7, 13).toSQLDate() //=> '2014-07-13'
   * @return {string}
   */
  toSQLDate() {
    return this.isValid ? vl(this, !0) : null;
  }
  /**
   * Returns a string representation of this DateTime appropriate for use in SQL Time
   * @param {Object} opts - options
   * @param {boolean} [opts.includeZone=false] - include the zone, such as 'America/New_York'. Overrides includeOffset.
   * @param {boolean} [opts.includeOffset=true] - include the offset, such as 'Z' or '-04:00'
   * @param {boolean} [opts.includeOffsetSpace=true] - include the space between the time and the offset, such as '05:15:16.345 -04:00'
   * @example DateTime.utc().toSQL() //=> '05:15:16.345'
   * @example DateTime.now().toSQL() //=> '05:15:16.345 -04:00'
   * @example DateTime.now().toSQL({ includeOffset: false }) //=> '05:15:16.345'
   * @example DateTime.now().toSQL({ includeZone: false }) //=> '05:15:16.345 America/New_York'
   * @return {string}
   */
  toSQLTime({ includeOffset: e = !0, includeZone: i = !1, includeOffsetSpace: a = !0 } = {}) {
    let n = "HH:mm:ss.SSS";
    return (i || e) && (a && (n += " "), i ? n += "z" : e && (n += "ZZ")), Ts(this, n, !0);
  }
  /**
   * Returns a string representation of this DateTime appropriate for use in SQL DateTime
   * @param {Object} opts - options
   * @param {boolean} [opts.includeZone=false] - include the zone, such as 'America/New_York'. Overrides includeOffset.
   * @param {boolean} [opts.includeOffset=true] - include the offset, such as 'Z' or '-04:00'
   * @param {boolean} [opts.includeOffsetSpace=true] - include the space between the time and the offset, such as '05:15:16.345 -04:00'
   * @example DateTime.utc(2014, 7, 13).toSQL() //=> '2014-07-13 00:00:00.000 Z'
   * @example DateTime.local(2014, 7, 13).toSQL() //=> '2014-07-13 00:00:00.000 -04:00'
   * @example DateTime.local(2014, 7, 13).toSQL({ includeOffset: false }) //=> '2014-07-13 00:00:00.000'
   * @example DateTime.local(2014, 7, 13).toSQL({ includeZone: true }) //=> '2014-07-13 00:00:00.000 America/New_York'
   * @return {string}
   */
  toSQL(e = {}) {
    return this.isValid ? `${this.toSQLDate()} ${this.toSQLTime(e)}` : null;
  }
  /**
   * Returns a string representation of this DateTime appropriate for debugging
   * @return {string}
   */
  toString() {
    return this.isValid ? this.toISO() : Sl;
  }
  /**
   * Returns a string representation of this DateTime appropriate for the REPL.
   * @return {string}
   */
  [Symbol.for("nodejs.util.inspect.custom")]() {
    return this.isValid ? `DateTime { ts: ${this.toISO()}, zone: ${this.zone.name}, locale: ${this.locale} }` : `DateTime { Invalid, reason: ${this.invalidReason} }`;
  }
  /**
   * Returns the epoch milliseconds of this DateTime. Alias of {@link DateTime#toMillis}
   * @return {number}
   */
  valueOf() {
    return this.toMillis();
  }
  /**
   * Returns the epoch milliseconds of this DateTime.
   * @return {number}
   */
  toMillis() {
    return this.isValid ? this.ts : NaN;
  }
  /**
   * Returns the epoch seconds of this DateTime.
   * @return {number}
   */
  toSeconds() {
    return this.isValid ? this.ts / 1e3 : NaN;
  }
  /**
   * Returns the epoch seconds (as a whole number) of this DateTime.
   * @return {number}
   */
  toUnixInteger() {
    return this.isValid ? Math.floor(this.ts / 1e3) : NaN;
  }
  /**
   * Returns an ISO 8601 representation of this DateTime appropriate for use in JSON.
   * @return {string}
   */
  toJSON() {
    return this.toISO();
  }
  /**
   * Returns a BSON serializable equivalent to this DateTime.
   * @return {Date}
   */
  toBSON() {
    return this.toJSDate();
  }
  /**
   * Returns a JavaScript object with this DateTime's year, month, day, and so on.
   * @param opts - options for generating the object
   * @param {boolean} [opts.includeConfig=false] - include configuration attributes in the output
   * @example DateTime.now().toObject() //=> { year: 2017, month: 4, day: 22, hour: 20, minute: 49, second: 42, millisecond: 268 }
   * @return {Object}
   */
  toObject(e = {}) {
    if (!this.isValid) return {};
    const i = { ...this.c };
    return e.includeConfig && (i.outputCalendar = this.outputCalendar, i.numberingSystem = this.loc.numberingSystem, i.locale = this.loc.locale), i;
  }
  /**
   * Returns a JavaScript Date equivalent to this DateTime.
   * @return {Date}
   */
  toJSDate() {
    return new Date(this.isValid ? this.ts : NaN);
  }
  // COMPARE
  /**
   * Return the difference between two DateTimes as a Duration.
   * @param {DateTime} otherDateTime - the DateTime to compare this one to
   * @param {string|string[]} [unit=['milliseconds']] - the unit or array of units (such as 'hours' or 'days') to include in the duration.
   * @param {Object} opts - options that affect the creation of the Duration
   * @param {string} [opts.conversionAccuracy='casual'] - the conversion system to use
   * @example
   * var i1 = DateTime.fromISO('1982-05-25T09:45'),
   *     i2 = DateTime.fromISO('1983-10-14T10:30');
   * i2.diff(i1).toObject() //=> { milliseconds: 43807500000 }
   * i2.diff(i1, 'hours').toObject() //=> { hours: 12168.75 }
   * i2.diff(i1, ['months', 'days']).toObject() //=> { months: 16, days: 19.03125 }
   * i2.diff(i1, ['months', 'days', 'hours']).toObject() //=> { months: 16, days: 19, hours: 0.75 }
   * @return {Duration}
   */
  diff(e, i = "milliseconds", a = {}) {
    if (!this.isValid || !e.isValid)
      return xe.invalid("created by diffing an invalid DateTime");
    const n = { locale: this.locale, numberingSystem: this.numberingSystem, ...a }, o = lC(i).map(xe.normalizeUnit), s = e.valueOf() > this.valueOf(), r = s ? this : e, l = s ? e : this, c = fv(r, l, o, n);
    return s ? c.negate() : c;
  }
  /**
   * Return the difference between this DateTime and right now.
   * See {@link DateTime#diff}
   * @param {string|string[]} [unit=['milliseconds']] - the unit or units units (such as 'hours' or 'days') to include in the duration
   * @param {Object} opts - options that affect the creation of the Duration
   * @param {string} [opts.conversionAccuracy='casual'] - the conversion system to use
   * @return {Duration}
   */
  diffNow(e = "milliseconds", i = {}) {
    return this.diff(K.now(), e, i);
  }
  /**
   * Return an Interval spanning between this DateTime and another DateTime
   * @param {DateTime} otherDateTime - the other end point of the Interval
   * @return {Interval}
   */
  until(e) {
    return this.isValid ? Ke.fromDateTimes(this, e) : this;
  }
  /**
   * Return whether this DateTime is in the same unit of time as another DateTime.
   * Higher-order units must also be identical for this function to return `true`.
   * Note that time zones are **ignored** in this comparison, which compares the **local** calendar time. Use {@link DateTime#setZone} to convert one of the dates if needed.
   * @param {DateTime} otherDateTime - the other DateTime
   * @param {string} unit - the unit of time to check sameness on
   * @param {Object} opts - options
   * @param {boolean} [opts.useLocaleWeeks=false] - If true, use weeks based on the locale, i.e. use the locale-dependent start of the week; only the locale of this DateTime is used
   * @example DateTime.now().hasSame(otherDT, 'day'); //~> true if otherDT is in the same current calendar day
   * @return {boolean}
   */
  hasSame(e, i, a) {
    if (!this.isValid) return !1;
    const n = e.valueOf(), o = this.setZone(e.zone, { keepLocalTime: !0 });
    return o.startOf(i, a) <= n && n <= o.endOf(i, a);
  }
  /**
   * Equality check
   * Two DateTimes are equal if and only if they represent the same millisecond, have the same zone and location, and are both valid.
   * To compare just the millisecond values, use `+dt1 === +dt2`.
   * @param {DateTime} other - the other DateTime
   * @return {boolean}
   */
  equals(e) {
    return this.isValid && e.isValid && this.valueOf() === e.valueOf() && this.zone.equals(e.zone) && this.loc.equals(e.loc);
  }
  /**
   * Returns a string representation of a this time relative to now, such as "in two days". Can only internationalize if your
   * platform supports Intl.RelativeTimeFormat. Rounds down by default.
   * @param {Object} options - options that affect the output
   * @param {DateTime} [options.base=DateTime.now()] - the DateTime to use as the basis to which this time is compared. Defaults to now.
   * @param {string} [options.style="long"] - the style of units, must be "long", "short", or "narrow"
   * @param {string|string[]} options.unit - use a specific unit or array of units; if omitted, or an array, the method will pick the best unit. Use an array or one of "years", "quarters", "months", "weeks", "days", "hours", "minutes", or "seconds"
   * @param {boolean} [options.round=true] - whether to round the numbers in the output.
   * @param {number} [options.padding=0] - padding in milliseconds. This allows you to round up the result if it fits inside the threshold. Don't use in combination with {round: false} because the decimal output will include the padding.
   * @param {string} options.locale - override the locale of this DateTime
   * @param {string} options.numberingSystem - override the numberingSystem of this DateTime. The Intl system may choose not to honor this
   * @example DateTime.now().plus({ days: 1 }).toRelative() //=> "in 1 day"
   * @example DateTime.now().setLocale("es").toRelative({ days: 1 }) //=> "dentro de 1 día"
   * @example DateTime.now().plus({ days: 1 }).toRelative({ locale: "fr" }) //=> "dans 23 heures"
   * @example DateTime.now().minus({ days: 2 }).toRelative() //=> "2 days ago"
   * @example DateTime.now().minus({ days: 2 }).toRelative({ unit: "hours" }) //=> "48 hours ago"
   * @example DateTime.now().minus({ hours: 36 }).toRelative({ round: false }) //=> "1.5 days ago"
   */
  toRelative(e = {}) {
    if (!this.isValid) return null;
    const i = e.base || K.fromObject({}, { zone: this.zone }), a = e.padding ? this < i ? -e.padding : e.padding : 0;
    let n = ["years", "months", "days", "hours", "minutes", "seconds"], o = e.unit;
    return Array.isArray(e.unit) && (n = e.unit, o = void 0), Iu(i, this.plus(a), {
      ...e,
      numeric: "always",
      units: n,
      unit: o
    });
  }
  /**
   * Returns a string representation of this date relative to today, such as "yesterday" or "next month".
   * Only internationalizes on platforms that supports Intl.RelativeTimeFormat.
   * @param {Object} options - options that affect the output
   * @param {DateTime} [options.base=DateTime.now()] - the DateTime to use as the basis to which this time is compared. Defaults to now.
   * @param {string} options.locale - override the locale of this DateTime
   * @param {string} options.unit - use a specific unit; if omitted, the method will pick the unit. Use one of "years", "quarters", "months", "weeks", or "days"
   * @param {string} options.numberingSystem - override the numberingSystem of this DateTime. The Intl system may choose not to honor this
   * @example DateTime.now().plus({ days: 1 }).toRelativeCalendar() //=> "tomorrow"
   * @example DateTime.now().setLocale("es").plus({ days: 1 }).toRelative() //=> ""mañana"
   * @example DateTime.now().plus({ days: 1 }).toRelativeCalendar({ locale: "fr" }) //=> "demain"
   * @example DateTime.now().minus({ days: 2 }).toRelativeCalendar() //=> "2 days ago"
   */
  toRelativeCalendar(e = {}) {
    return this.isValid ? Iu(e.base || K.fromObject({}, { zone: this.zone }), this, {
      ...e,
      numeric: "auto",
      units: ["years", "months", "days"],
      calendary: !0
    }) : null;
  }
  /**
   * Return the min of several date times
   * @param {...DateTime} dateTimes - the DateTimes from which to choose the minimum
   * @return {DateTime} the min DateTime, or undefined if called with no argument
   */
  static min(...e) {
    if (!e.every(K.isDateTime))
      throw new It("min requires all arguments be DateTimes");
    return pu(e, (i) => i.valueOf(), Math.min);
  }
  /**
   * Return the max of several date times
   * @param {...DateTime} dateTimes - the DateTimes from which to choose the maximum
   * @return {DateTime} the max DateTime, or undefined if called with no argument
   */
  static max(...e) {
    if (!e.every(K.isDateTime))
      throw new It("max requires all arguments be DateTimes");
    return pu(e, (i) => i.valueOf(), Math.max);
  }
  // MISC
  /**
   * Explain how a string would be parsed by fromFormat()
   * @param {string} text - the string to parse
   * @param {string} fmt - the format the string is expected to be in (see description)
   * @param {Object} options - options taken by fromFormat()
   * @return {Object}
   */
  static fromFormatExplain(e, i, a = {}) {
    const { locale: n = null, numberingSystem: o = null } = a, s = ke.fromOpts({
      locale: n,
      numberingSystem: o,
      defaultToEN: !0
    });
    return Ag(s, e, i);
  }
  /**
   * @deprecated use fromFormatExplain instead
   */
  static fromStringExplain(e, i, a = {}) {
    return K.fromFormatExplain(e, i, a);
  }
  /**
   * Build a parser for `fmt` using the given locale. This parser can be passed
   * to {@link DateTime.fromFormatParser} to a parse a date in this format. This
   * can be used to optimize cases where many dates need to be parsed in a
   * specific format.
   *
   * @param {String} fmt - the format the string is expected to be in (see
   * description)
   * @param {Object} options - options used to set locale and numberingSystem
   * for parser
   * @returns {TokenParser} - opaque object to be used
   */
  static buildFormatParser(e, i = {}) {
    const { locale: a = null, numberingSystem: n = null } = i, o = ke.fromOpts({
      locale: a,
      numberingSystem: n,
      defaultToEN: !0
    });
    return new Lg(o, e);
  }
  /**
   * Create a DateTime from an input string and format parser.
   *
   * The format parser must have been created with the same locale as this call.
   *
   * @param {String} text - the string to parse
   * @param {TokenParser} formatParser - parser from {@link DateTime.buildFormatParser}
   * @param {Object} opts - options taken by fromFormat()
   * @returns {DateTime}
   */
  static fromFormatParser(e, i, a = {}) {
    if (ae(e) || ae(i))
      throw new It(
        "fromFormatParser requires an input string and a format parser"
      );
    const { locale: n = null, numberingSystem: o = null } = a, s = ke.fromOpts({
      locale: n,
      numberingSystem: o,
      defaultToEN: !0
    });
    if (!s.equals(i.locale))
      throw new It(
        `fromFormatParser called with a locale of ${s}, but the format parser was created for ${i.locale}`
      );
    const { result: r, zone: l, specificOffset: c, invalidReason: d } = i.explainFromTokens(e);
    return d ? K.invalid(d) : In(
      r,
      l,
      a,
      `format ${i.format}`,
      e,
      c
    );
  }
  // FORMAT PRESETS
  /**
   * {@link DateTime#toLocaleString} format like 10/14/1983
   * @type {Object}
   */
  static get DATE_SHORT() {
    return Js;
  }
  /**
   * {@link DateTime#toLocaleString} format like 'Oct 14, 1983'
   * @type {Object}
   */
  static get DATE_MED() {
    return Bm;
  }
  /**
   * {@link DateTime#toLocaleString} format like 'Fri, Oct 14, 1983'
   * @type {Object}
   */
  static get DATE_MED_WITH_WEEKDAY() {
    return Mx;
  }
  /**
   * {@link DateTime#toLocaleString} format like 'October 14, 1983'
   * @type {Object}
   */
  static get DATE_FULL() {
    return Dm;
  }
  /**
   * {@link DateTime#toLocaleString} format like 'Tuesday, October 14, 1983'
   * @type {Object}
   */
  static get DATE_HUGE() {
    return Nm;
  }
  /**
   * {@link DateTime#toLocaleString} format like '09:30 AM'. Only 12-hour if the locale is.
   * @type {Object}
   */
  static get TIME_SIMPLE() {
    return Mm;
  }
  /**
   * {@link DateTime#toLocaleString} format like '09:30:23 AM'. Only 12-hour if the locale is.
   * @type {Object}
   */
  static get TIME_WITH_SECONDS() {
    return $m;
  }
  /**
   * {@link DateTime#toLocaleString} format like '09:30:23 AM EDT'. Only 12-hour if the locale is.
   * @type {Object}
   */
  static get TIME_WITH_SHORT_OFFSET() {
    return Pm;
  }
  /**
   * {@link DateTime#toLocaleString} format like '09:30:23 AM Eastern Daylight Time'. Only 12-hour if the locale is.
   * @type {Object}
   */
  static get TIME_WITH_LONG_OFFSET() {
    return Rm;
  }
  /**
   * {@link DateTime#toLocaleString} format like '09:30', always 24-hour.
   * @type {Object}
   */
  static get TIME_24_SIMPLE() {
    return Vm;
  }
  /**
   * {@link DateTime#toLocaleString} format like '09:30:23', always 24-hour.
   * @type {Object}
   */
  static get TIME_24_WITH_SECONDS() {
    return Em;
  }
  /**
   * {@link DateTime#toLocaleString} format like '09:30:23 EDT', always 24-hour.
   * @type {Object}
   */
  static get TIME_24_WITH_SHORT_OFFSET() {
    return Wm;
  }
  /**
   * {@link DateTime#toLocaleString} format like '09:30:23 Eastern Daylight Time', always 24-hour.
   * @type {Object}
   */
  static get TIME_24_WITH_LONG_OFFSET() {
    return zm;
  }
  /**
   * {@link DateTime#toLocaleString} format like '10/14/1983, 9:30 AM'. Only 12-hour if the locale is.
   * @type {Object}
   */
  static get DATETIME_SHORT() {
    return Hm;
  }
  /**
   * {@link DateTime#toLocaleString} format like '10/14/1983, 9:30:33 AM'. Only 12-hour if the locale is.
   * @type {Object}
   */
  static get DATETIME_SHORT_WITH_SECONDS() {
    return qm;
  }
  /**
   * {@link DateTime#toLocaleString} format like 'Oct 14, 1983, 9:30 AM'. Only 12-hour if the locale is.
   * @type {Object}
   */
  static get DATETIME_MED() {
    return Gm;
  }
  /**
   * {@link DateTime#toLocaleString} format like 'Oct 14, 1983, 9:30:33 AM'. Only 12-hour if the locale is.
   * @type {Object}
   */
  static get DATETIME_MED_WITH_SECONDS() {
    return Ym;
  }
  /**
   * {@link DateTime#toLocaleString} format like 'Fri, 14 Oct 1983, 9:30 AM'. Only 12-hour if the locale is.
   * @type {Object}
   */
  static get DATETIME_MED_WITH_WEEKDAY() {
    return $x;
  }
  /**
   * {@link DateTime#toLocaleString} format like 'October 14, 1983, 9:30 AM EDT'. Only 12-hour if the locale is.
   * @type {Object}
   */
  static get DATETIME_FULL() {
    return Xm;
  }
  /**
   * {@link DateTime#toLocaleString} format like 'October 14, 1983, 9:30:33 AM EDT'. Only 12-hour if the locale is.
   * @type {Object}
   */
  static get DATETIME_FULL_WITH_SECONDS() {
    return Um;
  }
  /**
   * {@link DateTime#toLocaleString} format like 'Friday, October 14, 1983, 9:30 AM Eastern Daylight Time'. Only 12-hour if the locale is.
   * @type {Object}
   */
  static get DATETIME_HUGE() {
    return jm;
  }
  /**
   * {@link DateTime#toLocaleString} format like 'Friday, October 14, 1983, 9:30:33 AM Eastern Daylight Time'. Only 12-hour if the locale is.
   * @type {Object}
   */
  static get DATETIME_HUGE_WITH_SECONDS() {
    return _m;
  }
}
function Lo(t) {
  if (K.isDateTime(t))
    return t;
  if (t && t.valueOf && Da(t.valueOf()))
    return K.fromJSDate(t);
  if (t && typeof t == "object")
    return K.fromObject(t);
  throw new It(
    `Unknown datetime argument: ${t}, of type ${typeof t}`
  );
}
function Nv() {
  const t = K.now().offset / 60;
  return t !== 0 ? `${t > 0 ? "+" : "-"}INTERVAL '${Math.abs(t) - 1}:59:59' HOUR TO SECOND` : "";
}
function Mv(t, e) {
  const i = Nv(), a = `EXTRACT(YEAR FROM ${t} ${i})`, n = `EXTRACT(MONTH FROM ${t} ${i})`, o = `EXTRACT(DAY FROM ${t} ${i})`, s = `EXTRACT(HOUR FROM ${t} ${i})`, r = `EXTRACT(MINUTE FROM ${t} ${i})`, l = `EXTRACT(SECOND FROM ${t} ${i})`;
  let c = [];
  switch (e) {
    case Q.Second:
      c = [a, n, o, s, r, l];
      break;
    case Q.Minute:
      c = [a, n, o, s, r];
      break;
    case Q.Hour:
      c = [a, n, o, s];
      break;
    case Q.Day:
    case Q.Week:
    case Q.Month:
    case Q.Year:
      c = [a, n, o];
      break;
  }
  return c;
}
function $v(t) {
  const { whereValue: e, outStatistics: i, y: a } = t;
  let n = ot.outStatistics.outStatisticFieldName ?? "";
  return i?.outStatisticFieldName !== void 0 ? n = i.outStatisticFieldName : i?.onStatisticField !== void 0 && i.statisticType !== void 0 ? n = `${i.statisticType}_${i.onStatisticField}_${e}` : a !== void 0 && (n = [a].flat()[0]), n;
}
function Pv(t) {
  const e = /* @__PURE__ */ new Map();
  for (let i = 0; i < t.length; i += 1) {
    const a = t[i], n = a.query?.where;
    if (n !== void 0 && "y" in a) {
      const o = Lt({ where: n, normalize: !0, escape: !1 });
      if (o !== "") {
        const s = $v({
          whereValue: o,
          outStatistics: a.query?.outStatistics?.[0],
          y: a.y
        });
        a.y = s, e.set(o, s);
      }
    }
  }
  return e;
}
function Rv(t) {
  const { uniqueQuery: e, splitByField: i, x: a } = t, n = [...e.groupByFieldsForStatistics ?? [], a, i].filter(
    (o) => o !== void 0 && o.trim() !== "" && o !== jo
  );
  e.groupByFieldsForStatistics = Array.from(new Set(n));
}
function Vv(t) {
  return t.statisticType === X.ContinuousPercentile || t.statisticType === X.DiscretePercentile;
}
function Ev(t) {
  const {
    uniqueQuery: e,
    y: i,
    useGenericOutStatFieldName: a,
    queryObject: n,
    chartSubType: o,
    isTimeBinningSeries: s,
    temporalBinningType: r,
    returnFeaturesExtent: l
  } = t, c = ot.outStatistics;
  if (e.outStatistics?.[0] !== void 0) {
    o !== L.PieFromFields && o !== L.BarAndLineFromFields && (e.outStatistics[0].outStatisticFieldName = a ? c.outStatisticFieldName : [i].flat()[0]);
    const { outStatistics: d } = e;
    for (let u = 0; u < d.length; u += 1) {
      const f = e.outStatistics[u];
      f !== void 0 && Vv(f) && (s && r !== wi.CalendarBased ? (d[u].statisticType = X.Count, delete d[u].statisticParameters) : d[u] = {
        ...d[u],
        statisticParameters: d[u].statisticParameters ?? {
          value: k.defaultStatParameterValue
        }
      });
    }
  } else if (n !== void 0) {
    const { objectIdField: d } = we(n);
    e.outStatistics = [
      {
        statisticType: c.statisticType,
        onStatisticField: d,
        outStatisticFieldName: a ? c.outStatisticFieldName : [i].flat()[0]
      }
    ];
  }
  l === !0 && e.outStatistics?.push({ statisticType: X.EnvelopeAggregate, onStatisticField: "1" });
}
function Wv(t) {
  const { chartConfig: e, fetchFullBoxPlotData: i } = t, { series: a } = e, n = qe(e);
  let o = [
    { statisticType: X.Average, suffix: Y.Average }
  ];
  i === !0 && (o = [
    ...o,
    { statisticType: X.Minimum, suffix: Y.Min },
    {
      statisticType: X.ContinuousPercentile,
      statisticParameters: { value: 0.25 },
      suffix: Y.FirstQuartile
    },
    {
      statisticType: X.ContinuousPercentile,
      statisticParameters: { value: 0.5 },
      suffix: Y.Median
    },
    {
      statisticType: X.ContinuousPercentile,
      statisticParameters: { value: 0.75 },
      suffix: Y.ThirdQuartile
    },
    { statisticType: X.Maximum, suffix: Y.Max },
    { statisticType: X.StandardDeviation, suffix: Y.StandardDeviation }
  ]);
  const s = /* @__PURE__ */ new Set();
  return n && "y" in a[0] ? [a[0].y].flat().forEach((l) => s.add(l)) : a.forEach((l) => {
    "y" in l && [l.y].flat().forEach((d) => s.add(d));
  }), [...s].flatMap(
    (l) => o.map((c) => {
      const d = {
        onStatisticField: l,
        statisticType: c.statisticType,
        outStatisticFieldName: `${l}_${c.suffix}`
      };
      return c.statisticType === X.ContinuousPercentile && (d.statisticParameters = c.statisticParameters), d;
    })
  );
}
function zv(t, e) {
  for (let i = 1; i < e.length; i += 1) {
    const a = { ...e[i].query?.outStatistics?.[0] };
    a !== void 0 && t.outStatistics !== void 0 && t.outStatistics.push(a);
  }
}
function Hv(t) {
  const { uniqueQuery: e, x: i, splitByField: a, unit: n, chartSubType: o, objectIdField: s } = t;
  if (n !== void 0) {
    const r = Mv(i, n);
    e.orderByFields = r, e.groupByFieldsForStatistics = r, o === L.BarAndLineSplitBy && !be(a) ? e.groupByFieldsForStatistics.push(a) : o === L.BarAndLineNoAggregation && (e.groupByFieldsForStatistics.push(s), e.outStatistics = [
      {
        onStatisticField: s,
        outStatisticFieldName: `COUNT_${s}`,
        statisticType: X.Count
      }
    ]);
  }
}
function Og(t) {
  const { chartConfig: e, options: i, uniqueQuery: a } = t;
  if (i?.chartLimits?.behaviorAfterLimit === eo.RenderUpToTheLimit) {
    const n = pm(e, i?.chartLimits);
    if (n !== void 0) {
      const o = H(e.series);
      if (o === L.PieFromFields || o === L.BarAndLineFromFields) {
        if (a.outStatistics?.[0] !== void 0) {
          const s = (c, d) => c.statisticType === X.EnvelopeAggregate === d, r = a.outStatistics.filter((c) => s(c, !0)), l = a.outStatistics.filter((c) => s(c, !1));
          l.splice(n), a.outStatistics = [...l, ...r];
        }
      } else
        a.num = n;
    }
  }
}
async function Pr(t) {
  const { chartConfig: e, queryConfig: i, options: a, queryObject: n, timeIntervalInfo: o, fetchFullBoxPlotData: s } = t, { setTimeBinningInfoWhenNotProvided: r, returnFeaturesExtent: l } = a ?? {}, c = e.series, d = H(c), u = ha(e), { query: f, x: m } = u, g = "y" in u ? u.y : void 0, y = ei({
    xAxisValueFormatType: ii(e),
    setTimeBinningInfoWhenNotProvided: r,
    seriesConfig: u
  });
  let p = /* @__PURE__ */ new Map(), S = !1, x = !1, C = !1, F = !1, v = !1, A = {};
  if (f !== void 0) {
    A = Ee(f);
    const W = Ze(f.where);
    let U = "";
    switch (i.fetchNullValues !== !0 && (m !== k.boxPlot.boxPlotCategory && (U = `${m} IS NOT NULL`), W.trim() !== "" && W !== m && !pr(f.where) && (U = Xe([U, `${W} IS NOT NULL`]))), d) {
      case L.BarAndLineSplitBy: {
        p = Pv(c), F = !0, S = !0, x = !0;
        break;
      }
      case L.BarAndLineMultiFields:
        zv(A, c), x = !0;
        break;
      case L.PieFromFields:
      case L.BarAndLineFromFields:
        U = "", C = !0, x = !0;
        break;
      case L.BarAndLineMonoField:
      case L.PieFromCategory:
        x = !0;
        break;
      case L.BoxPlotMonoField:
      case L.BoxPlotMultiFields:
        C = !0, v = !0;
        break;
      case L.BoxPlotMonoFieldAndCategory:
      case L.BoxPlotMultiFieldsAndCategory:
      case L.BoxPlotMonoFieldAndSplitBy:
      case L.BoxPlotMonoFieldAndCategoryAndSplitBy:
      case L.BoxPlotMultiFieldsAndSplitBy: {
        v = !0, F = !0, C = !0;
        break;
      }
      case L.PieNoAggregation:
      case L.BarAndLineNoAggregation:
      case L.BarAndLineSplitByNoAggregation:
    }
    if (x && Ev({
      uniqueQuery: A,
      y: g,
      useGenericOutStatFieldName: S,
      queryObject: n,
      chartSubType: d,
      isTimeBinningSeries: y,
      temporalBinningType: ci(c[0]) ? c[0].temporalBinning?.type : void 0,
      returnFeaturesExtent: l
    }), F && Rv({ uniqueQuery: A, splitByField: W, x: m }), v && (A.outStatistics = Wv({ chartConfig: e, fetchFullBoxPlotData: s })), C ? delete A.orderByFields : i.orderByFields !== void 0 && (A.orderByFields = i.orderByFields.filter((q) => {
      const Z = q.split(" ");
      return !be(Z[0]);
    })), y && ci(c[0])) {
      const q = we(n), { objectIdField: Z } = q;
      (await At(n)).find((ie) => ie.name === m)?.type !== fr.DateOnly && Hv({
        uniqueQuery: A,
        x: m,
        splitByField: Ze(f.where),
        unit: o?.unit ?? c[0].temporalBinning?.unit,
        chartSubType: d,
        objectIdField: Z
      });
    }
    A.where = U;
  }
  Og({ chartConfig: e, options: a, uniqueQuery: A });
  const { gdbVersion: w, geometry: O, distance: I, units: N, timeExtent: M, where: P, objectIds: R, spatialRelationship: $ } = i;
  return w !== void 0 && (A.gdbVersion = w), O !== void 0 && (A.geometry = O), I !== void 0 && (A.distance = I), N !== void 0 && (A.units = N), M !== void 0 && (A.timeExtent = M), R !== void 0 && (A.objectIds = R), $ !== void 0 && (A.spatialRelationship = $), P !== void 0 && (A.where = Xe([A.where, P])), { uniqueQuery: A, mapToStatField: p };
}
async function qv(t) {
  const { queryObject: e, queryConfig: i, chartConfig: a, abortKey: n } = t, o = a.series[0], { x: s, valueConversion: r } = o, l = _o(a), c = await aa({
    queryObject: e,
    queryConfig: i,
    featureCount: i.num ?? 1,
    // if a chart limitation has been provided we use it, otherwise we force 1 to avoid the batching
    abortKey: n
  });
  let d = [{ [s]: null }];
  if (l)
    d = c.map((u) => {
      Wc(u.attributes, s);
      const f = Ks(u.attributes[s], r);
      return { ...u.attributes, [s]: f };
    });
  else if (c.length > 0) {
    let u = c[0].attributes[s] ?? c[0].attributes[s.toUpperCase()] ?? c[0].attributes[s.toLowerCase()];
    u = Ks(u, r), d = [{ [s]: u }];
  }
  return d;
}
async function Gv(t) {
  const { queryObject: e, chartConfig: i, queryConfig: a, options: n, abortKey: o } = t, { chartLimits: s } = n ?? {}, r = { valid: !0 };
  if (e !== void 0) {
    const { behaviorAfterLimit: l, maxGaugeByFeaturesLimit: c } = s ?? {}, d = _o(i);
    let u = !0, f;
    if (d && (f = (await Gg({
      chartConfig: i,
      queryObject: e,
      queryConfig: a,
      behaviorAfterLimit: l,
      numberMaxOfFeaturesToFetch: c,
      isGaugeByFeature: d
    })).elementCount, n?.chartLimits?.behaviorAfterLimit !== eo.RenderUpToTheLimit && (u = Ba({
      count: f ?? 0,
      seriesCount: i.series.length,
      chartType: b.GaugeSeries,
      chartLimits: s
    })), n && (Number.isFinite(c) || Number.isFinite(f)))) {
      const m = Math.min(c ?? Number.NaN, f ?? Number.NaN);
      Number.isFinite(m) && (n.chartLimits = {
        ...s,
        maxGaugeByFeaturesLimit: m
      }), Og({ chartConfig: i, options: n, uniqueQuery: a });
    }
    if (Number.isNaN(u) || u) {
      const m = await qv({
        queryObject: e,
        chartConfig: i,
        queryConfig: a,
        abortKey: o
      });
      r.data = { dataItems: m }, r.count = m.length;
    } else
      r.count = f, Tm({
        dataInfo: r,
        chartType: b.GaugeSeries
      });
  }
  return r;
}
async function Yv(t) {
  const { queryObject: e, chartConfig: i, queryConfig: a } = t, { minimumFromField: n, maximumFromField: o } = i.axes[0], s = [];
  let r = "", l = "";
  n !== void 0 && (typeof n == "string" ? (r = `${X.Minimum}_${n}`, s.push({
    statisticType: X.Minimum,
    onStatisticField: n,
    outStatisticFieldName: r
  })) : (r = `${n.statisticType}_${n.onStatisticField}`, s.push({
    ...n,
    outStatisticFieldName: r
  }))), o !== void 0 && (typeof o == "string" ? (l = `${X.Maximum}_${o}`, s.push({
    statisticType: X.Maximum,
    onStatisticField: o,
    outStatisticFieldName: l
  })) : (l = `${o.statisticType}_${o.onStatisticField}`, s.push({
    ...o,
    outStatisticFieldName: l
  })));
  const c = {
    ...a,
    outStatistics: s,
    orderByFields: void 0,
    groupByFieldsForStatistics: void 0,
    returnDistinctValues: void 0,
    fetchNullValues: void 0,
    num: void 0
  }, d = await Zo({
    queryObject: e,
    queryConfig: c
  }), u = d.get(r), f = d.get(l);
  return { minimumFromData: u, maximumFromData: f };
}
function Xv(t = Vt.None, e) {
  return t === Vt.None || t === Vt.Log && e > 0 || t === Vt.Sqrt && e >= 0;
}
function Bg(t, e) {
  const i = { valid: !1 };
  return e === !0 ? i.invalidType = de.HistogramEmptyField : t === Vt.Log ? i.invalidType = de.NegativeValueInLogCalculation : t === Vt.Sqrt && (i.invalidType = de.NegativeValueInSqrtCalculation), i;
}
function Uv(t, e) {
  let i = t;
  switch (e) {
    case Vt.Log:
      i = Math.log(t);
      break;
    case Vt.Sqrt:
      i = Math.sqrt(t);
      break;
  }
  return i;
}
function jv(t) {
  let e = t;
  const i = t.toString().split(".");
  if (i[1] !== void 0) {
    const n = 10 ** -i[1].length;
    e = t - n;
  }
  return e;
}
function Dg(t) {
  let e = "field";
  switch (t) {
    case Vt.Log:
      e = "natural-log";
      break;
    case Vt.Sqrt:
      e = "square-root";
      break;
    case Vt.None:
  }
  return e;
}
function _v(t) {
  const e = new qb({
    layers: []
  });
  return new Xb({
    map: e,
    extent: t
  });
}
async function Zv(t) {
  const { queryObject: e, fieldName: i, queryConfig: a, abortKey: n } = t, o = we(e), { objectIdField: s } = o, r = `${X.Count}_${s}`, l = `${X.Count}_${i}`, c = `${X.Minimum}_${i}`, d = `${X.Maximum}_${i}`, u = {
    ...a,
    outStatistics: [
      {
        statisticType: X.Count,
        onStatisticField: s,
        outStatisticFieldName: r
      },
      {
        statisticType: X.Count,
        onStatisticField: i,
        outStatisticFieldName: l
      },
      {
        statisticType: X.Minimum,
        onStatisticField: i,
        outStatisticFieldName: c
      },
      {
        statisticType: X.Maximum,
        onStatisticField: i,
        outStatisticFieldName: d
      }
    ]
  }, f = await Zo({
    queryObject: e,
    queryConfig: u,
    abortKey: n
  }), m = f.get(r) ?? Number.NaN, g = f.get(l) ?? Number.NaN, y = f.get(c) ?? Number.NaN, p = f.get(d) ?? Number.NaN;
  return { countExcludingNulls: g, countIncludingNulls: m, min: y, max: p };
}
async function Qv(t) {
  const { queryConfig: e, chartConfig: i, queryObject: a, abortKey: n } = t, o = i.series[0], { x: s, dataTransformationType: r } = o;
  let l = [];
  const { countIncludingNulls: c, countExcludingNulls: d, min: u, max: f } = await Zv({
    queryObject: a,
    queryConfig: e,
    fieldName: s,
    abortKey: n
  }), m = Xv(r, u), g = d < 2 || u === f, y = { ...e };
  return y.where = Xe([y.where, `${s} is not null`]), {
    rawData: l,
    dataCompatibleWithTransformation: m,
    dataCountIncompatible: g,
    countExcludingNulls: d,
    countIncludingNulls: c
  };
}
function Kv(t) {
  const e = { ...t };
  return e.avg = e.avg ?? Number.NaN, e.count = e.count ?? Number.NaN, e.max = e.max ?? Number.NaN, e.min = e.min ?? Number.NaN, e.stddev = e.stddev ?? Number.NaN, e.sum = e.sum ?? Number.NaN, e.variance = e.variance ?? Number.NaN, e.median = e.median ?? Number.NaN, e;
}
function Jv(t) {
  const { seriesConfig: e, layer: i, useFeaturesInView: a, view: n, queryConfig: o } = t, { x: s, dataTransformationType: r } = e;
  let l = {
    layer: i,
    view: n,
    field: s,
    // excluding the filters like 1=1 from the sqlWhere. It's causing query failures (see https://devtopia.esri.com/WebGIS/arcgis-charts/issues/6677)
    sqlWhere: pr(o.where) ? void 0 : o.where,
    useFeaturesInView: a
  };
  return r !== Vt.None && (l = {
    ...l,
    normalizationType: Dg(r)
  }), l;
}
function e0(t) {
  const { seriesConfig: e, layer: i, useFeaturesInView: a, view: n, minValue: o, maxValue: s, queryConfig: r } = t, { x: l, binCount: c, dataTransformationType: d } = e;
  let u = {
    layer: i,
    view: n,
    field: l,
    minValue: o,
    maxValue: s,
    numBins: c ?? ab,
    classificationMethod: "equal-interval",
    // excluding the filters like 1=tionMethod: "equal-interval",1 from the sqlWhere. It's causing query failures (see https://devtopia.esri.com/WebGIS/arcgis-charts/issues/6677)
    sqlWhere: pr(r.where) ? void 0 : r.where,
    useFeaturesInView: a
  };
  return d !== Vt.None && (u = {
    ...u,
    normalizationType: Dg(d)
  }), u;
}
function t0(t, e) {
  let i = Number.NaN;
  return t !== void 0 && e !== void 0 && (i = t - e), i;
}
async function i0(t) {
  const {
    chartConfig: e,
    queryConfig: i,
    queryObject: a,
    countExcludingNulls: n,
    countIncludingNulls: o,
    options: s,
    errorStrings: r
  } = t, l = e.series[0], { dataTransformationType: c } = l;
  let d = { valid: !0 };
  if (a !== void 0) {
    const u = we(a), f = tb(i?.geometry)?.extent?.toJSON(), m = f !== void 0, g = s?.view ?? _v(f), y = Jv({
      seriesConfig: l,
      layer: u,
      view: g,
      useFeaturesInView: m,
      queryConfig: i
    }), p = new Hb({
      geometry: g.extent
    });
    if (g.extent !== void 0 && ib(u)) {
      const { distance: I, units: N } = i;
      I !== void 0 && (p.distance = I), N !== void 0 && (p.units = N);
    }
    i.timeExtent && (p.timeExtent = { start: i.timeExtent[0], end: i.timeExtent[1] }), y.filter = p;
    let S;
    try {
      S = await Yb(y);
    } catch (I) {
      throw new ln(nn.QueryFeaturesError, r.errors.queryError, I);
    }
    S = Kv(S);
    const { avg: x, count: C, stddev: F, min: v, max: A, sum: w, median: O } = S;
    if (C === 0)
      d = {
        ...Bg(c)
      };
    else {
      const I = e0({
        seriesConfig: l,
        layer: u,
        view: g,
        useFeaturesInView: m,
        minValue: jv(v),
        maxValue: A,
        valueExpression: y.valueExpression,
        queryConfig: i
      });
      I.filter = p;
      let N;
      try {
        I.useQueryAttributeBins = !1, N = await Gb(I);
      } catch (P) {
        throw new ln(nn.QueryFeaturesError, r.errors.queryError, P);
      }
      const M = t0(o, n);
      d.data = {
        mean: x,
        stddev: F,
        min: v,
        max: A,
        median: Number(O),
        bins: N?.bins,
        count: n,
        nulls: M,
        sum: w ?? void 0
      }, d.data.bins.length > 0 && (d.data.bins[d.data.bins.length - 1].isLastBin = !0);
    }
  }
  return d;
}
async function Ng(t) {
  const { chartConfig: e, queryConfig: i, queryObject: a, options: n, abortKey: o, errorStrings: s } = t, { series: r } = e, l = r[0], { rawData: c, dataCompatibleWithTransformation: d, dataCountIncompatible: u, countIncludingNulls: f, countExcludingNulls: m } = await Qv({
    queryObject: a,
    chartConfig: e,
    queryConfig: i,
    abortKey: o
  });
  let g = { valid: !0 };
  return !d || u ? g = Bg(l.dataTransformationType, u) : g = await i0({
    chartConfig: e,
    queryObject: a,
    queryConfig: i,
    countIncludingNulls: f,
    countExcludingNulls: m,
    options: n,
    errorStrings: s
  }), g;
}
async function a0(t) {
  const { queryObject: e, queryConfig: i, chartConfig: a, x: n } = t, { series: o } = a, { dataTransformationType: s } = o[0], r = {
    ...i,
    orderByFields: [n],
    outFields: [n]
  };
  return {
    valid: !0,
    data: { dataItems: (await aa({
      queryObject: e,
      queryConfig: r
    })).map((d) => ({
      [n]: Uv(d.attributes[n], s)
    })) }
  };
}
const fn = {
  groupByCaseBegin: "CASE",
  groupByOutKeyword: "OUT",
  groupByCaseEnd: "ELSE 'OUT' END"
}, n0 = "${ groupByFieldsForStatistics } WHEN (${ y } ${ yMinOperand } ${ yValue } AND ${ y } ${ yMaxOperand } ${ yValuePlusStep } AND ${ x } ${ xMinOperand } ${ xValue } AND ${ x } ${ xMaxOperand } ${ xValuePlusStep }) THEN '${ xValue }|${ xValuePlusStep}|${ yValue }|${ yValuePlusStep }'";
async function o0(t) {
  const { chartConfig: e, queryObject: i, queryConfig: a, abortKey: n } = t, o = e.series[0], { x: s, y: r } = o, { dataContextCountDistinctX: l, dataContextCountDistinctY: c } = k.scatterplotAggregationFields, d = {
    ...a,
    outStatistics: [
      {
        statisticType: X.Count,
        outStatisticFieldName: l,
        onStatisticField: s
      },
      {
        statisticType: X.Count,
        outStatisticFieldName: c,
        onStatisticField: r
      }
    ],
    returnDistinctValues: !0
    // this parameters guarantees the 2 count stats bring back distinct values. It has no impact on the other stats.
  };
  return await Zo({
    queryObject: i,
    queryConfig: d,
    abortKey: n
  });
}
async function s0(t) {
  const { statsMap: e, chartConfig: i, queryObject: a, options: n, queryConfig: o, abortKey: s } = t, {
    dataContextXMinField: r,
    dataContextXMaxField: l,
    dataContextYMinField: c,
    dataContextYMaxField: d,
    dataContextCountDistinctX: u,
    dataContextCountDistinctY: f
  } = k.scatterplotAggregationFields;
  let m, g, y, p, S;
  const x = e.get(r), C = e.get(l), F = e.get(c), v = e.get(d);
  if (x != null && F !== void 0 && F !== null && C !== void 0 && C !== null && v !== void 0 && v !== null && !Number.isNaN(x + C + F + v)) {
    const { maxScatterPointsAfterAggregation: A } = to(n?.chartLimits), O = Math.floor(Math.sqrt(A)), I = await o0({
      queryObject: a,
      chartConfig: i,
      queryConfig: o,
      abortKey: s
    });
    y = Math.min(I.get(f) ?? Number.NaN, O), p = Math.min(I.get(u) ?? Number.NaN, O), S = p * y, m = C === x ? 0 : (C - x) / (p - 1), g = v === F ? 0 : (v - F) / (y - 1), e.set(k.scatterplotAggregationFields.xStep, m), e.set(k.scatterplotAggregationFields.yStep, g), e.set(k.scatterplotAggregationFields.rowCount, y), e.set(k.scatterplotAggregationFields.columnCount, p), e.set(k.scatterplotAggregationFields.realGridSize, S);
  }
}
function r0(t) {
  const { groupByFieldsForStatistics: e, x: i, y: a, xValue: n, yValue: o, xStep: s, yStep: r, endOfRow: l, endOfColumn: c } = t;
  let d = e === "" ? fn.groupByCaseBegin : e;
  return d = Gt(n0, {
    groupByFieldsForStatistics: d,
    x: i,
    y: a,
    xValue: `${n}`,
    yValue: `${o}`,
    xValuePlusStep: `${n + (c ? 0 : s)}`,
    yValuePlusStep: `${o + (l ? 0 : r)}`,
    xMinOperand: c ? "=" : ">=",
    // we use = to catch the last value of the column, >= otherwise
    yMinOperand: l ? "=" : ">=",
    // we use = to catch the last value of the line, >= otherwise
    xMaxOperand: c ? "=" : "<",
    // we use = to catch the last value of the column, < otherwise
    yMaxOperand: l ? "=" : "<"
    // we use = to catch the last value of the line, < otherwise
  }), d;
}
async function l0(t) {
  const { chartConfig: e, queryConfig: i, queryObject: a, xMin: n, xMax: o, yMin: s, yMax: r, abortKey: l } = t, c = e.series[0], { x: d, y: u } = c, f = { ...i };
  return f.where = Xe([f.where, `${d}>=${n}`, `${d}<=${o}`]), d !== u && (f.where = Xe([f.where, `${u}>=${s}`, `${u}<=${r}`])), await aa({
    queryObject: a,
    queryConfig: f,
    noBatch: !0,
    featureCount: 1,
    // this will skip the query counting the features
    abortKey: l
  });
}
async function c0(t) {
  const { statsMap: e, chartConfig: i, queryObject: a, queryConfig: n, useQueryAttributeBins: o, errorStrings: s, abortKey: r } = t, l = i.series[0], { x: c, y: d } = l, {
    dataContextXMinField: u,
    dataContextXMaxField: f,
    dataContextYMinField: m,
    dataContextYMaxField: g,
    queryNumberOfFeatures: y,
    queryNumberOfAggregatedFeatures: p
  } = k.scatterplotAggregationFields;
  let S;
  const x = e?.get(u) ?? Number.NaN, C = e?.get(f) ?? Number.NaN, F = e?.get(y) ?? Number.NaN, v = e?.get(m) ?? x, A = e?.get(g) ?? C;
  if (x != null && v !== void 0 && v !== null && C !== void 0 && C !== null && A !== void 0 && A !== null && !Number.isNaN(x + C + v + A)) {
    const w = we(a), { objectIdField: O } = w, I = e?.get(k.scatterplotAggregationFields.xStep), N = e?.get(k.scatterplotAggregationFields.yStep), M = e?.get(k.scatterplotAggregationFields.realGridSize), P = e?.get(k.scatterplotAggregationFields.rowCount), R = e?.get(k.scatterplotAggregationFields.columnCount), $ = /* @__PURE__ */ new Map();
    if ((await At(a))?.forEach((q) => {
      cc(q) && $.set(q.name, {
        onStatisticField: q.name,
        outStatisticFieldName: q.name,
        statisticType: X.Maximum
      });
    }), (await Ef(w)).forEach((q) => {
      $.set(q, {
        onStatisticField: q,
        outStatisticFieldName: q,
        statisticType: X.Maximum
      });
    }), $.set(O, {
      onStatisticField: O,
      outStatisticFieldName: p,
      statisticType: X.Count
    }).set(c, {
      onStatisticField: c,
      outStatisticFieldName: c,
      statisticType: X.Maximum
    }).set(d, {
      onStatisticField: d,
      outStatisticFieldName: d,
      statisticType: X.Maximum
    }), I !== void 0 && N !== void 0) {
      if (o) {
        const q = {
          ...n,
          outStatistics: [...$.values()]
        };
        S = await nb({
          queryObject: a,
          queryConfig: q,
          xStep: I,
          xMin: x,
          xMax: C,
          x: c,
          y: d,
          yStep: N,
          errorStrings: s
        });
      } else if (P !== void 0 && R !== void 0) {
        let q = 0;
        const { maxScatterCellsPerQuery: Z, maxScatterCellsPerQueryForStandard: ee } = Uo(), ie = await ob(w) ? ee : Z, ge = [];
        let yt = !0, Nt = x, Mt = v, Oe = "", Fi = 1, Be = 1, le = Number.MAX_SAFE_INTEGER, bt = Number.MIN_SAFE_INTEGER, Qe = Number.MAX_SAFE_INTEGER, $t = Number.MIN_SAFE_INTEGER;
        for (; Be <= R && yt; ) {
          for (Mt = v, Fi = 1; Fi <= P && yt; ) {
            if (Oe = r0({
              groupByFieldsForStatistics: Oe,
              x: c,
              y: d,
              xValue: Nt,
              yValue: Mt,
              xStep: I,
              yStep: N,
              endOfRow: Fi === P,
              endOfColumn: Be === R
            }), Nt < le && (le = Nt), Nt + I > bt && (bt = Nt + I), Mt < Qe && (Qe = Mt), Mt + I > $t && ($t = Mt + N), q += 1, q % ie === 0 || q === M || q === F) {
              Oe = `${Oe} ${fn.groupByCaseEnd}`;
              const Li = {
                ...n,
                groupByFieldsForStatistics: [Oe],
                outStatistics: [...$.values()]
              };
              ge.push(
                l0({
                  chartConfig: i,
                  queryConfig: Li,
                  queryObject: a,
                  xMin: le,
                  xMax: bt,
                  yMin: Qe,
                  yMax: $t,
                  abortKey: r
                })
              ), le = Number.MAX_SAFE_INTEGER, bt = Number.MIN_SAFE_INTEGER, Qe = Number.MAX_SAFE_INTEGER, $t = Number.MIN_SAFE_INTEGER, Oe = "", q === M && (yt = !1);
            }
            Mt += N, Fi += 1;
          }
          Nt += I, Be += 1;
        }
        S = (await Promise.all(ge)).flat();
      }
    }
  }
  return S;
}
const d0 = {
  dataFormat: "json",
  outputFormat: "json",
  typeKey: "analyticType",
  typeValue: "LinRegR2",
  fieldValue: "onAnalyticField",
  slopePropertyList: ["Slope", "SLOPE", "slope"],
  interceptPropertyList: ["Intercept", "INTERCEPT", "intercept"],
  r2PropertyList: ["R2", "r2"]
};
async function u0(t) {
  const { queryObject: e } = t;
  let i = !1;
  const a = Po(e), n = we(e), o = yr(n);
  if (a && o.url !== void 0 && o.url !== null) {
    const s = `${o.url}/${o.layerId}?f=json`;
    try {
      const r = (await kb(s)).data, l = r?.advancedQueryCapabilities?.supportsQueryAnalytic === !0, c = r?.sqlParserVersion === void 0 || o.version != null && o.version >= 10.91;
      i = l && c;
    } catch {
    }
  }
  return i;
}
function f0(t) {
  const { x: e, y: i, trendlineXToY: a, data: n } = t, [o, s] = n ? Bb(n, (l) => l[e]) : [Number.NaN, Number.NaN];
  return [
    { [e]: o ?? Number.NaN, [i]: a(o ?? Number.NaN) },
    { [e]: s ?? Number.NaN, [i]: a(s ?? Number.NaN) }
  ];
}
function m0(t) {
  const { data: e, x: i, y: a } = t;
  let n = [];
  return e !== void 0 && (n = e.filter((o) => Number.isFinite(o[i]) && Number.isFinite(o[a])).map((o) => [o[i], o[a]])), n;
}
async function g0(t) {
  const { statsMap: e, queryObject: i, chartConfig: a, queryConfig: n } = t, o = a.series[0], { x: s, y: r } = o;
  let l = Number.NaN, c = [
    { [s]: Number.NaN, [r]: Number.NaN },
    { [s]: Number.NaN, [r]: Number.NaN }
  ];
  const {
    dataFormat: d,
    outputFormat: u,
    typeKey: f,
    typeValue: m,
    fieldValue: g,
    slopePropertyList: y,
    interceptPropertyList: p,
    r2PropertyList: S
  } = d0, x = `[{"${f}": "${m}", "${g}":"${s},${r}"}]`, C = await sb({
    queryObject: i,
    queryConfig: n,
    outputFormat: u,
    dataFormat: d,
    outAnalytics: x
  });
  if (C !== void 0) {
    let F = Number.NaN, v = Number.NaN;
    const { expr: A } = cl(C, y), { expr: w } = cl(C, p), { expr: O } = cl(C, S);
    A !== void 0 && Number.isFinite(C[A]) && (F = C[A]), w !== void 0 && Number.isFinite(C[w]) && (v = C[w]), O !== void 0 && Number.isFinite(C[O]) && (l = C[O]);
    const { dataContextXMinField: I, dataContextXMaxField: N, dataContextYMinField: M, dataContextYMaxField: P } = k.scatterplotAggregationFields, R = e.get(I) ?? Number.NaN, $ = e.get(N) ?? Number.NaN, W = e.get(M) ?? Number.NaN, U = e.get(P) ?? Number.NaN, Z = ($ - R) / 100;
    let ee = R - Z, j = Number.NaN;
    for (; !(j >= W && j <= U) && ee <= $; )
      ee += Z, j = F * ee + v;
    let ie = $ + Z, ge = Number.NaN;
    for (; !(ge >= W && ge <= U) && ie >= R; )
      ie -= Z, ge = F * ie + v;
    c = [
      { [s]: ee, [r]: j },
      { [s]: ie, [r]: ge }
    ];
  }
  return { r2: l, trendLinePoints: c };
}
function Mg(t) {
  const { data: e, chartConfig: i } = t, a = i.series[0], { x: n, y: o } = a;
  let { r2: s, trendLinePoints: r } = k.scatterplotSeries;
  const l = m0({ data: e, x: n, y: o });
  if (l !== void 0) {
    const c = Ub(l), d = jb(c);
    s = _b(l, d), r = f0({ x: n, y: o, trendlineXToY: d, data: e });
  }
  return { r2: s, trendLinePoints: r };
}
async function h0(t) {
  const e = await u0(t), { chartConfig: i } = t, a = i.series[0], { x: n, y: o } = a, { r2: s } = k.scatterplotSeries, r = [
    { [n]: Number.NaN, [o]: Number.NaN },
    { [n]: Number.NaN, [o]: Number.NaN }
  ];
  let l = { r2: s, trendLinePoints: r }, c = !1;
  if (e)
    try {
      l = await g0(t);
    } catch {
      c = !0;
    }
  return (!e || c) && (l = Mg(t)), l;
}
async function p0(t) {
  const { chartConfig: e, queryConfig: i, queryObject: a, abortKey: n } = t, o = e.series[0], { x: s, y: r } = o;
  let l = /* @__PURE__ */ new Map();
  const {
    dataContextXMinField: c,
    dataContextXMaxField: d,
    dataContextYMinField: u,
    dataContextYMaxField: f,
    queryNumberOfFeatures: m
  } = k.scatterplotAggregationFields, { objectIdField: g } = we(a), y = [
    {
      statisticType: X.Count,
      onStatisticField: g,
      outStatisticFieldName: m
    },
    {
      statisticType: X.Minimum,
      outStatisticFieldName: c,
      onStatisticField: s
    },
    {
      statisticType: X.Maximum,
      outStatisticFieldName: d,
      onStatisticField: s
    }
  ];
  s !== r && y.push(
    {
      statisticType: X.Minimum,
      outStatisticFieldName: u,
      onStatisticField: r
    },
    {
      statisticType: X.Maximum,
      outStatisticFieldName: f,
      onStatisticField: r
    }
  );
  const p = { ...i };
  return p.outStatistics = y, l = await Zo({
    queryObject: a,
    queryConfig: p,
    abortKey: n
  }), s === r && (l.set(u, l.get(c) ?? Number.NaN), l.set(f, l.get(d) ?? Number.NaN)), l;
}
function ws(t) {
  const { value: e, valueMin: i, valueMax: a } = t;
  return e === i || e === a ? e : Math.random() * (a - i) + i;
}
function y0(t) {
  const { useQueryAttributeBins: e, graphic: i, x: a, y: n, yStep: o } = t, { groupByOutKeyword: s } = fn, { dataContextXMinField: r, dataContextXMaxField: l, dataContextYMinField: c, dataContextYMaxField: d } = k.scatterplotAggregationFields;
  let u = [];
  if (e && "stackedAttributes" in i && i.stackedAttributes) {
    const f = cb(a, n), m = i.attributes[f.lowerBoundaryAlias], g = i.attributes[f.upperBoundaryAlias];
    i.stackedAttributes.forEach((y) => {
      let p = y[f.stackAlias], S;
      typeof p == "number" && typeof o == "number" && (p *= o), typeof p == "number" && typeof o == "number" && (S = p + o);
      const x = y[a], C = y[n];
      typeof p == "number" && typeof S == "number" && typeof x == "number" && typeof C == "number" && u.push({
        ...y,
        [a]: ws({ value: x, valueMin: m, valueMax: g }),
        [n]: ws({ value: C, valueMin: p, valueMax: S }),
        [r]: Math.min(m, g),
        [l]: Math.max(m, g),
        [c]: p,
        [d]: S
      });
    });
  } else {
    const { expr: f, isInItem: m } = hr(i.attributes);
    if (m && f && i.attributes[f] !== s) {
      let [g, y, p, S] = i.attributes[f].split("|");
      g = Math.min(g, y), y = Math.max(g, y), p = Math.min(p, S), S = Math.max(p, S);
      const x = {
        ...i.attributes,
        [r]: g,
        [l]: y,
        [c]: p,
        [d]: S
      };
      x[a] = ws({
        value: x[a],
        valueMin: g,
        valueMax: y
      }), x[n] = ws({
        value: x[n],
        valueMin: p,
        valueMax: S
      }), u = [x];
    }
  }
  return u;
}
async function b0(t) {
  const { queryObject: e, chartConfig: i, rawData: a, isAggregationMode: n, yStep: o, useQueryAttributeBins: s } = t, r = i.series[0], { x: l, y: c } = r, u = we(e).objectIdField;
  let m = (Array.isArray(a) ? a : a?.features)?.flatMap((g) => {
    let y = [{ ...g.attributes }];
    return Wc(y[0], [l, c]), n ? y = y0({
      useQueryAttributeBins: s,
      graphic: g,
      x: l,
      y: c,
      yStep: o
    }) : y[0][ot.uniqueIdsName] = y[0][u], y;
  });
  return m = m?.filter((g) => {
    const { expr: y } = hr(g);
    return Number.isFinite(g[l]) && Number.isFinite(g[c]) && (y === void 0 || g[y] !== fn.groupByOutKeyword);
  }), m ?? [];
}
async function S0(t) {
  const { queryObject: e, queryConfig: i, chartConfig: a, featureCount: n, abortKey: o } = t, s = a.series[0], { x: r, y: l } = s, c = we(e);
  let d = [];
  const f = ((await At(e))?.filter((y) => cc(y) && y.name !== r && y.name !== l) ?? []).map(
    (y) => y.name
  ) ?? [], m = [r, l, c.objectIdField, ...f];
  if (!yr(c).isTable) {
    const { rendererField: y, rendererNormalizationField: p } = lb(c?.renderer ?? void 0);
    be(y) || m.push(y), be(p) || m.push(p);
  }
  const g = {
    ...i,
    orderByFields: [`${r} ${ri.Ascending}`],
    outFields: m
  };
  return d = await aa({
    queryObject: e,
    queryConfig: g,
    featureCount: n,
    abortKey: o
  }), d;
}
async function x0(t) {
  let e;
  const {
    chartConfig: i,
    queryConfig: a,
    queryObject: n,
    statsMap: o,
    numberOfFeatures: s,
    isAggregationMode: r,
    useQueryAttributeBins: l,
    errorStrings: c,
    abortKey: d
  } = t, u = i.series[0], { x: f, y: m } = u;
  if (!Number.isNaN(s) && s > 0) {
    const g = { ...a };
    g.where = Xe([g.where, `${f} IS NOT NULL`, `${m} IS NOT NULL`]), r ? e = await c0({
      chartConfig: i,
      queryObject: n,
      queryConfig: g,
      statsMap: o,
      useQueryAttributeBins: l,
      errorStrings: c,
      abortKey: d
    }) : e = await S0({
      queryObject: n,
      chartConfig: i,
      queryConfig: g,
      featureCount: s,
      abortKey: d
    });
  }
  return e;
}
async function $g(t) {
  const { chartConfig: e, queryConfig: i, queryObject: a, sortData: n, calculateTrendLine: o, options: s, abortKey: r } = t, l = await p0({
    chartConfig: e,
    queryConfig: i,
    queryObject: a,
    abortKey: r
  }), { queryNumberOfFeatures: c, yStep: d } = k.scatterplotAggregationFields, { maxScatterPointsBeforeAggregation: u } = to(s?.chartLimits), f = l?.get(c) ?? Number.NaN, m = f >= u, g = rb(a);
  m && await s0({
    statsMap: l,
    chartConfig: e,
    queryObject: a,
    options: s,
    queryConfig: i,
    abortKey: r
  });
  const y = await x0({
    ...t,
    statsMap: l,
    numberOfFeatures: f,
    isAggregationMode: m,
    useQueryAttributeBins: g
  }), p = await b0({
    queryObject: a,
    chartConfig: e,
    rawData: y,
    isAggregationMode: m,
    yStep: l.get(d),
    useQueryAttributeBins: g
  });
  n !== !1 && Zs({
    arrayToSort: p,
    sortingField: e.series[0].x,
    orderBy: ri.Ascending
  });
  const { r2: S, trendLinePoints: x } = o !== !1 ? await h0({
    data: p,
    statsMap: l,
    queryConfig: i,
    options: s,
    queryObject: a,
    chartConfig: e
  }) : k.scatterplotSeries;
  return { dataItems: p, r2: S, trendLinePoints: x };
}
function Vc(t) {
  const { itemsA: e, itemsB: i, isPieFromFields: a } = t;
  let n = !1;
  if (e === void 0 && i !== void 0 || e !== void 0 && i === void 0)
    n = !0;
  else if (!a) {
    const o = [
      k.originalCategoryValue,
      k.originalDateValue,
      k.xAxisField,
      k.technicalSortingFieldBySum,
      k.technicalSortingFieldByPercent,
      k.pieChart.technicalFieldSlicePercent,
      k.pieChart.technicalFieldGroupedSlices,
      k.pieChart.technicalFieldSliceId,
      k.typeOrDomainFieldName,
      k.typeOrDomainIdValue,
      k.originalServerBinningRange,
      k.lastTemporalBin,
      ot.uniqueIdsName,
      ...db
    ], s = (d, u) => {
      const f = u[k.typeOrDomainFieldName];
      typeof f == "string" && u[f] !== void 0 && (u[f] = u[k.typeOrDomainIdValue]);
      const m = {};
      return Object.keys(u).forEach((g) => {
        !o.includes(g) && !g.includes(k.rendererSymbolField) && (m[g] = u[g]);
      }), d.push(m), d;
    }, r = (d, u) => JSON.stringify(d).localeCompare(JSON.stringify(u)), l = e?.reduce(s, [])?.sort(r), c = i?.reduce(s, [])?.sort(r);
    n = !Di(l, c);
  }
  return n;
}
function C0(t) {
  const { chartConfig: e, currentSelectionDataItems: i, options: a } = t, { selectionData: n } = a ?? {};
  let o = [];
  if (e !== void 0) {
    const s = e.series, r = H(s), { selectionItems: l } = n ?? {};
    if (l !== void 0 && Vc({
      itemsA: l,
      itemsB: i,
      isPieFromFields: H(e.series) === L.PieFromFields
    }) ? o = l : o = i ?? [], s.length > 1 && r !== L.BarAndLineNoAggregation && r !== L.BarAndLineSplitByNoAggregation) {
      const c = Ze(s[0].query?.where);
      o = ns({ data: o, x: s[0].x, splitByField: c });
    }
    Hi({
      arrayToSort: o,
      chartConfig: e
    });
  }
  return o ?? [];
}
function _n(t, e) {
  let i = "";
  if (t.trim() !== "" && e !== void 0)
    if (e === null)
      i = `${t} IS NULL`;
    else {
      const a = typeof e != "number" ? "'" : "";
      i = `${t}=${a}${e.toString()}${a}`;
    }
  return i;
}
function v0(t) {
  const { dataContext: e, xAxisField: i, yAxisField: a, options: n } = t;
  let o = "";
  const { dataContextXMinField: s, dataContextXMaxField: r, dataContextYMinField: l, dataContextYMaxField: c } = k.scatterplotAggregationFields;
  if (Lc({ dataContext: e, chartLimits: n?.chartLimits })) {
    const { [s]: d, [r]: u } = e, f = i !== a ? e[l] : d, m = i !== a ? e[c] : u;
    if (!Number.isNaN(d) && !Number.isNaN(u) && !Number.isNaN(f) && !Number.isNaN(m)) {
      const g = [];
      d === u ? g.push(`${i}=${d?.toString()}`) : (g.push(`${i}>=${d?.toString()}`), g.push(`${i}<=${u?.toString()}`)), f === m ? g.push(`${a}=${f?.toString()}`) : (g.push(`${a}>=${f?.toString()}`), g.push(`${a}<=${m?.toString()}`)), o = Xe(g);
    }
  } else
    o = Xe([
      cn({ where: _n(i, e[i]) }),
      a !== void 0 ? cn({ where: _n(a, e[a]) }) : ""
    ]);
  return o;
}
function Pg(t, e) {
  let i = "";
  const a = e[k.originalServerBinningRange] ?? e[k.dateBinningRange];
  if (ac(a) && a.length === 2) {
    let [n, o] = a;
    typeof n == "number" && typeof o == "number" && Number.isFinite(n) && Number.isFinite(o) && (n = Xn(n), o = Xn(o));
    const s = e[k.lastTemporalBin] === !0 ? "<=" : "<";
    i = `${t}>='${n}' AND ${t}${s}'${o}'`;
  }
  return i;
}
function Rg(t, e) {
  let i = "";
  if (Number.isFinite(t)) {
    const a = 1 / 10 ** k.queryMaxFloatPrecision;
    i = `${e}>=${t - a} AND ${e}<=${t + a}`;
  }
  return i;
}
function Vg(t) {
  const { xAxisField: e, yAxisField: i, splitBy: a, dataContext: n, isDateAxis: o, xAxisFieldType: s, showOutliers: r, chartSubType: l } = t;
  let c = "";
  if (e !== void 0 && e !== k.boxPlot.boxPlotCategory) {
    let m = Zt({
      value: n[e],
      dataContext: n,
      keepNullValues: !0,
      specificField: k.typeOrDomainIdValue
    });
    s === fr.Double ? c = Rg(m, e) : (o && (m = Xn(m)), c = cn({
      where: _n(e, m),
      normalize: !1,
      escape: !0
    }));
  }
  const d = cn({ where: a ?? "", normalize: !1, escape: !0 });
  let u = "";
  if (r === !0) {
    const m = l === L.BoxPlotMultiFieldsAndCategory ? i : void 0, g = oe({
      key: Y.Min,
      showOutliers: !0,
      splitBy: a,
      y: m
    }), y = oe({
      key: Y.Max,
      showOutliers: !0,
      splitBy: a,
      y: m
    }), p = e === k.boxPlot.boxPlotCategory ? n[e] : i;
    if (!be(p)) {
      const S = n[g], x = n[y];
      Number.isFinite(S) && Number.isFinite(x) && (u = `${p?.toString()}>=${S?.toString()} AND ${p?.toString()}<=${x?.toString()}`);
    }
  }
  return Xe([c, d, u]);
}
function F0(t) {
  const { xAxisField: e, splitBy: i, dataContext: a, isDateAxis: n, xAxisFieldType: o, chartSubType: s } = t;
  let r = "";
  if (k.dateBinningRange in a)
    r = Pg(e, a);
  else if (s !== L.BarAndLineFromFields) {
    let d = Zt({
      value: a[e],
      dataContext: a,
      keepNullValues: !0,
      specificField: k.typeOrDomainIdValue
    });
    o === fr.Double ? r = Rg(d, e) : (n && (d = Xn(d)), r = cn({
      where: _n(e, d),
      normalize: !1,
      escape: !0
    }));
  }
  const l = cn({ where: i ?? "", normalize: !1, escape: !0 });
  return Xe([r, l]);
}
function L0(t) {
  const { xAxisField: e, dataContext: i, chartSubType: a } = t;
  let n = k.typeOrDomainIdValue in i ? i[k.typeOrDomainIdValue] : i[k.originalCategoryValue];
  return n === void 0 && (n = i[e]), a === L.PieFromFields ? "" : cn({
    where: _n(e, n),
    normalize: !1,
    escape: !0
  });
}
function A0(t) {
  const { xAxisField: e, dataContext: i, dataTransformationType: a } = t;
  let n = "";
  const { minValue: o, maxValue: s } = i;
  if (Number.isFinite(o) && Number.isFinite(s)) {
    const r = qS(e, a), l = i.isLastBin ? "<=" : "<";
    n = Xe([
      `${r}>=${o?.toString()}`,
      `${r}${l}${s?.toString()}`
    ]);
  }
  return n;
}
function Eg(t) {
  const { chartType: e } = t;
  let i = "";
  switch (e) {
    case b.ScatterSeries:
      i = v0(t);
      break;
    case b.RadarSeries:
    case b.BarSeries:
    case b.LineSeries:
    case b.ComboLineAndBarSeries:
      i = F0(t);
      break;
    case b.BoxPlotSeries:
      i = Vg(t);
      break;
    case b.HistogramSeries:
      i = A0(t);
      break;
    case b.PieSeries:
      i = L0(t);
      break;
  }
  return i;
}
async function T0(t) {
  const { queryObject: e, queryConfig: i, chartConfig: a, currentSelectionDataItems: n, options: o, errorStrings: s, abortKey: r } = t, l = H(a.series);
  let c = { valid: !0, data: { dataItems: [] } };
  if (n !== void 0 && n.length > 0) {
    const d = ha(a), { x: u } = d, f = "y" in d ? d.y : "", m = mi(a.axes?.[0].valueFormat), g = Mi(a);
    let y;
    e !== void 0 && (y = (await At(e)).find((A) => A.name === u)?.type);
    const p = [], S = n.reduce(
      (v, A) => {
        let w = "";
        if (ot.uniqueIdsName in A)
          p.push(A[ot.uniqueIdsName]);
        else {
          switch (l) {
            case L.BoxPlotMonoFieldAndSplitBy:
            case L.BoxPlotMultiFieldsAndSplitBy:
            case L.BoxPlotMonoFieldAndCategoryAndSplitBy: {
              w = d.query?.where ?? "";
              const M = Ze(w);
              let P = "";
              const R = `_${Y.Average}`;
              Object.keys(A).forEach(($) => {
                $.includes(R) && (P = $.replace(R, ""));
              }), P.trim() !== "" && (w = _n(M, P));
              break;
            }
          }
          const O = [f].flat();
          let I = O.length === 1 ? O[0] : "";
          if (l === L.BoxPlotMultiFieldsAndCategory) {
            const M = `_${Y.FirstQuartile}`, P = Object.keys(A).find((R) => R.includes(M));
            P !== void 0 && (I = P.replace(M, ""));
          }
          const N = Vg({
            xAxisField: u,
            yAxisField: I,
            splitBy: w,
            dataContext: A,
            isDateAxis: m,
            xAxisFieldType: y,
            showOutliers: g,
            chartSubType: l
          });
          v.push(N);
        }
        return v;
      },
      []
    ), x = we(e);
    if (x !== void 0 && p.length > 0) {
      const { objectIdField: v } = x;
      S.push(`${v} IN (${p.join(",")})`);
    }
    const C = S.join(" OR "), F = { ...i };
    F.where = Xe([F.where, C]), c = await Ec({
      queryObject: e,
      chartConfig: a,
      queryConfig: F,
      options: o,
      errorStrings: s,
      abortKey: r
    });
  }
  return c;
}
async function w0(t) {
  const { queryObject: e, queryConfig: i, chartConfig: a, currentSelectionDataItems: n, options: o, errorStrings: s, abortKey: r } = t, { series: l } = a, c = z(l), d = ii(a);
  let u = { valid: !0 };
  const f = C0({ chartConfig: a, currentSelectionDataItems: n, options: o });
  let m = !1;
  switch (c) {
    case b.PieSeries:
      if (H(a.series) === L.PieFromFields) {
        const { x: g, y } = a.series[0], p = Ee(f);
        p.forEach((S) => {
          g in S && (S[tt] = S[g], delete S[g]), y in S && (S[Rt] = S[y], delete S[y]);
        }), u.data = { dataItems: p };
      } else
        u.data = { dataItems: f };
      u.count = f.length, m = !0;
      break;
    case b.BoxPlotSeries:
      u = await T0(t);
      break;
    case b.BarSeries:
    case b.ComboLineAndBarSeries:
    case b.RadarSeries:
    case b.LineSeries:
      if (f.length === 0 || !ei({
        xAxisValueFormatType: d,
        setTimeBinningInfoWhenNotProvided: o?.setTimeBinningInfoWhenNotProvided,
        seriesConfig: l[0]
      }))
        u.data = { dataItems: f }, u.count = f.length * l.length, m = !0;
      else {
        const g = { ...i };
        if (n !== void 0 && n.length > 0) {
          const p = n.map(
            (x) => Pg(l[0].x, x)
          ), S = Xe(p, "OR");
          g.where = Xe([g.where, S]);
        }
        u = await zc({
          queryObject: e,
          queryConfig: g,
          chartConfig: a,
          options: o
        });
      }
      break;
    case b.HistogramSeries: {
      if (f.length === 0)
        u.data = {
          mean: Number.NaN,
          median: Number.NaN,
          stddev: Number.NaN,
          max: Number.NaN,
          min: Number.NaN,
          bins: []
        }, u.count = 0;
      else {
        const { x: g } = l[0], y = f.map((x, C) => {
          const { minValue: F, maxValue: v } = x, A = C === f.length - 1 ? "<=" : "<";
          return `${g} >= ${F} AND ${g} ${A} ${v}`;
        }), p = Xe(y, "OR"), S = { ...i };
        S.where = Xe([S.where, p]), u = await Ng({
          queryObject: e,
          chartConfig: a,
          queryConfig: S,
          options: o,
          errorStrings: s,
          abortKey: r
        });
      }
      break;
    }
    case b.ScatterSeries: {
      if (f.length === 0) {
        const { r2: g, trendLinePoints: y } = k.scatterplotSeries;
        u.data = { dataItems: [], r2: g, trendLinePoints: y, count: 0 }, u.count = 0;
      } else {
        const { r2: g, trendLinePoints: y } = Mg({
          data: f,
          chartConfig: a
        });
        u.data = { dataItems: f, r2: g, trendLinePoints: y }, u.count = f.length;
      }
      break;
    }
  }
  return m && u.data !== void 0 && Hi({
    arrayToSort: "dataItems" in u.data ? u.data.dataItems : u.data,
    chartConfig: a
  }), u;
}
async function Ec(t) {
  const { queryObject: e, chartConfig: i, queryConfig: a, options: n, errorStrings: o, abortKey: s } = t;
  let r = { valid: !0 };
  const l = qe(i), c = await Hl({
    queryObject: e,
    queryConfig: a,
    fetchFullBoxPlotData: !l,
    options: n,
    chartConfig: i,
    abortKey: s
  });
  if (!l)
    r = c;
  else {
    const d = { dataItems: [] };
    d.meanLines = c.data.dataItems;
    const u = Or(i), f = (await Hl({
      queryObject: e,
      queryConfig: a,
      fetchFullBoxPlotData: !0,
      options: n,
      chartConfig: u,
      abortKey: s
    })).data;
    d.dataItems = f.dataItems, d.outliers = f.outliers, r.data = d;
  }
  return r;
}
async function k0(t) {
  const { queryObject: e, chartConfig: i, queryConfig: a, binnedServerData: n, options: o, errorStrings: s, abortKey: r, fieldList: l } = t, { series: c } = i, { filterBySelection: d } = o ?? {}, u = z(c);
  let f = { valid: !0 };
  if (d === !0)
    f = await w0(t);
  else
    switch (u) {
      case b.BoxPlotSeries:
        f = await Ec(t);
        break;
      case b.BarSeries:
      case b.ComboLineAndBarSeries:
      case b.PieSeries:
      case b.RadarSeries:
      case b.LineSeries: {
        const m = {
          queryObject: e,
          queryConfig: a,
          chartConfig: i,
          options: o,
          abortKey: r,
          fieldList: l
        };
        ei({
          xAxisValueFormatType: ii(i),
          setTimeBinningInfoWhenNotProvided: o?.setTimeBinningInfoWhenNotProvided,
          seriesConfig: c[0]
        }) ? (n !== void 0 && (m.binnedServerData = n), f = await zc(m)) : f = await Hl(m);
        break;
      }
      case b.ScatterSeries:
        f.data = await $g({
          queryObject: e,
          queryConfig: a,
          options: o,
          chartConfig: i,
          errorStrings: s,
          abortKey: r
        });
        break;
      case b.HistogramSeries:
        f = await Ng({
          queryObject: e,
          queryConfig: a,
          chartConfig: i,
          options: o,
          abortKey: r,
          errorStrings: s
        });
        break;
      case b.GaugeSeries:
        f = await Gv({
          queryObject: e,
          chartConfig: i,
          queryConfig: a,
          options: o,
          abortKey: r
        });
        break;
    }
  return f;
}
async function uo(t) {
  const {
    queryObject: e,
    chartConfig: i,
    abortKey: a,
    currentSelectionDataItems: n,
    binnedServerData: o,
    options: s,
    errorStrings: r,
    fieldList: l
  } = t;
  let c = { valid: !0 };
  const d = Wf({
    queryObject: e,
    chartConfig: i,
    runtimeDataFilters: s?.runtimeDataFilters,
    ignoreViewExtent: s?.ignoreViewExtent
  });
  return dc(a), c = await k0({
    chartConfig: i,
    queryObject: e,
    queryConfig: d,
    currentSelectionDataItems: n,
    binnedServerData: o,
    options: s,
    abortKey: a,
    errorStrings: r,
    fieldList: l
  }), c.queryConfig = d, c;
}
function I0(t, e, i) {
  const a = /* @__PURE__ */ new Map();
  for (let o = 0; o < t.length; o += 1)
    a.set(t[o], { [i]: t[o] });
  for (let o = 0; o < e.length; o += 1) {
    const s = e[o][i];
    (typeof s == "string" || typeof s == "number") && a.set(s, e[o]);
  }
  return [...a.values()];
}
async function O0(t) {
  const { seriesData: e, chartConfig: i, queryConfig: a, queryObject: n, categoryOrDateCount: o, behaviorAfterLimit: s, abortKey: r } = t, { series: l } = i;
  let c = e;
  const d = H(l), u = ii(i);
  if (s !== eo.RenderUpToTheLimit && n !== void 0 && o !== void 0 && o > e.length && d !== L.BarAndLineFromFields && d !== L.BarAndLineNoAggregation && d !== L.PieNoAggregation && u === b.CategoryAxisFormat) {
    const { x: f } = l[0], m = {
      ...a,
      returnDistinctValues: !0,
      outFields: [f]
    };
    delete m.outStatistics, delete m.orderByFields, delete m.groupByFieldsForStatistics;
    const y = (await aa({
      queryObject: n,
      queryConfig: m,
      featureCount: o,
      abortKey: r
    })).map((p) => p.attributes[f]).filter((p) => p != null);
    y.length > e.length && (c = I0(y, e, f));
  }
  return c;
}
function B0(t, e) {
  const i = t, { series: a } = e;
  if (ii(e) === b.CategoryAxisFormat && a[0].query?.outStatistics?.[0].statisticType === X.Count) {
    const n = a.reduce(
      (o, s) => {
        const r = s.query?.outStatistics?.[0].outStatisticFieldName ?? [s.y].flat()[0];
        return o[r] = 0, o;
      },
      {}
    );
    for (let o = 0; o < t.length; o += 1)
      t[o] = { ...n, ...t[o] };
  }
  return i;
}
const Wg = [
  L.BarAndLineMonoField,
  L.BarAndLineMultiFields,
  L.PieNoAggregation,
  L.PieFromCategory,
  L.BoxPlotMonoFieldAndCategory,
  L.BoxPlotMultiFieldsAndCategory,
  L.BoxPlotMonoFieldAndCategoryAndSplitBy
];
function zg(t, e) {
  let i = t;
  return e === Q.Week ? i /= 7 : e === Q.Month ? i /= 30 : e === Q.Year && (i /= 365), i = Math.ceil(i), i;
}
function Va(t) {
  const { date: e, unit: i, nextOrPrevious: a, size: n } = t;
  if (n !== void 0 && Number.isFinite(n)) {
    const o = a === "next" ? n : -n;
    switch (i) {
      case Q.Second:
        return K.fromMillis(e).plus({ seconds: o }).valueOf();
      case Q.Minute:
        return K.fromMillis(e).plus({ minutes: o }).valueOf();
      case Q.Hour:
        return K.fromMillis(e).plus({ hours: o }).valueOf();
      case Q.Week:
      case Q.Day:
        return K.fromMillis(e).plus({ days: o }).valueOf();
      case Q.Month:
        return K.fromMillis(e).plus({ months: o }).valueOf();
      case Q.Year:
        return K.fromMillis(e).plus({ years: o }).valueOf();
    }
  }
  return e;
}
function D0(t) {
  const { binFirstOrLastIndex: e, data: i, x: a, timeIntervalInfo: n } = t, { unit: o, size: s } = n, r = o === Q.Week ? (s ?? 1) * 7 : s, l = i[e][a];
  let c = e;
  const d = Va({
    date: l,
    unit: o,
    size: r,
    nextOrPrevious: "next"
  });
  let u = i[c][a];
  for (; c + 1 < i.length && u < d; )
    c += 1, u = i[c]?.[a];
  const f = c + 1 >= i.length;
  let m = c;
  f && i[m] !== void 0 && (m += 1);
  const g = f ? Va({
    date: l,
    unit: o,
    size: r,
    nextOrPrevious: "next"
  }) : i[c][a];
  return {
    binStartDate: l,
    binEndDate: g,
    last: f,
    nextBinFirstOrLastIndex: c,
    sliceStartIndex: e,
    sliceEndIndex: m
  };
}
function N0(t) {
  const { binFirstOrLastIndex: e, data: i, x: a, timeIntervalInfo: n } = t, { unit: o, size: s } = n, r = o === Q.Week ? (s ?? 1) * 7 : s, l = i[e][a];
  let c = e;
  const d = Va({
    date: l,
    unit: o,
    size: r,
    nextOrPrevious: "previous"
  });
  let u = i[c][a];
  for (; c - 1 >= 0 && u > d; )
    c -= 1, u = i[c]?.[a];
  const f = c - 1 <= 0;
  let m = e;
  return f && i[m] !== void 0 && (m -= 1), f && (c = 0), {
    binStartDate: f ? Va({
      date: l,
      unit: o,
      size: r,
      nextOrPrevious: "previous"
    }) : i[c][a],
    binEndDate: l,
    nextBinFirstOrLastIndex: c,
    sliceStartIndex: c,
    sliceEndIndex: m,
    last: f
  };
}
function M0(t) {
  const { binsToRegroup: e, statisticType: i, y: a, nullPolicy: n } = t;
  let o;
  n !== on.Interpolate && (o = n === on.Zero ? 0 : null);
  const s = e.filter((r) => Number.isFinite(r[a]));
  if (s.length > 0)
    switch (i) {
      case X.Count:
      case X.Sum:
        o = $b(s, (r) => r[a]);
        break;
      case X.Minimum:
        o = Mb(s, (r) => r[a]);
        break;
      case X.Maximum:
        o = Nb(s, (r) => r[a]);
        break;
      case X.Average:
        o = Db(s, (r) => r[a]);
        break;
      case X.ContinuousPercentile:
    }
  return o;
}
function $0(t) {
  const { data: e, seriesConfig: i, timeIntervalInfo: a, dateMinTimestamp: n, dateMaxTimestamp: o } = t;
  let s = [];
  const { unit: r } = a, l = a.size ?? 1, c = i[0], { x: d } = c;
  let u, f;
  if (ci(c) && (f = c.temporalBinning?.nullPolicy, u = c.temporalBinning?.timeAggregationType), l > 1 || r === Q.Week || r === Q.Month || r === Q.Year) {
    const { query: m } = i[0], g = pt(i), { statisticType: y } = m?.outStatistics?.[0] ?? mr;
    let p = !1, S = u === Yt.End ? e.length - 1 : 0;
    const x = {
      binFirstOrLastIndex: S,
      data: e,
      x: d,
      timeIntervalInfo: a
    };
    for (; !p; ) {
      let C = {};
      const { binStartDate: F, binEndDate: v, last: A, nextBinFirstOrLastIndex: w, sliceStartIndex: O, sliceEndIndex: I } = u === Yt.End ? (
        // When grouping from the end we'll start from the last date and move backward to create the bins
        N0(x)
      ) : (
        // When grouping from the start we'll start from the first date and move forward to create the bins
        D0(x)
      );
      if (p = A, C = u === Yt.End ? C = e[I - 1] : C = e[S], v > o && F < o || F < n && v > n || F >= n && v <= o) {
        const N = e.slice(O, I).filter((R) => !(k.dateBinModel in R));
        g.forEach((R) => {
          C[R] = M0({ binsToRegroup: N, statisticType: y, y: R, nullPolicy: f });
        });
        const M = N.map((R) => R[Oa]).filter((R) => R !== void 0), P = VS(M);
        P !== void 0 && (C[Oa] = P), C[d] = F, C[k.xAxisField] = F, C[k.dateBinningRange] = [F, v], delete C[k.dateBinModel], s.push(C);
      } else A && u !== Yt.End && s.length > 0 && (s[s.length - 1][k.dateBinningRange][1] = s[s.length - 1][k.dateBinningRange][1] + 1);
      S = w, x.binFirstOrLastIndex = w;
    }
    u === Yt.End && (s = s.reverse());
  } else l === 1 ? s = e.map((m, g) => {
    const y = m[d];
    let p = e[g + 1]?.[d];
    return p = typeof p == "number" ? p - 1 : Va({
      date: y,
      unit: r,
      size: l,
      nextOrPrevious: "next"
    }), {
      ...m,
      [k.dateBinningRange]: [y, p]
    };
  }) : s = e;
  return s;
}
function Hg(t) {
  const { dateMinTimestamp: e, dateMaxTimestamp: i, timeIntervalInfo: a } = t, { size: n, unit: o } = a;
  let s = 0, r = 0;
  if (n !== void 0 && Number.isFinite(n) && Number.isFinite(e) && Number.isFinite(i)) {
    let l = -1;
    const c = K.fromMillis(e), d = K.fromMillis(i);
    switch (o) {
      case Q.Second:
        l = d.diff(c, "seconds").get("seconds");
        break;
      case Q.Minute:
        l = d.diff(c, "minutes").get("minutes");
        break;
      case Q.Hour:
        l = d.diff(c, "hours").get("hours");
        break;
      case Q.Day:
      case Q.Month:
      case Q.Year:
        l = d.diff(c, "days").get("days");
        break;
      case Q.Week:
        l = d.diff(c, "weeks").get("weeks");
        break;
    }
    Number.isFinite(l) && (r = Math.ceil(l) + 1, s = n === 1 ? r : Math.ceil(r / n));
  }
  return { numberOfFinalBinsWithinDataRange: s, numberOfSingleBinsWithinDataRange: r };
}
function qg(t) {
  const e = t[0].temporalBinning?.nullPolicy;
  return t.reduce(
    (a, n) => {
      a[k.dateBinModel] = void 0;
      const o = n.query?.outStatistics?.[0].outStatisticFieldName ?? [n.y].flat()[0];
      return e !== on.Interpolate && (a[o] = e === on.Zero ? 0 : null), a;
    },
    {}
  );
}
function P0(t) {
  const {
    dateMaxTimestamp: e,
    numberOfFinalBinsWithinDataRange: i,
    numberOfSingleBinsWithinDataRange: a,
    data: n,
    seriesConfig: o,
    timeIntervalInfo: s
  } = t, { size: r, unit: l } = s, { x: c } = o[0], d = o[0].temporalBinning?.timeAggregationType;
  let u = n[0][c], f = e;
  if (r !== void 0 && Number.isFinite(r) && a / i !== r) {
    let g = Math.ceil(a / i) * i - a;
    l === Q.Week && (g *= 7);
    const y = qg(o);
    if (d === Yt.End) {
      let p = n[0][c];
      for (let S = 0; S < g; S += 1)
        p = Va({
          date: p,
          unit: l,
          size: 1,
          nextOrPrevious: "previous"
        }), n.push({
          ...y,
          [c]: p,
          [k.xAxisField]: p
        });
      g > 0 && (u = n[n.length - 1][c]);
    } else {
      let p = n[n.length - 1][c];
      for (let S = 0; S < g; S += 1)
        p = Va({
          date: p,
          unit: l,
          size: 1,
          nextOrPrevious: "next"
        }), n.push({
          ...y,
          [c]: p,
          [k.xAxisField]: p
        });
      f = n[n.length - 1][c];
    }
  }
  return { newDateMin: u, newDateMax: f };
}
function R0(t) {
  const { numberOfSingleBinsWithinDataRange: e, dataLength: i, unit: a } = t;
  return zg(i, a) >= e;
}
async function V0(t) {
  const { queryObject: e, queryConfig: i, x: a } = t, n = `MIN_${a}`, o = `MAX_${a}`, s = `COUNT_${a}`, r = {
    ...i,
    outStatistics: [
      {
        statisticType: X.Minimum,
        onStatisticField: a,
        outStatisticFieldName: n
      },
      {
        statisticType: X.Maximum,
        onStatisticField: a,
        outStatisticFieldName: o
      },
      {
        statisticType: X.Count,
        onStatisticField: a,
        outStatisticFieldName: s
      }
    ]
  };
  delete r.groupByFieldsForStatistics, delete r.orderByFields;
  const l = await Zo({
    queryObject: e,
    queryConfig: r
  });
  let c = l.get(n), d = l.get(o);
  const u = l.get(s);
  return typeof c == "string" && (c = new Date(c).valueOf()), typeof d == "string" && (d = new Date(d).valueOf()), { dateRange: { dateMinTimestamp: c, dateMaxTimestamp: d }, numberOfFeatures: u };
}
function E0(t) {
  const {
    newDateMin: e,
    newDateMax: i,
    seriesConfig: a,
    data: n,
    numberOfSingleBinsWithinDataRange: o,
    initialNumberOfBins: s,
    timeIntervalInfo: r
  } = t, { unit: l } = r, c = n;
  if (!R0({
    numberOfSingleBinsWithinDataRange: o,
    dataLength: s,
    unit: l
  })) {
    const { x: u } = a[0], f = a[0].temporalBinning?.timeAggregationType, m = qg(a);
    let y = f === Yt.End ? i : e, p = f === Yt.End ? n.length - 1 : 0;
    for (; p < n.length && (f === Yt.End && y > e || f !== Yt.End && y < i); )
      y !== n[p][u] ? c.push({
        ...m,
        [u]: y,
        [k.xAxisField]: y
      }) : p = f === Yt.End ? p - 1 : p + 1, y = Va({
        date: y,
        unit: l === Q.Month || l === Q.Year ? Q.Day : l,
        size: 1,
        nextOrPrevious: f === Yt.End ? "previous" : "next"
      });
  }
  return c;
}
function W0(t) {
  const { data: e, seriesConfig: i, dateMinTimestamp: a, dateMaxTimestamp: n } = t, o = e;
  if (i[0].temporalBinning?.trimIncompleteTimeInterval !== !1) {
    const { timeAggregationType: s } = i[0].temporalBinning ?? {}, r = e[0]?.[k.dateBinningRange]?.[0], l = e[e.length - 1]?.[k.dateBinningRange]?.[1];
    if (s === Yt.End ? r < a : l > n)
      if (s === Yt.End) {
        let d = r;
        for (; d < a && e.length > 0; )
          e.shift(), e.length > 0 && (d = e[0][k.dateBinningRange]?.[0]);
      } else {
        let d = l;
        for (; d > n && e.length > 0; )
          e.pop(), e.length > 0 && (d = e[e.length - 1][k.dateBinningRange]?.[1]);
      }
  }
  return o;
}
function z0(t) {
  const { groupByFieldsForStatistics: e, dateField: i, queryStartDate: a, queryEndDate: n, y: o, binIndex: s, lastBin: r } = t;
  let l = e === "" ? fn.groupByCaseBegin : e;
  return l = Gt(fb, {
    groupByFieldsForStatistics: l,
    dateField: i,
    startDate: `${a}`,
    endDate: `${n}`,
    y: [o].flat()[0],
    binIndex: `${s}`,
    endDateOperand: r ? "<=" : "<"
    // we use <= to catch the last bin's value, < otherwise
  }), l;
}
function* H0(t) {
  const { queryObject: e, seriesConfig: i, queryConfig: a, completeData: n } = t;
  for (let o = 0; o < i.length; o += 1) {
    const s = i[o], { query: r, x: l, y: c } = s, u = [
      {
        onStatisticField: r?.outStatistics?.[0]?.onStatisticField ?? "",
        outStatisticFieldName: X.ContinuousPercentile,
        statisticType: X.ContinuousPercentile,
        statisticParameters: { value: 0.5 }
      }
    ];
    let f = fn.groupByCaseBegin;
    for (let g = 0; g < n.length; g += 1) {
      const y = n[g], [p, S] = y[k.dateBinningRange], x = Xn(p), C = Xn(S);
      f = z0({
        groupByFieldsForStatistics: f,
        queryStartDate: x,
        queryEndDate: C,
        dateField: l,
        y: [c].flat()[0],
        binIndex: g,
        lastBin: g === n.length - 1
      });
    }
    f = `${f} ${fn.groupByCaseEnd}`;
    const m = {
      ...a,
      groupByFieldsForStatistics: [f],
      outStatistics: u,
      orderByFields: void 0
    };
    yield aa({
      queryObject: e,
      queryConfig: m,
      noBatch: !0
    });
  }
}
async function q0(t) {
  const { queryObject: e, data: i, seriesConfig: a, queryConfig: n } = t, o = i, { statisticType: s } = a[0].query?.outStatistics?.[0] ?? mr;
  if (s === X.ContinuousPercentile && o.length > 0) {
    const r = H0({
      queryObject: e,
      completeData: o,
      seriesConfig: a,
      queryConfig: n
    }), l = (await Promise.all(r)).flat();
    if (l.length > 0) {
      const { isInItem: c, expr: d } = hr(l[0].attributes);
      c && l.forEach((u) => {
        const f = u.attributes[`${d}`];
        if (f !== void 0) {
          const [m, g] = f.split("|");
          if (g !== void 0) {
            const y = u.attributes[X.ContinuousPercentile];
            o[g][`${m}`] = y;
          }
        }
      });
    }
  }
  return o;
}
async function G0(t) {
  const { queryResults: e, mapToStatField: i, splitByField: a, x: n, y: o, nullPolicy: s, queryObject: r } = t, l = ub(n), d = (await At(r)).find((f) => f.name === n)?.type, u = [];
  return e.forEach((f) => {
    const { attributes: m, stackedAttributes: g } = f;
    let y = m[l.lowerBoundaryAlias], p = m[l.upperBoundaryAlias];
    const S = y, x = p, C = (v) => {
      const { boundary: A, separator: w, xFieldType: O } = v;
      let I = A;
      return O === fr.DateOnly && (typeof A == "string" && A.length === 10 || typeof A == "number") ? (I = new Date(A), I = new Date(I.valueOf() + I.getTimezoneOffset() * 6e4).valueOf()) : typeof A == "string" && A.lastIndexOf(w) === A.length - 6 && (I = new Date(A.slice(0, A.lastIndexOf(w))).valueOf()), I;
    };
    ["+", "-"].forEach((v) => {
      y = C({ boundary: y, separator: v, xFieldType: d }), p = C({ boundary: p, separator: v, xFieldType: d });
    });
    const F = (v, A) => {
      A && s === on.Zero && (v[A] === void 0 || v[A] === null) && (v[A] = 0);
    };
    if (typeof y == "number" && typeof p == "number") {
      const v = { ...m };
      v[k.originalServerBinningRange] = [S, x], v[n] = y, v[k.xAxisField] = y, v[k.dateBinningRange] = [y, p], delete v[l.lowerBoundaryAlias], delete v[l.upperBoundaryAlias], g && a && !be(a) && i ? g.forEach((A) => {
        const w = A[a];
        if (w === null || typeof w == "string" || typeof w == "number") {
          const O = i?.get(w);
          O !== void 0 && (v[O] = A[ot.outStatistics?.outStatisticFieldName ?? ""], F(v, O));
        }
      }) : F(v, o), u.push(v);
    }
  }), u;
}
async function Y0(t) {
  const { queryObject: e, queryResults: i, x: a, queryConfig: n, seriesConfig: o, dateRange: s, timeIntervalInfo: r } = t, { dateMinTimestamp: l, dateMaxTimestamp: c } = s;
  let d = i;
  const u = i.length;
  if (Zs({
    arrayToSort: d,
    sortingField: a
  }), u > 1) {
    const { numberOfFinalBinsWithinDataRange: f, numberOfSingleBinsWithinDataRange: m } = Hg({
      dateMinTimestamp: l,
      dateMaxTimestamp: c,
      timeIntervalInfo: r
    }), { newDateMin: g, newDateMax: y } = P0({
      dateMaxTimestamp: c,
      data: d,
      numberOfFinalBinsWithinDataRange: f,
      numberOfSingleBinsWithinDataRange: m,
      seriesConfig: o,
      timeIntervalInfo: r
    });
    d = E0({
      newDateMin: g,
      newDateMax: y,
      seriesConfig: o,
      data: d,
      initialNumberOfBins: u,
      numberOfSingleBinsWithinDataRange: m,
      timeIntervalInfo: r
    }), Zs({
      arrayToSort: d,
      sortingField: a
    }), d = $0({
      data: d,
      seriesConfig: o,
      dateMinTimestamp: l,
      dateMaxTimestamp: c,
      timeIntervalInfo: r
    }), d = W0({
      data: d,
      seriesConfig: o,
      dateMinTimestamp: l,
      dateMaxTimestamp: c
    }), d = await q0({ queryObject: e, data: d, seriesConfig: o, queryConfig: n });
  }
  return d;
}
function X0(t) {
  return Math.floor(Math.min(Math.max(8, Math.sqrt(t ?? 8)), 128) + 0.5);
}
function U0(t) {
  const { dateRange: e, numberOfFeatures: i } = t;
  let { dateMinTimestamp: a, dateMaxTimestamp: n } = e;
  typeof a == "string" && (a = new Date(a).valueOf()), typeof n == "string" && (n = new Date(n).valueOf());
  const o = X0(i), s = (n - a) / o, r = Hd.findIndex((S) => S.threshold > s), l = Hd[r], { unitMs: c, preferredIntervalSize: d, unit: u } = l, f = s / c, m = d.findIndex(
    (S) => S >= f
  ), g = d[m], y = m === 0 ? d[0] : d[m - 1];
  return { size: g - f < f - y ? g : y, unit: u };
}
function j0(t) {
  const { series: e, isTimeBinningSeries: i, setTimeBinningInfoWhenNotProvided: a } = t;
  let n = !1;
  if (ci(e) && i) {
    const { unit: o, size: s } = e.temporalBinning ?? {};
    n = !Bl(o, s) && a === !0;
  }
  return n;
}
function _0(t) {
  const e = [];
  for (let i = 1; i <= 6; i += 1) {
    const a = t[`EXPR_${i}`] ?? t[`Expr${i}`] ?? t[`expr${i}`] ?? t[`EXPR${i}`];
    a !== null && e.push(a);
  }
  return K.local(
    Number(e[0] ?? 1969),
    Number(e[1] ?? 1),
    Number(e[2] ?? 1),
    Number(e[3] ?? 0),
    Number(e[4] ?? 0),
    Number(e[5] ?? 0)
  ).valueOf();
}
function Z0(t) {
  const { feature: e, splitByField: i, chartSubType: a } = t, { extent: n } = e.aggregateGeometries ?? e.geometry ?? {}, o = n?.toJSON();
  let s = Oa;
  return o !== void 0 && i !== void 0 && a !== void 0 && a === L.BarAndLineSplitBy && (s = e.attributes[i] !== void 0 ? `${Oa}_${e.attributes[i]}` : Oa), { featureExtent: o, featureExtentKey: s };
}
function Q0(t) {
  const { input: e, x: i, splitByField: a } = t;
  return e.reduce((o, s) => (a !== void 0 && a !== i && delete s[a], Object.assign(o, s)), {});
}
function ns(t) {
  const { data: e, x: i, splitByField: a } = t;
  let n = e;
  return e !== void 0 && e.length > 0 && (n = [...Pb(
    e,
    (s) => Q0({ input: s, x: i, splitByField: a }),
    (s) => s[i]
    // the field used to regroup the stats (ex: 'Year' category)
  ).values()]), n;
}
function K0(t, e) {
  const i = t, a = z(e);
  if (a !== b.PieSeries && a !== b.BoxPlotSeries) {
    const n = pt(e), o = e[0].y;
    t.forEach((s) => {
      let r = 0;
      if (n.forEach((l) => {
        const c = s[l];
        Number.isFinite(c) && (r += c);
      }), s[k.technicalSortingFieldBySum] = r, Number.isFinite(r) && r > 0) {
        const l = s[o];
        if (Number.isFinite(l)) {
          const c = l / r;
          s[k.technicalSortingFieldByPercent] = c;
        }
      }
    });
  }
  return i;
}
function J0(t, e) {
  const i = e, a = pt(t), n = a.length === 1;
  return a.forEach((o) => {
    const s = ko(n ? void 0 : o), r = i[s[Y.FirstQuartile]], l = i[s[Y.ThirdQuartile]];
    Number.isFinite(r) && Number.isFinite(l) && l >= r && (i[s[Y.IQR]] = l - r);
  }), i;
}
function Wc(t, e) {
  [e].flat().forEach((i) => {
    i && (t[i] === void 0 && (t[i] = t[i.toUpperCase()] !== void 0 ? t[i.toUpperCase()] : t[i.toLowerCase()]), t[i] !== void 0 ? (i !== i.toUpperCase() && delete t[i.toUpperCase()], i !== i.toLowerCase() && delete t[i.toLowerCase()]) : delete t[i]);
  });
}
function eF(t, e) {
  const i = Array.from(
    new Set(
      e.flatMap((a) => a.query?.outStatistics?.map((n) => n.outStatisticFieldName))
    )
  );
  i.push(ot.outStatistics.outStatisticFieldName), Wc(t, i);
}
function tF(t, e) {
  let i = { ...t };
  return t !== void 0 && e[0] !== void 0 && (i = Object.keys(t).reduce((a, n) => {
    const o = e.find(
      (s) => s.outStatisticFieldName?.toLowerCase() === n.toLowerCase()
    )?.onStatisticField;
    return o !== void 0 && t[n] !== void 0 && o !== n ? a[o] = t[n] : a[n] = t[n], a;
  }, {})), i;
}
function iF(t) {
  const { dataItem: e, splitByField: i, y: a } = t;
  if (e !== void 0 && !be(i) && !be(a)) {
    const n = e[i], o = `${a}_${n?.toString()}`;
    e[o] = e[a], delete e[a];
  }
}
function aF(t, e) {
  Object.keys(t).forEach((a) => {
    if (a.startsWith(`${e}_`)) {
      const n = a.slice(e.length + 1);
      t[n] = t[a], delete t[a];
    }
  });
}
function nF(t, e) {
  let i = 1;
  switch (t) {
    case L.BarAndLineFromFields:
    case L.PieFromFields:
      i = e.series[0].query?.outStatistics?.length ?? 1;
      break;
    case L.BoxPlotMultiFields:
    case L.BoxPlotMultiFieldsAndSplitBy:
      i = e.series[0].y.length;
      break;
    case L.BarAndLineNoAggregation:
    case L.BoxPlotMonoField:
    case L.BoxPlotMonoFieldAndCategory:
    case L.BoxPlotMultiFieldsAndCategory:
    case L.BoxPlotMonoFieldAndSplitBy:
    case L.BoxPlotMonoFieldAndCategoryAndSplitBy:
    case L.PieFromCategory:
    case L.BarAndLineSplitByNoAggregation:
    case L.PieNoAggregation:
    case L.BarAndLineSplitBy:
    case L.BarAndLineMonoField:
    case L.BarAndLineMultiFields:
    case L.NonSpecific:
  }
  return i;
}
function oF(t) {
  const { attributes: e, showMean: i, chartSubType: a } = t;
  i && (a === L.BoxPlotMonoFieldAndSplitBy || a === L.BoxPlotMultiFieldsAndSplitBy || a === L.BoxPlotMonoFieldAndCategoryAndSplitBy) && (e[k.boxPlot.boxPlotMeanLineMarkerId] = !0);
}
function sF(t) {
  const { queryResponse: e, chartConfig: i, maxCategoryCount: a } = t, n = H(i.series);
  return a && Number.isFinite(a) && a < e.length && Wg.includes(n) ? e.slice(0, a) : e;
}
function rF(t) {
  const { attributes: e, uniqueCategoryList: i, maxCategoryCount: a, x: n, chartSubType: o } = t;
  let s = !1;
  if (n && a && Number.isFinite(a) && !Wg.includes(o))
    if ((o === L.BarAndLineFromFields || o === L.PieFromFields) && Object.keys(e).length > a)
      Object.keys(e).filter((r) => r !== X.EnvelopeAggregate).forEach((r, l) => {
        l >= a && delete e[r];
      });
    else {
      const r = e[n];
      r !== void 0 && (i.size === a && !i.has(r) ? s = !0 : i.add(r));
    }
  return s;
}
function lF(t) {
  const {
    queryResponse: e,
    chartConfig: i,
    mapToStatField: a,
    splitByField: n,
    fieldOID: o,
    isDateField: s,
    isTimeBinningSeries: r,
    subtypeInfo: l,
    resultLimit: c,
    showMean: d,
    chartLimits: u,
    fieldList: f
  } = t, { series: m } = i, g = H(m), y = z(m), { x: p } = m[0], S = "y" in m[0] ? m[0].y : void 0, x = m[0].query?.outStatistics ?? [], { originalCategoryValue: C, originalDateValue: F, typeOrDomainFieldName: v, typeOrDomainIdValue: A } = k, w = [];
  let O = 0;
  const I = /* @__PURE__ */ new Set(), { maxCategoryCount: N } = to(u), M = sF({ queryResponse: e, chartConfig: i, maxCategoryCount: N });
  for (let P = 0; M[P] && P < M.length && !(c !== void 0 && O >= c); P += 1) {
    O += nF(g, i);
    const R = M[P];
    let $ = { ...R.attributes };
    if (rF({ attributes: $, uniqueCategoryList: I, maxCategoryCount: N, x: p, chartSubType: g }))
      continue;
    eF($, m), g === L.PieFromFields || g === L.BarAndLineFromFields ? $ = tF($, x) : typeof S == "string" && g === L.BarAndLineSplitByNoAggregation ? iF({ dataItem: $, splitByField: n, y: S }) : S && (g === L.BoxPlotMonoField || g === L.BoxPlotMonoFieldAndCategory || g === L.BoxPlotMonoFieldAndSplitBy || g === L.BoxPlotMonoFieldAndCategoryAndSplitBy) && aF(
      $,
      typeof S == "string" ? S : S[0]
    ), oF({ attributes: $, showMean: d, chartSubType: g });
    let W = $[p];
    W === null && m[0]?.query?.fetchNullValues === !0 && g !== L.PieFromFields && ($[C] = null, W = k.nullValue), s && typeof W == "string" ? W = new Date(W).valueOf() : r && (W = _0($));
    const { outStatisticFieldName: U } = ot.outStatistics ?? {}, { featureExtent: q, featureExtentKey: Z } = Z0({ feature: R, splitByField: n, chartSubType: g });
    if (q && ($[Z] = q), g === L.BarAndLineSplitBy && U !== void 0) {
      const j = $[n], ie = a?.get(j);
      ie !== void 0 && ($[ie] = $[U]), delete $[U];
    } else (g === L.PieNoAggregation || g === L.BarAndLineNoAggregation || g === L.BarAndLineSplitByNoAggregation) && (s ? $[F] = W : W !== k.nullValue && ($[C] = W), Tr({ isXAxis: !0, chartType: y, valueFormat: i.axes?.[0]?.valueFormat }) && ($[k.xAxisField] = `${W}-${P}`), $[ot.uniqueIdsName] = $[o]);
    const ee = br({
      subtypeInfo: l,
      fieldList: f,
      fieldName: p,
      fieldValueToMatch: W
    });
    ee !== void 0 && ee !== W && g !== L.PieFromFields && ($[C] = ee, $[v] = p, $[A] = W), y === b.BoxPlotSeries && ($ = J0(m, $)), y === b.PieSeries && typeof W == "number" && ($[C] === void 0 && ($[C] = $[p]), W = `${W}`), W !== void 0 && ($[C] === void 0 && ($[C] = $[p]), $[p] = ee ?? W, $[p] === null && ($[p] = k.nullValue), $[k.xAxisField] === void 0 && ($[k.xAxisField] = $[A] ?? $[p])), w.push($);
  }
  return w;
}
async function Rr(t) {
  const {
    queryObject: e,
    uniqueQuery: i,
    chartConfig: a,
    mapToStatField: n,
    abortKey: o,
    elementCount: s,
    isTimeBinningSeries: r,
    showMean: l,
    chartLimits: c,
    usePopupTemplateFieldsInfo: d
  } = t, { series: u } = a, f = H(u);
  let m = [];
  const g = f === L.BarAndLineSplitBy || f === L.BarAndLineSplitByNoAggregation ? Ze(u[0].query?.where) : "", y = await aa({
    queryObject: e,
    queryConfig: i,
    featureCount: s,
    abortKey: o
  }), p = await At(e, d), x = we(e).objectIdField, C = gb(p), { x: F } = u[0], v = C.includes(F), A = uc(e);
  return m = lF({
    queryResponse: y,
    chartConfig: a,
    mapToStatField: n,
    splitByField: g,
    fieldOID: x,
    isDateField: v,
    isTimeBinningSeries: r,
    subtypeInfo: A,
    fieldList: p,
    resultLimit: i.num,
    showMean: l,
    chartLimits: c
  }), f !== L.BarAndLineSplitByNoAggregation && f !== L.BarAndLineFromFields && (g !== "" && (m = ns({ data: m, x: F, splitByField: g })), m = K0(
    m,
    u
  )), m;
}
async function Gg(t) {
  const { chartConfig: e, queryObject: i, queryConfig: a, numberMaxOfFeaturesToFetch: n, behaviorAfterLimit: o, isGaugeByFeature: s } = t, { series: r } = e, l = H(r), { x: c } = r[0], d = r.length;
  let u, f;
  if (l === L.BoxPlotMonoField || l === L.BoxPlotMonoFieldAndSplitBy ? (f = d, u = f) : l === L.BoxPlotMultiFields || l === L.BoxPlotMultiFieldsAndSplitBy ? (f = e.series[0].y.length, u = f) : l === L.PieFromFields || l === L.BarAndLineFromFields ? (f = r[0].query?.outStatistics?.filter(
    (m) => m.statisticType !== X.EnvelopeAggregate
  ).length ?? 0, u = f) : u = await mb({ queryObject: i, x: c, chartSubType: l, queryConfig: a, isGaugeByFeature: s }), u !== void 0) {
    const m = l === L.BoxPlotMonoField || l === L.BoxPlotMonoFieldAndCategory || l === L.BoxPlotMonoFieldAndSplitBy;
    f = dn(l) && !m ? u * d : u;
  }
  return o === eo.RenderUpToTheLimit && f !== void 0 && n !== void 0 && n < f && (f = n, u = Math.ceil(f / d)), { categoryOrDateCount: u, elementCount: f };
}
function Hi(t) {
  const { arrayToSort: e, chartConfig: i, fieldList: a, isTimeBinningSeries: n } = t;
  if (n !== !0) {
    const { series: o } = i, s = H(o), r = z(o), l = ii(i), c = Ml(i);
    if (c !== void 0 && e !== void 0 && e.length > 1) {
      const { orderBy: d } = c;
      let { sortingField: u } = c;
      const f = i.orderOptions?.data?.orderType === en.Category, m = c.preferLabel !== !1, g = s === L.BarAndLineFromFields || s === L.PieFromFields || s === L.BoxPlotMultiFields || s === L.BoxPlotMultiFieldsAndSplitBy, y = g || r === b.PieSeries, p = s === L.PieNoAggregation || s === L.BarAndLineNoAggregation || s === L.BarAndLineSplitByNoAggregation, S = g ? !1 : e?.length > 0 && e.some((x) => Object.hasOwn(x, k.typeOrDomainIdValue));
      if (f && (!m || r === b.LineSeries && l === b.NumberAxisFormat) && (S ? u = k.typeOrDomainIdValue : y && (u = k.originalCategoryValue)), Array.isArray(d))
        ES({
          arrayToSort: e,
          orderBy: d,
          sortingField: u,
          fieldList: a,
          isByFieldsChart: g,
          preferLabel: m
        });
      else {
        const x = l === b.DateAxisFormat && f;
        Zs({
          arrayToSort: e,
          orderBy: d,
          sortingField: u,
          forceAscendingOrder: x,
          isNonAggregated: p,
          sortByCategory: f,
          preferLabel: m,
          isPieOrByFieldsChart: y
        });
      }
    }
  }
}
async function Hl(t) {
  const { chartConfig: e, queryConfig: i, fetchFullBoxPlotData: a, options: n, queryObject: o, abortKey: s, fieldList: r } = t, l = "showMean" in e && typeof e.showMean == "boolean" ? e.showMean : !1, { chartLimits: c, usePopupTemplateFieldsInfo: d } = n ?? {}, u = n?.replaceNoValueCategoryWithZero ?? k.options.replaceNoValueCategoryWithZero, { behaviorAfterLimit: f } = c ?? {}, m = { valid: !0 };
  let g, y = !1;
  const p = e.series, S = p[0], x = H(e.series);
  if (S !== void 0 && o !== void 0) {
    const C = z(p), { uniqueQuery: F, mapToStatField: v } = await Pr({
      chartConfig: e,
      queryObject: o,
      queryConfig: i,
      fetchFullBoxPlotData: a,
      options: n
    });
    let { categoryOrDateCount: A, elementCount: w } = await Gg({
      chartConfig: e,
      queryObject: o,
      queryConfig: i,
      behaviorAfterLimit: f,
      numberMaxOfFeaturesToFetch: F.num
    });
    const O = !Number.isFinite(w);
    let I = O || Ba({
      count: w ?? 0,
      seriesCount: p.length,
      chartType: C,
      chartLimits: c
    });
    if (I && (g = await Rr({
      queryObject: o,
      uniqueQuery: F,
      chartConfig: e,
      mapToStatField: v,
      elementCount: w,
      isTimeBinningSeries: !1,
      showMean: l,
      chartLimits: c,
      usePopupTemplateFieldsInfo: d,
      abortKey: s
    }), C === b.BoxPlotSeries && (m.data = await Ox({
      data: g,
      queryObject: o,
      fetchFullBoxPlotData: a,
      uniqueQuery: F,
      chartConfig: e,
      elementCount: w,
      chartLimits: c,
      abortKey: s
    }), c?.maxBoxPlotOutlierLimit !== void 0 && (I = (m.data.outliers ?? []).length <= c.maxBoxPlotOutlierLimit, y = !I)), O && (A = g.length, w = dn(x) ? A * p.length : A, I = Ba({
      count: w,
      seriesCount: p.length,
      chartType: C,
      chartLimits: c
    })), I)) {
      if (C === b.PieSeries) {
        x === L.PieFromFields && (g = Qs({
          dataToConvert: g[0],
          x: tt,
          y: Rt,
          fieldList: r
        }));
        let N = "";
        x === L.PieFromFields ? N = Rt : "y" in S && typeof S.y == "string" && (N = S.y), ax(g, N) ? m.data = { dataItems: g } : yx(m, de.PieChartMixOfNegativePositiveSlices);
      } else if ((C === b.RadarSeries || C === b.BarSeries || C === b.LineSeries || C === b.ComboLineAndBarSeries) && (x === L.BarAndLineFromFields && "y" in S && typeof S.y == "string" ? g = Qs({
        dataToConvert: g[0],
        x: S.x,
        y: S.y,
        fieldList: r
      }) : g = await O0({
        queryObject: o,
        seriesData: g,
        chartConfig: e,
        queryConfig: i,
        categoryOrDateCount: A,
        behaviorAfterLimit: f,
        abortKey: s
      }), w = dn(x) ? g.length * p.length : g.length, I = Ba({
        count: w,
        seriesCount: p.length,
        chartType: C,
        chartLimits: c
      }), I)) {
        u && (g = B0(g, e)), Hi({ arrayToSort: g, chartConfig: e, fieldList: r });
        let N = {};
        if (ci(S)) {
          const { size: M, unit: P } = S.temporalBinning ?? {};
          M !== void 0 && P !== void 0 && (N = { size: M, unit: P });
        }
        m.data = { dataItems: g, timeIntervalInfo: N };
      }
    }
    I || Tm({ dataInfo: m, chartType: C, subError: { outlierLimit: y } }), m.count = w;
  }
  return m;
}
async function zc(t) {
  const { chartConfig: e, queryConfig: i, queryObject: a, abortKey: n, binnedServerData: o, options: s } = t, { chartLimits: r, usePopupTemplateFieldsInfo: l } = s ?? {}, { behaviorAfterLimit: c } = r ?? {}, d = e.series, u = d[0], { x: f } = u, m = Ze(u.query?.where), g = { valid: !0 };
  let y;
  if (ci(u)) {
    const { temporalBinning: p } = u;
    if (a && p) {
      const { type: S, unit: x, size: C } = p;
      let F = 1, v = { unit: x, size: C };
      const A = j0({
        series: u,
        isTimeBinningSeries: !0,
        setTimeBinningInfoWhenNotProvided: s?.setTimeBinningInfoWhenNotProvided
      });
      let w = o?.timeBinningStats;
      !w && (S === wi.FixedDateBased || A) && (w = await V0({ queryObject: a, queryConfig: i, x: f })), A && w && (v = U0(w), p.size = v.size, p.unit = v.unit);
      const { uniqueQuery: O, mapToStatField: I } = await Pr({
        chartConfig: e,
        queryConfig: i,
        queryObject: a,
        timeIntervalInfo: v,
        options: s
      });
      let N = Ba({
        count: F ?? 0,
        seriesCount: d.length,
        chartType: b.LineSeries,
        chartLimits: r
      });
      if (N) {
        if (S === wi.CalendarBased) {
          const M = await zf({
            queryObject: a,
            dateField: f,
            splitByField: m,
            queryConfig: O,
            temporalBinning: p
          }), P = "y" in u && typeof u.y == "string" ? u.y : void 0;
          if (y = await G0({
            queryResults: M,
            mapToStatField: I,
            splitByField: m,
            x: f,
            y: P,
            nullPolicy: p.nullPolicy,
            queryObject: a
          }), !Ba({
            count: y.length,
            seriesCount: d.length,
            chartType: b.LineSeries,
            chartLimits: r
          })) {
            const R = pt(d), $ = y.filter(
              (W) => R.some((U) => U in W && Number.isFinite(W[U]))
            ).length;
            Ba({
              count: $,
              seriesCount: d.length,
              chartType: b.LineSeries,
              chartLimits: r
            }) || (N = !1);
          }
        } else if (w) {
          const { numberOfFinalBinsWithinDataRange: M } = Hg({
            dateMinTimestamp: w.dateRange.dateMinTimestamp,
            dateMaxTimestamp: w.dateRange.dateMaxTimestamp,
            timeIntervalInfo: v
          });
          F = M * d.length, F = zg(F, v.unit), y = o?.data ?? await Rr({
            queryObject: a,
            uniqueQuery: O,
            chartConfig: e,
            mapToStatField: I,
            elementCount: F,
            chartLimits: r,
            isTimeBinningSeries: !0,
            usePopupTemplateFieldsInfo: l,
            abortKey: n
          }), g.binnedServerData = { data: Ee(y), timeBinningStats: w }, y = await Y0({
            queryObject: a,
            queryConfig: i,
            queryResults: y,
            x: f,
            seriesConfig: d,
            dateRange: w.dateRange,
            timeIntervalInfo: v
          });
        }
        if (c === eo.RenderUpToTheLimit && y) {
          const M = pm(e, s?.chartLimits);
          M !== void 0 && y.splice(M);
        }
      }
      N || (g.valid = !1, g.invalidType = de.LineChartExceedsLimit), y && y.length > 0 && (y[y.length - 1][k.lastTemporalBin] = !0), g.data = { dataItems: y, timeIntervalInfo: v }, g.count = F;
    }
  }
  return g;
}
async function cF(t) {
  const { chartConfig: e, queryConfig: i, queryObject: a, abortKey: n, options: o } = t, s = qe(e), { setTimeBinningInfoWhenNotProvided: r, chartLimits: l, usePopupTemplateFieldsInfo: c } = o ?? {}, d = { valid: !0 };
  if (a !== void 0) {
    const u = e.series, f = ei({
      seriesConfig: u[0],
      xAxisValueFormatType: ii(e),
      setTimeBinningInfoWhenNotProvided: r
    }), { uniqueQuery: m, mapToStatField: g } = await Pr({
      chartConfig: e,
      queryObject: a,
      queryConfig: i,
      fetchFullBoxPlotData: !s,
      options: o
    });
    let y = await Rr({
      queryObject: a,
      uniqueQuery: m,
      elementCount: 1,
      // this will skip the query counting the number of features, not needed for selection
      chartConfig: e,
      mapToStatField: g,
      isTimeBinningSeries: f,
      showMean: s,
      chartLimits: l,
      usePopupTemplateFieldsInfo: c,
      abortKey: n
    });
    z(e.series) === b.BoxPlotSeries && (y = Im({ chartConfig: e, data: y, calculateZScore: !1 })), d.data = { dataItems: y };
  }
  return d;
}
async function dF(t) {
  const { chartConfig: e, queryConfig: i, queryObject: a, abortKey: n, options: o, errorStrings: s } = t, r = "showMean" in e ? e.showMean : !1, l = await Ec({
    queryObject: a,
    chartConfig: e,
    queryConfig: i,
    options: o,
    errorStrings: s,
    abortKey: n
  });
  return r && l.data && "dataItems" in l.data && "meanLines" in l.data && l.data.meanLines && (l.data.dataItems = [...l.data.dataItems, ...l.data.meanLines]), l;
}
function qi(t) {
  return t?.[Ut.defaultGroupOfSlicesId] === !0;
}
function uF(t, e) {
  const i = t.filter(
    (a) => !qi(a)
  );
  return !Di(i, e);
}
function fF(t, e) {
  let i = t.reduce((a, n) => {
    if (n[Ut.defaultGroupOfSlicesId] === !0) {
      const o = n[k.pieChart.technicalFieldGroupedSlices];
      o !== void 0 && o.forEach((s) => {
        a.push(s);
      });
    } else
      a.push(n);
    return a;
  }, []);
  return Hi({
    arrayToSort: i,
    chartConfig: e
  }), i = Fc({
    data: { dataItems: i },
    seriesConfig: e.series
  })?.dataItems ?? [], i;
}
function Yg(t) {
  const { stringToTruncate: e, characterLimit: i, ellipsis: a = k.chartEllipsis } = t;
  let n = e;
  return typeof i == "number" && Number.isFinite(i) && i > 0 && i < e.length && (n = e.slice(0, i), n = `${n}${a}`), n;
}
function ai(t, e = ":") {
  return t ? `‏${e}` : `‎${e}`;
}
function Hc(t) {
  return (i) => {
    let a = typeof i != "string" ? i?.toString() ?? "" : i;
    return !be(a) && a !== k.htmlEmptyContent && (a = Yg({
      stringToTruncate: a,
      characterLimit: t
    })), a;
  };
}
function Vr(t) {
  const e = /[[]/gu, i = /[\]]/gu, a = /[{]/gu, n = /[}]/gu, o = /[']/gu;
  return t = t.replace(e, "[["), t = t.replace(i, "]]"), t = t.replace(a, "{{"), t = t.replace(n, "}}"), t = t.replace(o, "''"), t;
}
function mF(t, e) {
  let i = "";
  return t !== void 0 && (i = `${e === "amChartsV5" ? "fontStyle" : "font-style"}:${t};`), i;
}
function gF(t, e) {
  let i = "";
  return t === !0 && (i = `${e === "amChartsV5" ? "letterSpacing" : "letter-spacing"}:1px;`), i;
}
function Ht(t) {
  const { textSymbol: e, placeholderString: i, format: a, axisLabelsBehavior: n, defaults: o } = t, s = mF(e?.font?.style, a), r = gF(e?.kerning, a);
  let l = i ?? e?.text ?? "";
  if (a === "html") {
    let { wrap: c, maxWidth: d } = o ?? {};
    n === De.Wrap && (c = !0, d = d ?? k.xAxisLabelMaxWidth);
    const u = c === !0 && Number.isFinite(d) ? `max-width: ${d}px; word-break: break-word;` : "";
    l = `<p style="margin:0;${s}${r}${u}">${l}</p>`;
  } else
    l = Vr(l), (s !== "" || r !== "") && (l = `[${s}${r}]${l}[/]`);
  return l;
}
function hF(t) {
  return t ? t.replace(/[A-Z]/gu, (e) => `-${e.toLowerCase()}`) : void 0;
}
const Ui = {
  ChartRenderer: 1,
  LayerRenderer: 2
};
function ja(t) {
  const { chartConfig: e, queryObject: i } = t;
  let a = !1;
  if (e.chartRenderer)
    a = !0;
  else {
    const { series: n } = e, o = z(n), s = H(n), r = ha(e), l = ei({
      seriesConfig: r
    }), d = we(i)?.renderer;
    switch (d?.type) {
      case qt.Simple:
        a = o === b.HistogramSeries || o === b.ScatterSeries || s === L.BarAndLineMonoField || s === L.BoxPlotMonoField || s === L.BoxPlotMultiFields || s === L.BoxPlotMonoFieldAndCategory || s === L.BarAndLineNoAggregation && n.length === 1 && !l;
        break;
      case qt.UniqueValue:
        {
          const f = d?.field, m = Ze(r.query?.where), { x: g } = r;
          a = (s === L.BoxPlotMonoFieldAndSplitBy || s === L.BoxPlotMultiFieldsAndSplitBy || s === L.BoxPlotMonoFieldAndCategoryAndSplitBy || s === L.BarAndLineSplitByNoAggregation || s === L.BarAndLineSplitBy) && f === m || (s === L.BoxPlotMonoFieldAndCategory || s === L.PieFromCategory || s === L.BarAndLineMonoField) && f === g || s === L.BarAndLineNoAggregation || s === L.PieNoAggregation || o === b.ScatterSeries;
        }
        break;
      case qt.PieChart:
        a = s === L.PieFromFields || s === L.BarAndLineFromFields || s === L.BarAndLineMultiFields || s === L.BarAndLineMonoField || s === L.BoxPlotMonoField || s === L.BoxPlotMultiFields || s === L.BoxPlotMonoFieldAndCategory || s === L.BoxPlotMultiFieldsAndCategory;
        break;
      case qt.ClassBreaks:
        a = o === b.ScatterSeries || s === L.BarAndLineNoAggregation || s === L.PieNoAggregation;
        break;
      case qt.Dictionary:
      case qt.DotDensity:
      case qt.Heatmap:
        break;
    }
  }
  return a;
}
function os(t, e) {
  return hF(t?.type) ?? e?.type;
}
function pF(t) {
  const e = k.rendererSymbolField;
  let i = e in t ? e : void 0;
  if (!i) {
    const a = t[k.originalCategoryValue];
    i = Object.keys(t).find((n) => {
      const o = t[n];
      return n.includes(e) && o?.label && o?.uniqueValue === a;
    }), i || (i = Object.keys(t).find((n) => n.includes(e)) ?? "");
  }
  return t[i]?.label;
}
function yF(t) {
  return t?.type !== void 0 && (t.color !== void 0 || t.label !== void 0 || t.style !== void 0 || t.outline !== void 0);
}
function Xg(t) {
  const { symbolField: e, dataItem: i, rendererSymbol: a, rendererOrigin: n } = t;
  let o = !1;
  if (!yF(a))
    delete i[e];
  else {
    const s = { ...a };
    s.color !== void 0 && n === Ui.LayerRenderer && (s.color[3] = io * 255), n === Ui.LayerRenderer && (delete s.style, delete s.outline, delete s.label), i[e] = s, o = !0;
  }
  return o;
}
function bF(t) {
  const { renderer: e, seriesConfig: i, chartSubType: a, dataItem: n, rendererOrigin: o } = t;
  let s, r = !1;
  const l = z(i), { outline: c, attributes: d } = e;
  return d.forEach(
    (u) => {
      let { field: f } = u;
      const { color: m, label: g } = u;
      let y;
      Array.isArray(m) && m?.length === 4 ? y = m : m && "toRgba" in m && (y = m.toRgba());
      let p = !1, S = !0;
      switch (l) {
        case b.BarSeries:
        case b.LineSeries:
        case b.ComboLineAndBarSeries:
        case b.RadarSeries:
          if (a !== L.BarAndLineFromFields) {
            const x = i.find((C) => C.query?.outStatistics?.[0]?.onStatisticField === f);
            x !== void 0 && "y" in x ? f = [x.y].flat()[0] : f = "";
          }
          p = a !== L.BarAndLineFromFields || f === n[k.originalCategoryValue];
          break;
        case b.PieSeries:
          p = a === L.PieFromFields && f === n[k.originalCategoryValue];
          break;
        case b.BoxPlotSeries:
          a === L.BoxPlotMonoField || a === L.BoxPlotMonoFieldAndCategory ? p = f === i[0].y : f && (a === L.BoxPlotMultiFields || a === L.BoxPlotMultiFieldsAndCategory) && (p = i.map((C) => C.y).flat().includes(f)), S = !1;
          break;
      }
      p && y && (s = {
        type: re.SMS,
        color: y,
        label: S && g ? g : void 0
      }, c != null && (s.outline = c), Xg({
        dataItem: n,
        symbolField: a === L.BarAndLineFromFields || a === L.PieFromFields ? k.rendererSymbolField : `${k.rendererSymbolField}_${f}`,
        rendererSymbol: s,
        rendererOrigin: o
      }) && (r = !0));
    }
  ), { rendererSymbol: s, colorMatchApplied: r };
}
function SF(t) {
  const { seriesConfig: e, chartSubType: i, rendererType: a } = t;
  let o = k.rendererSymbolField;
  if (a === qt.UniqueValue) {
    if (Vf(i)) {
      const s = Lt({
        where: e.query?.where
      });
      s === null ? o = k.nullValue : i === L.BarAndLineSplitBy && typeof e.y == "string" ? o = e.y : i === L.BarAndLineSplitByNoAggregation && typeof e.y == "string" ? o = `${e.y}_${s}` : o = `${s}`;
    }
  } else if (a === qt.PieChart)
    switch (i) {
      case L.BoxPlotMultiFields:
        o = Array.isArray(e.y) ? e.y.flat() : e.y;
        break;
      case L.BarAndLineMonoField:
      case L.BarAndLineMultiFields:
      case L.BoxPlotMonoField:
      case L.BoxPlotMonoFieldAndCategory:
      case L.BoxPlotMultiFieldsAndCategory:
        o = e.y;
        break;
    }
  return o;
}
function Ug(t) {
  const { seriesConfig: e, chartSubType: i, rendererType: a, dataItem: n } = t;
  let o = SF({
    seriesConfig: e,
    chartSubType: i,
    rendererType: a
  });
  return o instanceof Array && e.type === b.BoxPlotSeries && a === qt.PieChart && n !== void 0 && (o = o.find((s) => s === n[jo]) ?? o[0]), o = o !== k.rendererSymbolField ? `${k.rendererSymbolField}_${o.toString()}` : o, o;
}
function qc(t) {
  const { chartRenderer: e, queryObject: i } = t, a = e !== void 0 ? {
    // TODO: find a better way to copy the layer. For now it's all right as the information we need are not lost with the spread operator
    // eslint-disable-next-line @typescript-eslint/no-misused-spread
    ...we(i),
    renderer: Vb.fromJSON(e)
  } : we(i);
  return new Eb({
    layer: a
  });
}
async function Gc(t) {
  const {
    seriesConfig: e,
    dataItem: i,
    renderer: a,
    rendererType: n,
    rendererOrigin: o,
    chartSubType: s,
    splitByField: r,
    graphicTemplate: l,
    rendererFieldNames: c,
    mapAttributesToSymbol: d
  } = t;
  let u, f = !1;
  if (n === qt.PieChart) {
    const m = bF({
      renderer: a,
      seriesConfig: e,
      chartSubType: s,
      dataItem: i,
      rendererOrigin: o
    });
    u = m.rendererSymbol, f = m.colorMatchApplied;
  } else if (!qi(i)) {
    const { x: m } = e[0], g = /* @__PURE__ */ new Map();
    r && r.trim() !== "" ? e.forEach((y) => {
      if (y.type === b.BarSeries || y.type === b.LineSeries || y.type === b.BoxPlotSeries || y.type === b.RadarSeries) {
        const p = Ug({
          seriesConfig: y,
          chartSubType: s,
          rendererType: n,
          dataItem: i
        }), S = Lt({
          where: y.query?.where,
          normalize: !0,
          keepSurroundingQuotes: !1,
          escape: !1
        });
        g.set(p, {
          ...i,
          [r]: S
        });
      }
    }) : g.set(k.rendererSymbolField, {
      ...i,
      [m]: $i(i)
    });
    try {
      const y = Array.from(g.entries()), p = l.clone();
      p.layer = l.layer;
      const S = a?.uniqueValueInfos;
      for (let x = 0; x < y.length; x += 1) {
        const [C, F] = y[x];
        if (Bu({
          mode: "encode",
          x: m,
          splitByField: r,
          attributes: F
        }), c && c.length > 0 && Object.keys(F).forEach((A) => {
          c.includes(A) || delete F[A];
        }), p.attributes = F, d?.has(JSON.stringify(F)))
          u = d.get(JSON.stringify(F));
        else {
          if (u = (await fl.getDisplayedSymbol(p))?.toJSON(), u != null) {
            u.color === void 0 && (u.color = (await fl.getDisplayedColor(p))?.toJSON());
            const A = await fl.getLegendLabel(p);
            A != null && A !== "" && (u.label = A, u.uniqueValue = S?.find((w) => w.label === A)?.value ?? void 0);
          }
          d?.set(JSON.stringify(F), u);
        }
        Bu({
          mode: "revert",
          x: m,
          splitByField: r,
          attributes: i
        }), Xg({
          dataItem: i,
          symbolField: C,
          rendererSymbol: u,
          rendererOrigin: o
        }) && (f = !0);
      }
    } catch {
    }
  }
  return { rendererSymbol: u, colorMatchApplied: f };
}
function xF(t) {
  const e = t;
  return t?.type === "uniqueValue" && (t.uniqueValueInfos = t.uniqueValueInfos.map((i) => {
    const a = i.value === null ? k.nullValue : i.value;
    return { ...i, value: a };
  })), e;
}
function Bu(t) {
  const { splitByField: e, attributes: i, x: a, mode: n } = t;
  [a, e ?? ""].forEach((o) => {
    i[o] === (n === "encode" ? null : k.nullValue) && (i[o] = n === "encode" ? k.nullValue : null);
  });
}
async function fo(t) {
  const { data: e, queryObject: i, chartConfig: a, allowColorMatch: n } = t;
  let o = !1, s = [];
  if (n) {
    const { series: r, chartRenderer: l } = a, c = xF(l), d = c ? Ui.ChartRenderer : Ui.LayerRenderer, u = i ? we(i) : void 0, f = c ?? u?.renderer;
    let m;
    u && d === Ui.LayerRenderer ? s = await Ef(u) : d === Ui.ChartRenderer && (s = vF(f));
    const g = os(c, u?.renderer), y = qc({
      chartRenderer: l,
      queryObject: i
    }), p = H(r), S = ha(a), x = Ze(S.query?.where);
    m = /* @__PURE__ */ new Map();
    for (let C = 0; C < e.length; C += 1) {
      const F = e[C], v = await Gc({
        seriesConfig: a.series,
        dataItem: F,
        renderer: f,
        rendererType: g,
        rendererOrigin: d,
        chartSubType: p,
        splitByField: x,
        graphicTemplate: y,
        mapAttributesToSymbol: m,
        rendererFieldNames: s
      });
      o = o || v.colorMatchApplied;
    }
  }
  return { dataItems: e, colorMatchApplied: o, rendererFieldNames: s };
}
function Wt(t) {
  const { dataItem: e, seriesConfig: i, chartSubType: a, colorMatch: n, rendererType: o } = t;
  let s;
  if (n && e !== void 0) {
    const r = Ug({
      seriesConfig: i,
      chartSubType: a,
      rendererType: o,
      dataItem: e
    });
    s = e[r];
  }
  return s;
}
function jg(t) {
  const { seriesSymbol: e, rendererSymbol: i, colorIndex: a } = t, n = {
    ...e,
    color: i?.color ?? e.color ?? Si({ colorIndex: a, opacity: io })
  };
  return i?.type === e.type && i.style !== void 0 && (n.style = i.style), n.type !== re.SLS && (n.outline = {
    type: re.SLS,
    style: i?.outline?.style ?? n.outline?.style,
    width: i?.outline?.width ?? n.outline?.width,
    color: i?.outline?.color ?? n.outline?.color ?? i?.color
  }), n;
}
function CF(t) {
  let e = [];
  return t && (e = t.series.flatMap((i) => i.query?.outStatistics?.map((a) => a.onStatisticField)).filter((i) => i !== void 0), e.length === 0 && (e = pt(t.series))), e;
}
function Er(t, e) {
  let i = !1;
  if (t && e && e.length > 0 && Ri(t)) {
    const n = RS(t), o = ha(t);
    n ? i = CF(t).some((r) => e.includes(r)) : i = e.includes(o.x);
  }
  return i;
}
function vF(t) {
  let e = [];
  if (t && "type" in t && typeof t.type == "string")
    switch (t.type) {
      case "uniqueValue":
        "field1" in t && typeof t.field1 == "string" && (e = [t.field1]);
        break;
      case "classBreaks":
        "field" in t && typeof t.field == "string" && (e = [t.field]);
        break;
      case "pieChart":
        "attributes" in t && Array.isArray(t.attributes) && (e = t.attributes.map((i) => i.field));
        break;
    }
  return e;
}
function FF(t) {
  const { dataContext: e, dataIndex: i, objectIdField: a } = t;
  return `${Ut.sliceIdPrefix}-${e[a ?? ""]?.toString() ?? i}`;
}
function LF(t) {
  const { chartConfig: e, chartData: i, fieldList: a } = t;
  if (e.orderOptions?.data !== void 0) {
    Hi({
      arrayToSort: i,
      chartConfig: e,
      fieldList: a
    });
    const { slices: n } = e.series[0];
    n !== void 0 && n.sort((o, s) => {
      const r = i.findIndex(
        (c) => c[k.pieChart.technicalFieldSliceId] === o.sliceId
      ), l = i.findIndex(
        (c) => c[k.pieChart.technicalFieldSliceId] === s.sliceId
      );
      return r - l;
    });
  }
}
function Wr(t) {
  const { data: e, newChartConfig: i, pieSlicesSymbols: a, fieldList: n } = t, o = i.series[0], s = H(i.series) === L.PieFromFields ? tt : o.x;
  e.forEach((r) => {
    const l = qi(r), c = r[k.pieChart.technicalFieldSliceId], d = l ? o.sliceGrouping?.label : ar(a?.slices, c)?.label;
    AF({ dataContext: r, x: s, newLabel: d });
  }), LF({ chartConfig: i, chartData: e, fieldList: n });
}
function AF(t) {
  const { dataContext: e, newLabel: i, x: a } = t;
  i === void 0 ? e[k.originalCategoryValue] !== void 0 && (e[a] = e[k.originalCategoryValue]) : e[a] !== i && (e[k.originalCategoryValue] === void 0 && (e[k.originalCategoryValue] = e[a]), e[a] = i);
}
function ar(t, e) {
  let i;
  return t !== void 0 && e !== void 0 && (i = t.find((a) => a.sliceId === e)), i;
}
function _g(t) {
  const { dataContext: e, isNonAggregatedChart: i, x: a, dataIndex: n, objectIdField: o, isPieFromFields: s } = t;
  let r = "";
  return s === !0 ? r = e[k.originalCategoryValue] ?? e[tt] : i ? r = FF({
    dataContext: e,
    dataIndex: n,
    objectIdField: o
  }) : (r = e[k.typeOrDomainIdValue] ?? e[k.originalCategoryValue], r === "" ? r = Ut.emptySliceId : r === null && (r = Ut.nullSliceId), r = r ?? e[a]), r === void 0 && (r = Ut.undefinedSliceId), r.toString();
}
function Zg(t) {
  const {
    dataContext: e,
    sliceFromConfig: i,
    isGroupOfSlices: a,
    seriesConfig: n,
    fieldList: o,
    isPieFromFields: s,
    labelUpdateNeeded: r,
    colorMatch: l,
    commonStrings: c
  } = t, { sliceGrouping: d } = n;
  let { x: u } = n;
  s && (u = tt);
  const f = e[u] ?? e[k.originalCategoryValue], m = e[k.originalCategoryValue] ?? f;
  let g = f;
  if (r) {
    if (a)
      g = d?.label ?? d?.originalLabel?.toString() ?? c.pieChart.defaultSliceGroupingLabel;
    else if (l && e[k.rendererSymbolField]?.label !== void 0)
      g = e[k.rendererSymbolField].label;
    else if (i !== void 0 || o !== void 0) {
      g = i?.label ?? m;
      const y = e[k.typeOrDomainIdValue];
      y !== void 0 && g?.toString() === y?.toString() ? g = m : g === m && m !== void 0 && m !== null && (g = Ve(o, m));
    } else i === void 0 && (g = m);
    g === k.nullValue ? g = "null" : g != null && (g = g.toString());
  }
  return g;
}
function Qg(t, e) {
  return t[0]?.sliceGrouping?.percentageThreshold !== e[0]?.sliceGrouping?.percentageThreshold;
}
function ss(t) {
  const { groupOfSlicesDataContext: e, chartData: i } = t;
  return (e ?? i?.find((o) => o[Ut.defaultGroupOfSlicesId] === !0))?.[k.pieChart.technicalFieldGroupedSlices];
}
function Yc(t) {
  const { dataContext: e, pieSlicesSymbols: i, seriesConfig: a } = t;
  let n = a.fillSymbol ? { ...a.fillSymbol } : Hs();
  if (qi(e))
    n = {
      ...k.pieChart.sliceGrouping.fillSymbol,
      ...i?.groupOfSlices?.fillSymbol
    };
  else {
    const s = e[k.pieChart.technicalFieldSliceId], r = i?.slices?.find(
      (l) => l.sliceId === s
    );
    n = Ee(r?.fillSymbol ?? a.fillSymbol ?? Hs());
  }
  return n;
}
const TF = "arcgis-charts-randomization-seed", Kg = Xs(TF, Xs.URL), ue = {
  XAxisTitle: "XAxisTitle",
  YAxisTitle: "YAxisTitle",
  ChartTitle: "ChartTitle",
  ChartSubTitle: "ChartSubTitle",
  ChartFooter: "ChartFooter",
  GuideLabel: "GuideLabel",
  LegendTitle: "LegendTitle"
}, D = {
  ...k,
  chartPadding: 5,
  footerContainer: { ...k.footerContainer, paddingTop: 0, paddingBottom: 0 },
  headerContainer: { ...k.headerContainer, paddingBottom: 0 },
  chartContainer: { ...k.chartContainer },
  dataLabel: { ...k.dataLabel, verticalCenter: "bottom" },
  scrollbarPadding: 12,
  // setting a high z index so guide will be on top when above is set to true
  zIndexes: {
    guide: 100,
    scatterplotTrendLine: 2,
    // set layer to 1 so bullets will be above axis and trendlines
    bulletMarkers: 1
  },
  verticalSurfaceGuideLabels: {
    // The alignments are directly handled by adjustGuideLabelsPositionCallback()
    wrap: !0
  },
  verticalLineGuideLabels: {
    // The alignments are directly handled by adjustGuideLabelsPositionCallback()
    wrap: !0,
    rotation: 90
  },
  horizontalSurfaceGuideLabels: {
    // The alignments are directly handled by adjustGuideLabelsPositionCallback()
    wrap: !0
  },
  horizontalLineGuideLabels: {
    // The alignments are directly handled by adjustGuideLabelsPositionCallback()
    wrap: !0
  },
  overlayId: {
    scatterplotTrendLine: "arcgis_charts_scatter_plot_trendline",
    histogramMean: "arcgis_charts_histogram_mean",
    histogramMedian: "arcgis_charts_histogram_median",
    histogramStdDev: "arcgis_charts_histogram_std_dev",
    histogramNormalDistribution: "arcgis_charts_histogram_normal_distribution"
  },
  axisLabelSpacing: {
    verticalAxisLabelSidePadding: 8,
    horizontalAxisLabelPaddingTop: 6
  }
}, wF = "AM5C241025748", Se = {
  SelectEnded: "selectended",
  DataValidated: "datavalidated",
  Opened: "opened",
  BoundsChanged: "boundschanged",
  PointerUp: "pointerup",
  FrameEnded: "frameended",
  Click: "click"
}, ql = /* @__PURE__ */ new Map();
function mo(t, e) {
  const i = ql.get(t) ?? {};
  ql.set(t, { ...i, ...e });
}
function go(t, e) {
  return ql.get(t)?.[e];
}
function V(t, e) {
  return go(t, e);
}
function Le(t, e) {
  mo(t, e);
}
function $e(t, e) {
  return go(t, e);
}
function st(t, e) {
  mo(t, e);
}
function Ea(t, e) {
  return go(t, e);
}
function ho(t, e) {
  mo(t, e);
}
function pa(t, e) {
  return go(t, e);
}
function kF(t, e) {
  mo(t, e);
}
function Qt(t, e) {
  return go(t, e);
}
function Jg(t, e) {
  mo(t, e);
}
function IF(t, e) {
  return go(t, e);
}
function OF(t, e) {
  mo(t, e);
}
const pe = {
  Guides: "guides",
  Ticks: "ticks",
  GaugeFirstAndLastGuides: "firstAndLast",
  GaugeTicksWithLabels: "gaugeTicksWithLabels"
};
function BF(t, e) {
  e === !0 && t.setThemes([Qb.new(t)]);
}
function DF(t, e) {
  e === !0 && t.setThemes([Zb.new(t)]);
}
function je(t) {
  let e = No("#000000"), i = Qo;
  if (t != null) {
    const [a, n, o, s] = t;
    i = s / 255, e = No(`rgba(${a}, ${n}, ${o}, ${i})`);
  }
  return { color: e, opacity: i };
}
function _e(t, e) {
  e === !1 && (!("isHiding" in t) || !t.isHiding()) ? (t.set("visible", !1), "hide" in t && t.hide()) : e !== !1 && (!("isShowing" in t) || !t.isShowing()) && (t.set("visible", !0), "show" in t && t.show());
}
function Ye(t) {
  const { childId: e, parent: i, useChildId: a } = t, n = a ? e : Oi(e, i.uid);
  return i.children.values.find((o) => o.get("id") === n);
}
function Oi(t, e) {
  return `${t}${e}`;
}
function Du(t) {
  let e = Number.NaN;
  if (typeof t == "number")
    e = t;
  else if (t.includes("%")) {
    const i = Number.parseFloat(t.trim().replace("%", "").trim());
    Number.isFinite(i) && (e = Ni(i));
  }
  return e;
}
function NF(t, e) {
  return e !== !0 || t?.includes("Dot") === !0 ? "round" : "square";
}
function MF(t, e) {
  const i = t ?? xt.Solid, a = e ?? D.lineWidth, n = {
    [xt.Solid]: [],
    [xt.Dot]: [1, a],
    [xt.DashDotDot]: [4 * a, a, 1, a, 1, a],
    [xt.Dash]: [4 * a, 3 * a],
    [xt.DashDot]: [4 * a, 3 * a, 1, 3 * a],
    [xt.Null]: []
  };
  return n[i] ?? n[xt.Null];
}
function $F(t) {
  const { root: e, fill: i, rotation: a, isLinePattern: n } = t;
  let o;
  return n !== !1 ? o = Nf.new(e, {
    width: D.patternLineProperties.width ?? Number.NaN,
    height: D.patternLineProperties.height ?? Number.NaN,
    strokeWidth: D.patternLineProperties.strokeWidth ?? Number.NaN,
    fill: i,
    // TODO: or is it `color`?
    rotation: a ?? Number.NaN
  }) : o = qy.new(e, {
    // rectWidth: ChartDefaults.patternRectProperties.rectWidth ?? Number.NaN,
    // rectHeight: ChartDefaults.patternRectProperties.rectHeight ?? Number.NaN,
    // width: ChartDefaults.patternRectProperties.width ?? Number.NaN,
    // height: ChartDefaults.patternRectProperties.height ?? Number.NaN,
    // backgroundOpacity: ChartDefaults.patternRectProperties.backgroundOpacity ?? Number.NaN,
    // fillOpacity: ChartDefaults.patternRectProperties.fillOpacity ?? Number.NaN,
    // strokeWidth: ChartDefaults.patternRectProperties.strokeWidth ?? Number.NaN,
    // fill: EsriColorToAmChartsColor(ChartDefaults.color),
    // backgroundFill: fill,
    // rotation: rotation ?? Number.NaN
  }), o;
}
function PF(t) {
  const { fill: e, root: i, style: a } = t;
  let n, o, s = !0;
  switch (a) {
    case Ot.Horizontal: {
      o = 0;
      break;
    }
    case Ot.Vertical: {
      o = 90;
      break;
    }
    case Ot.ForwardDiagonal: {
      o = 45;
      break;
    }
    case Ot.BackwardDiagonal: {
      o = 135;
      break;
    }
    case Ot.DiagonalCross:
    case Ot.Cross: {
      o = 0, s = !1;
      break;
    }
    case Ot.Solid:
  }
  return o !== void 0 && i !== void 0 && (n = $F({ root: i, fill: e, rotation: o, isLinePattern: s })), n;
}
function eh(t, e = 0) {
  return (t ?? e) % 360;
}
function RF(t, e) {
  let i = "";
  const o = (e ?? 0) / 2, s = 0 - o, r = 0 + o, l = 0 - o, c = 0 + o;
  switch (t) {
    case Xt.Circle:
      i = `M ${s},0 a ${o},${o} 0 1,0 ${o * 2},0 a ${o},${o} 0 1,0 ${-o * 2},0`;
      break;
    case Xt.Cross:
      i = `M ${s},0 L ${r},0 M 0,${l} L 0,${c} E`;
      break;
    case Xt.Diamond:
      i = `M ${s},0 L 0,${l} L ${r},0 L 0,${c} L ${s},0 Z`;
      break;
    case Xt.Square:
      i = `M ${s},${c} L ${s},${l} L ${r},${l} L ${r},${c} L ${s},${c} Z`;
      break;
    case Xt.Triangle:
      i = `M ${s},${c} L 0,${l} L ${r},${c} L ${s},${c} Z`;
      break;
    case Xt.X:
      i = `M ${s},${c} L ${r},${l} M ${s},${l} L ${r},${c} E`;
      break;
  }
  return i;
}
function th(t, e) {
  const i = {
    stroke: je().color,
    strokeWidth: D.lineWidth,
    strokeDasharray: [],
    linecap: e !== !0 ? "round" : "square",
    strokeOpacity: Qo
  };
  if (t != null) {
    const a = je(t.color);
    i.stroke = a.color, t.width !== void 0 && (i.strokeWidth = t.width, i.strokeOpacity = t.width === 0 ? 0 : a.opacity), t.style !== void 0 && t.style !== xt.Null && (i.strokeDasharray = MF(t.style, i.strokeWidth), i.linecap = NF(t.style, e));
  }
  return i;
}
function ih(t, e) {
  let i = t;
  const [a, n, o, s] = t?.color ?? e ?? D.color, r = [a, n, o, s];
  return i == null ? i = { type: re.SLS, color: r } : i.color === void 0 && (i.color = r), th(i, !1);
}
function VF(t, e) {
  const { color: i, outline: a, style: n } = t, o = je(i);
  return {
    pattern: PF({ root: e, fill: o.color, style: n }),
    fill: o.color,
    outline: ih(a, i),
    fillOpacity: o.opacity
  };
}
function EF(t) {
  const { color: e, style: i, size: a, outline: n, xoffset: o, yoffset: s, angle: r } = t, l = eh(r), c = i !== void 0 ? RF(i, a) : "", d = je(e);
  return {
    path: c,
    fill: d.color,
    outline: ih(n, e),
    xOffset: o ?? 0,
    yOffset: s ?? 0,
    angle: l,
    fillOpacity: d.opacity
  };
}
function WF(t) {
  let e;
  switch (t) {
    case ll.LineThrough:
    case ll.Underline:
      e = t;
      break;
    case ll.None:
  }
  return e;
}
function zF(t) {
  return t === !0 ? "wrap" : "none";
}
function ah(t, e) {
  let i = Re;
  switch (t ?? e) {
    case he.Right:
      i = ct;
      break;
    case he.Left:
      i = St;
      break;
    case he.Center:
    case he.Justify:
  }
  return i;
}
function nh(t, e) {
  let i = Re;
  switch (t ?? e) {
    case ce.Top:
      i = St;
      break;
    case ce.Bottom:
      i = ct;
      break;
    case ce.Baseline:
    case ce.Middle:
  }
  return i;
}
function HF(t) {
  const { angle: e, mappedHAlignment: i, mappedVAlignment: a, isGuideLabel: n } = t;
  let o = i, s = a, r = i;
  const l = a;
  return (Math.abs(e) === 270 || Math.abs(e) === 90) && (n || (r = void 0, s = void 0), l === St ? o = ct : l === ct ? o = St : l === Re && (o = Re)), { align: o, valign: s, horizontalCenter: r, verticalCenter: l };
}
function Xc(t) {
  const { root: e, symbol: i, defaultToColorFromRamp: a, colorRampIndex: n, isChartFillSymbol: o = !1 } = t;
  let s;
  if (a === !0) {
    const r = o ? io : Qo;
    if (i.color = i.color ?? Si({ colorIndex: n, opacity: r }), Ys(i) || $n(i)) {
      const { outline: l } = i;
      l !== void 0 && (l.color = l?.color ?? Si({ colorIndex: n }), i.outline = { ...l });
    }
  }
  return $n(i) && (i.style ??= D.lineMarker.markerStyle, i.size ??= D.lineMarker.markerSize), Jf(i) ? s = th(i, !0) : $n(i) ? s = EF(i) : Ys(i) && (s = VF(i, e)), s;
}
function qF(t) {
  const { input: e, isGuideLabel: i, defaults: a } = t, n = eh(e.angle, a?.rotation), o = ah(e.horizontalAlignment, a?.horizontalCenter), s = nh(e.verticalAlignment, a?.verticalCenter), { align: r, valign: l, horizontalCenter: c, verticalCenter: d } = HF({
    angle: n,
    mappedHAlignment: o,
    mappedVAlignment: s,
    isGuideLabel: i
  });
  return {
    fill: je(e.color).color,
    fontFamily: e.font?.family ?? "Arial, Helvetica, sans-serif",
    fontSize: e.font?.size ?? D.generalFontSize,
    fontWeight: e.font?.weight ?? "400",
    textDecoration: WF(e.font?.decoration),
    align: r,
    valign: l,
    verticalCenter: d,
    horizontalCenter: c,
    text: Ht({ textSymbol: e, format: "amChartsV5" }),
    angle: n,
    xOffset: e.xoffset ?? a?.dx ?? 0,
    yOffset: e.yoffset ?? a?.dy ?? 0,
    backgroundFill: je(e.backgroundColor).color,
    borderFill: je(e.borderLineColor).color,
    borderWidth: e.borderLineSize ?? 1,
    // haloSize: input.haloSize ?? -1,
    haloColor: je(e.haloColor).color,
    rtl: e.rightToLeft ?? ia().rtl ? "rtl" : "ltr",
    wrap: zF(a?.wrap),
    maxWidth: a?.maxWidth ?? Number.NaN
  };
}
function oh(t, e) {
  e !== void 0 && (e.marginBottom !== void 0 && t.set("marginBottom", e.marginBottom), e.marginTop !== void 0 && t.set("marginTop", e.marginTop), e.marginRight !== void 0 && t.set("marginRight", e.marginRight), e.marginLeft !== void 0 && t.set("marginLeft", e.marginLeft), e.verticalCenter !== void 0 && t.set("y", nh(e.verticalCenter)), e.horizontalCenter !== void 0 && t.set("x", ah(e.horizontalCenter)), e.strokeWidth !== void 0 && t.get("background")?.set("strokeWidth", e.strokeWidth), e.paddingBottom !== void 0 && t.set("paddingBottom", e.paddingBottom), e.paddingTop !== void 0 && t.set("paddingTop", e.paddingTop), e.paddingLeft !== void 0 && t.set("paddingLeft", e.paddingLeft), e.paddingRight !== void 0 && t.set("paddingRight", e.paddingRight), e.maxWidth !== void 0 && t.set("maxWidth", e.maxWidth));
}
function Wo(t) {
  const { root: e, parent: i, defaults: a, index: n, id: o } = t, s = Pa.new(e, {
    text: "",
    textAlign: "center",
    background: nc.new(e, {}),
    paddingBottom: 0,
    paddingTop: 0,
    paddingLeft: 0,
    paddingRight: 0
  });
  return o !== void 0 && s.set("id", o), oh(s, a), i !== void 0 && i.children.insertIndex(n ?? i.children.length, s), s;
}
function Nu(t) {
  const { label: e, offset: i, offsetProperty: a } = t;
  e.adapters.remove(a), (e instanceof Pa ? [e] : e.entities).forEach((o) => {
    if (typeof i == "string" && !Number.isFinite(Number(i))) {
      let s = kr(i);
      typeof s == "number" && (s /= 100, o.adapters.add(a, () => (a === "dx" ? o.width() : o.height()) * (s ?? 0)));
    } else {
      const s = Number(i);
      Number.isFinite(s) && o.set(a, s);
    }
  });
}
function Zi(t) {
  const { label: e, labelConfig: i, defaults: a, skipSettingText: n } = t, o = i?.visible ?? !0;
  if (e !== void 0 && !e.isDisposed() && i !== void 0) {
    const s = e instanceof Pa && Qt(e.uid, "isGuide"), r = qF({ input: i.content, isGuideLabel: s, defaults: a });
    e.setAll({
      fill: r.fill,
      fontFamily: r.fontFamily,
      fontWeight: r.fontWeight,
      fontSize: r.fontSize,
      textDecoration: r.textDecoration,
      centerX: r.align,
      centerY: r.valign,
      x: r.horizontalCenter,
      y: r.verticalCenter,
      rotation: r.angle,
      direction: r.rtl,
      oversizedBehavior: r.wrap,
      maxWidth: r.maxWidth
      // TODO: double check whether issue #6942 happens here too
    }), n || e.setAll({ text: r.text }), Nu({
      label: e,
      offset: r.xOffset,
      offsetProperty: "dx"
    }), Nu({
      label: e,
      offset: r.yOffset,
      offsetProperty: "dy"
    }), e.get("background")?.setAll({
      strokeWidth: r.borderWidth,
      strokeOpacity: 1
    }), e.set("visible", o), e instanceof Pa ? _e(e, o) : e.entities.forEach((l) => {
      _e(l, o);
    });
  }
}
function ua(t) {
  const { chart: e, label: i, labelType: a } = t, { legendTitle: n } = D.legendProperties, o = V(e.uid, "config");
  let s = n.maxWidth ?? Number.NaN, r = Number.NaN;
  switch (a) {
    case ue.GuideLabel:
      if (e instanceof Te) {
        const l = i.get("rotation");
        l === 90 || l === 270 ? s = e.seriesContainer.height() : s = e.seriesContainer.width();
      }
      break;
    case ue.XAxisTitle:
      e instanceof Te && (s = e.seriesContainer.width());
      break;
    case ue.YAxisTitle:
      e instanceof Te && (r = e.seriesContainer.height());
      break;
    case ue.ChartTitle:
    case ue.ChartSubTitle:
    case ue.ChartFooter:
      s = e.chartContainer.width() - 20;
      break;
    case ue.LegendTitle:
      o?.legend?.position !== void 0 && (o?.legend?.position === me.Top || o?.legend?.position === me.Bottom) && (s = e.chartContainer.width() - 20);
      break;
  }
  s > 0 && i.setAll({
    maxWidth: s,
    oversizedBehavior: "wrap"
  }), r > 0 && a === ue.YAxisTitle && i.setAll({
    maxHeight: r,
    oversizedBehavior: "wrap"
  });
}
function zo(t) {
  const { chart: e } = t;
  ua(t), e.events.on(
    Se.BoundsChanged,
    at(() => ua(t), D.debounceTime)
  );
}
function nr(t, e) {
  const i = e.get("axisFill"), a = e.get("label");
  if (i !== void 0 && a !== void 0) {
    const n = Qt(a.uid, "guideLabelConfig"), o = t.get("renderer") instanceof li, s = Math.round(i.width()), r = Math.round(i.height()), l = Math.round(a.height()), c = Math.round(a.width()), { horizontalAlignment: d, verticalAlignment: u } = n ?? {};
    let f = 0, m = 0;
    if (o) {
      const g = s !== 0;
      switch (d) {
        case he.Left:
          g ? f = -c / 2 : f = -c;
          break;
        case he.Right:
          g ? f = c / 2 : f = c;
          break;
        case he.Center:
        case he.Justify:
          break;
        default:
          g || (f = c / 2);
          break;
      }
      switch (u) {
        case ce.Bottom:
          g ? m = -l : m = -l / 2;
          break;
        case ce.Middle:
          m = -r / 2;
          break;
        case ce.Top:
        default:
          m = -r + l / 2;
          break;
      }
    } else {
      const g = r !== 0;
      switch (d) {
        case he.Center:
          f = s / 2;
          break;
        case he.Left:
          f = c / 2;
          break;
        case he.Right:
        default:
          f = s - c / 2;
          break;
      }
      switch (u) {
        case ce.Bottom:
          g ? m = r / 2 : m = l;
          break;
        case ce.Top:
          g ? m = -r / 2 + l / 2 : m = -l;
          break;
        case ce.Middle:
        default:
          g || (m = -l / 2);
          break;
      }
    }
    a.setAll({ dx: f, dy: m });
  }
}
function GF(t) {
  const { axis: e, guide: i, label: a } = t, { chart: n } = e;
  if (n) {
    const o = e.get("renderer") instanceof li ? n.yAxes.getIndex(0) : n.xAxes.getIndex(0);
    o && (o.events.on(
      Se.BoundsChanged,
      at(() => {
        nr(e, i);
      }, D.debounceTime)
    ), e.events.on(
      Se.BoundsChanged,
      at(() => {
        nr(e, i);
      }, D.debounceTime)
    ));
  }
  a.setAll({
    paddingTop: 0,
    paddingRight: 0,
    paddingBottom: 0,
    paddingLeft: 0
  });
}
function YF(t) {
  const { guide: e, axis: i, guideLabelConfig: a } = t, n = e.get("label");
  if (n !== void 0) {
    oh(n), Jg(n.uid, { isGuide: !0, guideLabelConfig: a });
    const { chart: o } = i;
    o !== void 0 && zo({
      chart: o,
      label: n,
      labelType: ue.GuideLabel
    }), GF({ axis: i, guide: e, label: n });
  }
}
function XF(t) {
  const { axis: e, guide: i, guideConfig: a, guideType: n } = t, o = i?.get("label");
  if (o !== void 0)
    if (a.label !== void 0) {
      const s = e.get("renderer") instanceof li;
      let r;
      e instanceof ta || (s ? n === re.SFS ? r = D.verticalSurfaceGuideLabels : r = D.verticalLineGuideLabels : n === re.SFS ? r = D.horizontalSurfaceGuideLabels : r = D.horizontalLineGuideLabels), Jg(o.uid, { guideLabelConfig: a.label });
      const l = {
        type: b.Text,
        visible: a.visible,
        content: {
          ...a.label,
          // Resetting the alignments - they will be fully handled by adjustGuideLabelsPositionCallback()
          verticalAlignment: ce.Middle,
          horizontalAlignment: he.Center,
          // For guide labels, when dir attribute is set to "rtl" along with the "lang",
          // we need to ignore the guide label's rtl property and set the rightToLeft property from labelConfig
          // to the rtl value from chart. See issue #7798 for more details
          rightToLeft: o.get("direction") === "rtl"
        }
      };
      Zi({ label: o, labelConfig: l, defaults: r }), o.events.once(Se.BoundsChanged, () => {
        nr(e, i);
      }), nr(e, i);
    } else
      _e(o, !1);
}
function sh(t) {
  const { element: e, fill: i, fillOpacity: a, pattern: n } = t, o = e.get("tooltip");
  let s = !0;
  n !== void 0 ? (o !== void 0 && (s = !1, o.get("background")?.set("fill", i)), e.set("fillPattern", n)) : e.set("fill", i), o !== void 0 && o.set("getFillFromSprite", s), e.set("fillOpacity", a);
}
function or(t, e) {
  t.setAll({
    stroke: e.stroke,
    strokeDasharray: e.strokeDasharray,
    strokeOpacity: e.strokeOpacity,
    strokeWidth: e.strokeWidth,
    lineCap: e.linecap
  });
}
function rh(t) {
  const { element: e, markerSymbol: i, visible: a, defaultToColorFromRamp: n, colorRampIndex: o } = t;
  let s;
  return e !== void 0 && i !== void 0 && (s = Xc({
    symbol: i,
    defaultToColorFromRamp: n,
    colorRampIndex: o
  }), s !== void 0 && (e.setAll({
    svgPath: s.path,
    rotation: s.angle,
    dx: s.xOffset,
    dy: s.yOffset
  }), sh({
    element: e,
    fill: s.fill,
    fillOpacity: s.fillOpacity
  }), or(e, s.outline)), _e(e, a)), s;
}
function Zn(t) {
  const {
    root: e,
    element: i,
    fillSymbol: a,
    visible: n,
    defaultToColorFromRamp: o,
    colorRampIndex: s,
    isChartFillSymbol: r,
    keepCurrentVisibility: l
  } = t;
  let c;
  return i !== void 0 && !i.isDisposed() && (a !== void 0 && (c = Xc({
    root: e,
    symbol: a,
    defaultToColorFromRamp: o,
    colorRampIndex: s,
    isChartFillSymbol: r
  }), c !== void 0 && (sh({
    element: i,
    fill: c.fill,
    fillOpacity: c.fillOpacity,
    pattern: c.pattern
  }), or(i, c.outline))), l || _e(i, n)), c;
}
function ra(t) {
  const { element: e, lineSymbol: i, visible: a, defaultToColorFromRamp: n, colorRampIndex: o } = t;
  let s;
  return e !== void 0 && !e.isDisposed() && (i !== void 0 && (s = Xc({
    symbol: i,
    defaultToColorFromRamp: n,
    colorRampIndex: o
  }), s !== void 0 && (or(e, s), e instanceof Ae && or(e.strokes.template, s))), _e(e, a)), s;
}
function Pt(t) {
  const {
    root: e,
    element: i,
    seriesIndex: a,
    seriesSymbol: n,
    isChartFillSymbol: o,
    colorMatch: s,
    rendererSymbol: r,
    keepCurrentVisibility: l
  } = t;
  let c, d;
  s && r !== void 0 && (c = jg({
    rendererSymbol: r,
    seriesSymbol: n,
    colorIndex: a
  }));
  const u = {
    root: e,
    element: i,
    defaultToColorFromRamp: !0,
    colorRampIndex: a
  }, f = c ?? { ...n };
  switch (n.type) {
    case re.SLS:
      d = ra({
        ...u,
        lineSymbol: f
      });
      break;
    case re.SFS:
      d = Zn({
        ...u,
        fillSymbol: f,
        isChartFillSymbol: o,
        keepCurrentVisibility: l
      });
      break;
    case re.SMS:
      d = rh({
        ...u,
        markerSymbol: f
      });
      break;
  }
  return { symbolWithColorInfo: f, stylingInfo: d };
}
function Mu(t, e) {
  if (e !== void 0) {
    const { elementColor: i, elementOutlineColor: a, elementOutlineWidth: n, rotation: o, transformation: s } = e, { opacity: r, scale: l } = s ?? {};
    if (i !== void 0 && t.setAll({ fill: je(i).color, fillOpacity: 1 }), a !== void 0 && t.setAll({ stroke: je(a).color }), n !== void 0 && t.setAll({ strokeWidth: n }), o !== void 0 && t.setAll({ rotation: o }), l !== void 0 && t.setAll({ scale: l }), r !== void 0) {
      t.setAll({ fillOpacity: (t.get("fillOpacity") ?? 1) * r });
      const c = t.get("strokeOpacity");
      c !== void 0 && t.setAll({ strokeOpacity: c * r });
    }
  }
}
async function UF(t = ia().locale) {
  let e = await import("@amcharts/amcharts5/locales/en_US.js"), i = await import("../../chunks/messages.en-US4.js");
  switch (t) {
    case G.Arabic:
      e = await import("@amcharts/amcharts5/locales/ar.js"), i = await import("../../chunks/messages.ar4.js");
      break;
    case G.Bosnian:
      e = await import("@amcharts/amcharts5/locales/bs_BA.js"), i = await import("../../chunks/messages.bs4.js");
      break;
    case G.Bulgarian:
      e = await import("../../chunks/bg_BG.js"), i = await import("../../chunks/messages.bg4.js");
      break;
    case G.Catalan:
      e = await import("@amcharts/amcharts5/locales/ca_ES.js"), i = await import("../../chunks/messages.ca4.js");
      break;
    case G.Czech:
      e = await import("@amcharts/amcharts5/locales/cs_CZ.js"), i = await import("../../chunks/messages.cs4.js");
      break;
    case G.Danish:
      break;
    case G.German:
      e = await import("@amcharts/amcharts5/locales/de_DE.js"), i = await import("../../chunks/messages.de4.js");
      break;
    case G.Greek:
      e = await import("@amcharts/amcharts5/locales/el_GR.js"), i = await import("../../chunks/messages.el4.js");
      break;
    case G.EnglishUSA:
      e = await import("@amcharts/amcharts5/locales/en_US.js"), i = await import("../../chunks/messages.en-US4.js");
      break;
    case G.Spanish:
      e = await import("@amcharts/amcharts5/locales/es_ES.js"), i = await import("../../chunks/messages.es4.js");
      break;
    case G.Estonian:
      e = await import("@amcharts/amcharts5/locales/et_EE.js"), i = await import("../../chunks/messages.et4.js");
      break;
    case G.Finnish:
      e = await import("@amcharts/amcharts5/locales/fi_FI.js"), i = await import("../../chunks/messages.fi4.js");
      break;
    case G.French:
      e = await import("@amcharts/amcharts5/locales/fr_FR.js"), i = await import("../../chunks/messages.fr4.js");
      break;
    case G.Hebrew:
      e = await import("@amcharts/amcharts5/locales/he_IL.js"), i = await import("../../chunks/messages.he4.js");
      break;
    case G.Croatian:
      e = await import("@amcharts/amcharts5/locales/hr_HR.js"), i = await import("../../chunks/messages.hr4.js");
      break;
    case G.Hungarian:
      e = await import("@amcharts/amcharts5/locales/hu_HU.js"), i = await import("../../chunks/messages.hu4.js");
      break;
    case G.Indonesian:
      e = await import("@amcharts/amcharts5/locales/id_ID.js"), i = await import("../../chunks/messages.id4.js");
      break;
    case G.Italian:
      e = await import("@amcharts/amcharts5/locales/it_IT.js"), i = await import("../../chunks/messages.it4.js");
      break;
    case G.Japanese:
      e = await import("@amcharts/amcharts5/locales/ja_JP.js"), i = await import("../../chunks/messages.ja4.js");
      break;
    case G.Korean:
      e = await import("@amcharts/amcharts5/locales/ko_KR.js"), i = await import("../../chunks/messages.ko4.js");
      break;
    case G.Lithuanian:
      e = await import("@amcharts/amcharts5/locales/lt_LT.js"), i = await import("../../chunks/messages.lt4.js");
      break;
    case G.Latvian:
      e = await import("@amcharts/amcharts5/locales/lv_LV.js"), i = await import("../../chunks/messages.lv4.js");
      break;
    case G.NorwegianBokml:
      e = await import("@amcharts/amcharts5/locales/nb_NO.js");
      break;
    case G.Dutch:
      e = await import("@amcharts/amcharts5/locales/nl_NL.js"), i = await import("../../chunks/messages.nl4.js");
      break;
    case G.Polish:
      e = await import("@amcharts/amcharts5/locales/pl_PL.js"), i = await import("../../chunks/messages.pl4.js");
      break;
    case G.PortugueseBrazil:
      e = await import("@amcharts/amcharts5/locales/pt_BR.js"), i = await import("../../chunks/messages.pt-BR4.js");
      break;
    case G.PortuguesePortugal:
      e = await import("@amcharts/amcharts5/locales/pt_PT.js"), i = await import("../../chunks/messages.pt-PT4.js");
      break;
    case G.Romanian:
      e = await import("@amcharts/amcharts5/locales/ro_RO.js"), i = await import("../../chunks/messages.ro4.js");
      break;
    case G.Russian:
      e = await import("@amcharts/amcharts5/locales/ru_RU.js"), i = await import("../../chunks/messages.ru4.js");
      break;
    case G.Serbian:
      e = await import("@amcharts/amcharts5/locales/sr_RS.js"), i = await import("../../chunks/messages.sr4.js");
      break;
    case G.Slovak:
      e = await import("../../chunks/sk_SK.js"), i = await import("../../chunks/messages.sk4.js");
      break;
    case G.Slovenian:
      e = await import("@amcharts/amcharts5/locales/sl_SL.js"), i = await import("../../chunks/messages.sl4.js");
      break;
    case G.Swedish:
      e = await import("@amcharts/amcharts5/locales/sv_SE.js"), i = await import("../../chunks/messages.sv4.js");
      break;
    case G.Thai:
      e = await import("@amcharts/amcharts5/locales/th_TH.js"), i = await import("../../chunks/messages.th4.js");
      break;
    case G.Turkish:
      break;
    case G.Ukrainian:
      e = await import("@amcharts/amcharts5/locales/uk_UA.js"), i = await import("../../chunks/messages.uk4.js");
      break;
    case G.Vietnamese:
      e = await import("@amcharts/amcharts5/locales/vi_VN.js"), i = await import("../../chunks/messages.vi4.js");
      break;
    case G.ChineseChina:
      e = await import("@amcharts/amcharts5/locales/zh_Hans.js"), i = await import("../../chunks/messages.zh-CN4.js");
      break;
    case G.ChineseHongKong:
      e = await import("@amcharts/amcharts5/locales/zh_Hant.js"), i = await import("../../chunks/messages.zh-HK4.js");
      break;
    case G.ChineseTaiwan:
      e = await import("@amcharts/amcharts5/locales/zh_Hant.js"), i = await import("../../chunks/messages.zh-TW4.js");
      break;
    case G.English:
  }
  return { ...e.default, ...i.default };
}
function Qi(t) {
  const { root: e, type: i, intlOptions: a, formatLocale: n } = t;
  let o;
  switch (i) {
    case b.NumberAxisFormat: {
      o = Mf.new(e, {}), o.set("intlLocales", n), o.set("numberFormat", a);
      break;
    }
    case b.DateAxisFormat: {
      o = Gy.new(e, {}), o.set("intlLocales", n);
      break;
    }
  }
  return o;
}
const ve = {
  Top: "top",
  Bottom: "bottom",
  Median: "median",
  Outliers: "outliers"
};
async function jF(t) {
  const { numberOfQueries: e, selectionOIDs: i, chartConfig: a, queryConfig: n, options: o, errorStrings: s, queryObject: r } = t, { setTimeBinningInfoWhenNotProvided: l } = o ?? {}, { series: c } = a, d = z(c), u = [], { maxOIDsPerSelectionQuery: f } = Uo();
  for (let g = 0; g < e; g += 1) {
    const y = g * f, p = (g + 1) * f - 1, S = i.slice(y === 0 ? 0 : y - 1, p), x = { ...n };
    switch (x.objectIds = S, d) {
      case b.PieSeries:
      case b.BarSeries:
      case b.LineSeries:
      case b.RadarSeries:
      case b.ComboLineAndBarSeries:
        if (ei({
          xAxisValueFormatType: ii(a),
          setTimeBinningInfoWhenNotProvided: l,
          seriesConfig: c[0]
        })) {
          const C = a;
          "temporalBinning" in C.series[0] && C.series[0].temporalBinning && (C.series[0].temporalBinning.trimIncompleteTimeInterval = !1, C.series[0].temporalBinning.type === wi.CalendarBased && (delete C.series[0].temporalBinning.start, delete C.series[0].temporalBinning.end)), u.push(
            zc({
              chartConfig: C,
              queryConfig: x,
              queryObject: r,
              options: o
            })
          );
        } else
          u.push(
            cF({
              queryObject: r,
              chartConfig: a,
              options: o,
              queryConfig: x
            })
          );
        break;
      case b.BoxPlotSeries:
        u.push(
          dF({
            queryObject: r,
            chartConfig: a,
            options: o,
            errorStrings: s,
            queryConfig: x
          })
        );
        break;
      case b.ScatterSeries:
        u.push(
          $g({
            queryObject: r,
            chartConfig: a,
            queryConfig: x,
            options: o,
            errorStrings: s,
            sortData: !1,
            // sort not needed
            calculateTrendLine: !1
            // trendline not needed
          })
        );
        break;
      case b.HistogramSeries:
        u.push(
          a0({
            queryObject: r,
            queryConfig: x,
            chartConfig: a,
            x: c[0].x
          })
        );
        break;
    }
  }
  return await Promise.all(u);
}
function _F(t) {
  const { dataFetchingResults: e, numberOfQueries: i, series: a } = t, n = z(a), o = H(a);
  let s = [];
  for (let r = 0; r < i; r += 1) {
    const l = e[r];
    if (l !== void 0) {
      let c;
      if (n === b.ScatterSeries)
        c = l.dataItems;
      else if ("data" in l && l.data) {
        const d = l.data;
        "dataItems" in d && (c = d.dataItems), "outliers" in d && d.outliers && s.push(...d.outliers), "meanLines" in d && d.meanLines && s.push(...d.meanLines);
      }
      if (c)
        if (a[0].type === b.ScatterSeries) {
          const { x: d, y: u } = a[0];
          s.push(
            ...c.map((f) => ({
              [d]: f[d],
              [u]: f[u]
            }))
          );
        } else l.valid && (o === L.PieFromFields ? s = Qs({
          dataToConvert: c[0],
          x: tt,
          y: Rt
        }) : o === L.BarAndLineFromFields ? s = Qs({
          dataToConvert: c[0],
          x: a[0].x,
          y: a[0].y
        }) : s.push(...c));
    }
  }
  return s;
}
async function lh(t) {
  const {
    chartConfig: e,
    queryConfig: i,
    chartData: a,
    currentSelectionOIDs: n,
    dataWasUpdated: o,
    queryObject: s,
    options: r,
    errorStrings: l
  } = t, { series: c } = e, { selectionData: d, viewExtentUpdated: u, returnSelectionOIDs: f, chartLimits: m } = r ?? {}, { selectionItems: g, selectionOIDs: y } = d ?? {};
  let p;
  const x = z(c) !== b.HistogramSeries && g !== void 0 && g.length > 0 && !(c[0].x in g[0]) && !(tt in g[0]) && !(k.boxPlot.boxPlotCategory in g[0]);
  if (u !== !0 && f !== !1 && y !== void 0 && y.length > 0 && (o === !0 || x || !Di(y, n))) {
    const F = Vi(a);
    if (F !== void 0 && !Ac({ dataContext: F[0], chartConfig: e, chartLimits: m }))
      p = F.filter((v) => {
        const A = v[ot.uniqueIdsName];
        return typeof A == "number" ? y?.includes(A) : !1;
      });
    else if (y?.[0] !== void 0 && i !== void 0) {
      const { maxOIDsPerSelectionQuery: v } = Uo(), A = Math.ceil(y.length / v), w = await jF({
        numberOfQueries: A,
        selectionOIDs: y,
        queryConfig: i,
        queryObject: s,
        options: r,
        errorStrings: l,
        chartConfig: e
      });
      p = _F({
        dataFetchingResults: w,
        numberOfQueries: A,
        series: c
      });
    }
  }
  return p;
}
function* ZF(t) {
  const { filterList: e, queryObject: i, queryConfig: a } = t;
  for (let n = 0; n < e.length; n += 1) {
    const o = { ...a };
    o.where = Xe([o.where, e[n]]), yield hb({
      queryObject: i,
      queryConfig: o,
      uniqueFeature: !0
    });
  }
}
async function ch(t) {
  const { whereList: e, queryObject: i, queryFilter: a, queryConfig: n } = t;
  let o = [];
  if (e.length > 0) {
    const s = Uo().maxElementsPerSelectionQuery, r = [], l = Math.ceil(e.length / s);
    for (let d = 0; d < l; d += 1) {
      const u = d * s, f = (d + 1) * s, m = e.slice(u === 0 ? 0 : u - 1, f);
      let g = Xe(m, "OR");
      g = Xe([a, g]), r.push(g);
    }
    const c = ZF({
      filterList: r,
      queryObject: i,
      queryConfig: n
    });
    o = (await Promise.all(c)).flat(), o = Array.from(new Set(o));
  }
  return o;
}
const Ia = {
  Outlier: "outlier",
  Box: "box",
  OutlierToOutlier: "outlier-outlier",
  OutlierToBox: "outlier-box",
  BoxToOutlier: "box-outlier",
  BoxToBox: "box-box"
};
function QF(t, e) {
  const i = t[k.boxPlot.boxPlotOutlierId] === !0 ? Ia.Outlier : Ia.Box, a = typeof e == "number" ? Ia.Outlier : Ia.Box;
  return `${i}-${a}`;
}
function KF(t) {
  const { oneSelectedItem: e, dataContext: i, selectedOutlierKey: a } = t;
  return e[a] === i[a];
}
function JF(t) {
  const { elementMin: e, elementMax: i, selectedOutlierValue: a } = t;
  let n;
  return typeof e == "number" && typeof i == "number" && typeof a == "number" && (n = a >= e && a <= i), n;
}
function eL(t) {
  const { selectedMin: e, selectedMax: i, elementOutlierValue: a, oneSelectedItem: n, iqrField: o } = t;
  let s;
  typeof e == "number" && typeof i == "number" && typeof a == "number" && (s = a >= e && a <= i);
  const r = o in n;
  return s !== !1 && r;
}
function tL(t) {
  const { selectedMin: e, selectedMax: i, elementMin: a, oneSelectedItem: n, elementMax: o, iqrField: s } = t;
  let r;
  typeof a == "number" && typeof o == "number" && typeof e == "number" && typeof i == "number" && (r = !(a >= i || o <= e));
  const l = s in n;
  return r !== !1 && l;
}
function iL(t) {
  const { oneSelectedItem: e, dataContext: i, xAxisField: a } = t, n = i[k.typeOrDomainIdValue] ?? i[k.originalCategoryValue] ?? i[k.boxPlot.boxPlotCategory] ?? i[a], o = e[k.typeOrDomainIdValue] ?? e[k.originalCategoryValue] ?? e[k.boxPlot.boxPlotCategory] ?? e[a];
  return n === o;
}
function aL(t) {
  const { chartSubType: e, yAxisField: i, splitBy: a, showOutliers: n } = t, o = e === L.BoxPlotMultiFieldsAndCategory ? i : void 0, s = { y: o, splitBy: a }, r = oe({
    ...s,
    key: Y.Outlier
  }), l = oe({
    ...s,
    key: Y.Max,
    showOutliers: n
  }), c = oe({
    ...s,
    key: Y.Min,
    showOutliers: n
  }), d = oe({
    ...s,
    key: Y.Max,
    showOutliers: !1
  }), u = oe({
    ...s,
    key: Y.Min,
    showOutliers: !1
  }), f = oe({
    ...s,
    key: Y.Max,
    showOutliers: !0
  }), m = oe({
    ...s,
    key: Y.Min,
    showOutliers: !0
  }), g = oe({
    splitBy: a,
    y: o,
    key: Y.IQR
  });
  return {
    selectedOutlierKey: r,
    maxField: l,
    minField: c,
    selectedMaxFieldWoOutliers: d,
    selectedMinFieldWoOutliers: u,
    selectedMaxFieldWithOutliers: f,
    selectedMinFieldWithOutliers: m,
    iqrField: g
  };
}
function nL(t) {
  const { elementDataContext: e, layerOidField: i, xAxisField: a, splitBy: n, yAxisField: o, chartSubType: s, showOutliers: r } = t, l = e;
  let c;
  if (l?.[k.boxPlot.boxPlotMeanLineMarkerId] === !0) {
    const u = oe({
      splitBy: n,
      key: Y.Average
    });
    c = (f) => {
      const m = !a || !(a in f && a in l) || f[a] === l[a], g = u in f && u in l;
      return m && g;
    };
  } else
    a !== void 0 && o !== void 0 && (c = (u) => {
      let f;
      if (i !== void 0 && i in u && i in l)
        f = u[i] === l[i];
      else {
        const {
          selectedOutlierKey: m,
          maxField: g,
          minField: y,
          selectedMaxFieldWoOutliers: p,
          selectedMinFieldWoOutliers: S,
          selectedMaxFieldWithOutliers: x,
          selectedMinFieldWithOutliers: C,
          iqrField: F
        } = aL({ chartSubType: s, yAxisField: o, splitBy: n, showOutliers: r }), v = l[m], A = u[m], w = l[y], O = l[g], I = u[S] ?? u[C], N = u[p] ?? u[x];
        let M = iL({ oneSelectedItem: u, dataContext: l, xAxisField: a });
        if (M)
          switch (QF(u, v)) {
            case Ia.OutlierToOutlier:
              M = KF({ oneSelectedItem: u, dataContext: l, selectedOutlierKey: m });
              break;
            case Ia.OutlierToBox:
              M = JF({ elementMin: w, elementMax: O, selectedOutlierValue: A });
              break;
            case Ia.BoxToOutlier:
              M = eL({
                selectedMin: I,
                selectedMax: N,
                elementOutlierValue: v,
                oneSelectedItem: u,
                iqrField: F
              });
              break;
            case Ia.BoxToBox:
              M = tL({
                selectedMin: I,
                selectedMax: N,
                elementMin: w,
                oneSelectedItem: u,
                elementMax: O,
                iqrField: F
              });
              break;
          }
        f = M === !0;
      }
      return f;
    });
  return c;
}
function Uc(t) {
  const { layerOidField: e, sliceDataContext: i, selectionDataContext: a, xAxisField: n } = t;
  let o = !1;
  if (e !== void 0 && e in i && e in a)
    o = a[e]?.toString() === i[e]?.toString();
  else {
    let s = i[k.typeOrDomainIdValue];
    s === void 0 && (s = i[k.originalCategoryValue]), s === void 0 && (s = i[n]), s === void 0 && (s = i[tt]);
    let r = a[k.typeOrDomainIdValue];
    r === void 0 && (r = a[k.originalCategoryValue]), r === void 0 && (r = a[n]), r === void 0 && (r = a[tt]), o = s !== void 0 && r !== void 0 && s === r;
  }
  return o;
}
function zr(t) {
  const { options: e, elementDataContext: i, selectionDataItems: a, layerOidField: n, xAxisField: o, yAxisField: s, chartType: r } = t, { originalCategoryValue: l } = k;
  let c = !1, d;
  if (i !== void 0 && a !== void 0)
    switch (r) {
      case b.RadarSeries:
      case b.BarSeries:
      case b.LineSeries:
      case b.ComboLineAndBarSeries:
        if (o !== void 0 && s !== void 0) {
          const u = i;
          d = (f) => {
            let m;
            if (n !== void 0 && n in f && n in u)
              m = f[n] === u[n];
            else if (k.dateBinningRange in u && typeof f[o] == "number") {
              const g = f[o], [y, p] = u[k.dateBinningRange], S = u[k.lastTemporalBin] === !0 ? g <= p : g < p;
              m = g >= y && S && s in f && Number.isFinite(f[s]);
            } else {
              const g = (S) => {
                let x = S[k.typeOrDomainIdValue];
                return x === void 0 && (x = S[l]), x === void 0 && (x = S[o]), x = x === null ? k.nullValue : x, x;
              }, y = g(u);
              m = g(f) === y && s in f;
            }
            return m;
          };
        }
        break;
      case b.BoxPlotSeries:
        d = nL(t);
        break;
      case b.ScatterSeries:
        if (o !== void 0 && s !== void 0) {
          const u = i;
          if (!Lc({
            dataContext: u,
            chartLimits: e?.chartLimits
          }))
            d = (f) => {
              let m;
              return n !== void 0 && n in u && n in f ? m = f[n] === u[n] : m = f[o] === u[o] && f[s] === u[s], m;
            };
          else {
            const { dataContextXMinField: f, dataContextXMaxField: m, dataContextYMinField: g, dataContextYMaxField: y } = k.scatterplotAggregationFields, { [f]: p, [m]: S } = u, x = o !== s ? u[g] : p, C = o !== s ? u[y] : S, F = (A) => {
              const w = A[o] ?? Number.NaN, O = p ?? Number.NaN, I = S ?? Number.NaN;
              return p === S ? w === O : (w ?? Number.NaN) >= O && (w ?? Number.NaN) < I;
            }, v = (A) => {
              const w = A[s] ?? Number.NaN, O = x ?? Number.NaN, I = C ?? Number.NaN;
              return x === C ? w === O : w >= O && w < I;
            };
            d = (A) => F(A) && v(A);
          }
        }
        break;
      case b.HistogramSeries:
        d = (u) => {
          let f = !1;
          const { minValue: m, maxValue: g } = i, { isLastBin: y } = i;
          if (o !== void 0 && o in u) {
            const p = u[o];
            f = typeof p == "number" && p >= m && (y && p <= g || !y && p < g);
          } else if ("minValue" in u && "maxValue" in u) {
            const { minValue: p, maxValue: S } = u;
            f = !(m >= S || g <= p);
          }
          return f;
        };
        break;
      case b.PieSeries:
        o !== void 0 && (d = (u) => {
          const f = i, m = qi(f), g = [f];
          return m && g.push(...ss({ groupOfSlicesDataContext: f }) ?? []), g.some(
            (p) => Uc({
              sliceDataContext: p,
              selectionDataContext: u,
              layerOidField: n,
              xAxisField: o
            })
          );
        });
        break;
    }
  return d !== void 0 && (c = a.some(d)), c;
}
function fa(t) {
  const {
    isFeatureCollectionLayer: e,
    dataContext: i,
    yAxisField: a,
    yList: n,
    xAxisField: o,
    splitBy: s,
    chartType: r,
    chartSubType: l,
    showOutliers: c
  } = t;
  let d = { ...i };
  if (i !== void 0) {
    if (r === b.RadarSeries || r === b.BarSeries || r === b.LineSeries || r === b.ComboLineAndBarSeries || r === b.PieSeries) {
      r !== b.PieSeries && (e || l !== L.BarAndLineNoAggregation && l !== L.BarAndLineSplitByNoAggregation) && n.forEach((f) => {
        f !== a && delete d[f];
      });
      const u = Zt({
        value: i[o],
        dataContext: i,
        keepNullValues: !0
      });
      d[o] = u, !be(s) && !pr(s) && (d[Ze(s)] = Lt({ where: s, escape: !1 }));
    } else if (r === b.BoxPlotSeries) {
      d = { [o]: i[o] }, [
        ot.uniqueIdsName,
        k.boxPlot.boxPlotMeanLineMarkerId,
        k.boxPlot.boxPlotOutlierId,
        k.typeOrDomainIdValue
      ].forEach((f) => {
        i[f] && (d[f] = i[f]);
      });
      const u = l === L.BoxPlotMultiFieldsAndCategory ? a : void 0;
      Object.values(Y).forEach((f) => {
        const m = oe({ key: f, y: u, splitBy: s, showOutliers: c });
        i[m] !== void 0 && (d[m] = i[m]);
      });
    }
  }
  return d;
}
function oL(t) {
  let e = !1;
  return t instanceof Te && (e = V(t.uid, "isRotated") === !0 ? t.yAxes.getIndex(0) instanceof nt : t.xAxes.getIndex(0) instanceof nt), e;
}
function sL(t, e) {
  const i = { ..._i(e) }, a = [
    "year",
    "month",
    "day",
    "hour",
    "minute",
    "second"
  ], n = {}, o = {}, s = Yy.new(i.timeZone);
  t.root.timezone?.name !== s.name && (t.root.timezone = s);
  for (let r = 0; r < a.length; r += 1) {
    const l = a[r], c = r === 0 ? l : a[r - 1], d = e?.formatPerDateTimeUnit?.[l] ?? i, u = e?.formatPerDateTimeUnit?.[c];
    d && Object.values(d).find((f) => f !== void 0 && (typeof f != "string" || !be(f))) && (n[l] = d, o[l] = u ?? d);
  }
  Object.keys(n).length > 0 && t.set("dateFormats", n), Object.keys(o).length > 0 && t.set("periodChangeDateFormats", o);
}
function dh(t, e, i) {
  const a = e - t;
  let n = [];
  if (a !== 0) {
    if (i === 1)
      n = [t];
    else if (i > 1) {
      const o = a / (i - 1);
      n = [...Rb(t, e, o), e];
    }
  }
  return n;
}
function uh({ x: t, mean: e, stddev: i, scalingFactor: a }) {
  const o = -1 / (2 * i ** 2);
  return (a ?? 1) * Math.exp(o * (t - e) ** 2);
}
function fh(t) {
  let e = 0;
  if (t.length > 0)
    for (let i = 0; i < t.length; i += 1)
      t[i].count > e && (e = t[i].count);
  return e;
}
const Tt = {
  CustomActive: "custom-active",
  CustomInactive: "custom-inactive",
  Default: "default",
  Active: "active"
};
function mh(t) {
  let e = !1, i;
  if (t.target.dataItem?.component instanceof oc ? { chart: i } = t.target.dataItem.component : (t.target instanceof Rf || t.target instanceof Pf) && ({ chart: i } = t.target), i instanceof Te || i instanceof sn) {
    const a = V(i.uid, "actionMode");
    if (a !== void 0) {
      const { originalEvent: n } = t;
      e = a === ne.MultiSelection || a === ne.MultiSelectionWithCtrlKey && ("ctrlKey" in n && n.ctrlKey || "metaKey" in n && n.metaKey);
    }
  }
  return e;
}
function Dt(t) {
  const { element: e, selected: i, multiSelect: a, isDateOrCategoryAxis: n, backToDefaultState: o } = t;
  let s = !1;
  if (e !== void 0) {
    const r = pa(e.uid, "selected") ?? !1;
    s = r, a !== !0 ? n === !0 ? s = r ? !1 : r !== i : s = i : s = r !== i;
    const l = o === !0 ? Tt.Default : Tt.CustomInactive;
    e.states.apply(Tt.Default), e.states.apply(s ? Tt.CustomActive : l), s !== r && kF(e.uid, { selected: s });
  }
  return s;
}
function rL(t, e) {
  const i = V(e.chart?.uid ?? Number.NaN, "actionMode"), a = mh(t);
  return i === ne.MonoSelection || i === ne.MultiSelectionWithCtrlKey && !a;
}
function na(t, e) {
  const { selectedElementsTheme: i, nonSelectedElementsTheme: a } = e ?? D.selectionTheme ?? {}, n = t.states.create(Tt.CustomActive, {}), o = t.states.create(Tt.CustomInactive, {});
  Mu(n, i), Mu(o, a);
}
function lL(t) {
  return !!/^data:[a-z]+\/[a-z+.-]+;base64/u.test(t);
}
function gh(t, e = 512) {
  if (!lL(t))
    throw new Error("Cannot convert a string that is not a data uri to a blob");
  const i = t.split(",")[0].split(":")[1].split(";")[0], a = atob(t.split(",")[1]), n = [];
  for (let o = 0; o < a.length; o += e) {
    const s = a.slice(o, o + e), r = new Array(s.length);
    for (let c = 0; c < s.length; c++)
      r[c] = s.charCodeAt(c);
    const l = new Uint8Array(r);
    n.push(l);
  }
  return new Blob(n, { type: i });
}
function Qn(t) {
  const { value: e, valueFormat: i, formatLocale: a, root: n } = t;
  let o = e?.toString();
  const s = Qi({
    type: i.type,
    intlOptions: i.intlOptions,
    formatLocale: a,
    root: n
  });
  return (typeof e == "number" && i.type === b.NumberAxisFormat || (typeof e == "number" || e instanceof Date) && i.type === b.DateAxisFormat) && (o = s.format(e, _i(i))), o;
}
async function cL(t) {
  const { root: e, exportOptions: i } = t, { format: a, quality: n = 1, ...o } = i, s = n < 0 || n > 1 ? 1 : n, l = await oS.new(e, {}).exportImage(a, {
    quality: s,
    ...o
  }), c = gh(l), d = a === "jpg" ? "image/jpeg" : "image/png";
  return new File([c], `chart.${a}`, { type: d });
}
function Bo(t, e) {
  if (t !== void 0 && e !== void 0 && (t.states.lookup("default")?.setAll({
    fill: e.fill,
    // stylingInfo.pattern ?? stylingInfo.fill,
    fillOpacity: e.fillOpacity
  }), e.outline !== void 0)) {
    const { outline: i } = e;
    t.states.lookup("default")?.setAll({
      stroke: i.stroke,
      // "strokeOpacity": outline.stroke.alpha === 0 ? 0 : 1,
      strokeDasharray: i.strokeDasharray,
      lineCap: i.linecap,
      strokeWidth: i.strokeWidth
    });
  }
}
const h = {
  Rotated: 0,
  NonRotated: 1,
  RTL: 2,
  LTR: 3,
  Stacked: 4,
  Stacked100: 5,
  SideBySide: 6,
  LegendTop: 7,
  LegendBottom: 8,
  LegendLeft: 9,
  LegendRight: 10,
  DateAxis: 11,
  ValueAxis: 12,
  CategoryAxis: 13,
  OrderByFieldsASC: 14,
  OrderByFieldsDESC: 15
}, hh = /* @__PURE__ */ new Set([
  // Case of descending order for a DateAxis
  // SideBySide
  `${h.NonRotated}-${h.LTR}-${h.SideBySide}-${h.LegendLeft}-${h.DateAxis}-${h.OrderByFieldsDESC}`,
  `${h.NonRotated}-${h.LTR}-${h.SideBySide}-${h.LegendRight}-${h.DateAxis}-${h.OrderByFieldsDESC}`,
  `${h.NonRotated}-${h.LTR}-${h.SideBySide}-${h.LegendTop}-${h.DateAxis}-${h.OrderByFieldsDESC}`,
  `${h.NonRotated}-${h.LTR}-${h.SideBySide}-${h.LegendBottom}-${h.DateAxis}-${h.OrderByFieldsDESC}`,
  `${h.NonRotated}-${h.RTL}-${h.SideBySide}-${h.LegendLeft}-${h.DateAxis}-${h.OrderByFieldsDESC}`,
  `${h.NonRotated}-${h.RTL}-${h.SideBySide}-${h.LegendRight}-${h.DateAxis}-${h.OrderByFieldsDESC}`,
  `${h.Rotated}-${h.LTR}-${h.SideBySide}-${h.LegendRight}-${h.DateAxis}-${h.OrderByFieldsDESC}`,
  `${h.Rotated}-${h.LTR}-${h.SideBySide}-${h.LegendLeft}-${h.DateAxis}-${h.OrderByFieldsDESC}`,
  `${h.Rotated}-${h.LTR}-${h.SideBySide}-${h.LegendTop}-${h.DateAxis}-${h.OrderByFieldsDESC}`,
  `${h.Rotated}-${h.LTR}-${h.SideBySide}-${h.LegendBottom}-${h.DateAxis}-${h.OrderByFieldsDESC}`,
  `${h.Rotated}-${h.RTL}-${h.SideBySide}-${h.LegendRight}-${h.DateAxis}-${h.OrderByFieldsDESC}`,
  `${h.Rotated}-${h.RTL}-${h.SideBySide}-${h.LegendLeft}-${h.DateAxis}-${h.OrderByFieldsDESC}`,
  // Stacked:
  // LTR and notRotated chart
  `${h.NonRotated}-${h.LTR}-${h.Stacked}-${h.LegendLeft}-${h.DateAxis}-${h.OrderByFieldsDESC}`,
  `${h.NonRotated}-${h.LTR}-${h.Stacked}-${h.LegendRight}-${h.DateAxis}-${h.OrderByFieldsDESC}`,
  `${h.NonRotated}-${h.LTR}-${h.Stacked}-${h.LegendTop}-${h.DateAxis}-${h.OrderByFieldsDESC}`,
  `${h.NonRotated}-${h.LTR}-${h.Stacked}-${h.LegendBottom}-${h.DateAxis}-${h.OrderByFieldsDESC}`,
  // RTL and choosing between rotated or notRotated chart
  `${h.NonRotated}-${h.RTL}-${h.Stacked}-${h.LegendLeft}-${h.DateAxis}-${h.OrderByFieldsDESC}`,
  `${h.NonRotated}-${h.RTL}-${h.Stacked}-${h.LegendRight}-${h.DateAxis}-${h.OrderByFieldsDESC}`,
  `${h.Rotated}-${h.RTL}-${h.Stacked}-${h.LegendTop}-${h.DateAxis}-${h.OrderByFieldsDESC}`,
  `${h.Rotated}-${h.RTL}-${h.Stacked}-${h.LegendBottom}-${h.DateAxis}-${h.OrderByFieldsDESC}`,
  // Stacked100:
  // LTR and notRotated chart
  `${h.NonRotated}-${h.LTR}-${h.Stacked100}-${h.LegendLeft}-${h.DateAxis}-${h.OrderByFieldsDESC}`,
  `${h.NonRotated}-${h.LTR}-${h.Stacked100}-${h.LegendRight}-${h.DateAxis}-${h.OrderByFieldsDESC}`,
  `${h.NonRotated}-${h.LTR}-${h.Stacked100}-${h.LegendTop}-${h.DateAxis}-${h.OrderByFieldsDESC}`,
  `${h.NonRotated}-${h.LTR}-${h.Stacked100}-${h.LegendBottom}-${h.DateAxis}-${h.OrderByFieldsDESC}`,
  // RTL and choosing between rotated or notRotated chart
  `${h.NonRotated}-${h.RTL}-${h.Stacked100}-${h.LegendLeft}-${h.DateAxis}-${h.OrderByFieldsDESC}`,
  `${h.NonRotated}-${h.RTL}-${h.Stacked100}-${h.LegendRight}-${h.DateAxis}-${h.OrderByFieldsDESC}`,
  `${h.Rotated}-${h.RTL}-${h.Stacked100}-${h.LegendTop}-${h.DateAxis}-${h.OrderByFieldsDESC}`,
  `${h.Rotated}-${h.RTL}-${h.Stacked100}-${h.LegendBottom}-${h.DateAxis}-${h.OrderByFieldsDESC}`,
  // Case of ascending order for a DateAxis
  // SideBySide
  `${h.NonRotated}-${h.RTL}-${h.SideBySide}-${h.LegendTop}-${h.DateAxis}-${h.OrderByFieldsASC}`,
  `${h.NonRotated}-${h.RTL}-${h.SideBySide}-${h.LegendBottom}-${h.DateAxis}-${h.OrderByFieldsASC}`,
  `${h.Rotated}-${h.RTL}-${h.SideBySide}-${h.LegendBottom}-${h.DateAxis}-${h.OrderByFieldsASC}`,
  `${h.Rotated}-${h.RTL}-${h.SideBySide}-${h.LegendTop}-${h.DateAxis}-${h.OrderByFieldsASC}`,
  // Stacked:
  // LTR and notRotated chart
  `${h.NonRotated}-${h.LTR}-${h.Stacked}-${h.LegendLeft}-${h.DateAxis}-${h.OrderByFieldsASC}`,
  `${h.NonRotated}-${h.LTR}-${h.Stacked}-${h.LegendRight}-${h.DateAxis}-${h.OrderByFieldsASC}`,
  `${h.NonRotated}-${h.LTR}-${h.Stacked}-${h.LegendTop}-${h.DateAxis}-${h.OrderByFieldsASC}`,
  `${h.NonRotated}-${h.LTR}-${h.Stacked}-${h.LegendBottom}-${h.DateAxis}-${h.OrderByFieldsASC}`,
  // RTL and choosing between rotated or notRotated chart
  `${h.NonRotated}-${h.RTL}-${h.Stacked}-${h.LegendLeft}-${h.DateAxis}-${h.OrderByFieldsASC}`,
  `${h.NonRotated}-${h.RTL}-${h.Stacked}-${h.LegendRight}-${h.DateAxis}-${h.OrderByFieldsASC}`,
  `${h.Rotated}-${h.RTL}-${h.Stacked}-${h.LegendTop}-${h.DateAxis}-${h.OrderByFieldsASC}`,
  `${h.Rotated}-${h.RTL}-${h.Stacked}-${h.LegendBottom}-${h.DateAxis}-${h.OrderByFieldsASC}`,
  // Stacked100:
  // LTR and notRotated chart
  `${h.NonRotated}-${h.LTR}-${h.Stacked100}-${h.LegendLeft}-${h.DateAxis}-${h.OrderByFieldsASC}`,
  `${h.NonRotated}-${h.LTR}-${h.Stacked100}-${h.LegendRight}-${h.DateAxis}-${h.OrderByFieldsASC}`,
  `${h.NonRotated}-${h.LTR}-${h.Stacked100}-${h.LegendTop}-${h.DateAxis}-${h.OrderByFieldsASC}`,
  `${h.NonRotated}-${h.LTR}-${h.Stacked100}-${h.LegendBottom}-${h.DateAxis}-${h.OrderByFieldsASC}`,
  // RTL and choosing between rotated or notRotated chart
  `${h.NonRotated}-${h.RTL}-${h.Stacked100}-${h.LegendLeft}-${h.DateAxis}-${h.OrderByFieldsASC}`,
  `${h.NonRotated}-${h.RTL}-${h.Stacked100}-${h.LegendRight}-${h.DateAxis}-${h.OrderByFieldsASC}`,
  `${h.Rotated}-${h.RTL}-${h.Stacked100}-${h.LegendTop}-${h.DateAxis}-${h.OrderByFieldsASC}`,
  `${h.Rotated}-${h.RTL}-${h.Stacked100}-${h.LegendBottom}-${h.DateAxis}-${h.OrderByFieldsASC}`,
  // Case of ascending order for a CategoryAxis
  // SideBySide
  `${h.NonRotated}-${h.RTL}-${h.SideBySide}-${h.LegendTop}-${h.CategoryAxis}-${h.OrderByFieldsASC}`,
  `${h.NonRotated}-${h.RTL}-${h.SideBySide}-${h.LegendBottom}-${h.CategoryAxis}-${h.OrderByFieldsASC}`,
  `${h.Rotated}-${h.RTL}-${h.SideBySide}-${h.LegendTop}-${h.CategoryAxis}-${h.OrderByFieldsASC}`,
  `${h.Rotated}-${h.RTL}-${h.SideBySide}-${h.LegendBottom}-${h.CategoryAxis}-${h.OrderByFieldsASC}`,
  // Stacked:
  // LTR and notRotated chart: done done
  `${h.NonRotated}-${h.LTR}-${h.Stacked}-${h.LegendRight}-${h.CategoryAxis}-${h.OrderByFieldsASC}`,
  `${h.NonRotated}-${h.LTR}-${h.Stacked}-${h.LegendLeft}-${h.CategoryAxis}-${h.OrderByFieldsASC}`,
  `${h.NonRotated}-${h.LTR}-${h.Stacked}-${h.LegendTop}-${h.CategoryAxis}-${h.OrderByFieldsASC}`,
  `${h.NonRotated}-${h.LTR}-${h.Stacked}-${h.LegendBottom}-${h.CategoryAxis}-${h.OrderByFieldsASC}`,
  // RTL and choosing between rotated or notRotated chart
  `${h.NonRotated}-${h.RTL}-${h.Stacked}-${h.LegendLeft}-${h.CategoryAxis}-${h.OrderByFieldsASC}`,
  `${h.NonRotated}-${h.RTL}-${h.Stacked}-${h.LegendRight}-${h.CategoryAxis}-${h.OrderByFieldsASC}`,
  `${h.Rotated}-${h.RTL}-${h.Stacked}-${h.LegendTop}-${h.CategoryAxis}-${h.OrderByFieldsASC}`,
  `${h.Rotated}-${h.RTL}-${h.Stacked}-${h.LegendBottom}-${h.CategoryAxis}-${h.OrderByFieldsASC}`,
  // Stacked100:
  // LTR and notRotated chart: done done
  `${h.NonRotated}-${h.LTR}-${h.Stacked100}-${h.LegendRight}-${h.CategoryAxis}-${h.OrderByFieldsASC}`,
  `${h.NonRotated}-${h.LTR}-${h.Stacked100}-${h.LegendLeft}-${h.CategoryAxis}-${h.OrderByFieldsASC}`,
  `${h.NonRotated}-${h.LTR}-${h.Stacked100}-${h.LegendTop}-${h.CategoryAxis}-${h.OrderByFieldsASC}`,
  `${h.NonRotated}-${h.LTR}-${h.Stacked100}-${h.LegendBottom}-${h.CategoryAxis}-${h.OrderByFieldsASC}`,
  // RTL and choosing between rotated or notRotated chart
  `${h.NonRotated}-${h.RTL}-${h.Stacked100}-${h.LegendLeft}-${h.CategoryAxis}-${h.OrderByFieldsASC}`,
  `${h.NonRotated}-${h.RTL}-${h.Stacked100}-${h.LegendRight}-${h.CategoryAxis}-${h.OrderByFieldsASC}`,
  `${h.Rotated}-${h.RTL}-${h.Stacked100}-${h.LegendTop}-${h.CategoryAxis}-${h.OrderByFieldsASC}`,
  `${h.Rotated}-${h.RTL}-${h.Stacked100}-${h.LegendBottom}-${h.CategoryAxis}-${h.OrderByFieldsASC}`,
  // Case of descending order for a CategoryAxis
  // SideBySide
  `${h.NonRotated}-${h.RTL}-${h.SideBySide}-${h.LegendTop}-${h.CategoryAxis}-${h.OrderByFieldsDESC}`,
  `${h.NonRotated}-${h.RTL}-${h.SideBySide}-${h.LegendBottom}-${h.CategoryAxis}-${h.OrderByFieldsDESC}`,
  `${h.Rotated}-${h.RTL}-${h.SideBySide}-${h.LegendTop}-${h.CategoryAxis}-${h.OrderByFieldsDESC}`,
  `${h.Rotated}-${h.RTL}-${h.SideBySide}-${h.LegendBottom}-${h.CategoryAxis}-${h.OrderByFieldsDESC}`,
  // Stacked:
  // LTR and notRotated chart: done done
  `${h.NonRotated}-${h.LTR}-${h.Stacked}-${h.LegendRight}-${h.CategoryAxis}-${h.OrderByFieldsDESC}`,
  `${h.NonRotated}-${h.LTR}-${h.Stacked}-${h.LegendLeft}-${h.CategoryAxis}-${h.OrderByFieldsDESC}`,
  `${h.NonRotated}-${h.LTR}-${h.Stacked}-${h.LegendTop}-${h.CategoryAxis}-${h.OrderByFieldsDESC}`,
  `${h.NonRotated}-${h.LTR}-${h.Stacked}-${h.LegendBottom}-${h.CategoryAxis}-${h.OrderByFieldsDESC}`,
  // RTL and choosing between rotated or notRotated chart
  `${h.NonRotated}-${h.RTL}-${h.Stacked}-${h.LegendLeft}-${h.CategoryAxis}-${h.OrderByFieldsDESC}`,
  `${h.NonRotated}-${h.RTL}-${h.Stacked}-${h.LegendRight}-${h.CategoryAxis}-${h.OrderByFieldsDESC}`,
  `${h.Rotated}-${h.RTL}-${h.Stacked}-${h.LegendTop}-${h.CategoryAxis}-${h.OrderByFieldsDESC}`,
  `${h.Rotated}-${h.RTL}-${h.Stacked}-${h.LegendBottom}-${h.CategoryAxis}-${h.OrderByFieldsDESC}`,
  // Stacked100:
  // LTR and notRotated chart: done done
  `${h.NonRotated}-${h.LTR}-${h.Stacked100}-${h.LegendRight}-${h.CategoryAxis}-${h.OrderByFieldsDESC}`,
  `${h.NonRotated}-${h.LTR}-${h.Stacked100}-${h.LegendLeft}-${h.CategoryAxis}-${h.OrderByFieldsDESC}`,
  `${h.NonRotated}-${h.LTR}-${h.Stacked100}-${h.LegendTop}-${h.CategoryAxis}-${h.OrderByFieldsDESC}`,
  `${h.NonRotated}-${h.LTR}-${h.Stacked100}-${h.LegendBottom}-${h.CategoryAxis}-${h.OrderByFieldsDESC}`,
  // RTL and choosing between rotated or notRotated chart
  `${h.NonRotated}-${h.RTL}-${h.Stacked100}-${h.LegendLeft}-${h.CategoryAxis}-${h.OrderByFieldsDESC}`,
  `${h.NonRotated}-${h.RTL}-${h.Stacked100}-${h.LegendRight}-${h.CategoryAxis}-${h.OrderByFieldsDESC}`,
  `${h.Rotated}-${h.RTL}-${h.Stacked100}-${h.LegendTop}-${h.CategoryAxis}-${h.OrderByFieldsDESC}`,
  `${h.Rotated}-${h.RTL}-${h.Stacked100}-${h.LegendBottom}-${h.CategoryAxis}-${h.OrderByFieldsDESC}`,
  // Case of ascending order for a ValueAxis
  // SideBySide
  `${h.NonRotated}-${h.RTL}-${h.SideBySide}-${h.LegendTop}-${h.ValueAxis}-${h.OrderByFieldsASC}`,
  `${h.NonRotated}-${h.RTL}-${h.SideBySide}-${h.LegendBottom}-${h.ValueAxis}-${h.OrderByFieldsASC}`,
  `${h.Rotated}-${h.RTL}-${h.SideBySide}-${h.LegendTop}-${h.ValueAxis}-${h.OrderByFieldsASC}`,
  `${h.Rotated}-${h.RTL}-${h.SideBySide}-${h.LegendBottom}-${h.ValueAxis}-${h.OrderByFieldsASC}`,
  // Stacked:
  // LTR and notRotated chart
  `${h.NonRotated}-${h.LTR}-${h.Stacked}-${h.LegendRight}-${h.ValueAxis}-${h.OrderByFieldsASC}`,
  `${h.NonRotated}-${h.LTR}-${h.Stacked}-${h.LegendLeft}-${h.ValueAxis}-${h.OrderByFieldsASC}`,
  `${h.NonRotated}-${h.LTR}-${h.Stacked}-${h.LegendTop}-${h.ValueAxis}-${h.OrderByFieldsASC}`,
  `${h.NonRotated}-${h.LTR}-${h.Stacked}-${h.LegendBottom}-${h.ValueAxis}-${h.OrderByFieldsASC}`,
  // RTL and choosing between rotated or notRotated chart
  `${h.NonRotated}-${h.RTL}-${h.Stacked}-${h.LegendLeft}-${h.ValueAxis}-${h.OrderByFieldsASC}`,
  `${h.NonRotated}-${h.RTL}-${h.Stacked}-${h.LegendRight}-${h.ValueAxis}-${h.OrderByFieldsASC}`,
  `${h.Rotated}-${h.RTL}-${h.Stacked}-${h.LegendTop}-${h.ValueAxis}-${h.OrderByFieldsASC}`,
  `${h.Rotated}-${h.RTL}-${h.Stacked}-${h.LegendBottom}-${h.ValueAxis}-${h.OrderByFieldsASC}`,
  // Stacked100:
  // LTR and notRotated chart
  `${h.NonRotated}-${h.LTR}-${h.Stacked100}-${h.LegendRight}-${h.ValueAxis}-${h.OrderByFieldsASC}`,
  `${h.NonRotated}-${h.LTR}-${h.Stacked100}-${h.LegendLeft}-${h.ValueAxis}-${h.OrderByFieldsASC}`,
  `${h.NonRotated}-${h.LTR}-${h.Stacked100}-${h.LegendTop}-${h.ValueAxis}-${h.OrderByFieldsASC}`,
  `${h.NonRotated}-${h.LTR}-${h.Stacked100}-${h.LegendBottom}-${h.ValueAxis}-${h.OrderByFieldsASC}`,
  // RTL and choosing between rotated or notRotated chart
  `${h.NonRotated}-${h.RTL}-${h.Stacked100}-${h.LegendLeft}-${h.ValueAxis}-${h.OrderByFieldsASC}`,
  `${h.NonRotated}-${h.RTL}-${h.Stacked100}-${h.LegendRight}-${h.ValueAxis}-${h.OrderByFieldsASC}`,
  `${h.Rotated}-${h.RTL}-${h.Stacked100}-${h.LegendTop}-${h.ValueAxis}-${h.OrderByFieldsASC}`,
  `${h.Rotated}-${h.RTL}-${h.Stacked100}-${h.LegendBottom}-${h.ValueAxis}-${h.OrderByFieldsASC}`,
  // Case of descending order for a ValueAxis
  // SideBySide
  `${h.NonRotated}-${h.RTL}-${h.SideBySide}-${h.LegendTop}-${h.ValueAxis}-${h.OrderByFieldsDESC}`,
  `${h.NonRotated}-${h.RTL}-${h.SideBySide}-${h.LegendBottom}-${h.ValueAxis}-${h.OrderByFieldsDESC}`,
  `${h.Rotated}-${h.RTL}-${h.SideBySide}-${h.LegendTop}-${h.ValueAxis}-${h.OrderByFieldsDESC}`,
  `${h.Rotated}-${h.RTL}-${h.SideBySide}-${h.LegendBottom}-${h.ValueAxis}-${h.OrderByFieldsDESC}`,
  // Stacked:
  // LTR and notRotated chart
  `${h.NonRotated}-${h.LTR}-${h.Stacked}-${h.LegendRight}-${h.ValueAxis}-${h.OrderByFieldsDESC}`,
  `${h.NonRotated}-${h.LTR}-${h.Stacked}-${h.LegendLeft}-${h.ValueAxis}-${h.OrderByFieldsDESC}`,
  `${h.NonRotated}-${h.LTR}-${h.Stacked}-${h.LegendTop}-${h.ValueAxis}-${h.OrderByFieldsDESC}`,
  `${h.NonRotated}-${h.LTR}-${h.Stacked}-${h.LegendBottom}-${h.ValueAxis}-${h.OrderByFieldsDESC}`,
  // RTL and choosing between rotated or notRotated chart
  `${h.NonRotated}-${h.RTL}-${h.Stacked}-${h.LegendLeft}-${h.ValueAxis}-${h.OrderByFieldsDESC}`,
  `${h.NonRotated}-${h.RTL}-${h.Stacked}-${h.LegendRight}-${h.ValueAxis}-${h.OrderByFieldsDESC}`,
  `${h.Rotated}-${h.RTL}-${h.Stacked}-${h.LegendTop}-${h.ValueAxis}-${h.OrderByFieldsDESC}`,
  `${h.Rotated}-${h.RTL}-${h.Stacked}-${h.LegendBottom}-${h.ValueAxis}-${h.OrderByFieldsDESC}`,
  // Stacked100:
  // LTR and notRotated chart
  `${h.NonRotated}-${h.LTR}-${h.Stacked100}-${h.LegendRight}-${h.ValueAxis}-${h.OrderByFieldsDESC}`,
  `${h.NonRotated}-${h.LTR}-${h.Stacked100}-${h.LegendLeft}-${h.ValueAxis}-${h.OrderByFieldsDESC}`,
  `${h.NonRotated}-${h.LTR}-${h.Stacked100}-${h.LegendTop}-${h.ValueAxis}-${h.OrderByFieldsDESC}`,
  `${h.NonRotated}-${h.LTR}-${h.Stacked100}-${h.LegendBottom}-${h.ValueAxis}-${h.OrderByFieldsDESC}`,
  // RTL and choosing between rotated or notRotated chart
  `${h.NonRotated}-${h.RTL}-${h.Stacked100}-${h.LegendLeft}-${h.ValueAxis}-${h.OrderByFieldsDESC}`,
  `${h.NonRotated}-${h.RTL}-${h.Stacked100}-${h.LegendRight}-${h.ValueAxis}-${h.OrderByFieldsDESC}`,
  `${h.Rotated}-${h.RTL}-${h.Stacked100}-${h.LegendTop}-${h.ValueAxis}-${h.OrderByFieldsDESC}`,
  `${h.Rotated}-${h.RTL}-${h.Stacked100}-${h.LegendBottom}-${h.ValueAxis}-${h.OrderByFieldsDESC}`
]), jc = "arcgis_charts_title_container", _c = "arcgis_charts_subtitle_container", Zc = "arcgis_charts_footer_container", ph = "arcgis_charts_title", yh = "arcgis_charts_subtitle", bh = "arcgis_charts_footer", xn = "arcgis_charts_legend_container", po = "arcgis_charts_legend_title", $u = "arcgis_charts_axis_title_id", Sh = "arcgis_charts_loader_container", xh = "arcgis_charts_loader_spinner";
function Ch(t) {
  const e = t.get("id");
  t.on("visible", (i, a) => {
    if (a) {
      const { chart: n } = a;
      if (n instanceof Wn) {
        const o = Ye({ childId: xn, parent: n });
        o !== void 0 && o.dataItems?.forEach((s) => {
          s.get("id") === e && o.set("opacity", i ? 1 : D.legendProperties.legendLabelReducedOpacity);
        });
      }
    }
  });
}
function dL(t) {
  const e = t.target.dataItem;
  if (e?.dataContext !== void 0) {
    const { dataContext: i } = e;
    if (i instanceof oc) {
      const n = { visible: !i.get("visible") };
      ya(i) || ls(i) ? n.overlayType = $e(i.uid, "type") : n.seriesId = i.get("id"), bm(n, i.root.dom);
    }
  }
}
function uL(t) {
  t.itemContainers.template.events.on(Se.Click, dL);
}
function fL(t, e) {
  const i = V(e.uid, "rtl") ?? !1;
  t.itemContainers.template.setAll({ reverseChildren: i });
}
function Pu(t) {
  let e = 0;
  return t.dataItems.forEach((i) => {
    const a = i.get("itemContainer").width();
    e = Math.max(a, e);
  }), Math.ceil(e);
}
function vh(t) {
  const { chart: e, legend: i, chartConfig: a, hideEmptySeries: n } = t, o = z(a.series);
  if (e.series.length > 1 || o === b.PieSeries) {
    let s = [];
    const r = H(a.series);
    switch (o) {
      case b.BoxPlotSeries: {
        const l = qe(a);
        s = e.series.values.filter((c) => {
          let d = !1;
          return l ? d = c instanceof Ae && !(c instanceof gr) : d = c instanceof bn, d;
        });
        break;
      }
      case b.HistogramSeries: {
        s = e.series.values.filter((l) => {
          let c = !1;
          if ($e(l.uid, "isOverlay")) {
            const d = a.series[0].type === b.HistogramSeries ? a.series[0].overlays : void 0, u = $e(l.uid, "type");
            let f;
            switch (u) {
              case ze.Mean:
                f = d?.mean?.created;
                break;
              case ze.Median:
                f = d?.median?.created;
                break;
              case ze.Normal:
                f = d?.comparisonDistribution?.created;
                break;
              case ze.StdDev:
                f = d?.standardDeviation?.created;
                break;
            }
            c = f === !0;
          }
          return c;
        });
        break;
      }
      case b.PieSeries: {
        s = e.series.getIndex(0)?.dataItems ?? [];
        break;
      }
      case b.ComboLineAndBarSeries:
      case b.LineSeries:
      case b.RadarSeries:
      case b.BarSeries:
        s = e.series.values.filter((l) => {
          let c = !0;
          if (n !== !1) {
            const d = a.series.find((u) => u.id === l.get("id"));
            if (d !== void 0 && "y" in d && typeof d.y == "string") {
              const { x: u, y: f } = d, m = r === L.BarAndLineSplitByNoAggregation ? `${f}_${Lt({ where: d.query?.where })}` : f;
              c = l.data.values.some(
                (y) => fc({ dataItem: y, x: u, y: m })
              );
            }
          }
          return c;
        });
        break;
      case b.ScatterSeries: {
        const l = Wh(e);
        l?.isVisible() && (s = [l]);
        break;
      }
    }
    i.data.setAll(s);
  }
}
function Ws(t, e) {
  const { root: i } = t, a = Ye({ childId: xn, parent: t });
  if (a !== void 0) {
    const n = V(t.uid, "config"), o = V(t.uid, "rtl"), s = n?.title ? n.title.visible ?? !0 : !1, r = n?.subtitle ? n.subtitle.visible ?? !0 : !1, l = n?.footer ? n.footer.visible ?? !0 : !1, c = n?.legend ? n.legend.visible ?? !0 : !1, d = n?.legend?.title ? n.legend.title.visible ?? !0 : !1, u = Ye({ childId: jc, parent: t }), f = u instanceof Mn && s ? u.height() : 0, m = Ye({ childId: _c, parent: t }), g = m instanceof Mn && r ? m.height() : 0, y = Ye({ childId: Zc, parent: t }), p = y instanceof Mn && l ? y.height() : 0, S = Ye({ childId: po, parent: a }), x = S instanceof Pa && c && d ? S?.height() : 0, C = n?.legend?.position ?? D.legendProperties.position;
    let F;
    const v = e.get("verticalScrollbar");
    let A = Re, w = Re, O = i.verticalLayout, I = Re, N = Re, M = Re, P = Re, R = 0, $;
    const U = e.height() + x;
    let q = 0, Z = 0, ee = 0, j = 0, ie, ge;
    switch (C) {
      case me.Left:
        O = i.verticalLayout, I = St, M = St, N = St, P = St, $ = void 0, A = St, w = St, q = a.width(), R = f + g, U < t.seriesContainer.height() && (R += t.seriesContainer.height() / 2 - U / 2), F = Pu(e), v?.width() !== void 0 && F && v.isVisible() && (F += v.width() + D.scrollbarPadding), o && (ie = ct, ge = q);
        break;
      case me.Right:
        O = i.verticalLayout, I = ct, M = ct, N = St, P = St, $ = void 0, A = St, w = St, Z = a.width(), R = f + g, U < t.seriesContainer.height() && (R += t.seriesContainer.height() / 2 - U / 2), F = Pu(e), v?.width() !== void 0 && F && v.isVisible() && (F += v.width() + D.scrollbarPadding), o && (ie = ct, ge = Z);
        break;
      case me.Top:
        O = i.gridLayout, I = Re, M = Re, N = St, P = St, $ = ct, A = Re, w = Re, ee += U, R += f + g, F = void 0, o && (ie = void 0, ge = 0);
        break;
      case me.Bottom:
        O = i.gridLayout, I = Re, M = Re, N = ct, P = ct, $ = ct, A = Re, w = Re, j = U, R = -j - p, F = void 0, o && (ie = void 0, ge = 0);
        break;
    }
    (F === void 0 || F > 0) && (o && e.itemContainers.template.setAll({ centerX: ie, dx: ge }), e.setAll({ layout: O, x: A, centerX: w }), e.setPrivate("width", F), a.setAll({
      x: I,
      y: N,
      centerX: M,
      centerY: P,
      dy: R,
      width: $,
      height: 0
    }), t.chartContainer.setAll({
      paddingBottom: j,
      paddingTop: ee,
      paddingLeft: q,
      paddingRight: Z
    }), $ === void 0 && (a.setPrivate("width", void 0), a.markDirty()));
  }
}
function mL(t) {
  const { chart: e, legend: i, legendContainer: a } = t, n = Ye({ childId: po, parent: a });
  n && n.on("visible", () => {
    i.root.events.once(Se.FrameEnded, () => {
      Ws(e, i);
    });
  }), a.events.on(Se.BoundsChanged, () => {
    Ws(e, i);
  }), e.seriesContainer.onPrivate("height", () => {
    Ws(e, i);
  });
}
function Fh(t, e) {
  const i = Wo({
    root: e.root,
    parent: e,
    index: 0,
    id: Oi(po, e.uid)
  });
  return i.set("paddingTop", 10), zo({
    chart: t,
    label: i,
    labelType: ue.LegendTitle
  }), i;
}
function gL(t, e) {
  e.markers.template.setAll({
    width: D.legendProperties.legendMarkersSize,
    height: D.legendProperties.legendMarkersSize
  }), e.labels.template.adapters.add("text", (i, a) => {
    let n = i;
    const o = a.dataItem?.component;
    o instanceof Jt ? n = (a.dataItem?.dataContext?.[o.get("categoryField") ?? ""] ?? i)?.toString() : o instanceof oc && (n = o.get("name"));
    const s = V(t.uid, "config");
    if (s !== void 0) {
      const { legend: r } = s, l = { ...r?.body, type: re.TS, text: n };
      n = Ht({ textSymbol: l, format: "amChartsV5" });
    }
    return n;
  });
}
function hL(t, e) {
  e.seriesContainer.onPrivate("height", (i) => {
    let a = 0;
    const n = V(e.uid, "config"), o = n?.legend, s = Ye({ childId: xn, parent: e });
    if (s !== void 0) {
      const l = Ye({ childId: po, parent: s });
      l !== void 0 && o?.visible !== !1 && o?.title?.visible !== !1 && (a = l.height());
    }
    let r = n?.legend?.maxHeight ?? Number.NaN;
    Number.isFinite(r) || (n?.legend?.position === me.Top || n?.legend?.position === me.Bottom ? r = D.legendProperties.maxHeight : typeof i == "number" && (r = i - a)), t.set("maxHeight", r);
  });
}
function pL(t, e, i) {
  t.events.on(Se.DataValidated, () => {
    t.dataItems.length > 0 && Lh(t, e, i);
  });
}
function yL(t) {
  let e;
  if (t !== void 0) {
    const i = V(t?.uid, "config");
    e = V(t.uid, "rtl") && (i?.legend?.position === me.Top || i?.legend?.position === me.Bottom);
  }
  return e ?? !1;
}
function bL(t) {
  let e = "";
  if (t instanceof Te) {
    const i = V(t.uid, "config"), a = di(i), n = a ? h.Rotated : h.NonRotated, o = ti(i);
    let s = h.SideBySide;
    o === Ie.Stacked ? s = h.Stacked : o === Ie.Stacked100 && (s = h.Stacked100);
    const r = V(t.uid, "rtl") ? h.RTL : h.LTR;
    let l;
    switch (i?.legend?.position) {
      case me.Left:
        l = h.LegendLeft;
        break;
      case me.Top:
        l = h.LegendTop;
        break;
      case me.Bottom:
        l = h.LegendBottom;
        break;
      case me.Right:
      default:
        l = h.LegendRight;
        break;
    }
    const c = a ? t.yAxes.getIndex(0) : t.xAxes.getIndex(0);
    let d;
    c instanceof nt ? d = h.DateAxis : c instanceof We ? d = h.ValueAxis : d = h.CategoryAxis;
    const f = i?.orderOptions?.data?.orderBy === ri.Descending ? h.OrderByFieldsDESC : h.OrderByFieldsASC;
    e = `${n}-${r}-${s}-${l}-${d}-${f}`;
  }
  return e;
}
function SL(t) {
  const e = bL(t);
  return hh.has(e);
}
function Lh(t, e, i) {
  switch (i) {
    case b.HistogramSeries:
    case b.PieSeries:
      t.set("reverseChildren", yL(e));
      break;
    case b.BarSeries:
    case b.LineSeries:
    case b.RadarSeries:
    case b.ComboLineAndBarSeries:
      t.set("reverseChildren", SL(e));
      break;
  }
}
function xL(t, e) {
  const i = Ye({ childId: xn, parent: t });
  if (i !== void 0) {
    const a = Ye({ childId: po, parent: i }) ?? Fh(t, i);
    if (e !== void 0) {
      const { title: n, visible: o } = e, { legendTitle: s } = D.legendProperties;
      n !== void 0 && Zi({
        label: a,
        labelConfig: { ...n, visible: o !== !1 && n.visible !== !1 },
        defaults: { ...s, verticalCenter: ce.Top }
      });
    }
    ua({
      chart: t,
      label: a,
      labelType: ue.LegendTitle
    });
  }
}
function CL(t, e = !1) {
  const i = e ? 10 : 0;
  t.markerRectangles.template.setAll({
    cornerRadiusTL: i,
    cornerRadiusTR: i,
    cornerRadiusBL: i,
    cornerRadiusBR: i
  });
}
function vL(t, e) {
  if (t !== void 0) {
    const i = {
      type: b.Text,
      visible: e?.visible,
      content: {
        ...e?.body,
        type: re.TS,
        text: " "
        // using a non empty string to kick in the adapter on `text`
      }
    };
    Zi({ label: t.labels.template, labelConfig: i }), t.labels.template.setAll({ x: void 0, y: void 0, paddingRight: 5 });
  }
}
function FL(t, e) {
  e === !0 && t.itemContainers.each((i) => {
    i.events.disableType(Se.Click);
  });
}
function Ru(t, e) {
  const { root: i } = t, a = Mn.new(i, {
    id: Oi(xn, t.uid),
    layout: i.verticalLayout
  }), n = $f.new(i, { verticalScrollbar: Il.new(i, { orientation: "vertical" }) });
  return n.valueLabels.template.setAll({ forceHidden: !0 }), gL(t, n), Fh(t, a), uL(n), fL(n, t), mL({ chart: t, legend: n, legendContainer: a }), hL(n, t), pL(n, t, z(e)), a.children.push(n), t.children.push(a), n;
}
function LL(t) {
  const { chart: e, legend: i, showLegend: a } = t, n = Ye({ childId: xn, parent: e });
  if (n) {
    const o = Ye({ childId: po, parent: n });
    _e(n, a), _e(i, a), o && _e(o, a);
  }
}
function Ah(t) {
  const { chart: e, chartConfig: i, legend: a, hideEmptySeries: n } = t, { legend: o, series: s } = i;
  if (a !== void 0 && Ye({ childId: xn, parent: e }) !== void 0) {
    const l = Hf(s) && o?.visible !== !1;
    if (LL({ chart: e, legend: a, showLegend: l }), l) {
      CL(a, o?.roundMarkers), vL(a, o), Lh(a, e, z(s)), vh({ chart: e, legend: a, chartConfig: i, hideEmptySeries: n }), xL(e, o), Ws(e, a);
      const c = V(e.uid, "options");
      FL(a, c?.disableTogglingLegendItems);
    }
  }
}
function Th(t) {
  const { axesConfig: e, currentSeries: i, tooltipValueFormat: a } = t, { root: n, chart: o } = i;
  if (o) {
    const s = e?.[1]?.valueFormat, r = e?.[0].valueFormat, l = V(o.uid, "formatLocale");
    if (s?.type === b.NumberAxisFormat) {
      const c = Qi({
        root: n,
        type: s.type,
        formatLocale: l,
        intlOptions: s.intlOptions
      });
      st(i.uid, {
        tooltipValueYNumberFormatCallback: (d) => c.format(d, a?.intlOptions ?? s.intlOptions)
      });
    }
    if (r?.type === b.NumberAxisFormat) {
      const c = Qi({
        root: n,
        type: r.type,
        formatLocale: l,
        intlOptions: r.intlOptions
      });
      st(i.uid, {
        tooltipValueXNumberFormatCallback: (d) => c.format(d, a?.intlOptions ?? r.intlOptions)
      });
    }
  }
}
function Ki(t, e) {
  return e != null && e !== "" ? e : t;
}
function wh(t, e) {
  let i;
  switch (t) {
    case X.Average: {
      i = e.statistics.mean;
      break;
    }
    case X.ContinuousPercentile: {
      i = e.statistics.median;
      break;
    }
    case X.Sum: {
      i = e.statistics.sum;
      break;
    }
    case X.Minimum: {
      i = e.statistics.minimum;
      break;
    }
    case X.Maximum: {
      i = e.statistics.maximum;
      break;
    }
    case X.Variance: {
      i = e.statistics.variance;
      break;
    }
    case X.DiscretePercentile: {
      i = e.statistics.discretePercentile;
      break;
    }
    case X.NoAggregation: {
      i = e.statistics.noAggregation;
      break;
    }
    case X.Count:
    default: {
      i = e.statistics.count;
      break;
    }
  }
  return i;
}
function kh(t) {
  const { config: e, fieldName: i = "", commonStrings: a } = t, n = e.series[0].query?.outStatistics?.[0].statisticType ?? mr.statisticType, o = wh(n, a);
  return Gt(a.statistics.aggregation, {
    statistics: o,
    fieldName: i
  });
}
function Ih(t) {
  const { config: e, fieldList: i, objectIdField: a, seriesIndex: n, isStacked100: o, commonStrings: s } = t;
  let r = "";
  const l = e.series[n].name, c = e.series[n], d = [c.y].flat()[0], u = e.axes, f = H(e.series), m = a ?? ot.outStatistics.onStatisticField, g = c.query?.outStatistics?.[0].onStatisticField ?? m, y = Ve(i, g), p = c.query?.outStatistics?.[0].statisticType ?? mr.statisticType, S = wh(p, s);
  return f === L.BarAndLineNoAggregation ? r = l ?? Ve(i, d) : f === L.BarAndLineSplitByNoAggregation ? r = Ve(i, d) : (r = p === X.Count && g === m ? s.statistics.count : Gt(s.statistics.aggregation, {
    statistics: S,
    fieldName: y ?? l
  }), f === L.BarAndLineMonoField && !o && (r = Ki(r, u[1].title?.content?.text))), r;
}
function Oh(t) {
  return Xs(t.uid.toString(), Kg);
}
function Hr(t) {
  return t != null && !t.isDisposed();
}
function AL(t) {
  const e = No(t), { r: i, g: a, b: n } = e;
  return { r: i, g: a, b: n };
}
function Bh(t) {
  const e = rs(t);
  t.columns.template.set("tooltip", e), t.columns.template.setAll({
    tooltipText: " ",
    tooltipPosition: "fixed"
  }), t.columns.template.adapters.remove("tooltipText"), t.columns.template.adapters.add(
    "tooltipText",
    (i, a) => yo(a, t)
  );
}
function TL(t) {
  const { axes: e, seriesConfig: i, series: a, fieldList: n, commonStrings: o } = t, { dataTooltipVisible: s } = i;
  let r;
  const l = V(a.chart?.uid ?? 0, "rtl") ?? !1, c = ai(l);
  return s === !1 ? r = (d, u, f) => "" : r = (d, u, f) => {
    const m = Ve(n, i.x), g = Ki(m, e?.[0].title?.content?.text), y = Ki(
      o?.statistics.count ?? "",
      e?.[1]?.title?.content?.text ?? ""
    ), p = $e(
      a.uid,
      "tooltipValueXNumberFormatCallback"
    ), S = $e(
      a.uid,
      "tooltipValueYNumberFormatCallback"
    ), x = p ? p(u) : u, C = p ? p(f) : f, F = S ? S(d) : d;
    return l ? `${x} - ${C}[bold]${g}${c} [/]
${F}[bold]${y}${c} [/]` : `[bold]${g}${c} [/]${x} - ${C}
[bold]${y}${c} [/]${F}`;
  }, r;
}
function wL(t) {
  const { seriesConfig: e, series: i, tooltip: a } = t, { dataTooltipVisible: n } = e;
  if (n !== !1) {
    const o = $e(
      i.uid,
      "histogramTooltipFormatter"
    );
    if (o !== void 0) {
      const s = a.dataItem;
      if (s !== void 0) {
        const r = s.dataContext;
        return o(s.get("valueY") ?? 0, r.minValue, r.maxValue);
      }
    }
  }
  return "";
}
function Dh(t) {
  const e = rs(t);
  t.columns.template.set("tooltip", e), t.columns.template.setAll({
    tooltipText: " ",
    tooltipPosition: "fixed"
  }), t.columns.template.adapters.add("tooltipText", (i, a) => yo(a, t));
}
function kL(t) {
  const { series: e, tooltipFormatter: i, axesConfig: a, seriesConfig: n } = t;
  Th({
    axesConfig: a,
    currentSeries: e,
    tooltipValueFormat: n.dataTooltipValueFormat
  }), st(e.uid, {
    histogramTooltipFormatter: i ?? TL(t)
  });
}
function Nh(t) {
  const {
    pieChart: e,
    valueIntlOptions: i,
    percentageIntlOptions: a,
    displayNumericValue: n,
    displayPercentage: o,
    valuePrefix: s,
    valueSuffix: r,
    percentagePrefix: l,
    percentageSuffix: c
  } = t, { root: d } = e, u = V(e.uid, "formatLocale"), f = Qi({
    root: d,
    type: b.NumberAxisFormat,
    intlOptions: i,
    formatLocale: u
  }), m = Qi({
    root: d,
    type: b.NumberAxisFormat,
    intlOptions: { ...a, style: "percent" },
    formatLocale: u
  }), g = ai(V(e.uid, "rtl") ?? !1, " ");
  return (p, S, x) => {
    let C = "";
    if (S !== void 0 && x !== void 0) {
      const F = `${s ?? ""}${f.format(S)}${r ?? ""}`, v = `${l ?? ""}${m.format(Math.abs(x / 100))}${c ?? ""}`;
      Number.isFinite(S) ? n === !0 && o === !0 ? C = `${v}${g}(${F})` : n === !0 ? C = F : o === !0 && (C = v) : C = "";
    }
    return C;
  };
}
function IL(t, e) {
  let i = (g, y, p) => "";
  const {
    numericValueFormat: a,
    percentValueFormat: n,
    dataTooltipValueFormat: o,
    dataTooltipPercentFormat: s,
    displayCategoryOnTooltip: r,
    displayNumericValueOnTooltip: l,
    displayPercentageOnTooltip: c,
    valuePrefix: d,
    valueSuffix: u,
    percentagePrefix: f,
    percentageSuffix: m
  } = e;
  return i = (g, y, p) => {
    let S = "";
    const { chart: x } = t;
    if (x) {
      const F = Nh({
        pieChart: x,
        valueIntlOptions: (o ?? a)?.intlOptions,
        percentageIntlOptions: (s ?? n)?.intlOptions,
        displayNumericValue: l ?? D.pieChart.displayNumericValueOnTooltip,
        displayPercentage: c ?? D.pieChart.displayPercentageOnTooltip,
        valuePrefix: d,
        valueSuffix: u,
        percentagePrefix: f,
        percentageSuffix: m
      })("", y, p), v = !be(g) && (r ?? D.pieChart.displayCategoryOnTooltip);
      if (v && (S = `[bold]${g}[/]`), !be(F)) {
        const A = Vr(F);
        S = v ? `${S}
${A}` : A;
      }
    }
    return S;
  }, i;
}
function OL(t) {
  const e = t.get("tooltip");
  if (e !== void 0) {
    let i = t.get("fill");
    i instanceof Nf && (i = i.get("fill")), e.get("background")?.set("fill", i);
  }
}
function BL(t) {
  const { pieSeries: e, tooltip: i } = t;
  let a = "";
  const { chart: n } = e;
  if (n !== void 0 && i !== void 0) {
    const o = V(n.uid, "config"), { dataTooltipVisible: s } = o?.series[0] ?? {};
    if (s !== !1) {
      const r = $e(
        e.uid,
        "pieChartTooltipFormatter"
      );
      if (r) {
        const l = i.dataItem;
        if (l !== void 0) {
          const c = l, d = c.get("category") ?? "", u = l.dataContext;
          let f = $i(u);
          f === void 0 && (f = d);
          const m = c.get("value"), g = c.get("valuePercentTotal");
          typeof m == "number" && m !== 0 && o?.series?.[0]?.dataTooltipVisible !== !1 ? (i.set("disabled", !1), OL(c.get("slice")), a = r(d, m, g, f)) : i.set("disabled", !0);
        }
      }
    } else
      return;
  }
  return rt(a);
}
function Mh(t) {
  const e = t.slices.template, i = rs(t);
  e.setAll({
    tooltip: i,
    tooltipText: " ",
    tooltipPosition: "fixed"
  }), e.adapters.remove("tooltipText"), e.adapters.add("tooltipText", (a, n) => {
    let o = " ";
    try {
      const s = n.get("tooltip");
      s && (s.dataItem = n.dataItem, o = yo(s, t));
    } catch {
    }
    return o;
  }), e.set("tooltipText", " ");
}
function DL(t) {
  const { series: e, seriesConfig: i, tooltipFormatter: a } = t;
  st(e.uid, {
    pieChartTooltipFormatter: a ?? IL(e, i)
  });
}
function Vu(t, e) {
  if (e !== void 0) {
    const i = AL(e);
    i !== void 0 && t.label.setAll({
      fill: sS(i) ? No("#000000") : No("#ffffff")
    });
  }
}
function $h(t) {
  t.label.setAll({
    paddingTop: 4,
    paddingBottom: 4
  });
}
function Ph(t, e) {
  const { dataTooltipStyleReversed: i, dataTooltipStyle: a } = D;
  if (e === !0) {
    const n = t.get("background")?.get("fill");
    n !== void 0 && (Vu(t, t.get("background")?.get("fill")?.toCSS()), i?.color !== void 0 && n.toCSSHex() !== je(i.color).color.toCSSHex() && t.get("background")?.setAll({
      fill: je(i.color).color,
      stroke: n,
      strokeWidth: i.outline?.width ?? Number.NaN
    }));
  } else
    Vu(t, t.get("background")?.get("fill")?.toCSS()), t.setAll({ getStrokeFromSprite: !0, getFillFromSprite: !0 }), t.get("background")?.setAll({
      strokeWidth: a?.outline?.width ?? Number.NaN,
      stroke: je(a?.outline?.color).color
    });
}
function Eu(t, e) {
  if (t.get("tooltip") === void 0) {
    const i = rs(e);
    t.set("tooltip", i), t.setAll({
      tooltipText: " ",
      tooltipPosition: "fixed"
    }), t.adapters.remove("tooltipText"), t.adapters.add("tooltipText", (a, n) => yo(n, e));
  }
}
function rs(t) {
  const { root: e, chart: i } = t, a = Kn.new(e, {});
  return a.adapters.add("visible", (n, o) => (n && Vh(o, t), n)), Rh(a, i), a;
}
function Qc(t, e) {
  const { chart: i } = e, a = Kn.new(t, {});
  return a.adapters.add("visible", (n, o) => (n && Vh(o, e), n)), Rh(a, i), a.adapters.remove("tooltipText"), a.adapters.add("tooltipText", (n, o) => yo(o, e)), a;
}
function Rh(t, e) {
  if (t) {
    const i = V(e?.uid ?? 0, "rtl");
    t.label.set("textAlign", i ? "right" : "left"), $h(t), t.get("background")?.setAll({
      fillOpacity: io
      // Adjust transparency for fill
    });
  }
}
function Vh(t, e) {
  const { chart: i } = e;
  if (i && t) {
    const a = V(i.uid, "config");
    if (a) {
      const { seriesConfig: n } = Gr(e, a);
      if (n) {
        const { dataTooltipReverseColor: o } = n;
        Ph(t, o);
      }
    }
  }
}
function NL(t) {
  const { seriesConfig: e, series: i, tooltip: a, isRotated: n } = t, o = $e(
    i.uid,
    "barAndLineTooltipFormatter"
  );
  if (o !== void 0) {
    const s = a.dataItem;
    if (s !== void 0) {
      const r = s.get("valueX"), l = s.get("valueY"), c = s.get("valueXTotalPercent"), d = s.get("valueYTotalPercent"), u = n ? r : l;
      let f;
      n && typeof c == "number" ? f = c : !n && typeof d == "number" && (f = d), f && (f /= 100);
      const m = s.dataContext ?? {}, g = V(i.chart?.uid ?? 0, "config"), y = V(i.chart?.uid ?? 0, "rendererFieldNames"), p = Zt({
        value: m[e.x],
        dataContext: m,
        useRendererLabel: Er(g, y)
      });
      let S = $i(m);
      S === void 0 && (S = p);
      const x = m[D.dateBinningRange];
      if (S !== void 0 || u !== void 0 || f !== void 0 || x !== void 0)
        return o({
          seriesName: i.get("name") ?? e.name,
          xValue: p,
          originalXValue: S,
          dateBinningRange: x,
          statValue: u,
          percentValue: f
        });
    }
  }
}
function Wu(t, e) {
  if (t instanceof Kn)
    t.set("forceHidden", e);
  else {
    const i = t.get("tooltip");
    i && i.set("forceHidden", e);
  }
}
function yo(t, e) {
  let i;
  const { chart: a } = e;
  if (a !== void 0) {
    const n = V(a.uid, "config"), { seriesConfig: o } = Gr(e, n), { dataTooltipVisible: s } = n?.series[0] ?? {};
    if (s === !1 || !o)
      i = "", Wu(t, !0);
    else
      switch (Wu(t, !1), o.type) {
        case b.ScatterSeries:
          e instanceof Ae && (i = WL({
            seriesConfig: o,
            markerSeries: e,
            tooltip: t
          }));
          break;
        case b.BarSeries:
        case b.LineSeries:
        case b.RadarSeries:
          i = NL({
            seriesConfig: o,
            series: e,
            tooltip: t,
            isRotated: n?.rotated ?? !1
          });
          break;
        case b.HistogramSeries:
          i = wL({
            seriesConfig: o,
            series: e,
            tooltip: t
          });
          break;
        case b.PieSeries:
          e instanceof Jt && t instanceof Kn && (i = BL({
            pieSeries: e,
            tooltip: t
          }));
          break;
      }
  }
  return i ?? "";
}
function ML(t) {
  const { series: e, dateRange: i, xAxisValueFormat: a } = t;
  let n;
  const o = V(
    e.chart?.uid ?? Number.NaN,
    "timeIntervalInfo"
  );
  if (i !== void 0 && i.length > 0) {
    let s = {};
    switch (o?.unit) {
      case Q.Second:
        s = {
          month: "numeric",
          day: "numeric",
          year: "numeric",
          hour: "numeric",
          minute: "numeric",
          second: "numeric"
        };
        break;
      case Q.Minute:
        s = {
          month: "numeric",
          day: "numeric",
          year: "numeric",
          hour: "numeric",
          minute: "numeric"
        };
        break;
      case Q.Hour:
        s = {
          month: "numeric",
          day: "numeric",
          year: "numeric",
          hour: "numeric",
          minute: "numeric"
        };
        break;
      case Q.Day:
      case Q.Week:
      case Q.Month:
      case Q.Year:
        s = {
          month: "numeric",
          day: "numeric",
          year: "numeric"
        };
        break;
    }
    s.timeZone = a.intlOptions.timeZone;
    const r = new Date(i[0]), l = new Date(i[1]), { root: c } = e;
    if (!Number.isNaN(r.valueOf()) && e.chart !== void 0) {
      const d = V(e.chart.uid, "formatLocale"), u = Qi({
        root: c,
        type: b.DateAxisFormat,
        formatLocale: d,
        intlOptions: s
      }), f = u.format(r, s);
      if (n = f, !Number.isNaN(l.valueOf())) {
        const m = u.format(l, s);
        m !== f && (n = `${n} - ${m}`);
      }
    }
  }
  return n?.toString() ?? "";
}
function $L(t) {
  const {
    seriesConfig: e,
    xAxisValueFormat: i,
    setTimeBinningInfoWhenNotProvided: a,
    dataTooltipValueFormat: n,
    dataTooltipDateFormat: o,
    series: s,
    xValue: r,
    dateBinningRange: l
  } = t, { root: c } = s;
  let d;
  const u = V(s.chart?.uid ?? 0, "formatLocale");
  return /* case 1: time binning chart */ ei({
    seriesConfig: e,
    xAxisValueFormatType: i?.type,
    setTimeBinningInfoWhenNotProvided: a
  }) && l !== void 0 && i?.type === b.DateAxisFormat ? d = ML({
    series: s,
    dateRange: l,
    xAxisValueFormat: i
  }) : mi(i) && r !== void 0 ? d = Qn({
    root: c,
    value: r,
    valueFormat: o ?? i,
    formatLocale: u
  }) : typeof r == "number" && Pe(i) ? d = Qn({
    root: c,
    value: r,
    valueFormat: n ?? i,
    formatLocale: u
  }) : d = r, d?.toString() ?? "";
}
function PL(t) {
  const {
    isStacked100: e,
    series: i,
    statValue: a,
    percentValue: n,
    yAxisValueFormat: o,
    dataTooltipValueFormat: s,
    dataTooltipPercentFormat: r
  } = t, l = i.chart?.uid ?? 0, { root: c } = i;
  let d = s;
  d === void 0 && (Pe(o) && o ? (d = o, e && (d.intlOptions.style = "decimal")) : d = mc());
  const u = V(l, "formatLocale"), f = a !== void 0 ? Qn({
    root: c,
    value: a,
    valueFormat: d,
    formatLocale: u
  }) : "";
  let m = "";
  if (e && n !== void 0 && c !== void 0) {
    let g = r;
    g === void 0 && (g = Gf(), g.intlOptions.minimumFractionDigits = 2, g.intlOptions.maximumFractionDigits = 2), m = Qn({
      root: c,
      value: n,
      valueFormat: g,
      formatLocale: u
    });
  }
  return { formattedStatValue: f, formattedPercentValue: m };
}
function RL(t) {
  const {
    commonStrings: e,
    fieldList: i,
    queryObject: a,
    series: n,
    seriesConfig: o,
    seriesIndex: s,
    setTimeBinningInfoWhenNotProvided: r
  } = t, { chart: l } = n, { dataTooltipDateFormat: c, dataTooltipPercentFormat: d, dataTooltipValueFormat: u } = o;
  let f = () => "";
  if (l !== void 0) {
    const m = V(l.uid, "config");
    if (m !== void 0) {
      const { dataTooltipVisible: g } = o, y = n instanceof Ae ? o.markerVisible : void 0;
      if (g !== !1 && y !== !1) {
        const p = m.axes, S = p[0].valueFormat, x = p[1].valueFormat, C = H(m.series), F = ti(m) === Ie.Stacked100, v = we(a)?.objectIdField, A = Ve(i, o.x), w = Ki(A, p[0].title?.content.text), O = Ih({
          config: m,
          fieldList: i,
          objectIdField: v,
          seriesIndex: s,
          commonStrings: e,
          isStacked100: F
        }), I = V(l.uid, "rtl"), N = ai(I ?? !1);
        f = (M) => {
          const { seriesName: P, statValue: R, percentValue: $, xValue: W, dateBinningRange: U } = M, q = $L({
            seriesConfig: o,
            xAxisValueFormat: S,
            dataTooltipValueFormat: u,
            dataTooltipDateFormat: c,
            setTimeBinningInfoWhenNotProvided: r,
            series: n,
            xValue: W,
            dateBinningRange: U
          }), { formattedStatValue: Z, formattedPercentValue: ee } = PL({
            isStacked100: F,
            yAxisValueFormat: x,
            dataTooltipValueFormat: u,
            dataTooltipPercentFormat: d,
            series: n,
            statValue: R,
            percentValue: $
          }), j = [`[bold]${w}${N} [/]${q}`];
          switch (C) {
            case L.BarAndLineFromFields: {
              j.pop();
              const ie = kh({
                config: m,
                fieldName: Ve(i, q ?? ""),
                commonStrings: e
              });
              j.push(`[bold]${ie}${N} [/]${Z}`);
              break;
            }
            case L.BarAndLineMonoField:
            case L.BarAndLineNoAggregation:
            case L.BarAndLineMultiFields:
              j.push(`[bold]${O}${N} [/]${Z}`);
              break;
            case L.BarAndLineSplitByNoAggregation:
            case L.BarAndLineSplitBy:
              {
                const ie = Ze(o.query?.where, !1), ge = qf({
                  value: Ve(i, ie)
                });
                j.push(
                  `[bold]${ge}${N} [/]${P}
[bold]${O}${N} [/]${Z}`
                );
              }
              break;
          }
          return F && j.push(`[bold]${e.statistics.percent}${N} [/]${ee}`), j.join(`
`);
        };
      }
    }
  }
  return f;
}
function Kc(t) {
  const { series: e, tooltipFormatter: i } = t;
  st(e.uid, {
    barAndLineTooltipFormatter: i ?? RL(t)
  });
}
function VL(t, e) {
  switch (!0) {
    case (t === b.HistogramSeries && e instanceof Ft): {
      Dh(e);
      break;
    }
    case (t === b.PieSeries && e instanceof Jt): {
      e.events.once(Se.DataValidated, () => {
        Mh(e);
      });
      break;
    }
    case ((t === b.ComboLineAndBarSeries || t === b.BarSeries) && e instanceof Ft): {
      Bh(e);
      break;
    }
    case ((t === b.ComboLineAndBarSeries || t === b.LineSeries) && e instanceof Ae): {
      const i = $e(e.uid, "bulletTemplate");
      i && Eu(i, e);
      break;
    }
    case (t === b.ScatterSeries && e instanceof Ae): {
      const i = $e(e.uid, "bulletTemplate");
      i && zL(i, e);
      break;
    }
    case (t === b.RadarSeries && e instanceof Ae): {
      const i = $e(e.uid, "bulletTemplate");
      i && Eu(i, e);
      break;
    }
  }
}
function EL(t) {
  const { axesConfig: e, seriesConfig: i, series: a, fieldList: n } = t, { dataTooltipVisible: o } = i;
  let s;
  const { chart: r } = a, l = r?.uid !== void 0 ? V(r.uid, "rtl") : !1, c = ai(l ?? !1);
  return o === !1 ? s = (d, u, f) => "" : s = (d, u, f) => {
    const m = Ve(n, i.x), g = be(e?.[0].title?.content?.text) ? m : e?.[0].title?.content?.text, y = Ve(n, i.y), p = be(e?.[1]?.title?.content?.text) ? y : e?.[1]?.title?.content?.text, S = $e(
      a.uid,
      "tooltipValueXNumberFormatCallback"
    ), x = S ? S(d) : d, C = $e(
      a.uid,
      "tooltipValueYNumberFormatCallback"
    ), F = C ? C(u) : u;
    let v = l ? `${x}[bold]${g}${c} [/]
${F}[bold]${p}${c} [/]` : `[bold]${g}${c} [/]${x}
[bold]${p}${c} [/]${F}`;
    if (f !== void 0 && i.sizePolicy?.field !== void 0) {
      const A = Ve(n, i.sizePolicy?.field), w = C ? C(f) : f;
      v += l ? `
${w}[bold]${A}${c} [/]` : `
[bold]${A}${c} [/]${w}`;
    }
    return v;
  }, s;
}
function WL(t) {
  const { seriesConfig: e, markerSeries: i, tooltip: a } = t, { x: n, y: o, sizePolicy: s, dataTooltipVisible: r } = e, { field: l } = s ?? {};
  if (r !== !1) {
    const c = $e(
      i.uid,
      "scatterplotTooltipFormatter"
    );
    if (!a.isHidden() && c) {
      const { dataItem: d } = a;
      if (d) {
        const u = d.dataContext;
        if (u) {
          const f = n in u && typeof u[n] == "number" ? Number(u[n]) : Number.NaN, m = o in u && typeof u[o] == "number" ? Number(u[o]) : Number.NaN, g = l && l in u && typeof u[l] == "number" ? Number(u[l]) : void 0;
          return c(f, m, g);
        }
      }
    }
  }
}
function zL(t, e) {
  const i = rs(e);
  t.set("tooltip", i), t.setAll({
    tooltipText: " ",
    tooltipPosition: "fixed"
  }), t.adapters.add("tooltipText", (a, n) => yo(n, e));
}
function HL(t) {
  const { axesConfig: e, series: i, seriesConfig: a, tooltipFormatter: n } = t;
  Th({
    axesConfig: e,
    currentSeries: i,
    tooltipValueFormat: a.dataTooltipValueFormat
  }), st(i.uid, {
    scatterplotTooltipFormatter: n ?? EL(t)
  });
}
function qL(t) {
  const { series: e, seriesConfig: i, newMin: a, newMax: n } = t, o = e.get("heatRules")?.[0];
  let s = o === void 0 && i.sizePolicy !== void 0 || o !== void 0 && i.sizePolicy === void 0;
  if (!s && o !== void 0) {
    const r = o.min === a && o.max === n, l = e.get("valueField") === i.sizePolicy?.field, c = i.sizePolicy?.scaleType === $a.Linear && o.logarithmic !== !0 || i.sizePolicy?.scaleType === $a.Logarithmic && o.logarithmic === !0;
    s = !(r && l && c);
  }
  return s;
}
function GL(t, e) {
  const { sizePolicy: i } = t, a = e.get("heatRules")?.[0], n = $e(e.uid, "bulletTemplate");
  if (n !== void 0)
    if (i !== void 0) {
      const { scaleType: o, field: s, minSize: r, maxSize: l } = i, c = Yf(), d = t.markerSymbol?.size ?? gc().size ?? 1, u = (r ?? c.minSize) / d, f = (l ?? c.maxSize) / d;
      a !== void 0 ? qL({ series: e, seriesConfig: t, newMin: u, newMax: f }) && (a.min = u, a.max = f, a.logarithmic = o === $a.Logarithmic, e.set("valueField", s)) : e.setAll({
        valueField: s,
        calculateAggregates: !0,
        heatRules: [
          {
            target: n,
            key: "scale",
            min: u,
            max: f,
            dataField: "value",
            // this is a static value to be kept in sync with the series.valueField from the creation step
            logarithmic: o === $a.Logarithmic
          }
        ]
      });
    } else
      e.get("heatRules")?.pop(), e.setAll({
        valueField: void 0,
        calculateAggregates: !1
      });
}
function ya(t) {
  return t.get("id") === D.overlayId.scatterplotTrendLine;
}
function Eh(t) {
  return t.series.values.find((e) => !ya(e));
}
function Wh(t) {
  return t.series.values.find((e) => ya(e));
}
function YL(t) {
  const { root: e, xAxis: i, yAxis: a, seriesConfig: n } = t, { x: o, y: s } = n, r = Ae.new(e, {
    xAxis: i,
    yAxis: a,
    valueXField: o,
    valueYField: s,
    layer: D.zIndexes.scatterplotTrendLine
  });
  return r.set("id", D.overlayId.scatterplotTrendLine), st(r.uid, {
    type: ze.Trendline
  }), r;
}
function XL(t, e) {
  const i = Jn.new({});
  st(t.uid, { bulletTemplate: i }), t.bullets.push((a) => {
    const n = ga.new(
      a,
      {
        nonScalingStroke: !0,
        // this avoids the border to scale with the marker when using heat rules (bubble plot), which was leading to an opacity glitch (see https://help.amcharts.com/hc/en-us/requests/99558)
        tooltip: Qc(a, t),
        tooltipText: " "
      },
      i
    );
    return na(n, e?.selectionTheme), oa(n, t), _h(n, t), za.new(a, {
      sprite: n
    });
  });
}
function UL(t) {
  const { root: e, seriesConfig: i, xAxis: a, yAxis: n, options: o } = t, { x: s, y: r, id: l } = i, c = [], d = Ae.new(e, {
    xAxis: a,
    yAxis: n,
    valueXField: s,
    valueYField: r,
    id: l,
    opacity: 0,
    // to avoid showing the line
    valueField: "value",
    // necessary for bubble plot / heat rules. See `updateSizePolicy()`
    maskBullets: !1,
    layer: D.zIndexes.bulletMarkers
  });
  d.strokes.template.set("forceHidden", !0), XL(d, o), ds(d), c.push(d);
  const u = YL({
    root: e,
    xAxis: a,
    yAxis: n,
    seriesConfig: i
  });
  return Ch(u), c.push(u), d.appear(), c;
}
function jL(t) {
  const { root: e, trendLineSeries: i, data: a, valueFormat: n, defaultR2Value: o, chartConfig: s } = t, { chart: r } = i, l = s.series[0], c = l.overlays?.trendLine, d = c?.symbol ?? {
    type: re.SLS
  }, u = c?.created === !0 && c.visible !== !1;
  if (a !== void 0) {
    const f = D.scatterplotSeries, m = r !== void 0 ? V(r.uid, "formatLocale") : void 0, { x: g, y } = l;
    i.setAll({
      valueXField: g,
      valueYField: y
    }), i.data.setAll(a.trendLinePoints ?? D.scatterplotSeries.trendLinePoints);
    const p = Number.isFinite(a.r2) ? Qn({
      root: e,
      value: a.r2 ?? f.r2,
      valueFormat: n,
      formatLocale: m
    }) : void 0, S = p !== void 0 ? `R² = ${p}` : o;
    i.set("name", S);
  }
  d.color === void 0 && (d.color = Si({ colorIndex: 1 })), ra({
    element: i,
    lineSymbol: d,
    visible: u
  });
}
function _L(t) {
  const { root: e, chartConfig: i, markerSeries: a } = t, n = a.chart;
  if (n) {
    const o = i.series[0], s = Ri(i);
    let r, l;
    const c = gc(), d = /* @__PURE__ */ new Set();
    a.dataItems.forEach((f) => {
      const m = f.bullets?.[0]?.get("sprite");
      if (m !== void 0) {
        const g = Wt({
          dataItem: f?.dataContext,
          seriesConfig: o,
          chartSubType: L.NonSpecific,
          colorMatch: s
        }), y = Pt({
          root: e,
          element: m,
          seriesSymbol: o.markerSymbol ?? c,
          rendererSymbol: g,
          colorMatch: s
        });
        r = y.symbolWithColorInfo, l = y.stylingInfo, Bo(m, l), d.add(JSON.stringify(l));
      }
    }), r = d.size > 1 ? void 0 : r;
    const u = /* @__PURE__ */ new Map();
    u.set(0, r), zi({
      data: u,
      htmlContainer: e.dom,
      chartId: a.chart?.get("id"),
      colorMatchApplied: Yr(n)
    });
  }
}
function ZL(t) {
  const { dataWasUpdated: e, seriesWereReinitialized: i, data: a, series: n, chartConfig: o, loaderHandle: s } = t;
  if ((e === !0 || i === !0) && a) {
    const { x: r, y: l } = o.series[0];
    n.setAll({
      valueXField: r,
      valueYField: l
    }), n.events.once(Se.DataValidated, () => {
      s.hideLoader();
    }), n.data.setAll(a.dataItems);
  }
}
function QL(t) {
  const {
    root: e,
    chartConfig: i,
    seriesConfig: a,
    options: n,
    fieldList: o,
    series: s,
    trendLineSeries: r,
    data: l,
    dataWasUpdated: c,
    seriesWereReinitialized: d,
    loaderHandle: u,
    commonStrings: f
  } = t, { axes: m } = i, { tooltipFormatter: g } = n ?? {};
  s.set("id", a.id), _e(s.bulletsContainer, a.visible), jL({
    root: e,
    trendLineSeries: r,
    chartConfig: i,
    data: l,
    valueFormat: Sr(),
    defaultR2Value: f.notAvailable
  }), GL(a, s), ba(t) && Sa({
    // TODO: Remove the type assertion and correct the typings
    styleCallback: _L,
    callbackProps: { root: e, chartConfig: i, markerSeries: s, dataWasUpdated: c },
    series: s,
    seriesConfig: a
  }), HL({
    axesConfig: m,
    seriesConfig: a,
    series: s,
    fieldList: o,
    tooltipFormatter: g
  }), ZL({
    dataWasUpdated: c,
    seriesWereReinitialized: d,
    data: l,
    series: s,
    chartConfig: i,
    loaderHandle: u
  });
}
function KL(t) {
  t.series.each((e) => {
    e instanceof Ae ? e.dataItems.forEach((i) => {
      const a = i.bullets?.[0];
      a && Dt({
        element: a.get("sprite"),
        selected: !1,
        backToDefaultState: !0
      });
    }) : e instanceof Ft ? e.columns.each((i) => {
      Dt({
        element: i,
        selected: !1,
        backToDefaultState: !0
      });
    }) : e instanceof Jt && e.slices.each((i) => {
      Dt({
        element: i,
        selected: !1,
        backToDefaultState: !0
      });
    });
  });
}
function Wa(t) {
  const { chart: e, selectionSource: i } = t, a = V(
    e.uid,
    "currentSelectionDataItems"
  );
  Le(e.uid, {
    currentSelectionDataItems: void 0,
    currentSelectionOIDs: void 0,
    currentSelectionIndexes: void 0,
    computedSelectionDataItems: void 0,
    computedSelectionIndexes: void 0,
    pendingSelectionQueries: !1
  }), Hr(e) && KL(e), a && oo({
    data: {
      selectionSource: i ?? Ue.ClearSelection
    },
    htmlContainer: e.root.dom
  });
}
function oa(t, e) {
  t.events.on(Se.PointerUp, async (i) => {
    const { chart: a } = e;
    if (a) {
      const n = V(e.chart?.uid ?? Number.NaN, "actionMode");
      if (!V(e.chart?.uid ?? Number.NaN, "filterBySelection") && n !== ne.None && n !== ne.Zoom) {
        const s = i.target, r = rL(i, e);
        Dt({
          element: s,
          selected: pa(s.uid, "selected") !== !0
          // switching the bullet state
        }), r && a.series.each((l) => {
          l instanceof Ae ? l.dataItems.forEach((c) => {
            const d = c.bullets?.[0]?.get("sprite");
            d !== s && Dt({ element: d, selected: !1 });
          }) : l instanceof Ft ? l.columns.each((c) => {
            c !== s && Dt({ element: c, selected: !1 });
          }) : l instanceof Jt && l.slices.each((c) => {
            c !== s && Dt({ element: c, selected: !1 });
          });
        }), await Jc(a, Ue.SelectionByClick);
      }
    }
  });
}
function zu(t, e) {
  let i = Number.NaN, a = Number.NaN;
  const n = e.get("renderer") instanceof li, o = t.getPrivate(n ? "downPositionX" : "downPositionY"), s = t.getPrivate(n ? "positionX" : "positionY");
  return o !== void 0 && s !== void 0 && (i = o * (n ? e.width() : e.height()), a = s * (n ? e.width() : e.height())), { coord1: i, coord2: a };
}
function JL(t) {
  if (t instanceof Te) {
    const e = t.get("cursor");
    t.plotContainer.events.on(Se.PointerUp, () => {
      e?.selection.width() === 2e7 && Wa({ chart: t });
    });
  } else t instanceof sn && t.get("background")?.events.on(Se.Click, () => {
    Wa({ chart: t });
  });
}
function eA(t) {
  const { series: e, cursorBounds: i, multiSelect: a } = t;
  e.columns.each((n) => {
    const o = n.get("x"), s = n.get("y");
    if (typeof o == "number" && typeof s == "number") {
      const r = {
        left: o,
        right: o + n.width(),
        top: s,
        bottom: s + n.height()
      }, c = !(r.left > i.right || r.right < i.left || r.top > i.bottom || r.bottom < i.top) || a && pa(n.uid, "selected") === !0;
      Dt({ element: n, selected: c });
    }
  });
}
function tA(t) {
  const { series: e, cursorBounds: i, multiSelect: a } = t;
  e.dataItems.forEach((n) => {
    const o = n.bullets?.[0]?.get("sprite");
    if (o) {
      const s = n.bullets?.[0]?.get("sprite").get("x"), r = n.bullets?.[0]?.get("sprite").get("y"), c = typeof s == "number" && typeof r == "number" && s >= i.left && s <= i.right && r >= i.top && r <= i.bottom || a && pa(o.uid, "selected") === !0;
      Dt({ element: o, selected: c });
    }
  });
}
function iA(t) {
  const { cursor: e, xAxis: i, yAxis: a } = t, n = e.get("behavior"), { coord1: o, coord2: s } = zu(e, i), { coord1: r, coord2: l } = zu(e, a), c = {
    left: o > s ? s : o,
    right: o > s ? o : s,
    top: r < l ? r : l,
    bottom: r < l ? l : r
  };
  return n === "selectX" ? (c.top = Number.NEGATIVE_INFINITY, c.bottom = Number.POSITIVE_INFINITY) : n === "selectY" && (c.right = Number.POSITIVE_INFINITY, c.left = Number.NEGATIVE_INFINITY), c;
}
function aA(t) {
  t.get("cursor")?.events.on(Se.SelectEnded, async (i) => {
    const a = V(t.uid, "actionMode");
    if (a === ne.MultiSelection || a === ne.MultiSelectionWithCtrlKey) {
      const n = t.xAxes.getIndex(0), o = t.yAxes.getIndex(0);
      if (n && o) {
        const s = t.get("cursor"), r = iA({ cursor: s, xAxis: n, yAxis: o }), l = mh(i);
        t.series.each((c) => {
          !ya(c) && !ls(c) && (c instanceof Ft || c instanceof Ae) && (c instanceof Ft ? eA({ series: c, cursorBounds: r, multiSelect: l }) : c instanceof Ae && tA({ series: c, cursorBounds: r, multiSelect: l }));
        }), _e(s.selection, !1), await Jc(t, Ue.SelectionByRange);
      }
    }
  });
}
function nA(t) {
  JL(t), t instanceof Te && aA(t);
}
function zh(t) {
  const { numberFormatter: e, dataLabelsConfigContent: i, stackedType: a, externalDataLabelFormatter: n } = t;
  return (o, s) => {
    let r = a === Ie.Stacked100 && s !== void 0 ? s : o;
    return e.get("numberFormat").style === "percent" && (r /= 100), Ht({
      textSymbol: {
        ...i,
        text: e.format(r)
      },
      format: n === void 0 ? "amChartsV5" : "html"
    });
  };
}
function oA(t, e) {
  const i = t.dataItem;
  let a;
  switch (e) {
    case b.LineSeries:
    case b.ScatterSeries:
      a = i.get("point");
      break;
    case b.HistogramSeries:
    case b.BarSeries:
      a = i.get("graphics");
      break;
  }
  const n = a ?? t, o = a?.x ?? n?.get("x") ?? 0, s = a?.y ?? n?.get("y") ?? 0;
  return { x: o, y: s };
}
function Hh(t) {
  const { label: e, chart: i, seriesType: a } = t, n = (s) => {
    if (i instanceof Te) {
      const r = oA(s, a), l = i.plotContainer, c = l.x(), d = l.y(), u = r.x < c || r.x > c + l.width() || r.y < d || r.y > d + l.height();
      s.setAll({
        visible: !u,
        forceHidden: u
      });
    }
  }, o = at((s, r) => {
    r && n(r);
  }, D.debounceTime);
  e.on("x", o), e.on("y", o);
}
function sA(t, e) {
  e.adapters.add("y", (i, a) => {
    const { chart: n } = t, o = n !== void 0 ? V(n.uid, "isRotated") : !1;
    let s = typeof i == "number" ? i : i?.value;
    const r = a.dataItem;
    if (r !== void 0 && s !== void 0 && s !== null) {
      const l = r?.get("valueY"), c = a.localBounds().bottom;
      if (o !== !0) {
        const d = D.dataLabelNegative?.paddingTop ?? 0;
        t.get("stacked") && (l < 0 ? s += c - d : s += c);
      } else {
        const d = D.rotatedChartPadding?.paddingTop ?? 0;
        s += c / 2 + d;
      }
    }
    return s;
  }), e.adapters.add("x", (i, a) => {
    const { chart: n } = t, o = n !== void 0 ? V(n.uid, "isRotated") : !1;
    let s = typeof i == "number" ? i : i?.value;
    const r = a.dataItem;
    if (r !== void 0 && s !== void 0 && s !== null && o === !0) {
      const l = r?.get("valueX"), d = a.width() / 2, u = D.rotatedChartPadding?.paddingRight ?? 0, f = d + u;
      t.get("stacked") || (l < 0 ? s -= f : s += f);
    }
    return s;
  });
}
function rA(t) {
  const { series: e, isRotated: i, dataLabelsConfig: a, externalDataLabelFormatter: n, labelDefaults: o, seriesType: s } = t;
  e.bullets.push(() => {
    const r = e.get("stacked"), l = za.new(e.root, {
      locationY: !r && !i ? 1 : void 0,
      locationX: !r && i ? 1 : void 0,
      sprite: Pa.new(e.root, {
        text: i ? "{valueX}" : "{valueY}",
        populateText: !0,
        centerY: ct,
        centerX: St,
        // remove padding so if they fit in the label, it shows
        paddingBottom: 0,
        paddingTop: 0,
        paddingRight: 0,
        paddingLeft: 0,
        fill: je(a?.content.color).color,
        fontSize: a?.content.font?.size
      })
    }), c = l.get("sprite");
    if (c) {
      const d = c;
      lA({
        dataLabel: d,
        series: e,
        externalDataLabelFormatter: n
      }), e.chart && a?.visible && Hh({ label: c, chart: e.chart, seriesType: s }), sA(e, c), qr({
        ...t,
        dataLabel: d,
        labelDefaults: o,
        defaultDataLabelFormatter: zh,
        externalDataLabelFormatter: n
      });
    }
    return l;
  });
}
function qh(t, e = 1) {
  t.bullets.removeIndex(e);
}
function lA(t) {
  const { dataLabel: e, series: i, externalDataLabelFormatter: a } = t;
  e.adapters.remove("text"), e.adapters.remove("html");
  const n = a !== void 0 ? "html" : "text";
  e.adapters.add(n, (o, s) => {
    let r = o ?? "";
    const l = s.dataItem, c = $e(
      i.uid,
      i instanceof Ft ? "barSeriesDataLabelFormatter" : "lineSeriesDataLabelFormatter"
    );
    if (c !== void 0 && i.chart && l) {
      const d = V(i.chart.uid, "isRotated"), u = d === !0 ? l.get("valueX") : l.get("valueY"), f = d === !0 ? l.get("valueXTotalPercent") : l.get("valueYTotalPercent"), m = i.get("valueYShow") === "valueYTotalPercent" || i.get("valueXShow") === "valueXTotalPercent";
      r = c(m ? f : u);
    }
    return n === "html" ? rt(r) : r;
  });
}
function qr(t) {
  const {
    series: e,
    seriesConfig: i,
    dataLabel: a,
    labelDefaults: n,
    dataLabelsConfig: o,
    yAxisValueFormat: s,
    stackedType: r,
    isRotated: l,
    seriesType: c,
    defaultDataLabelFormatter: d,
    externalDataLabelFormatter: u
  } = t, { chart: f } = e;
  if (a !== void 0) {
    let m = u;
    const g = o?.content ?? { type: re.TS };
    if (u === void 0 && d !== void 0 && s?.type === b.NumberAxisFormat && f) {
      const C = V(f.uid, "formatLocale"), F = Qi({
        root: f.root,
        type: s.type,
        formatLocale: C,
        intlOptions: s.intlOptions
      });
      m = d({
        numberFormatter: F,
        dataLabelsConfigContent: g,
        stackedType: r,
        externalDataLabelFormatter: u
      });
    }
    let y;
    switch (c) {
      case b.BarSeries:
        y = "barSeriesDataLabelFormatter";
        break;
      case b.LineSeries:
        y = "lineSeriesDataLabelFormatter";
        break;
      case b.HistogramSeries:
        y = "histogramDataLabelFormatter";
        break;
      case b.ScatterSeries:
        y = "scatterplotDataLabelFormatter";
        break;
    }
    y !== void 0 && st(e.uid, {
      [y]: m
    }), o !== void 0 && (o.content.text = l === !0 ? "{valueX}" : "{valueY}", o.visible = o.visible !== !1), Zi({
      label: a,
      labelConfig: o,
      defaults: n ?? D.dataLabel,
      skipSettingText: !0
    });
    const p = e.get("stacked"), S = p && c === b.BarSeries && i?.hideOversizedStackedLabels !== !1;
    !p && c === b.BarSeries && i?.hideOversizedSideBySideLabels === !0 || S ? a.setAll({
      oversizedBehavior: "hide",
      maxWidth: void 0
    }) : a.setAll({
      oversizedBehavior: "none"
    });
  }
}
function cA(t) {
  const { series: e, labelDefaults: i, externalDataLabelFormatter: a } = t;
  e.dataItems.forEach((n) => {
    const o = n.bullets?.[1];
    if (o) {
      o.set("locationY", e.get("stacked") ? void 0 : 1);
      const s = o.get("sprite");
      s && qr({
        ...t,
        dataLabel: s,
        labelDefaults: i,
        defaultDataLabelFormatter: zh,
        externalDataLabelFormatter: a
      });
    }
  });
}
function Gh(t) {
  const { series: e, dataLabelsConfig: i } = t, a = i?.visible, n = e.bullets.hasIndex(1);
  a !== !0 ? n && qh(e) : (n || rA(t), cA(t));
}
function dA(t) {
  const { series: e, dataLabelsConfig: i, labelDefaults: a, externalDataLabelFormatter: n, seriesType: o } = t;
  e.bullets.push(() => {
    const s = za.new(e.root, {
      locationY: 1,
      sprite: Pa.new(e.root, {
        populateText: !0,
        oversizedBehavior: "hide",
        centerY: ct,
        centerX: Re,
        paddingBottom: 0,
        paddingTop: 0,
        paddingRight: 0,
        paddingLeft: 0,
        fill: je(i?.content.color).color,
        fontSize: i?.content.font?.size
      })
    }), r = s.get("sprite");
    return r && (uA({
      dataLabel: r,
      series: e,
      externalDataLabelFormatter: n
    }), e.chart && i?.visible && Hh({ label: r, chart: e.chart, seriesType: o }), qr({
      ...t,
      dataLabel: r,
      labelDefaults: a,
      defaultDataLabelFormatter: Yh
    })), s;
  });
}
function uA(t) {
  const { dataLabel: e, series: i, externalDataLabelFormatter: a } = t;
  e.adapters.remove("text"), e.adapters.remove("html");
  const n = a !== void 0 ? "html" : "text";
  e.adapters.add(n, (o, s) => {
    let r = o ?? "";
    const l = $e(
      i.uid,
      "histogramDataLabelFormatter"
    ), c = s.dataItem;
    if (c && "dataContext" in c && c.dataContext !== void 0 && l !== void 0) {
      const { count: d, minValue: u, maxValue: f } = c.dataContext;
      r = l(d, u, f);
    }
    return n === "html" ? rt(r) : r;
  });
}
function Yh(t) {
  const { numberFormatter: e, dataLabelsConfigContent: i, externalDataLabelFormatter: a } = t;
  return (n, o, s) => Ht({
    textSymbol: {
      ...i,
      text: e.format(n)
    },
    format: a === void 0 ? "amChartsV5" : "html"
  });
}
function fA(t) {
  const { series: e, labelDefaults: i, externalDataLabelFormatter: a } = t;
  e.dataItems.forEach((n) => {
    const o = n.bullets?.[0];
    if (o) {
      const s = o.get("sprite");
      s && qr({
        ...t,
        dataLabel: s,
        labelDefaults: i,
        defaultDataLabelFormatter: Yh,
        externalDataLabelFormatter: a
      });
    }
  });
}
function Xh(t) {
  const { series: e, dataLabelsConfig: i } = t, a = i?.visible, n = e.bullets.hasIndex(0);
  a !== !0 ? n && qh(e, 0) : (n || dA(t), fA(t));
}
function ls(t) {
  return [
    D.overlayId.histogramMean,
    D.overlayId.histogramMedian,
    D.overlayId.histogramStdDev,
    D.overlayId.histogramNormalDistribution
  ].includes(t.get("id") ?? "");
}
function mA(t) {
  let e = "";
  switch (t) {
    case ze.Mean:
      e = D.overlayId.histogramMean;
      break;
    case ze.Median:
      e = D.overlayId.histogramMedian;
      break;
    case ze.StdDev:
      e = D.overlayId.histogramStdDev;
      break;
    case ze.Normal:
      e = D.overlayId.histogramNormalDistribution;
      break;
  }
  return e;
}
function gA(t) {
  const { series: e, seriesConfig: i, colorMatch: a, rendererSymbol: n } = t, { root: o } = e, s = e.chart;
  if (s) {
    const r = i.fillSymbol ?? Xf(), c = Pt({
      root: e.root,
      element: e.columns.template,
      seriesSymbol: r,
      rendererSymbol: n,
      colorMatch: a,
      isChartFillSymbol: !0
    }).symbolWithColorInfo;
    if (c !== void 0) {
      const d = /* @__PURE__ */ new Map();
      d.set(0, c), zi({
        data: d,
        htmlContainer: o.dom,
        chartId: s.get("id"),
        colorMatchApplied: Yr(s)
      });
    }
  }
}
function hA(t) {
  const { series: e, data: i, dataWasUpdated: a, seriesWereReinitialized: n, loaderHandle: o } = t;
  i && (a === !0 || n === !0) && (e.events.once(Se.DataValidated, () => {
    o.hideLoader();
  }), e.data.setAll(i.bins));
}
function ks(t) {
  const { root: e, xAxis: i, yAxis: a, type: n, commonStrings: o } = t, s = Ae.new(e, {
    id: mA(n),
    valueXField: "x",
    valueYField: "y",
    xAxis: i,
    yAxis: a,
    visible: !1
  });
  return n === ze.Normal && So(s, o.overlays.normal), st(s.uid, { isOverlay: !0, type: n }), s.set("connect", !1), s.appear(), s;
}
function pA(t) {
  const { root: e, seriesConfig: i, xAxis: a, yAxis: n, options: o, chartConfig: s } = t, { id: r, name: l } = i, c = Ft.new(e, {
    id: r,
    name: l,
    xAxis: a,
    yAxis: n,
    categoryXField: Ro.Start,
    valueYField: Ro.Count,
    maskBullets: !1
  });
  return na(c.columns.template, o?.selectionTheme), oa(c.columns.template, c), c.columns.template.setAll({
    width: ct
  }), Xh({
    yAxisValueFormat: s.axes?.[1]?.valueFormat,
    series: c,
    seriesConfig: i,
    seriesType: b.HistogramSeries,
    dataLabelsConfig: i.dataLabels,
    externalDataLabelFormatter: o?.dataLabelFormatter
  }), ds(c), c.appear(), c;
}
function yA(t) {
  const { root: e, seriesConfig: i, xAxis: a, xAxisForOverlaySeries: n, yAxis: o, commonStrings: s, options: r, chartConfig: l } = t, c = [], d = pA({ root: e, seriesConfig: i, xAxis: a, yAxis: o, options: r, chartConfig: l });
  return c.push(d), Dh(d), n && (c.push(
    ks({
      root: e,
      xAxis: n,
      yAxis: o,
      type: ze.Mean,
      commonStrings: s
    })
  ), c.push(
    ks({
      root: e,
      xAxis: n,
      yAxis: o,
      type: ze.Median,
      commonStrings: s
    })
  ), c.push(
    ks({
      root: e,
      xAxis: n,
      yAxis: o,
      type: ze.StdDev,
      commonStrings: s
    })
  ), c.push(
    ks({
      root: e,
      xAxis: n,
      yAxis: o,
      type: ze.Normal,
      commonStrings: s
    })
  )), c;
}
function bA(t) {
  const { lineSeries: e, overlayConfig: i, data: a, commonStrings: n } = t;
  if (!i)
    _e(e, !1);
  else {
    const { symbol: o, created: s, visible: r } = i, l = $e(e.uid, "type"), c = o ?? { type: re.SLS };
    if (i.symbol?.color === void 0 && (c.color = Si({
      colorIndex: qs(l),
      histogramOverlays: !0
    })), ra({
      element: e,
      lineSymbol: c,
      visible: s === !0 && r !== !1
    }), a && "bins" in a) {
      const f = a.bins.map((F) => F.count), m = Math.max(...f), { mean: g, stddev: y, median: p } = a, S = g - y, x = g + y;
      let C = [];
      switch (l) {
        case ze.Mean:
          C = [
            { x: g, y: 0 },
            { x: g, y: m }
          ];
          break;
        case ze.Median:
          C = [
            { x: p, y: 0 },
            { x: p, y: m }
          ];
          break;
        case ze.StdDev:
          C = [
            { x: S, y: 0 },
            { x: S, y: m },
            { x: null, y: null },
            // inserting null stats to create a gap between the 2 stddev lines
            { x, y: 0 },
            { x, y: m }
          ];
          break;
      }
      e.data.setAll(C);
    }
    let u = e.data.getIndex(0)?.x;
    if (l === ze.StdDev && (u = a?.stddev ?? $e(e.uid, "stddev"), st(e.uid, { stddev: u })), typeof u == "number") {
      let f = l;
      switch (l) {
        case ze.Mean:
          f = n.overlays.mean;
          break;
        case ze.Median:
          f = n.overlays.median;
          break;
        case ze.StdDev:
          f = n.overlays.stdDev;
          break;
      }
      const m = V(e.chart?.uid ?? Number.NaN, "formatLocale"), g = V(e.chart?.uid ?? Number.NaN, "rtl");
      let y = `${f}`;
      const p = Qn({
        root: e.root,
        value: u,
        valueFormat: Sr(),
        formatLocale: m
      });
      g ? y = `${p} :${f}` : y = `${f}: ${p}`, So(e, y);
    }
  }
}
function SA(t) {
  const { lineSeries: e, overlayConfig: i, data: a, numberOfPoints: n } = t;
  if (!i)
    _e(e, !1);
  else {
    const { symbol: o, created: s, visible: r } = i, l = o ?? { type: re.SLS };
    if (i?.symbol?.color === void 0 && (l.color = Si({
      colorIndex: qs(ze.Normal),
      histogramOverlays: !0
    })), ra({
      element: e,
      lineSymbol: l,
      visible: s === !0 && r !== !1
    }), a && "bins" in a) {
      const { mean: d, stddev: u, min: f, max: m } = a, g = fh(a.bins), y = dh(
        f,
        m,
        n ?? D.histogramSeries.normalDistribNumberOfPoints
      ).map(
        (p) => ({
          x: p,
          y: uh({
            x: p,
            mean: d,
            stddev: u,
            scalingFactor: g
          })
        })
      );
      e.data.setAll(y);
    }
  }
}
async function xA(t) {
  const {
    series: e,
    chartConfig: i,
    seriesConfig: a,
    seriesWereReinitialized: n,
    dataWasUpdated: o,
    queryObject: s,
    chartRenderer: r,
    data: l,
    loaderHandle: c
  } = t;
  _e(e, a.visible), So(e, a.name);
  const d = we(s), u = qc({
    chartRenderer: r,
    queryObject: s
  }), f = r ?? d?.renderer, m = os(r, d?.renderer);
  let g;
  if (ja({ chartConfig: i, queryObject: s })) {
    const y = await Gc({
      seriesConfig: [a],
      dataItem: {},
      renderer: f,
      rendererOrigin: r !== void 0 ? Ui.ChartRenderer : Ui.LayerRenderer,
      rendererType: m,
      chartSubType: L.NonSpecific,
      graphicTemplate: u
    });
    g = y.rendererSymbol, Le(e.chart?.uid ?? Number.NaN, { colorMatchApplied: y.colorMatchApplied });
  }
  ba(t) && Sa({
    // TODO: Remove the type assertion and correct the typings
    styleCallback: gA,
    callbackProps: { ...t, rendererSymbol: g },
    series: e,
    seriesConfig: a
  }), hA({
    series: e,
    seriesWereReinitialized: n,
    dataWasUpdated: o,
    data: l,
    loaderHandle: c
  });
}
async function CA(t) {
  const {
    allChartSeries: e,
    seriesConfig: i,
    data: a,
    commonStrings: n,
    fieldList: o,
    axes: s,
    options: r,
    dataLabelFormatter: l,
    chartConfig: c
  } = t, { tooltipFormatter: d } = r ?? {};
  for (let u = 0; u < e.length; u++) {
    const f = e[u];
    if (f instanceof Ae && $e(f.uid, "isOverlay")) {
      const m = $e(f.uid, "type");
      if (m === ze.Normal)
        SA({
          lineSeries: f,
          overlayConfig: i.overlays?.comparisonDistribution,
          data: a
        });
      else {
        let g;
        switch (m) {
          case ze.Mean:
            g = i.overlays?.mean;
            break;
          case ze.Median:
            g = i.overlays?.median;
            break;
          case ze.StdDev:
            g = i.overlays?.standardDeviation;
            break;
        }
        bA({
          lineSeries: f,
          overlayConfig: g,
          data: a,
          commonStrings: n
        });
      }
    } else f instanceof Ft && (f.set("id", i.id), await xA({ ...t, series: f }), Xh({
      series: f,
      yAxisValueFormat: c.axes?.[1]?.valueFormat,
      seriesConfig: i,
      seriesType: b.HistogramSeries,
      dataLabelsConfig: i.dataLabels,
      externalDataLabelFormatter: l
    }), kL({
      axes: s,
      series: f,
      seriesConfig: i,
      fieldList: o,
      tooltipFormatter: d,
      commonStrings: n,
      axesConfig: c.axes
    }));
  }
}
function vA(t) {
  let e = "";
  return t instanceof rc ? e = t.get("categoryXField") ?? t.get("valueXField") ?? "" : t instanceof Jt && (e = t.get("categoryField") ?? ""), e;
}
function FA(t) {
  let e = "";
  return t instanceof rc ? e = t.get("categoryYField") ?? t.get("valueYField") ?? "" : t instanceof Jt && (e = t.get("categoryField") ?? ""), e;
}
function cs(t) {
  let e = "";
  const { chart: i } = t;
  return i !== void 0 && (e = V(i.uid, "isRotated") === !0 ? vA(t) : FA(t)), e;
}
function LA(t) {
  dc(), Sm(t.root.dom), Wa({ chart: t });
}
function AA(t) {
  const { chart: e, chartType: i, showMean: a } = t;
  return e.series.values.filter(
    (o) => !ya(o) && !ls(o) && (i !== b.BoxPlotSeries || !a || a && $e(o.uid, "isBoxPlotMeanLineSeries"))
  ).every((o) => $e(o.uid, "isSelectionApplied") === !0);
}
function TA(t) {
  t.series.each((e) => st(e.uid, { isSelectionApplied: void 0 }));
}
function wA(t) {
  let e = [];
  if (!ya(t) && !ls(t))
    switch (!0) {
      case t instanceof Jt:
        e = t.slices.values;
        break;
      case t instanceof Ft:
        const { chart: i } = t;
        if (i) {
          const a = V(i.uid, "config");
          if (a) {
            const o = z(a?.series) === b.HistogramSeries ? [Ro.Count] : pt(a?.series, [t.get("id") ?? ""]);
            e = t.columns.values.filter((s) => {
              let r = !1;
              const l = s.dataItem?.dataContext;
              return l && (r = o.some((c) => c in l && Number.isFinite(l[c]))), r;
            });
          }
        }
        break;
      case t instanceof Ae:
        e = Array.from(t.dataItems.values());
        break;
    }
  return e;
}
function Uh(t, e) {
  const i = V(t.uid, "actionMode");
  (i === ne.MonoSelection || i === ne.None) && e.length > 1 ? Wa({ chart: t }) : e.forEach((n) => {
    Dt({ element: n, selected: !0 });
  });
}
function kA(t, e) {
  const i = [], a = [], n = V(t.uid, "config"), o = V(t.uid, "queryObject"), s = Mi(n), r = pt(n?.series ?? []), l = H(n?.series), c = z(n?.series);
  return t.series.each((d, u) => {
    if (n && d.get("visible") === !0 && d.get("id") !== D.overlayId.scatterplotTrendLine) {
      const f = n.series[0].x, m = cs(d), g = e.get(u);
      if (g !== void 0) {
        let y;
        if (d instanceof Ae && (y = d.dataItems.map((p) => p?.bullets?.[0]?.get("sprite")).filter((p) => p !== void 0)), y !== void 0) {
          const { indexesToSelect: p } = g;
          y.forEach((S, x) => {
            if (p === void 0 || p.includes(x)) {
              const C = fa({
                dataContext: S.dataItem?.dataContext,
                yList: r,
                yAxisField: m,
                xAxisField: f,
                chartType: c,
                chartSubType: l,
                showOutliers: s,
                isFeatureCollectionLayer: la(o)
              });
              C !== void 0 && i.push(C), a.push(S);
            } else
              Dt({ element: S, selected: !1 });
          });
        }
      }
    }
  }), Uh(t, a), i;
}
function IA(t) {
  const {
    chart: e,
    chartConfig: i,
    options: a,
    elementsToApplySelectionTo: n,
    selectionDataItems: o,
    layerOidField: s,
    xAxisField: r,
    yAxisField: l,
    splitBy: c
  } = t, d = z(i.series), u = H(i.series), f = Mi(i), m = V(e.uid, "queryObject"), g = [], y = [], p = [], S = pt(i.series);
  return n.forEach((x, C) => {
    const F = x instanceof Mo || x instanceof zn ? x : x.bullets?.[0]?.get("sprite");
    if (F !== void 0) {
      let v = x instanceof Mo || x instanceof zn ? F.dataItem?.dataContext : x.dataContext;
      if (v !== void 0 && d === b.BoxPlotSeries && v[D.boxPlot.boxPlotOutlierId] !== !0 && (v = fa({
        dataContext: v,
        yAxisField: l,
        yList: S,
        xAxisField: r,
        splitBy: c,
        chartType: d,
        chartSubType: u,
        showOutliers: f,
        isFeatureCollectionLayer: la(m)
      })), zr({
        elementDataContext: v,
        options: a,
        selectionDataItems: o,
        layerOidField: s,
        xAxisField: r,
        yAxisField: l,
        chartType: d,
        chartSubType: u,
        showOutliers: f
      }))
        if (g.push(F), y.push(C), F?.dataItem instanceof Ha && v !== void 0)
          p.push(v);
        else {
          const w = /* @__PURE__ */ new Set();
          d === b.PieSeries && qi(v) ? (ss({
            groupOfSlicesDataContext: v
          }) ?? []).forEach((I) => {
            o.forEach((N) => {
              Uc({
                layerOidField: s,
                sliceDataContext: I,
                selectionDataContext: N,
                xAxisField: r
              }) && w.add(I);
            });
          }) : w.add(v), Array.from(w)?.forEach((O) => {
            const I = fa({
              dataContext: O,
              yAxisField: l,
              yList: S,
              xAxisField: r,
              splitBy: c,
              chartType: d,
              chartSubType: u,
              showOutliers: f,
              isFeatureCollectionLayer: la(m)
            });
            I !== void 0 && p.push(I);
          });
        }
      else
        Dt({ element: F, selected: !1 });
    }
  }), Uh(e, g), { selectedIndexes: y, newSelectionDataItems: p };
}
function OA(t) {
  const {
    series: e,
    seriesIndex: i,
    queryObject: a,
    dataWasUpdated: n,
    sortChanged: o,
    groupOfSlicesWasUpdated: s,
    xAxisField: r,
    yAxisField: l,
    splitBy: c,
    rotationChanged: d
  } = t, { chart: u } = e;
  if (u instanceof Wn) {
    const f = V(u.uid, "options"), { filterBySelection: m, selectionData: g, returnSelectionIndexes: y, returnSelectionOIDs: p } = f ?? {}, { selectionIndexes: S } = g ?? {}, x = V(u.uid, "config"), C = qe(x), F = z(x?.series), v = H(x?.series), A = wA(e);
    if (m !== !0 && x !== void 0) {
      let w;
      a !== void 0 && (w = we(a).objectIdField);
      const O = V(
        u.uid,
        "currentSelectionDataItems"
      );
      let I = !1, N = !1, M, P = !1;
      if (A?.[0] !== void 0) {
        if (f?.viewExtentUpdated !== !0) {
          M = f?.selectionData?.selectionItems ?? O;
          const R = V(
            u.uid,
            "currentSelectionIndexes"
          );
          P = Vc({
            itemsA: M,
            itemsB: O,
            isPieFromFields: v === L.PieFromFields
          });
          const $ = !Di(S, R);
          I = o === !0 || n === !0 || s === !0 || d === !0 || M !== void 0 && P;
          let W = !0;
          if (S !== void 0 && S.size > 0) {
            const { indexesToSelect: U } = S.get(i ?? 0) ?? {};
            W = U !== void 0 && U[0] === void 0;
          }
          N = n === !0 || s === !0 || d === !0 || !W && $;
        }
        if (I && M !== void 0 && M.length > 0) {
          const { selectedIndexes: R, newSelectionDataItems: $ } = IA({
            chart: u,
            chartConfig: x,
            options: f,
            elementsToApplySelectionTo: A,
            selectionDataItems: M,
            layerOidField: w,
            xAxisField: r,
            yAxisField: l,
            splitBy: c
          });
          let W = V(u.uid, "computedSelectionDataItems") ?? [];
          if (W.push(...$), x.series.length > 1 && v !== L.BarAndLineNoAggregation && v !== L.BarAndLineSplitByNoAggregation && (W = ns({
            data: W,
            x: x.series[0].x,
            splitByField: Ze(x.series[0].query?.where)
          })), Le(u.uid, { computedSelectionDataItems: W }), y === !0) {
            const U = Array.from(new Set(R));
            let q = V(
              u.uid,
              "computedSelectionIndexes"
            );
            q === void 0 && (q = /* @__PURE__ */ new Map()), U.length === A.length ? q.set(i ?? 0, {}) : q.set(i ?? 0, { indexesToSelect: U }), Le(u.uid, { computedSelectionIndexes: q });
          }
        } else if (S !== void 0 && N)
          M = kA(u, S);
        else {
          const R = ($) => {
            const W = $.dataItem?.dataContext;
            return zr({
              elementDataContext: W,
              options: f,
              selectionDataItems: M ?? O ?? [],
              layerOidField: w,
              xAxisField: r,
              yAxisField: l,
              chartType: F,
              chartSubType: v
            });
          };
          A.forEach(($) => {
            const W = $ instanceof Mo || $ instanceof zn ? $ : $.bullets?.[0]?.get("sprite");
            W !== void 0 && Dt({
              element: W,
              selected: pa(W.uid, "selected") === !0 || R(W)
            });
          });
        }
      }
      if (st(e.uid, { isSelectionApplied: !0 }), AA({ chart: u, chartType: F, showMean: C }) && (TA(u), P || N)) {
        let R = V(u.uid, "computedSelectionDataItems") ?? M;
        R = Array.from(
          new Set(R?.map((W) => JSON.stringify(W)))
        ).map((W) => JSON.parse(W)), M !== void 0 && Le(u.uid, { currentSelectionDataItems: R }), g?.selectionOIDs !== void 0 && Le(u.uid, { currentSelectionOIDs: g.selectionOIDs });
        let $;
        if (y === !0 && ($ = V(u.uid, "computedSelectionIndexes") ?? S, $ !== void 0 && Le(u.uid, { currentSelectionIndexes: $ })), R === void 0 || R.length === 0)
          Wa({ chart: u, selectionSource: Ue.ProgrammaticSelection });
        else {
          const W = {
            selectionItems: R,
            selectionSource: Ue.ProgrammaticSelection
          };
          y === !0 && (W.selectionIndexes = $), p !== !1 && (W.selectionOIDs = g?.selectionOIDs ?? V(u.uid, "currentSelectionOIDs")), oo({
            data: W,
            seriesConfig: x.series,
            htmlContainer: u.root.dom
          });
        }
        Le(u.uid, { computedSelectionIndexes: void 0, computedSelectionDataItems: void 0 });
      }
    }
  }
}
async function BA(t) {
  const { chart: e, options: i, dataWasUpdated: a, data: n, chartConfig: o, queryObject: s, errorStrings: r } = t, l = V(e.uid, "currentSelectionOIDs"), c = V(e.uid, "queryConfig");
  if (!V(e.uid, "filterBySelection")) {
    const u = await lh({
      chartConfig: o,
      queryConfig: c,
      chartData: n,
      currentSelectionOIDs: l,
      dataWasUpdated: a,
      queryObject: s,
      options: i,
      errorStrings: r
    });
    u !== void 0 && i !== void 0 && (i.selectionData = { ...i?.selectionData, selectionItems: u }), e.series.values.filter((f) => !ya(f) && !ls(f)).forEach((f) => {
      const { seriesConfig: m, seriesIndex: g } = Gr(f, o);
      if (m) {
        const y = m.x, p = m.type === b.BoxPlotSeries ? m.y.toString() : cs(f), S = m.query?.where ?? "";
        DA({
          callbackProps: { ...t, series: f, seriesIndex: g, xAxisField: y, yAxisField: p, splitBy: S },
          series: f,
          seriesConfig: m
        });
      }
    });
  }
}
async function Jc(t, e) {
  const i = V(t.uid, "config"), a = V(t.uid, "queryObject");
  if (i) {
    const n = V(t.uid, "options"), o = z(i.series), s = H(i.series), r = Mi(i), l = pt(i.series), c = i.series[0].x, d = i?.series[0].type === b.HistogramSeries ? i?.series[0].dataTransformationType : void 0, u = oL(t);
    let f;
    a !== void 0 && (f = (await At(a)).find((g) => g.name === c)?.type);
    try {
      const m = /* @__PURE__ */ new Set(), g = [], y = /* @__PURE__ */ new Map(), p = [];
      let S = [], x = 0;
      if (t.series.each(async (C, F) => {
        const { seriesConfig: v } = Gr(C, i), A = v?.query?.where ?? "", w = v?.type === b.BoxPlotSeries ? v.y.toString() : cs(C);
        let O;
        C instanceof Ae ? O = C.dataItems : C instanceof Ft ? O = C.columns.values : C instanceof Jt && (O = C.slices.values), O?.forEach((I, N) => {
          const M = I instanceof Mo || I instanceof zn ? I : I.bullets?.[0]?.get("sprite");
          if (M !== void 0 && pa(M.uid, "selected") === !0) {
            x += 1;
            let P = I instanceof Mo || I instanceof zn ? I.dataItem?.dataContext : I.dataContext;
            if (P !== void 0) {
              if (P = fa({
                dataContext: P,
                yAxisField: w,
                yList: l,
                xAxisField: c,
                splitBy: A,
                chartType: o,
                chartSubType: s,
                showOutliers: r,
                isFeatureCollectionLayer: la(a)
              }), m.has(JSON.stringify(P)) || (m.add(JSON.stringify(P)), g.push(P)), N !== void 0) {
                const $ = y.get(F)?.indexesToSelect ?? [];
                $.push(N), y.set(F, {
                  indexesToSelect: Array.from(new Set($))
                });
              }
              const R = P[ot.uniqueIdsName] !== void 0 ? [P[ot.uniqueIdsName]].flat() : [];
              if (R.length > 0)
                S.push(...R);
              else if (n?.returnSelectionOIDs !== !1) {
                const $ = Eg({
                  chartType: o,
                  dataContext: P,
                  options: n,
                  xAxisField: c,
                  yAxisField: w ?? "",
                  splitBy: A,
                  dataTransformationType: d,
                  isDateAxis: u,
                  xAxisFieldType: f,
                  chartSubType: s,
                  showOutliers: Mi(i)
                });
                p.push($);
              }
            }
          }
        });
      }), x === 0)
        Wa({ chart: t, selectionSource: e });
      else {
        if (n?.returnSelectionOIDs !== !1 && a !== void 0 && p.length > 0) {
          const v = { ...V(t.uid, "queryConfig") };
          delete v.groupByFieldsForStatistics, delete v.orderByFields, delete v.outStatistics;
          const A = await ch({
            whereList: p,
            queryObject: a,
            queryConfig: v
          });
          if (p.length === x)
            S = A;
          else
            for (let w = 0; w < A.length; w += 1)
              S.push(A[w]);
        }
        S = Array.from(new Set(S)), Le(t.uid, {
          currentSelectionDataItems: g,
          currentSelectionOIDs: S,
          currentSelectionIndexes: y
        });
        const C = {
          selectionItems: g,
          selectionSource: e
        };
        n?.returnSelectionIndexes === !0 && (C.selectionIndexes = y), n?.returnSelectionOIDs !== !1 && (C.selectionOIDs = S), oo({
          data: C,
          seriesConfig: i?.series,
          htmlContainer: t.root.dom
        });
      }
    } catch (m) {
      Le(t.uid, { pendingSelectionQueries: !1 });
      const { httpStatus: g } = m instanceof ln ? m.details.details : m.details ?? {};
      if (g === 429)
        LA(t);
      else
        throw m;
    }
    Le(t.uid, { pendingSelectionQueries: !1 });
  }
}
function bo(t, e) {
  const { y: i, query: a } = e, o = H(t.series) === L.BarAndLineSplitByNoAggregation ? `${i.toString()}_${Lt({ where: a?.where })}` : [i].flat()[0], s = D.xAxisField, r = t.rotated === !0 ? "categoryYField" : "categoryXField", l = t.rotated === !0 ? "valueYField" : "valueXField", c = t.axes?.[0]?.valueFormat.type === b.CategoryAxisFormat ? r : l, d = t.rotated === !0 ? "valueXField" : "valueYField";
  return { xField: s, yField: o, xAxisField: c, yAxisField: d };
}
function ba(t) {
  const { chartConfig: e, seriesWereReinitialized: i, dataWasUpdated: a, colorMatchChanged: n, seriesStyleChanged: o, sortChanged: s } = t, r = e.series.length === 1, l = z(e.series), c = (i || a || n || o) ?? !1;
  let d = !1;
  switch (l) {
    case b.BarSeries:
      d = (r && s) ?? !1;
      break;
  }
  return d || c;
}
function jh(t) {
  const { series: e, callbackInfo: i, seriesConfig: a } = t, n = (s) => {
    const { type: r, callbackProps: l } = s;
    r === "selection" ? OA(l) : (_e(e, a.visible), s.styleCallback(l));
  }, o = V(e.chart?.uid ?? Number.NaN, "config");
  switch (!0) {
    case e instanceof gr:
    case e instanceof Jt:
      e.events.once(Se.DataValidated, () => n(i));
      break;
    case e instanceof Ft:
      {
        const s = e.root.events.on(Se.FrameEnded, () => {
          e.columns.length === e.dataItems.length && (s.dispose(), n(i));
        });
      }
      break;
    case e instanceof Ae:
      {
        const s = $e(e.uid, "bulletTemplate");
        if (s)
          if (z(o?.series ?? [a]) === b.ScatterSeries) {
            const l = e.root.events.on(Se.FrameEnded, () => {
              s.entities.length === e.data.length && e.dataItems[e.dataItems.length - 1]?.bullets?.[0]?.get("sprite") && (l.dispose(), n(i));
            });
          } else {
            const l = e.root.events.on(Se.FrameEnded, () => {
              const c = cs(e) ?? "", d = o?.series[0]?.x ?? "";
              e.dataItems.filter((f) => {
                const m = f.dataContext;
                return c in m && d in m && m[d] !== void 0;
              }).every(
                (f) => !Number.isFinite(f.dataContext[c]) || f?.bullets?.[0]?.get("sprite")
              ) && (l.dispose(), n(i));
            });
            i.type === "style" && n(i);
          }
      }
      break;
    default:
      n(i);
      break;
  }
}
function DA(t) {
  const { series: e, callbackProps: i, seriesConfig: a } = t;
  jh({
    callbackInfo: { callbackProps: i, type: "selection" },
    series: e,
    seriesConfig: a
  });
}
function Sa(t) {
  const { series: e, styleCallback: i, callbackProps: a, seriesConfig: n } = t;
  jh({
    callbackInfo: { styleCallback: i, callbackProps: a, type: "style" },
    series: e,
    seriesConfig: n
  });
}
function NA(t) {
  let e;
  return t && t.series.length > 0 && (e = t.series.values.map((i) => i.get("visible") !== !1 ? `${i.get("id")}` : "").filter((i) => i !== "")), e;
}
function ed(t) {
  const { series: e, chartConfig: i, isRotated: a } = t, n = ti(i), o = i.series[0];
  switch (n) {
    case Ie.Stacked: {
      e.setAll({
        stacked: !0,
        valueYShow: "valueYWorking",
        valueXShow: "valueXWorking"
      }), e instanceof Ae && e.set(
        "stackToNegative",
        o.stackNegativeValuesToBaseline ?? D.lineSeries.stackNegativeValuesToBaseline
      );
      break;
    }
    case Ie.Stacked100: {
      if (e.setAll({ stacked: !0 }), a === !0) {
        e.setAll({ valueXShow: "valueXTotalPercent" });
        const s = e.chart?.xAxes.getIndex(0);
        s instanceof We && s.set("calculateTotals", !0);
      } else {
        e.setAll({ valueYShow: "valueYTotalPercent" });
        const s = e.chart?.yAxes.getIndex(0);
        s instanceof We && s.set("calculateTotals", !0);
      }
      break;
    }
    case Ie.Side:
    default: {
      e.setAll({
        stacked: !1,
        valueYShow: "valueYWorking",
        valueXShow: "valueXWorking"
      });
      break;
    }
  }
}
function So(t, e) {
  t.set("name", e);
}
function MA(t) {
  const { chart: e, chartType: i, rotated: a, assignToSecondValueAxis: n } = t, o = e.xAxes.getIndex(0), s = e.yAxes.getIndex(0), r = [o, s, e.xAxes.getIndex(1) ?? e.yAxes.getIndex(1)];
  let l, c;
  a !== !0 ? (l = r[0], c = n === !0 && r[2] ? r[2] : r[1]) : (l = n === !0 && r[2] ? r[2] : r[0], c = r[1]);
  const d = i === b.HistogramSeries ? e.xAxes.getIndex(1) : void 0;
  return {
    xAxis: l,
    xAxisForHistogramOverlaySeries: d,
    yAxis: c
  };
}
function ds(t) {
  switch (!0) {
    case t instanceof Ft:
      t.columns.template.setAll({ focusable: !0, hoverOnFocus: !0 }), t.columns.template.set("ariaLabel", _s());
      break;
  }
}
function $A(t, e) {
  let i = !1;
  const a = Eh(t), n = e.series[0];
  if (a && n.type === b.ScatterSeries) {
    const o = a.get("heatRules")?.[0];
    i = o === void 0 && n.sizePolicy !== void 0 || o !== void 0 && n.sizePolicy === void 0 || a.get("valueField") !== n.sizePolicy?.field;
  }
  return i;
}
function PA(t) {
  const { chart: e, chartConfig: i, updateNeededDetails: a, seriesFilteredOut: n } = t;
  let o = !1;
  switch (z(i.series)) {
    case b.BarSeries:
    case b.LineSeries:
    case b.RadarSeries:
    case b.ComboLineAndBarSeries:
    case b.BoxPlotSeries:
      o = n || a?.common.numberOfSeriesChanged === !0 || e.series.length !== i.series.length;
      break;
    case b.ScatterSeries:
      o = $A(e, i);
      break;
  }
  return o;
}
function td(t) {
  const { chartConfig: e, series: i, seriesIndex: a, subtypeInfo: n, fieldList: o } = t, s = e.series[a];
  if (s) {
    const r = H(e.series);
    let l = s.name;
    if (r === L.BarAndLineSplitBy || r === L.BarAndLineSplitByNoAggregation) {
      const c = Ze(s.query?.where);
      l = br({
        subtypeInfo: n,
        fieldList: o,
        fieldName: c,
        fieldValueToMatch: l
      }) ?? l;
    }
    So(i, l);
  }
}
function Gr(t, e) {
  const i = z(e?.series);
  let a, n;
  return e?.series.forEach((o, s) => {
    let r = !1;
    i !== b.BoxPlotSeries || t instanceof bn ? r = t.get("id") === o.id : t instanceof gr ? r = t.get("id")?.replace(`_${ve.Top}`, "") === o.id || t.get("id")?.replace(`_${ve.Median}`, "") === o.id || t.get("id")?.replace(`_${ve.Bottom}`, "") === o.id : t instanceof Ae && (r = t.get("id")?.replace(`_${ve.Outliers}`, "") === o.id), r && (a = o, n = s);
  }), { seriesConfig: a, seriesIndex: n };
}
function RA(t, e) {
  const { chart: i } = e;
  if (i instanceof Te) {
    const a = {
      x: t.get("x") ?? 0,
      y: t.get("y") ?? 0
    }, n = i.plotContainer, o = n.x(), s = n.y(), r = a.x < o || a.x > o + n.width() || a.y < s || a.y > s + n.height();
    t.set("forceHidden", r);
  }
}
function _h(t, e) {
  const i = at((a, n) => {
    n !== void 0 && RA(n, e);
  }, D.debounceTime);
  t.on("x", i), t.on("y", i);
}
function Yr(t, e) {
  let i = e;
  i === void 0 && (i = V(t.uid, "config"));
  const a = V(t.uid, "colorMatchApplied") ?? !1;
  return (i?.colorMatch ?? !1) && a;
}
function Zh(t) {
  const { root: e, intlOptions: i, formatLocale: a, overridePercentMultiplication: n } = t, o = Qi({
    root: e,
    intlOptions: i,
    type: b.NumberAxisFormat,
    formatLocale: a
  });
  return (s) => {
    let r = `${s}`;
    if (o !== void 0 && s !== null && !(s instanceof Date)) {
      let l = typeof s == "number" ? s : Uf(s, o.get("intlLocales"));
      n === !0 && i.style === "percent" && (l /= 100), r = o.format(l);
    } else s instanceof Date && (r = s.toLocaleString(void 0, i));
    return r;
  };
}
function VA(t) {
  const { axis: e, intlOptions: i, overridePercentMultiplication: a, valueAxisFormatter: n } = t, { chart: o, root: s } = e, r = o !== void 0 ? V(o.uid, "formatLocale") : void 0, l = n ?? Zh({
    root: s,
    intlOptions: i,
    formatLocale: r,
    overridePercentMultiplication: a
  });
  return ho(e.uid, {
    numberFormatter: l
  }), l;
}
function EA(t) {
  const { chart: e, formatOptions: i, isNonAggregatedChart: a } = t, { root: n } = e;
  return (s) => {
    let r = s ?? "";
    const l = V(e.uid, "formatLocale"), c = V(e.uid, "config");
    if (typeof s == "number" && i.type === b.NumberAxisFormat)
      r = Zh({
        root: n,
        intlOptions: i.intlOptions,
        formatLocale: l
      })(s);
    else if (a === !0 && i.type === b.DateAxisFormat)
      r = Qi({
        root: n,
        type: b.DateAxisFormat,
        intlOptions: i.intlOptions,
        formatLocale: l
      }).format(r, i.intlOptions);
    else if (i.type === b.CategoryAxisFormat) {
      const d = H(c?.series);
      if ([
        L.BoxPlotMonoField,
        L.BoxPlotMultiFields,
        L.BoxPlotMonoFieldAndSplitBy,
        L.BoxPlotMultiFieldsAndSplitBy,
        L.BarAndLineFromFields
      ].includes(d) && typeof s == "string") {
        const m = V(e.uid, "fieldList");
        s = Ve(m, s);
      }
      const { characterLimit: f } = i;
      r = typeof s != "string" ? s?.toString() ?? "" : s, !be(r) && r !== D.htmlEmptyContent && (r = Yg({ stringToTruncate: r, characterLimit: f }));
    }
    return r.toString();
  };
}
function Hu(t) {
  const { axis: e, valueFormat: i, chartType: a } = t, n = nd({
    isXAxis: !0,
    chartType: a,
    valueFormat: i
  }), o = mi(i) && e instanceof nt, s = Pe(i) && e instanceof We && !(e instanceof nt), r = n && e instanceof jt;
  return !o && !s && !r;
}
function Qh(t) {
  const { dataContext: e, defaultValue: i, chartUID: a } = t;
  let n = $i(e);
  const o = V(a, "config"), s = V(a, "rendererFieldNames"), r = z(o?.series), l = H(o?.series);
  return r === b.BoxPlotSeries && (l === L.BoxPlotMonoField || l === L.BoxPlotMultiFields || l === L.BoxPlotMonoFieldAndSplitBy || l === L.BoxPlotMultiFieldsAndSplitBy) ? n = e?.[jo] : r === b.HistogramSeries ? n = e?.[Ro.Start] : n = Zt({
    value: i ?? "",
    dataContext: e,
    useRendererLabel: Er(o, s)
  }), { labelValue: n, originalLabelValue: $i(e) };
}
function WA(t, e) {
  const { chart: i } = t;
  if (i !== void 0) {
    const a = t.get("renderer").labels.template;
    a.adapters.remove("text"), a.adapters.remove("html");
    const n = e !== void 0 ? "html" : "text";
    a.adapters.add(n, (o, s) => {
      let r = o;
      const l = Ea(t.uid, "labelFormatter");
      if (!Qt(s.uid, "isGuide") && l !== void 0) {
        let d, u;
        switch (!0) {
          case t instanceof nt:
          case t instanceof We:
            d = s.dataItem?._settings?.value;
            break;
          case t instanceof jt:
            {
              const f = s.dataItem?.dataContext, m = Qh({
                dataContext: f,
                defaultValue: o,
                chartUID: i.uid
              });
              d = m.labelValue, u = m.originalLabelValue;
            }
            break;
        }
        d !== void 0 && (r = l(d, u), n === "html" && (r = rt(r)));
      }
      return r;
    }), a.adapters.add(n, (o, s) => {
      let r = o;
      const l = V(i.uid, "config");
      if (!Qt(s.uid, "isGuide") && l !== void 0) {
        const d = l.rotated ?? !1, u = _a(t.get("renderer"), d), f = l.axes?.[u ? 0 : 1], m = {
          type: re.TS,
          ...f?.labels.content,
          text: o
        };
        r = Ht({
          textSymbol: m,
          format: n === "text" ? "amChartsV5" : "html"
        });
      }
      return r;
    }), n === "html" && a.set("html", D.htmlEmptyContent);
  }
}
function zA(t) {
  const { axis: e, isRotated: i, chartConfig: a } = t;
  if (e instanceof jt || e instanceof nt) {
    const n = a.orderOptions?.data?.orderBy === ri.Descending;
    let o = i === !0;
    n && e instanceof nt && (o = !o), e.get("renderer").set("inversed", o);
  }
}
async function HA(t) {
  const {
    axis: e,
    isXAxis: i,
    chartType: a,
    formatOptions: n,
    isNonAggregatedChart: o,
    overridePercentMultiplication: s,
    externalAxisLabelFormatter: r,
    errorStrings: l
  } = t, { chart: c } = e;
  if (c !== void 0) {
    const d = nd({
      isXAxis: i,
      chartType: a,
      valueFormat: n
    }), u = e instanceof We && !(e instanceof nt) && Pe(n), f = e instanceof nt && mi(n), m = e instanceof jt && d;
    if (!(u || f || m))
      await Ga("mismatchAxisAndValueFormat", l);
    else {
      WA(e, r);
      let y = r;
      r === void 0 && (m ? y = EA({
        chart: c,
        formatOptions: n,
        isNonAggregatedChart: o
      }) : u ? y = VA({
        axis: e,
        intlOptions: n.intlOptions,
        overridePercentMultiplication: s,
        valueAxisFormatter: r
      }) : f && sL(e, n)), ho(e.uid, { labelFormatter: y });
    }
  }
}
function qA(t) {
  const {
    chart: e,
    chartConfig: { axes: i, rotated: a, series: n },
    rotationChanged: o,
    axisLabelsBehaviorChanged: s,
    timeIntervalInfoWasReset: r
  } = t, l = z(n), c = a === !0 ? 1 : 0, d = a === !0 ? 0 : 1, u = i?.[c]?.valueFormat, f = i?.[d]?.valueFormat, m = e.xAxes.getIndex(0), g = e.yAxes.getIndex(0), y = m === void 0 || o || u !== void 0 && Hu({
    axis: m,
    valueFormat: u,
    chartType: l
  }), p = g === void 0 || o || f !== void 0 && Hu({ axis: g, valueFormat: f, chartType: l });
  return r || s?.[0] || s?.[1] || y || p;
}
function _a(t, e) {
  return t instanceof li && e !== !0 || t instanceof rn && e === !0 || t instanceof ta;
}
function Xr(t) {
  return t instanceof li;
}
function GA(t) {
  return t instanceof rn;
}
function YA(t) {
  let e = !1;
  if (t !== void 0) {
    const i = V(t.uid, "config");
    if (i !== void 0) {
      const a = Jo({ chartConfig: i }), { stackedMinY: n, stackedMaxY: o } = pb({
        seriesConfig: i.series,
        filteredData: t.series.getIndex(0)?.data.values ?? [],
        filteredSeriesIds: a
      });
      e = n < 0 || o < 0;
    }
  }
  return e;
}
function Kh(t) {
  const { axis: e, isSecondValueAxis: i, data: a } = t, { chart: n } = e;
  let o = !0;
  if (n !== void 0) {
    const s = V(n.uid, "config"), r = V(n.uid, "isRotated");
    if (s !== void 0) {
      const l = _a(e.get("renderer"), r);
      let c = 0;
      l || (c = i === !0 ? 2 : 1);
      const { isLogarithmic: d } = s.axes?.[c] ?? {};
      if (d === !0) {
        const u = Jo({ chartConfig: s, isSecondValueAxis: i }), f = a !== void 0 && "dataItems" in a ? Vi(a) : void 0, { minY: m, maxY: g, minX: y, maxX: p } = xr({
          chartConfig: s,
          chartData: f ?? n.series.getIndex(0)?.data.values ?? [],
          filteredSeriesIds: u
        }), S = l ? y : m, x = l ? p : g;
        Number.isFinite(S) && S !== Number.MAX_SAFE_INTEGER && Number.isFinite(x) && x !== Number.MIN_SAFE_INTEGER && (o = S > 0 && x > 0);
      }
    }
  }
  return o;
}
function XA(t) {
  const { axis: e, isLogarithmic: i, isSecondValueAxis: a } = t;
  (e instanceof nt || e instanceof We) && e.setAll({
    logarithmic: i === !0 && Kh({ axis: e, isSecondValueAxis: a }),
    // zero values could mess up log calculations
    // https://www.amcharts.com/docs/v5/charts/xy-chart/axes/value-axis/#Avoiding_zero_values
    treatZeroAs: i === !0 ? 1e-3 : 0,
    // don't allow decimals in log scale
    maxPrecision: i === !0 ? 0 : void 0
  });
}
function UA(t, e) {
  if (t instanceof We) {
    const { integerOnlyValues: i, valueFormat: a } = e, n = em(a) ? a.intlOptions.maximumFractionDigits : void 0;
    t.set("maxPrecision", i === !0 || n === 0 ? 0 : Number.NaN);
  }
}
function Jh(t, e) {
  const { chart: i } = e, a = Kn.new(t, { forceHidden: !0 });
  return e.set("tooltip", a), a.adapters.add("labelText", (n, o) => {
    let s = n ?? "";
    const r = Ea(e.uid, "labelFormatter");
    if (!o.isHidden() && r && i) {
      const { label: l } = o, c = l.get("text") ?? "";
      if (e instanceof We) {
        const d = Number.parseFloat(c.replace(/,/gu, ""));
        s = r(Number.isNaN(d) ? c : d, n);
      } else if (e instanceof jt) {
        const d = l.dataItem?.dataContext, u = Qh({ dataContext: d, defaultValue: n, chartUID: i.uid });
        s = r(u.labelValue ?? c, n ?? u.originalLabelValue);
      }
    }
    return s;
  }), a;
}
function jA(t) {
  const { root: e, axis: i, displayCursorTooltip: a } = t;
  (i.get("tooltip") ?? Jh(e, i)).set("forceHidden", a !== !0);
}
function _A(t) {
  const { axis: e, timeIntervalInfo: i, dateBaseInterval: a } = t;
  if (e instanceof nt) {
    let { size: n, unit: o } = i ?? {};
    if (o || ({ size: n, unit: o } = a ?? {}), n !== void 0 && o !== void 0) {
      let s;
      switch (o) {
        case Q.Second:
          s = "second";
          break;
        case Q.Minute:
          s = "minute";
          break;
        case Q.Hour:
          s = "hour";
          break;
        case Q.Day:
          s = "day";
          break;
        case Q.Week:
          s = "week";
          break;
        case Q.Month:
          s = "month";
          break;
        case Q.Year:
          s = "year";
          break;
      }
      s !== void 0 && e.set("baseInterval", { timeUnit: s, count: n });
    }
  }
}
function ZA(t, e) {
  let { buffer: i } = e ?? {};
  return i ??= D.buffer, t instanceof We && !(t instanceof nt) && !i;
}
function QA(t, e) {
  let i = !1;
  return t instanceof We && !(t instanceof nt) && (i = ZA(t, e), t.set("strictMinMax", i)), i;
}
function qu(t, e) {
  let i;
  if (!t || t <= 0)
    i = 1;
  else {
    const n = (e ? Math.ceil : Math.floor)(Math.log10(t));
    i = Math.pow(10, n);
  }
  return i;
}
function KA(t) {
  const { axis: e, minimumFromConfig: i, maximumFromConfig: a, data: n, isSecondValueAxis: o } = t;
  let s = i, r = a;
  const { chart: l } = e;
  if (l !== void 0) {
    const c = V(l.uid, "config"), d = c?.rotated;
    if (l instanceof Te && c !== void 0) {
      const u = z(c?.series), f = ti(c), m = _a(e.get("renderer"), d), g = NA(l), y = Jo({ chartConfig: c, isSecondValueAxis: o, seriesIds: g }), p = Vi(n), S = xr({
        chartConfig: c,
        // using either the provided data (at creation or after a data update) or the current series data
        chartData: p ?? l.series.getIndex(0)?.data.values ?? [],
        filteredSeriesIds: y
      }), { minX: x, maxX: C, minY: F, maxY: v } = S, [A, w] = m ? [x ?? Number.NaN, C ?? Number.NaN] : [F, v];
      u === b.BarSeries || u === b.HistogramSeries && !m || u === b.ComboLineAndBarSeries || (u === b.LineSeries || u === b.RadarSeries) && f === Ie.Stacked && !m ? (s = Math.min(A, 0), r = Math.max(w, 0)) : (s = A, r = w);
    }
    s = i ?? s, r = a ?? r;
  }
  return { min: s, max: r };
}
function JA(t) {
  const { axis: e, axisConfig: i, minimumFromConfig: a, maximumFromConfig: n, isLogarithmic: o, chartType: s, data: r, isSecondValueAxis: l } = t;
  if (e instanceof We || e instanceof nt)
    if (QA(e, i)) {
      let d = Number.isNaN(a) ? void 0 : a, u = Number.isNaN(n) ? void 0 : n;
      if (
        // If both the min and max from the config are valid, we directly assign them.
        // Otherwise, if strictMinMax is true, we add some logic to consider the chart's data
        !Number.isFinite(a) || !Number.isFinite(n)
      ) {
        const f = KA({
          axis: e,
          data: r,
          minimumFromConfig: d,
          maximumFromConfig: u,
          isSecondValueAxis: l
        });
        d = !o || Number.isFinite(a) ? f.min : qu(f.min, !1) ?? Number.NaN, u = !o || Number.isFinite(n) ? f.max : qu(f.max, !0) ?? Number.NaN;
      }
      d = d ?? Number.NaN, u = u ?? Number.NaN, Number.isNaN(d) || Number.isNaN(u) || d < u ? e.setAll({ min: d, max: u }) : e.setAll({ min: Number.NaN, max: Number.NaN }), s === b.GaugeSeries && e.markDirty();
    } else
      e.setAll({ min: Number.NaN, max: Number.NaN });
}
function sr(t, e) {
  if (t !== void 0) {
    const i = V(t.uid, "config"), a = ti(i), n = YA(t);
    if (i !== void 0 && (a !== Ie.Stacked100 || n)) {
      const o = z(i?.series), s = t.xAxes.getIndex(0), r = i.axes?.[0], l = i.axes?.[1], c = i.axes?.[2], d = t.yAxes.getIndex(0), u = t.xAxes.getIndex(1) ?? t.yAxes.getIndex(1);
      [
        { axis: s, axisConfig: r },
        { axis: d, axisConfig: l },
        {
          axis: u,
          axisConfig: o === b.HistogramSeries ? r : c,
          isSecondValueAxis: o !== b.HistogramSeries
        }
      ].forEach((f) => {
        const { axis: m, axisConfig: g, isSecondValueAxis: y } = f;
        if (m !== void 0) {
          const {
            minimum: p,
            maximum: S,
            buffer: x,
            isLogarithmic: C
          } = g ?? {};
          JA({
            axis: m,
            axisConfig: g,
            data: e,
            chartType: o,
            minimumFromConfig: p,
            maximumFromConfig: S,
            isLogarithmic: C,
            isSecondValueAxis: y
          });
        }
      });
    } else a === Ie.Stacked100 && (di(i) ? t.xAxes : t.yAxes).each((r) => {
      r instanceof We && r.setAll({ min: 0, max: 100 });
    });
  }
}
function eT(t) {
  t.get("renderer").grid.template.adapters.add("strokeWidth", (e, i) => {
    const a = Ea(
      t.uid,
      "zeroGridLine"
    ), n = a?.displayZeroLine === !0;
    let o = a?.strokeWidth ?? D.lineWidth;
    return i.get("themeTags")?.includes("base") && n && (o = (o === 0 ? 1 : o) * 1.5), o;
  }), t.get("renderer").grid.template.adapters.add("strokeOpacity", (e, i) => {
    const a = Ea(
      t.uid,
      "zeroGridLine"
    ), n = a?.displayZeroLine === !0;
    let o = a?.visible === !0 ? e : 0;
    return i.get("themeTags")?.includes("base") && n && (o = 1), o;
  });
}
function id(t) {
  t.on("visible", () => {
    t.chart instanceof Te && sr(t.chart);
  }), t.events.on(Se.DataValidated, () => {
    t.chart instanceof Te && sr(t.chart);
  });
}
function tT(t) {
  let e = 0;
  return t.dataItems.forEach((i) => {
    const a = i.get("label");
    a !== void 0 && Qt(a.uid, "isGuide") !== !0 && a.getText() !== void 0 && a.height() > e && a.isVisible() && (e = a.height());
  }), e;
}
function Gu(t, e) {
  if (e) {
    const { chart: i } = e;
    if (i) {
      const a = V(i.uid, "isRotated"), n = V(i.uid, "config"), o = z(n?.series), s = [], r = (l, c) => {
        if (l instanceof We) {
          const d = l.get("renderer") instanceof ta;
          s.push({
            isXAxis: _a(l.get("renderer"), a),
            isSecondValueAxis: c === 1 && o !== b.HistogramSeries,
            // histogram have 2 x-axes but it's not what we consider as "second value axis"
            minimum: d ? l.get("min") : l.getPrivate("min"),
            maximum: d ? l.get("max") : l.getPrivate("max")
          });
        }
      };
      i.xAxes.each(r), i.yAxes.each(r), s.length > 0 && s.every((l) => Number.isFinite(l.minimum) && Number.isFinite(l.maximum)) && xm(s, i.root.dom);
    }
  }
}
function ep(t) {
  t.ghostLabel.set("forceHidden", !0);
}
function Yu(t) {
  const { axis: e, start: i, end: a } = t;
  e.zoom(i ?? 0, a ?? 1);
}
function Xu(t) {
  t !== void 0 && t.setAll({ start: 0, end: 1 });
}
function iT(t) {
  t instanceof Te && (t.xAxes.each((e) => Yu({ axis: e })), t.yAxes.each((e) => Yu({ axis: e })), Xu(t.get("scrollbarX")), Xu(t.get("scrollbarY")));
}
function aT(t) {
  const { axis: e, guide: i, guideIndex: a } = t, { root: n, chart: o } = e, s = i.get("axisFill");
  s?.set("tooltip", Kn.new(n, { autoTextColor: !1 }));
  const r = s?.get("tooltip");
  if (r !== void 0 && o !== void 0 && (r.label.setAll({
    oversizedBehavior: "wrap"
  }), r.label.adapters.add(
    "maxWidth",
    () => Math.min(D.tooltipWidth, o.seriesContainer.width())
  ), r.get("background")?.set("fillOpacity", io)), s !== void 0) {
    s.adapters.add("tooltipText", (c, d) => {
      let u = c;
      const { dataItem: f } = d;
      if (!(e.get("renderer") instanceof ta)) {
        const m = Ea(
          e.uid,
          "guideTooltipFormatter"
        );
        if (m !== void 0 && f instanceof Xy) {
          let g, y;
          switch (!0) {
            case e instanceof nt:
            case e instanceof We:
              g = f.get("value"), y = f.get("endValue");
              break;
            case e instanceof jt:
              g = f.get("category"), y = f.get("endCategory");
              break;
          }
          u = m({
            guideName: IF(f.uid, "name") ?? "",
            start: g ?? "",
            end: y,
            // TODO: not pass guideEnd if undefined or null? or let guideTooltipFormatter() handle
            guideIndex: a
          });
        }
      }
      return u ?? "";
    });
    const l = s.getTooltip();
    l && ($h(l), l.adapters.add("x", (c, d) => {
      const { chart: u } = e;
      if (u && d) {
        const f = V(u.uid, "config"), m = V(u.uid, "isRotated");
        if (f) {
          const y = !_a(e.get("renderer"), m) ? 1 : 0, S = f?.axes?.[y]?.guides?.[a];
          if (S) {
            const { tooltipReverseColor: x } = S;
            Ph(d, x);
          }
        }
      }
      return c;
    }));
  }
}
function nT(t, e) {
  return (i) => {
    const { guideName: a, start: n, end: o } = i, { chart: s, root: r } = t;
    let l = "";
    if (s !== void 0) {
      const c = V(s.uid, "config"), d = V(s.uid, "isRotated"), f = !_a(t.get("renderer"), d) ? 1 : 0, g = c?.axes?.[f]?.guides;
      let y = n, p = o;
      if (t instanceof nt) {
        let v;
        if (s !== void 0) {
          const A = V(t.chart?.uid ?? Number.NaN, "formatLocale");
          v = Qi({
            root: t.root,
            type: b.DateAxisFormat,
            // iLocale: chart.language.locale, // TODO: iLocale
            // intlOptions,
            formatLocale: A
          });
          const w = c?.axes?.[0]?.valueFormat?.type === b.DateAxisFormat ? c.axes[0].valueFormat.intlOptions : void 0;
          y = v.format(n, w), o !== void 0 && (p = v.format(o, w));
        }
      } else if (t instanceof We && !(n instanceof Date) && !(o instanceof Date)) {
        const v = g?.find((I) => I.name === a), { start: A, end: w } = tp(t, v);
        Number.isFinite(A) && (y = A), Number.isFinite(w) && (p = w);
        const O = Ea(t.uid, "numberFormatter") ?? ((I) => Mf.new(r, {}).format(I));
        y = O(y), p !== void 0 && (p = O(p));
      } else t instanceof jt && (y = n, p = o);
      const S = y.toString(), x = p?.toString() ?? "";
      !be(x) && S !== x ? l = Gt(e.guideTooltipLabel, {
        guideStart: S,
        guideEnd: x
      }) : l = S;
      const C = V(s.uid, "rtl"), F = ai(C ?? !1);
      l = `${a}${F} ${l}`;
    }
    return l;
  };
}
function oT(t) {
  const { axis: e, guideTooltipFormatter: i, commonStrings: a } = t;
  ho(e.uid, {
    guideTooltipFormatter: i ?? nT(e, a)
  });
}
function Uu(t) {
  const { inputValue: e, axis: i, axisMin: a, axisMax: n } = t;
  let o = e;
  if (e != null)
    switch (!0) {
      case i instanceof nt:
        o = e;
        break;
      case i instanceof jt:
        o = e.toString();
        break;
      case i instanceof We:
        if (typeof e != "number") {
          const s = e.toString().trim(), r = kr(s);
          r !== void 0 ? a !== void 0 && n !== void 0 ? o = r / 100 * (n - a) + a : o = null : o = Number.parseFloat(s);
        }
        break;
    }
  return o;
}
function ad(t, e) {
  return t.axisRanges?.values?.filter((a) => {
    const n = a.get("label"), o = Qt(n?.uid ?? Number.NaN, "isGuide") ?? !1, s = Qt(n?.uid ?? Number.NaN, "isGaugeAxisLabel") ?? !1;
    let r = !1;
    switch (e) {
      case pe.Ticks:
        r = !o;
        break;
      case pe.Guides:
        r = o;
        break;
      case pe.GaugeTicksWithLabels:
        r = s && "value" in a && a.value !== void 0;
        break;
    }
    return r;
  }) ?? [];
}
function sT(t) {
  const { axis: e, guideConfig: i, above: a } = t, n = i !== void 0, o = e.axisRanges.length, s = e.axisRanges.insertIndex(o, e.makeDataItem({ above: a }));
  n && (a === !0 && s.get("axisFill")?.setAll({ layer: D.zIndexes.guide }), YF({ guide: s, axis: e, guideLabelConfig: i?.label }));
  const r = s.get("axisFill");
  r !== void 0 && r.setAll({ disabled: !0, fillOpacity: 1 });
  const l = s.get("grid");
  return l !== void 0 && n && l.set("strokeOpacity", 0), s;
}
function rT(t) {
  const { axis: e, guideIndex: i, guideConfig: a } = t, n = sT({ axis: e, guideConfig: a, above: a?.above });
  aT({ axis: e, guide: n, guideIndex: i });
  const o = n.get("tick"), s = n.get("label"), r = n.get("grid");
  o !== void 0 && o.set("disabled", !0), s !== void 0 && s.set("inside", !0), r !== void 0 && r.set("disabled", !0);
}
function lT(t, e) {
  const a = ad(t, pe.Guides).length, o = (e?.length ?? a) - a;
  for (let s = 0; s < o; s += 1)
    rT({ axis: t, guideIndex: s, guideConfig: e?.[s] });
}
function cT(t, e) {
  const { start: i, end: a } = e;
  let n = i !== null ? i : void 0, o = a !== null ? a : void 0;
  const { chart: s } = t, r = V(s?.uid ?? Number.NaN, "config");
  if (r !== void 0) {
    const l = Tc(r), c = t.data.values, u = c.find(
      (f) => f[D.originalCategoryValue] === i
    )?.[l];
    if ((typeof u == "string" || typeof u == "number" || u instanceof Date) && (n = u), o !== void 0)
      for (let f = c.length - 1; f >= 0; f -= 1) {
        const m = c[f], g = m[l];
        if (m[D.originalCategoryValue] === a && (typeof g == "string" || typeof g == "number" || g instanceof Date)) {
          o = g;
          break;
        }
      }
  }
  return { modifiedStart: n, modifiedEnd: o };
}
function tp(t, e) {
  const { start: i, end: a } = e ?? {};
  let n;
  if (e !== void 0 && i !== void 0 && i !== null) {
    const o = t instanceof We ? t.get("min") : void 0, s = t instanceof We ? t.get("max") : void 0, r = Uu({ inputValue: i, axis: t, axisMin: o, axisMax: s }), l = e.style?.type === re.SFS && a !== null && a !== void 0 ? Uu({ inputValue: a, axis: t, axisMin: o, axisMax: s }) : r;
    n = {
      isValidGuide: r != null && (a === void 0 || l != null),
      start: r,
      end: l
    };
  } else
    n = { isValidGuide: !1, start: void 0, end: void 0 };
  return n;
}
function dT(t) {
  const { axis: e, guide: i, guideConfig: a } = t, { start: n, end: o } = a;
  if (n !== void 0) {
    const { chart: s } = e;
    let r;
    if (e instanceof jt && s instanceof Te && V(s.uid, "isNonAggregatedChart") === !0) {
      const { modifiedStart: l, modifiedEnd: c } = cT(e, a);
      r = { isValidGuide: !0, start: l ?? n, end: c ?? o };
    } else
      r = tp(e, a);
    if (r.isValidGuide) {
      let l, c;
      switch (!0) {
        case e instanceof nt:
        case e instanceof We:
          l = "value", c = "endValue";
          break;
        case e instanceof jt:
          l = "category", c = "endCategory";
          break;
      }
      l !== void 0 && r.start !== void 0 && i.setAll({ [l]: r.start }), c !== void 0 && r.end !== void 0 && i.setAll({ [c]: r.end });
    }
  }
}
function uT(t) {
  const { axis: e, guide: i, guideConfig: a } = t;
  if (i) {
    const n = i.get("axisFill"), o = i.get("label");
    if (a !== void 0) {
      OF(i.uid, { name: a.name }), _e(i, a.visible), dT({ axis: e, guide: i, guideConfig: a }), a.style.type === re.SLS ? Zn({
        element: n,
        fillSymbol: { type: re.SFS, color: a.style?.color, outline: a.style },
        visible: a.visible
      }) : a.style.type === re.SFS && Zn({ element: n, fillSymbol: a.style, visible: a.visible }), XF({ axis: e, guide: i, guideConfig: a, guideType: a.style.type });
      const { chart: s } = e;
    } else
      n !== void 0 && n.set("disabled", !0), o !== void 0 && o.set("disabled", !0);
  }
}
function fT(t) {
  const { axis: e, guideConfigs: i, guideTooltipFormatter: a, commonStrings: n } = t;
  if (i !== void 0) {
    const o = ad(e, pe.Guides);
    i.forEach((s, r) => {
      uT({ axis: e, guide: o[r], guideConfig: s });
    }), oT({ axis: e, guideTooltipFormatter: a, commonStrings: n });
  }
}
function mT(t) {
  const { axis: e, tickOrGuide: i, numberOfElementsToBeDeleted: a } = t, n = [];
  let o = e.axisRanges.length - 1, s = a;
  for (; s > 0 && o >= 0; ) {
    const r = e.axisRanges.getIndex(o);
    r !== void 0 && (Qt(r.get("label")?.uid ?? Number.NaN, "isGuide") ?? !1) === !0 && i === pe.Guides && (n.push(r), s -= 1), o -= 1;
  }
  for (let r = 0; r < n.length; r += 1)
    e.axisRanges.removeValue(n[r]);
}
function ju(t, e) {
  const a = ad(t, pe.Guides).length, n = e?.length ?? 0, o = a - n;
  mT({
    axis: t,
    numberOfElementsToBeDeleted: o,
    tickOrGuide: pe.Guides
  });
}
function gT(t) {
  const { axis: e, guideConfigs: i, anyGuideAboveChanged: a } = t;
  a && ju(e), lT(e, i), fT(t), ju(e, i);
}
function ip(t) {
  return t.getCellWidthPosition() * t.width();
}
function hT(t, e) {
  const i = t.get("renderer");
  if (t !== void 0) {
    let a = Number.NaN;
    if (e === De.Wrap) {
      let n = Number.MAX_SAFE_INTEGER;
      i.labels.each((s) => {
        Qt(s.uid, "isGuide") !== !0 && s.width() > 0 && (n = Math.min(
          n,
          s.innerWidth()
        ));
      });
      const o = t instanceof nt ? t.width() / D.maxNumberOfXAxisLabelsInWrapModeForDateAxis : t.width() / D.maxNumberOfXAxisLabelsInWrapMode;
      a = Math.max(n, o);
    } else if (e === De.Hide) {
      let n = Number.MIN_SAFE_INTEGER;
      i.labels.each((o) => {
        Qt(o.uid, "isGuide") !== !0 && o.width() > 0 && (n = Math.max(
          n,
          o.innerWidth()
        ));
      }), a = n + 2;
    }
    Number.isFinite(a) && a > D.shortestMinGridDistance && i.set("minGridDistance", a);
  }
}
function pT(t) {
  const { axis: e, chartType: i, labelConfig: a, isSecondValueAxis: n, tickSpacing: o } = t;
  let { horizontalAxisLabelsBehavior: s } = t;
  s === void 0 && (s = i !== b.HistogramSeries ? De.Rotate : De.Hide);
  const r = e.get("renderer");
  let l = r.get("minGridDistance");
  if (typeof o == "number" && Number.isFinite(o))
    l = o;
  else if (i !== b.RadarSeries)
    if (r instanceof ta)
      l = D.gauge.gaugeMinGridDistance;
    else if (e instanceof We)
      l = r instanceof li ? D.xAxisMinGridDistance : D.yAxisMinGridDistance;
    else if (r instanceof li)
      if (n === !0)
        l = D.secondRotatedValueAxisMinGridDistance;
      else if (s === De.Rotate) {
        const c = a.content.font?.size ?? D.generalFontSize, d = e instanceof jt ? D.categoryAxisLabelPadding : D.axisLabelPadding;
        l = c * d;
      } else if (s === De.Wrap || s === De.Hide) {
        let c = Ea(
          e.uid,
          "minGridDistanceCallbackDisposer"
        );
        c !== void 0 && c.dispose(), c = e.events.on(Se.BoundsChanged, () => {
          hT(e, s);
        }), ho(e.uid, { minGridDistanceCallbackDisposer: c });
      } else s === De.Stagger ? l = D.staggerMinGridDistance : l = e instanceof jt ? D.xCategoryAxisMinGridDistance : D.xAxisMinGridDistance;
    else
      l = e instanceof jt ? D.yCategoryAxisMinGridDistance : D.yAxisMinGridDistance;
  r.set("minGridDistance", l);
}
function _u(t = 1, e) {
  e.get("renderer").labels.template.set("maxWidth", ip(e) * t);
}
function Zu(t, e = 1) {
  t.get("renderer").labels.template.setAll({
    oversizedBehavior: "wrap",
    paddingLeft: 0.5,
    paddingRight: 0.5,
    textAlign: "center"
  }), t.events.on(Se.BoundsChanged, () => _u(e, t)), _u(e, t);
}
function yT(t) {
  const e = t.get("renderer").labels.template;
  e.adapters.add("rotation", (i, a) => {
    const n = Qt(a.uid, "isGuide") !== !0 ? Ea(t.uid, "rotation") ?? 0 : i ?? 0;
    return e.set("centerX", n === 0 ? Re : ct), n;
  });
}
function Qu(t) {
  if (t?.chart !== void 0) {
    const e = t.get("renderer");
    if (V(t.chart.uid, "config")?.axes?.[0].labels !== void 0 && e.labels.length > 1) {
      const n = e.labels.getIndex(0)?.get("rotation");
      let o = 0;
      e.labels.each((l) => {
        if (Qt(l.uid, "isGuide") !== !0 && l.width() > 0) {
          const c = n === D.rotatedAxisLabel.rotation ? Math.sqrt(l.innerHeight() ** 2 + l.innerWidth() ** 2) : l.innerWidth();
          c > o && (o = c);
        }
      });
      const r = ip(t) >= o + 5;
      if (!r && n === 0 || r && n === D.rotatedAxisLabel.rotation) {
        const l = r ? D.axisLabel.rotation : D.rotatedAxisLabel.rotation;
        e.labels.template.setAll({
          rotation: l,
          centerX: r ? Re : ct,
          centerY: St,
          paddingTop: r ? D.axisLabel.paddingTop : D.rotatedAxisLabel.paddingTop,
          paddingLeft: r ? D.axisLabel.paddingLeft : D.rotatedAxisLabel.paddingLeft,
          paddingRight: r ? D.axisLabel.paddingRight : D.rotatedAxisLabel.paddingRight
        }), ho(t.uid, { rotation: l });
      }
    }
  }
}
function Ku(t) {
  const e = t.get("renderer");
  yT(t), e.labels.template.setAll({ oversizedBehavior: "hide" }), t.events.on(Se.BoundsChanged, () => Qu(t)), Qu();
}
function Ju(t) {
  if (t && V(t.chart?.uid ?? Number.NaN, "config")?.axes?.[0].labels?.visible !== !1) {
    let a = 0;
    t.dataItems.forEach((n, o) => {
      const s = n.get("label");
      s !== void 0 && Qt(s.uid, "isGuide") !== !0 && s.getText() !== void 0 && s.width() > 0 && o % 2 === 0 && s.innerHeight() > a && (a = s.innerHeight());
    }), a = Math.round(a), a > 0 && (t.dataItems.filter((n) => {
      const o = n.get("tick"), s = n.get("label");
      return o !== void 0 && s !== void 0 && Qt(s.uid, "isGuide") !== !0 && s.getText() !== void 0 && s.width() > 0;
    }).forEach((n, o) => {
      const s = n.get("tick"), r = n.get("label"), l = o % 2 === 1;
      s && s.set("length", l ? a + 5 : D.axisTickLength), r && r.set("dy", l ? a : 0);
    }), a && t.get("renderer").labels.template.get("paddingBottom") !== a + 5 && t.get("renderer").labels.template.set("paddingBottom", a + 5));
  }
}
function bT(t) {
  t.get("renderer").labels.template.set("oversizedBehavior", "wrap"), t.events.on(Se.BoundsChanged, () => Ju(t)), Ju(t);
}
function ST(t) {
  t.get("renderer").labels.template.setAll({
    oversizedBehavior: "wrap",
    maxWidth: D.yAxisLabelMaxWidth,
    textAlign: "end"
  });
}
function xT(t) {
  const {
    axis: e,
    horizontalAxisLabelsBehavior: i,
    verticalAxisLabelsBehavior: a,
    axisLabelsBehaviorChanged: n,
    labelConfig: o,
    chartType: s
  } = t, r = e.get("renderer");
  if (!(r instanceof ta))
    if (Xr(r) && n?.[0] === !0)
      switch (s === b.HistogramSeries && i === void 0 ? De.Hide : i) {
        case De.Hide:
          break;
        case De.Stagger:
          bT(e), Zu(e, 1.5);
          break;
        case De.Wrap:
          Zu(e);
          break;
        case De.Rotate:
          Ku(e);
          break;
        default:
          o.content.angle !== null && o.content.angle === void 0 && Ku(e);
          break;
      }
    else GA(r) && a !== De.Hide && ST(e);
}
function CT(t) {
  const { renderer: e, axisConfig: i, labelConfig: a } = t;
  switch (i.labelsOrientation) {
    case Pd.Horizontal:
      e.labels.template.setAll({ textType: "adjusted" }), e.labels.template.remove("radius");
      break;
    case Pd.Radial:
      e.labels.template.setAll({ textType: "radial", radius: 35 }), a.content.verticalAlignment = ce.Middle;
      break;
    default:
      e.labels.template.setAll({ textType: "circular" }), e.labels.template.remove("radius");
  }
}
function vT(t) {
  const {
    axis: e,
    axisConfig: { labels: i },
    horizontalAxisLabelsBehavior: a,
    verticalAxisLabelsBehavior: n,
    axisLabelsBehaviorChanged: o,
    chartType: s
  } = t, r = { ...i }, l = e.get("renderer"), c = l?.get("opposite");
  Xr(l) ? (r.content.horizontalAlignment = he.Center, r.content.verticalAlignment = c ? ce.Bottom : ce.Top) : (r.content.horizontalAlignment = c ? he.Left : he.Right, r.content.verticalAlignment = ce.Middle), l instanceof ta ? CT({ renderer: l, axisConfig: t.axisConfig, labelConfig: i }) : r.content.angle = r.content.angle ?? l.labels.template.get("rotation"), Zi({
    label: l.labels.template,
    labelConfig: r
  }), xT({
    axis: e,
    horizontalAxisLabelsBehavior: a,
    verticalAxisLabelsBehavior: n,
    labelConfig: i,
    axisLabelsBehaviorChanged: o,
    chartType: s
  });
}
function FT(t) {
  const { axis: e, isHorizontalAxis: i, label: a } = t, { chart: n } = e;
  if (n) {
    const o = i ? "width" : "height", s = i ? ue.XAxisTitle : ue.YAxisTitle;
    ua({ chart: n, label: a, labelType: s }), e.onPrivate(
      o,
      at(() => ua({ chart: n, label: a, labelType: s }), D.debounceTime)
    );
  }
}
function Ho(t) {
  const { value: e, axisMin: i, axisMax: a } = t;
  let n = Number.NaN;
  const o = a - i;
  return o !== 0 && (n = (e - i) / o), n;
}
function Gl(t) {
  return t != null && t !== 0;
}
function ap(t) {
  const {
    minimum: e,
    maximum: i,
    labelsIncrement: a,
    minimumValueConversion: n,
    maximumValueConversion: o
  } = t;
  let s = e ?? k.gauge.axisMinimum, r = i ?? k.gauge.axisMaximum;
  s = Ks(s, n), r = Ks(r, o);
  const l = Gl(a);
  let c = Gl(a) ? a : Math.abs(r - s) / k.gauge.numberOfLabelIntervals, d = l ? Math.round(Math.abs(r - s) / c) : k.gauge.numberOfLabelIntervals;
  if (l)
    if (d > k.gauge.maximumNumberOfLabelIntervals)
      c = Math.abs(r - s), d = 1;
    else {
      const u = s + d * c;
      u < r ? (d += 1, r = s + d * c) : u > r && (r = u);
    }
  return {
    min: s,
    max: r,
    labelsIncrement: c,
    numberOfIntervals: d
  };
}
function np(t) {
  const { axisConfig: e, axisMin: i, axisMax: a } = t;
  typeof i == "number" && typeof a == "number" && a - i !== 0 && e.guides?.forEach((o) => {
    const { start: s, end: r } = o;
    typeof s == "number" && (o.start = Ho({ value: s, axisMin: i, axisMax: a })), typeof r == "number" && (o.end = Ho({ value: r, axisMin: i, axisMax: a }));
  });
}
function LT(t) {
  const { featureIndex: e, chartData: i, chartConfig: a } = t, { minimumFromField: n, maximumFromField: o } = a?.axes?.[0] ?? {};
  let s, r;
  if (e >= 0 && e < i.length) {
    const l = i[e];
    typeof n == "string" && !be(n) && Number.isFinite(l[n]) && (s = l[n]), typeof o == "string" && !be(o) && Number.isFinite(l[o]) && (r = l[o]);
  }
  return { minimumFromData: s, maximumFromData: r };
}
function AT(t) {
  const { featureIndex: e, chartData: i, x: a } = t;
  let n = -1;
  if (e >= 0 && e < i.length) {
    const o = i[e];
    a !== void 0 && !be(a) && Number.isFinite(o[a]) && (n = o[a]);
  }
  return n;
}
async function op(t) {
  const { featureIndex: e = 0, chartData: i, queryConfig: a, chartConfig: n, queryObject: o } = t, { axes: s, series: r } = n, l = _o(n), { minimum: c, maximum: d } = s?.[0] ?? {}, { x: u } = r?.[0] ?? {}, f = k.gauge;
  let m, g;
  l ? { minimumFromData: m, maximumFromData: g } = LT({
    featureIndex: e,
    chartData: i,
    chartConfig: n
  }) : o !== void 0 && a !== void 0 && ({ minimumFromData: m, maximumFromData: g } = await Yv({
    queryObject: o,
    chartConfig: n,
    queryConfig: a
  }));
  const y = m ?? c ?? f.axisMinimum, p = g ?? d ?? f.axisMaximum, S = AT({ chartData: i, featureIndex: e, x: u });
  return { minimum: y, maximum: p, dataValue: S };
}
function TT(t) {
  const { oldConfig: e, axisMax: i, min: a, max: n, labelsIncrement: o, numberOfIntervals: s, valueFormat: r, minimumFromField: l } = t, c = ao(r);
  let d = !0;
  if (e !== void 0) {
    const {
      minimum: u,
      minimumFromField: f,
      labelsIncrement: m,
      valueFormat: g
    } = e.axes[0], y = g?.intlOptions?.style !== r?.intlOptions?.style, p = Gl(m) ? m !== o : s !== k.gauge.numberOfLabelIntervals;
    d = y || a !== u || l !== f || !c && n !== i || p;
  }
  return d;
}
function wT(t) {
  const { x: e, data: i, chart: a, valueFormat: n, minimum: o, maximum: s } = t;
  let r = Number.NaN;
  if (i !== void 0 && e !== void 0) {
    const l = i.find((d) => e in d), c = Number.parseFloat(l[e]);
    Number.isFinite(c) && (r = c, Le(a.uid, { gaugeData: r }));
  } else {
    const l = V(a.uid, "gaugeData");
    Number.isFinite(l) && (r = l);
  }
  return ao(n) && o !== void 0 && s !== void 0 && o !== null && s !== null && r !== null && s - o !== 0 && (r = Ho({
    value: r,
    axisMin: o,
    axisMax: s
  })), r;
}
function kT(t, e) {
  let i = e ?? null;
  if (e != null) {
    const a = t.xAxes.getIndex(0), n = V(t.uid, "config"), o = a.get("min") ?? n?.axes?.[0].minimum ?? D.gauge.axisMinimum, s = a.get("max") ?? n?.axes?.[0].maximum ?? D.gauge.axisMaximum;
    e < o ? i = o : e > s && (i = s);
  }
  return i ?? void 0;
}
function IT(t) {
  const { root: e } = t, i = Ol.new(e, {
    radius: Ni(100)
  }), a = t.makeDataItem({
    value: 0,
    bullet: Ky.new(e, {
      sprite: i
    })
  });
  return t.createAxisRange(a), a.get("grid")?.set("visible", !1), a.get("tick")?.set("visible", !1), i;
}
function OT(t) {
  const { chart: e, axis: i, needleConfig: a, gaugeValue: n } = t, o = i.axisRanges.values.find(
    (r) => r.get("bullet")?.get("sprite") instanceof Ol
  ), s = o?.get("bullet")?.get("sprite");
  if (o && s instanceof Ol) {
    const { startWidth: r, endWidth: l, innerRadius: c } = D.gaugeNeedle;
    Zn({ element: s.hand, fillSymbol: a?.symbol }), Zn({ element: s.pin, fillSymbol: a?.symbol }), o.set("value", kT(e, n)), s.pin.set("visible", a?.displayPin === !0), s.setAll({
      visible: a?.visible ?? !0,
      innerRadius: Ni(a?.innerRadius ?? c),
      bottomWidth: a?.startWidth ?? r,
      topWidth: a?.endWidth ?? l
    });
  }
}
function BT(t, e) {
  const i = Number.isFinite(e?.innerRadius) ? e?.innerRadius : D.gauge.innerRadius;
  typeof i == "number" && Number.isFinite(i) && t.set("innerRadius", Ni(i));
}
function DT(t, e) {
  const i = Number.isFinite(e?.startAngle) ? e?.startAngle : D.gauge.startAngle, a = Number.isFinite(e?.endAngle) ? e?.endAngle : D.gauge.endAngle;
  typeof i == "number" && Number.isFinite(i) && t.set("startAngle", i), typeof a == "number" && Number.isFinite(a) && t.set("endAngle", a);
}
async function NT(t) {
  const { chart: e, chartConfig: i, data: a, queryObject: n, xAxisLabelFormatter: o, commonStrings: s, errorStrings: r } = t, { axes: l, series: c } = i, d = _o(i), { featureIndex: u, x: f } = c[0], m = l?.[0], g = e.xAxes.getIndex(0), y = { ...m };
  if (g instanceof We && g.get("renderer") instanceof ta && y !== void 0 && a && "dataItems" in a) {
    const { valueFormat: p, needle: S } = y;
    BT(e, i), DT(e, i);
    const x = await op({
      featureIndex: u,
      chartData: a.dataItems,
      chartConfig: i,
      queryObject: n,
      queryConfig: V(e.uid, "queryConfig")
    });
    y.minimum = x.minimum, y.maximum = x.maximum;
    const { min: C, max: F } = ap(y), v = { ...y };
    ao(p) ? (v.minimum = 0, v.maximum = 1, np({
      axisConfig: v,
      axisMin: y.minimum,
      axisMax: y.maximum
    })) : (v.minimum = C, v.maximum = F), await od({
      chartConfig: i,
      axis: g,
      axisConfig: v,
      externalAxisLabelFormatter: o,
      commonStrings: s,
      errorStrings: r
    });
    const A = d ? x?.dataValue : wT({
      x: f,
      data: a.dataItems,
      chart: e,
      minimum: y.minimum,
      maximum: y.maximum,
      valueFormat: p
    });
    OT({
      chart: e,
      axis: g,
      needleConfig: S,
      gaugeValue: A
    });
  }
}
async function MT(t) {
  const { chart: e, axesConfig: i, errorStrings: a } = t, { root: n } = e;
  await Xa({ chartType: b.GaugeSeries, axesConfig: i, errorStrings: a });
  const o = e.xAxes.push(
    We.new(n, {
      min: 0,
      max: 100,
      renderer: ta.new(n, {})
    })
  );
  IT(o), ep(o);
}
async function $T(t) {
  const {
    chart: e,
    chartConfig: i,
    axisLabelsBehaviorChanged: a,
    data: n,
    yAxisLabelFormatter: o,
    guideTooltipFormatter: s,
    commonStrings: r,
    errorStrings: l
  } = t, { horizontalAxisLabelsBehavior: c, verticalAxisLabelsBehavior: d, axes: u } = i, f = b.HistogramSeries, m = e.xAxes.getIndex(0), g = e.yAxes.getIndex(0);
  await Xa({
    chartType: f,
    axesConfig: u,
    errorStrings: l
  }), [
    { axis: m, axisConfig: u?.[0] },
    { axis: g, axisConfig: u?.[1] }
  ].forEach(async (y) => {
    const { axis: p, axisConfig: S } = y;
    p !== void 0 && S !== void 0 && await od({
      axis: p,
      data: n,
      axisConfig: S,
      horizontalAxisLabelsBehavior: c,
      verticalAxisLabelsBehavior: d,
      axisLabelsBehaviorChanged: a,
      commonStrings: r,
      chartConfig: i,
      externalAxisLabelFormatter: o,
      guideTooltipFormatter: s,
      errorStrings: l
    });
  }), sr(e, n);
}
async function PT(t) {
  const { chart: e, axesConfig: i, x: a, errorStrings: n } = t, { root: o } = e, s = b.HistogramSeries;
  await Xa({ chartType: s, axesConfig: i, errorStrings: n });
  const r = { root: o, x: a, chartType: s }, l = i?.[0]?.valueFormat, c = i?.[1]?.valueFormat;
  if (l !== void 0 && c !== void 0) {
    const d = Na({
      ...r,
      axes: e.xAxes,
      valueFormat: l,
      axisRenderer: li.new(o, {}),
      isXAxis: !0,
      x: a
    }), u = Na({
      ...r,
      axes: e.xAxes,
      valueFormat: l,
      axisRenderer: li.new(o, {}),
      isAxisForHistogramOverlaySeries: !0,
      isXAxis: !0,
      x: a
    });
    Na({
      ...r,
      axes: e.yAxes,
      valueFormat: c,
      axisRenderer: rn.new(o, {}),
      isXAxis: !1,
      x: a
    }), d && (d.get("renderer").grid.template.set("location", 0), d.get("renderer").ticks.template.set("location", 0), d.get("renderer").labels.template.set("location", 0)), u && (u.set("visible", !1), u.get("renderer").grid.template.set("visible", !1), u.get("renderer").ticks.template.set("visible", !1), u.get("renderer").labels.template.set("visible", !1));
  }
}
function nd(t) {
  const { isXAxis: e, chartType: i, valueFormat: a, isAxisForHistogramOverlaySeries: n } = t;
  return e && (Ya(a) || i === b.HistogramSeries && !n || i === b.BarSeries && Pe(a));
}
function sp(t, e) {
  return e ? `${$u}_x_${t.uid}` : `${$u}_y_${t.uid}`;
}
function rp(t, e) {
  const i = V(t.chart?.uid ?? Number.NaN, "config"), a = di(i) ? 1 : 0, n = i?.axes?.[a]?.title?.content?.verticalAlignment, o = tT(t);
  let s = o;
  switch (n) {
    case ce.Baseline:
    case ce.Middle:
      s = o / 2;
      break;
    case ce.Bottom:
      s = Math.min(o, 0);
      break;
    case ce.Top:
  }
  e?.set("dy", s);
}
function RT(t) {
  t instanceof We && (t.onPrivate("min", Gu), t.onPrivate("max", Gu));
}
function VT(t) {
  const { axis: e, isHorizontalAxis: i, isSecondValueAxis: a } = t, { root: n } = e, o = i ? { ...D.xAxisTitleLabel, verticalCenter: ce.Top } : D.yAxisTitleLabel, s = Wo({ root: n, id: sp(e, i), defaults: o });
  return e.get("renderer") instanceof rn && a !== !0 || e.get("renderer") instanceof li && a === !0 ? e.children.unshift(s) : e.children.push(s), i && a !== !0 && e.events.on(
    Se.BoundsChanged,
    at(() => {
      rp(e, s);
    }, D.debounceTime)
  ), FT({ axis: e, isHorizontalAxis: i, label: s }), s;
}
function Na(t) {
  const {
    root: e,
    axes: i,
    isXAxis: a,
    valueFormat: n,
    axisRenderer: o,
    isSecondValueAxis: s = !1,
    chartType: r,
    x: l,
    isAxisForHistogramOverlaySeries: c
  } = t;
  let d;
  if (nd({ isXAxis: a, chartType: r, valueFormat: n, isAxisForHistogramOverlaySeries: c }) && !s) {
    let u = D.xAxisField;
    r === b.HistogramSeries ? u = Ro.Start : r === b.BoxPlotSeries && (u = l), d = i.push(jt.new(e, { categoryField: u, renderer: o }));
  } else if (mi(n))
    d = i.push(nt.new(e, { strictMinMax: !0, baseInterval: { timeUnit: "day", count: 1 }, renderer: o }));
  else if (Pe(n) && (d = i.push(We.new(e, { strictMinMax: !0, renderer: o })), s && d instanceof We)) {
    const u = i.getIndex(0);
    u instanceof We && d.set("syncWithAxis", u);
  }
  if (d !== void 0 && !c) {
    eT(d), Jh(e, d);
    const u = r === b.HistogramSeries ? 0 : 0.1, f = r === b.HistogramSeries ? 1 : 0.9;
    d.get("renderer").setAll({ cellStartLocation: u, cellEndLocation: f }), ep(d), RT(d), Xr(d.get("renderer")) ? d.get("renderer").labels.template.set(
      s ? "paddingBottom" : "paddingTop",
      D.axisLabelSpacing.horizontalAxisLabelPaddingTop
    ) : o instanceof rn && d.get("renderer").labels.template.set(
      s ? "paddingLeft" : "paddingRight",
      D.axisLabelSpacing.verticalAxisLabelSidePadding
    );
  }
  return d;
}
function ET(t, e) {
  if (e !== void 0) {
    const i = Vi(e);
    t.data.setAll(i ?? []);
  }
}
function WT(t) {
  const { axis: e, axisTitleConfig: i, isSecondValueAxis: a } = t, n = e.get("renderer"), { chart: o } = e, s = Xr(n), r = Ye({ childId: sp(e, s), parent: e, useChildId: !0 }) ?? VT({ axis: e, isHorizontalAxis: s, isSecondValueAxis: a });
  if (r instanceof Pa) {
    const l = s ? { ...D.xAxisTitleLabel, verticalCenter: ce.Top } : D.yAxisTitleLabel;
    if (Zi({ label: r, labelConfig: i, defaults: l }), s && a !== !0 && rp(e, r), o) {
      const c = { chart: o, label: r, labelType: s ? ue.XAxisTitle : ue.YAxisTitle };
      ua(c);
    }
  }
}
async function od(t) {
  const {
    axis: e,
    data: i,
    axisConfig: a,
    timeIntervalInfo: n,
    horizontalAxisLabelsBehavior: o,
    verticalAxisLabelsBehavior: s,
    axisLabelsBehaviorChanged: r,
    anyGuideAboveChanged: l,
    isNonAggregatedChart: c,
    isSecondValueAxis: d,
    chartConfig: u,
    externalAxisLabelFormatter: f,
    guideTooltipFormatter: m,
    commonStrings: g,
    errorStrings: y
  } = t, {
    visible: p,
    lineSymbol: S,
    title: x,
    labels: C,
    isLogarithmic: F,
    grid: v,
    displayCursorTooltip: A,
    displayZeroLine: w,
    valueFormat: O,
    guides: I,
    tickSpacing: N,
    dateBaseInterval: M
  } = a, { root: P } = e, R = z(u.series), $ = ti(u), W = u.rotated, U = e.get("renderer");
  ho(e.uid, {
    zeroGridLine: { displayZeroLine: w, strokeWidth: v?.width ?? D.lineWidth, visible: v !== void 0 }
  }), XA({ axis: e, isLogarithmic: F, isSecondValueAxis: d }), await HA({
    axis: e,
    isXAxis: _a(e.get("renderer"), W),
    chartType: R,
    formatOptions: O,
    isNonAggregatedChart: c,
    overridePercentMultiplication: $ === Ie.Stacked100,
    externalAxisLabelFormatter: f,
    errorStrings: y
  }), zA({ axis: e, isRotated: W, chartConfig: u }), _A({ axis: e, timeIntervalInfo: n, dateBaseInterval: M }), ra({
    element: U,
    lineSymbol: { color: [...D.color], ...S ?? Cr() },
    visible: p
  }), ra({ element: U.ticks.template, lineSymbol: S, visible: p }), ra({ element: U.grid.template, lineSymbol: v, visible: p }), v === void 0 && (e.get("renderer").grid.template.set("strokeWidth", D.lineWidth), e.markDirtyValues()), vT({
    axis: e,
    axisConfig: a,
    chartType: R,
    horizontalAxisLabelsBehavior: o,
    verticalAxisLabelsBehavior: s,
    axisLabelsBehaviorChanged: r
  }), WT({ axis: e, axisTitleConfig: x, isSecondValueAxis: d }), UA(e, a), pT({
    axis: e,
    chartType: R,
    labelConfig: C,
    horizontalAxisLabelsBehavior: o,
    isSecondValueAxis: d,
    tickSpacing: N
  }), jA({ root: P, axis: e, displayCursorTooltip: A }), gT({ axis: e, guideConfigs: I, guideTooltipFormatter: m, anyGuideAboveChanged: l, commonStrings: g }), ET(e, i);
}
async function zT(t) {
  const { chart: e, chartType: i, axesConfig: a, x: n, isRotated: o, errorStrings: s } = t, { root: r } = e;
  await Xa({ chartType: i, axesConfig: a, errorStrings: s });
  const l = { root: r, x: n, chartType: i }, c = o === !0 ? a?.[1] : a?.[0], d = o === !0 ? a?.[0] : a?.[1], u = c?.valueFormat, f = d?.valueFormat;
  if (u !== void 0 && f !== void 0 && (Na({
    ...l,
    axes: e.xAxes,
    valueFormat: u,
    axisRenderer: li.new(r, {}),
    isXAxis: o !== !0,
    x: n
  }), Na({
    ...l,
    axes: e.yAxes,
    valueFormat: f,
    axisRenderer: rn.new(r, {}),
    isXAxis: o === !0,
    x: n
  }), a?.[2] !== void 0)) {
    const m = o === !0 ? li : rn;
    Na({
      ...l,
      axes: o === !0 ? e.xAxes : e.yAxes,
      valueFormat: a[2]?.valueFormat,
      axisRenderer: m.new(r, { opposite: !0 }),
      isSecondValueAxis: !0,
      isXAxis: o === !0,
      x: n
    });
  }
}
async function HT(t) {
  const { chart: e, chartType: i, axesConfig: a, x: n, errorStrings: o } = t, { root: s } = e, r = a?.[0], l = a?.[1];
  if (await Xa({ chartType: i, axesConfig: a, errorStrings: o }), r?.valueFormat !== void 0 && l?.valueFormat !== void 0) {
    const c = { root: s, x: n, chartType: i };
    Na({
      ...c,
      axes: e.xAxes,
      valueFormat: r.valueFormat,
      axisRenderer: ta.new(s, {}),
      isXAxis: !0,
      x: n
    }), Na({
      ...c,
      axes: e.yAxes,
      valueFormat: l.valueFormat,
      axisRenderer: Qy.new(s, {}),
      isXAxis: !1,
      x: n
    });
  }
}
async function lp(t) {
  const { chart: e, chartConfig: i, errorStrings: a } = t, { rotated: n, axes: o } = i, { x: s } = i.series[0], r = z(i.series);
  switch (e.xAxes.clear(), e.yAxes.clear(), r) {
    case b.GaugeSeries:
      e instanceof Ra && await MT({ chart: e, axesConfig: o, errorStrings: a });
      break;
    case b.HistogramSeries:
      await PT({ chart: e, axesConfig: o, x: s, errorStrings: a });
      break;
    case b.BarSeries:
    case b.ComboLineAndBarSeries:
    case b.ScatterSeries:
    case b.LineSeries:
    case b.BoxPlotSeries:
      await zT({ chart: e, axesConfig: o, chartType: r, x: s, isRotated: n, errorStrings: a });
      break;
    case b.RadarSeries:
      e instanceof Ra && await HT({ chart: e, axesConfig: o, chartType: r, x: s, errorStrings: a });
      break;
  }
}
async function qT(t) {
  const {
    chart: e,
    chartConfig: i,
    axisLabelsBehaviorChanged: a,
    anyGuideAboveChanged: n,
    data: o,
    timeIntervalInfo: s,
    xAxisLabelFormatter: r,
    yAxisLabelFormatter: l,
    secondaryYAxisLabelFormatter: c,
    guideTooltipFormatter: d,
    commonStrings: u,
    errorStrings: f
  } = t, {
    horizontalAxisLabelsBehavior: m,
    verticalAxisLabelsBehavior: g,
    axes: y,
    rotated: p
  } = i, S = z(i.series), x = V(e.uid, "isNonAggregatedChart"), C = e.xAxes.getIndex(0), F = e.yAxes.getIndex(0), v = e.xAxes.getIndex(1) ?? e.yAxes.getIndex(1);
  await Xa({ chartType: S, axesConfig: y, errorStrings: f });
  const A = y?.[p === !0 ? 1 : 0], w = y?.[p === !0 ? 0 : 1];
  [
    {
      axis: C,
      axisConfig: A,
      externalAxisLabelFormatter: p !== !0 ? r : l
    },
    {
      axis: F,
      axisConfig: w,
      externalAxisLabelFormatter: p !== !0 ? l : r
    },
    {
      axis: v,
      axisConfig: y?.[2],
      axisLabelFormatter: c,
      isSecondValueAxis: !0
    }
  ].forEach(async (O) => {
    const { axis: I, axisConfig: N, externalAxisLabelFormatter: M, isSecondValueAxis: P } = O;
    I !== void 0 && !I.isDisposed() && N !== void 0 && await od({
      axis: I,
      data: o,
      timeIntervalInfo: s,
      axisConfig: N,
      horizontalAxisLabelsBehavior: m,
      verticalAxisLabelsBehavior: g,
      axisLabelsBehaviorChanged: a,
      anyGuideAboveChanged: n,
      isNonAggregatedChart: x,
      isSecondValueAxis: P,
      commonStrings: u,
      chartConfig: i,
      externalAxisLabelFormatter: M,
      guideTooltipFormatter: d,
      errorStrings: f
    });
  }), sr(e, o);
}
async function cp(t) {
  const { chart: e, chartConfig: i } = t, a = z(i.series);
  a === b.GaugeSeries && e instanceof Ra ? await NT(t) : a === b.HistogramSeries ? await $T(t) : await qT(t);
}
function GT(t, e) {
  const i = je(D.backgroundColor);
  e.set(
    "background",
    nc.new(t, {
      fill: i.color,
      fillOpacity: i.opacity
    })
  );
}
function dp(t, e) {
  const i = je(e ?? D.backgroundColor);
  t.get("background")?.setAll({ fill: i.color, fillOpacity: i.opacity });
}
const Ce = {
  SelectXY: "selectXY",
  SelectX: "selectX",
  SelectY: "selectY",
  ZoomXY: "zoomXY",
  ZoomX: "zoomX",
  ZoomY: "zoomY",
  None: "none"
};
function up(t) {
  const { actionMode: e, cursorRange: i, isRotated: a } = t;
  let n = Ce.None;
  switch (i) {
    case dl.MultiAxes:
      e === ne.MultiSelectionWithCtrlKey || e === ne.MultiSelection ? n = Ce.SelectXY : e === ne.Zoom && (n = Ce.ZoomXY);
      break;
    case dl.XAxis:
      e === ne.MultiSelectionWithCtrlKey || e === ne.MultiSelection ? n = a === !0 ? Ce.SelectY : Ce.SelectX : e === ne.Zoom && (n = a === !0 ? Ce.ZoomY : Ce.ZoomX);
      break;
    case dl.YAxis:
      e === ne.MultiSelectionWithCtrlKey || e === ne.MultiSelection ? n = a === !0 ? Ce.SelectX : Ce.SelectY : e === ne.Zoom && (n = a === !0 ? Ce.ZoomX : Ce.ZoomY);
      break;
  }
  return n;
}
function fp(t, e) {
  const i = z(e.series);
  return t instanceof Te && i !== b.GaugeSeries;
}
function YT(t, e) {
  const i = D.cursorCrosshair.style, a = {
    type: re.SLS,
    style: e?.style ?? i.style,
    color: e?.color ?? i.color,
    width: e?.width ?? i.width
  }, n = t.get("cursor")?.lineX, o = t.get("cursor")?.lineY;
  ra({ element: n, lineSymbol: a }), ra({ element: o, lineSymbol: a });
}
function mp(t) {
  const { root: e, chart: i, config: a } = t;
  let n;
  if (fp(i, a)) {
    const o = i instanceof Ra ? Pf : Rf;
    n = i.set("cursor", o.new(e, {}));
  }
  return n;
}
function gp(t) {
  const { root: e, chart: i, cursorCrosshair: a, config: n } = t;
  if (fp(i, n)) {
    const o = i.get("cursor") ?? mp({ root: e, chart: i, config: n });
    o && (YT(i, a?.style), o.lineX.set(
      "visible",
      a?.verticalLineVisible ?? D.cursorCrosshair.verticalLineVisible
    ), o.lineY.set(
      "visible",
      a?.horizontalLineVisible ?? D.cursorCrosshair.horizontalLineVisible
    ));
  }
}
function XT(t) {
  const { chart: e, enabled: i } = t, a = i ? "pointer" : "default";
  e instanceof Wn && e.series.each((n) => {
    switch (!0) {
      case n instanceof Ft:
        n.columns.template.set("cursorOverStyle", a);
        break;
      case n instanceof Ae:
        const o = $e(n.uid, "bulletTemplate");
        o !== void 0 && !ya(n) && o.set("cursorOverStyle", a);
        break;
      case n instanceof Jt:
        n.slices.template.setAll({ cursorOverStyle: a });
        break;
    }
  });
}
function UT(t) {
  const { chart: e, actionMode: i, cursorRange: a } = t, n = V(e.uid, "isRotated"), o = V(e.uid, "config"), s = z(o?.series), r = s === b.ScatterSeries, l = (s === b.LineSeries || s === b.RadarSeries) && Pe(o?.axes?.[0]?.valueFormat), c = (s === b.LineSeries || s === b.RadarSeries) && Ya(o?.axes?.[0]?.valueFormat), d = (s === b.LineSeries || s === b.RadarSeries) && mi(o?.axes?.[0]?.valueFormat);
  let u, f = !1;
  const m = i ?? V(e.uid, "actionMode") ?? D.actionMode;
  if (V(e.uid, "filterBySelection") === !0)
    u = Ce.None, f = !1;
  else if (a !== void 0)
    u = up({ actionMode: m, cursorRange: a, isRotated: n });
  else
    switch (m) {
      case ne.Zoom:
        r || l || d ? u = Ce.ZoomXY : u = n === !0 ? Ce.ZoomY : Ce.ZoomX, f = !1;
        break;
      case ne.MultiSelection:
      case ne.MultiSelectionWithCtrlKey:
        c ? u = n === !0 ? Ce.SelectY : Ce.SelectX : u = Ce.SelectXY, f = !0;
        break;
      case ne.MonoSelection:
        u = Ce.None, f = !0;
        break;
      case ne.None:
        u = Ce.None, f = !1;
        break;
    }
  e instanceof Te && e.get("cursor") !== void 0 && u !== void 0 && e.get("cursor")?.set("behavior", u), XT({ chart: e, enabled: f });
}
function jT(t, e) {
  e !== void 0 && (e.width !== void 0 && t.set("width", Du(e.width)), e.height !== void 0 && t.set("height", Du(e.height)), e.paddingTop !== void 0 && t.set("paddingTop", e.paddingTop), e.paddingBottom !== void 0 && t.set("paddingBottom", e.paddingBottom));
}
function Yl(t) {
  const { root: e, defaults: i, parent: a, id: n, index: o } = t, s = Mn.new(e, {});
  return jT(s, i), a !== void 0 && a.children.insertIndex(o ?? a.children.length, s), n !== void 0 && s.set("id", n), s;
}
function Xl(t, e) {
  e ? t.hide() : t.show();
}
function _T(t, e) {
  const i = Yl({
    root: t,
    defaults: D.headerContainer,
    parent: e,
    id: Oi(jc, e.uid),
    index: 0
  }), a = Yl({
    root: t,
    defaults: D.headerContainer,
    parent: e,
    id: Oi(_c, e.uid),
    index: 1
  }), n = Wo({
    root: t,
    parent: i,
    defaults: D.titleLabel,
    id: Oi(ph, i.uid)
  }), o = Wo({
    root: t,
    parent: a,
    defaults: D.subtitleLabel,
    id: Oi(yh, a.uid)
  });
  zo({
    chart: e,
    label: n,
    labelType: ue.ChartTitle
  }), zo({
    chart: e,
    label: o,
    labelType: ue.ChartSubTitle
  });
}
function hp(t, e) {
  const { title: i, subtitle: a } = e ?? {}, n = Ye({ childId: jc, parent: t });
  if (n !== void 0) {
    const s = Ye({ childId: ph, parent: n });
    s !== void 0 && (Zi({
      label: s,
      labelConfig: i,
      defaults: D.titleLabel
    }), ua({
      chart: t,
      label: s,
      labelType: ue.ChartTitle
    }), Xl(n, s.get("disabled") === !0 || (i?.content.text ?? "") === ""));
  }
  const o = Ye({ childId: _c, parent: t });
  if (o !== void 0) {
    const s = Ye({ childId: yh, parent: o });
    s !== void 0 && (Zi({
      label: s,
      labelConfig: a,
      defaults: D.subtitleLabel
    }), ua({
      chart: t,
      label: s,
      labelType: ue.ChartSubTitle
    }), Xl(
      o,
      s.get("disabled") === !0 || (a?.content.text ?? "") === ""
    ));
  }
}
function ZT(t) {
  const { root: e } = t, i = Yl({
    root: e,
    defaults: D.footerContainer,
    parent: t,
    id: Oi(Zc, t.uid)
  }), a = Wo({
    root: e,
    parent: i,
    id: Oi(bh, i.uid)
  });
  zo({
    chart: t,
    label: a,
    labelType: ue.ChartFooter
  });
}
function pp(t, e) {
  const i = Ye({ childId: Zc, parent: t });
  if (i !== void 0) {
    const a = Ye({ childId: bh, parent: i });
    a !== void 0 && (Zi({
      label: a,
      labelConfig: e,
      defaults: D.footer
    }), ua({
      chart: t,
      label: a,
      labelType: ue.ChartFooter
    }), Xl(i, a.get("disabled") || (e?.content.text ?? "") === ""));
  }
}
function QT(t) {
  const { root: e, parent: i, curtainColor: a } = t, n = je(a ?? D.backgroundColor), o = Mn.new(e, {
    id: Oi(Sh, i.uid),
    width: ct,
    height: ct,
    interactive: !0,
    // avoids elements tooltips to bubble up through the curtain
    layer: 1e3,
    // assigns a layer to the container: See issue: https://devtopia.esri.com/WebGIS/arcgis-web-components/issues/4195
    background: nc.new(e, {
      fill: n.color,
      fillOpacity: n.opacity
    })
  });
  return i.children.push(o), o;
}
function KT(t) {
  const { root: e, parent: i, spinnerColor: a } = t, n = je(a ?? D.loaderSpinnerColor), o = ga.new(e, {
    id: Oi(xh, i.uid),
    centerX: Re,
    centerY: Re,
    x: Re,
    y: Re,
    svgPath: "M2.2 16A13.81 13.81 0 0 1 14 2.362v1.01a12.8 12.8 0 1 0 4 0v-1.01A13.792 13.792 0 1 1 2.2 16z",
    stroke: n.color,
    strokeWidth: 2
  });
  return i.children.push(o), o;
}
function JT(t) {
  return t.animate({
    from: 0,
    to: 360,
    key: "rotation",
    loops: Number.MAX_SAFE_INTEGER,
    duration: D.loaderRotationSpeed
  });
}
function ew(t, e) {
  const i = QT({
    root: t,
    parent: t.container,
    curtainColor: e?.loaderColors?.curtainColor
  }), a = KT({
    root: t,
    parent: i,
    spinnerColor: e?.loaderColors?.spinnerColor
  }), n = JT(a);
  return { loaderSpinner: a, loaderContainer: i, spinnerAnimation: n };
}
function tw(t) {
  const { root: e, chart: i, options: a } = t, { loaderContainer: n, spinnerAnimation: o } = ew(e, a);
  function s() {
    o.stop(), n !== void 0 && (_e(n, !1), i instanceof Te && i.zoomOutButton.set("disabled", !1));
  }
  s();
  function r(l) {
    l && (o.play(), n !== void 0 && (_e(n), i instanceof Te && i.zoomOutButton.set("disabled", !0)));
  }
  return { hideLoader: s, showLoader: r };
}
function iw(t, e) {
  const { root: i } = t, a = Ye({ childId: Sh, parent: i.container });
  if (a) {
    const n = je(
      e?.loaderColors?.curtainColor ?? D.backgroundColor
    );
    a.get("background")?.setAll({ fill: n.color, fillOpacity: n.opacity });
    const o = je(
      e?.loaderColors?.spinnerColor ?? D.loaderSpinnerColor
    );
    Ye({ childId: xh, parent: a })?.set("stroke", o.color);
  }
}
function aw(t, e) {
  t.events.once(Se.FrameEnded, () => {
    no(t.dom), e();
  });
}
function yp(t) {
  if (!(t instanceof Ra) && t instanceof Te) {
    const { root: e } = t, i = Il.new(e, {
      orientation: "horizontal",
      visible: !1,
      marginTop: 0
    }), a = Il.new(e, {
      orientation: "vertical",
      visible: !1
    });
    t.setAll({ scrollbarX: i, scrollbarY: a });
  }
}
function nw(t, e) {
  if (e !== void 0) {
    const i = je(e), a = e[3] / 255, n = a / 2;
    [
      { element: t.get("background"), specificOpacity: n },
      { element: t.startGrip.get("background") },
      { element: t.endGrip.get("background") },
      { element: t.thumb }
    ].forEach((o) => {
      const { element: s, specificOpacity: r } = o;
      s !== void 0 && s.setAll({ fill: i.color, fillOpacity: r ?? a });
    }), [
      { element: t.get("background"), stateName: "default", specificOpacity: n },
      {
        element: t.startGrip.get("background"),
        stateName: "default"
      },
      { element: t.startGrip.get("background"), stateName: "hover" },
      { element: t.startGrip.get("background"), stateName: "down" },
      { element: t.endGrip.get("background"), stateName: "default" },
      { element: t.endGrip.get("background"), stateName: "hover" },
      { element: t.endGrip.get("background"), stateName: "down" },
      { element: t.thumb, stateName: "default" },
      { element: t.thumb, stateName: "hover" },
      { element: t.thumb, stateName: "down" }
    ].forEach((o) => {
      const { element: s, stateName: r, specificOpacity: l } = o;
      (s?.states.lookup(r) ?? s?.states.create(r, {}))?.setAll({ fill: i.color, fillOpacity: l ?? a });
    });
  }
}
function ow(t, e) {
  typeof e == "number" && Number.isFinite(e) && (t.get("orientation") === "horizontal" ? t.setAll({ height: e, minHeight: e }) : t.setAll({ width: e, minWidth: e }));
}
function sw(t, e) {
  if (typeof e == "number" && Number.isFinite(e)) {
    const a = e / 30;
    t.startGrip.set("scale", a), t.endGrip.set("scale", a);
  }
}
function ef(t, e) {
  typeof e == "number" && Number.isFinite(e) && (t.get("orientation") === "horizontal" ? t.set("marginBottom", e) : t.set("marginLeft", e), t.markDirtyBounds());
}
function bp(t) {
  const { chart: e, scrollbarXConfig: i, scrollbarYConfig: a } = t;
  if (!(e instanceof Ra) && e instanceof Te) {
    const n = V(e.uid, "isRotated");
    (e.get("scrollbarX") === void 0 || e.get("scrollbarY") === void 0) && yp(e);
    const o = e.get("scrollbarX"), s = e.get("scrollbarY");
    [o, s].forEach((r) => {
      if (r !== void 0) {
        const l = r.get("orientation") === "horizontal" && n !== !0 || r.get("orientation") === "vertical" && n === !0 ? i : a, c = l?.visible !== !0;
        if (_e(r, !c), l !== void 0 && !c) {
          const { width: d, color: u, gripSize: f, margin: m } = l;
          ef(r, m ?? d ?? D.scrollbarPadding), nw(r, u), sw(r, f), ow(r, d);
        } else
          ef(r, 0);
      }
    });
  }
}
function rw(t) {
  Gh(t);
}
function tf(t) {
  return t.get("legendDataItem")?.get("marker").children.getIndex(0);
}
function lw(t, e) {
  t.columns.each((i) => {
    (i.dataItem?.dataContext)[e] === 0 && i.set("strokeOpacity", 0);
  });
}
function cw(t) {
  const { root: e, chartConfig: i, seriesConfig: a, xAxis: n, yAxis: o, options: s } = t, { id: r, name: l } = a, { xField: c, yField: d, xAxisField: u, yAxisField: f } = bo(i, a), m = cx(i), g = Ft.new(e, {
    id: r,
    name: l,
    stacked: m,
    xAxis: n,
    yAxis: o,
    [u]: c,
    [f]: d,
    maskBullets: !1
  });
  na(g.columns.template, s?.selectionTheme);
  const y = Jn.new({});
  return st(g.uid, { bulletTemplate: y }), oa(g.columns.template, g), g.bullets.push((p) => {
    const S = ga.new(p, {}, y);
    return za.new(p, {
      sprite: S
    });
  }), g.columns.template.set("width", Ni(100)), id(g), Bh(g), Ch(g), ds(g), g.appear(), g;
}
function dw(t) {
  const { series: e, seriesConfig: i, seriesIndex: a, numberOfSeries: n, chartSubType: o, colorMatch: s, rendererType: r } = t, l = e.root, c = cs(e), d = /* @__PURE__ */ new Set();
  let u, f;
  const m = i.fillSymbol, g = {
    root: l,
    seriesConfig: i,
    seriesIndex: a,
    seriesSymbol: m,
    isChartFillSymbol: !0
  };
  let y = {};
  const p = jf(a);
  if (e.columns.length === 0 ? y = Pt({
    root: l,
    seriesIndex: a,
    colorMatch: s,
    seriesSymbol: m ?? p,
    element: ga.new(l, {}),
    isChartFillSymbol: !0
  }) : e.columns.each((S) => {
    const x = S.dataItem?.dataContext;
    Number.isFinite(x?.[c]) && (f = Wt({
      dataItem: x,
      seriesConfig: i,
      chartSubType: o,
      colorMatch: s,
      rendererType: r
    }), y = Pt({
      ...g,
      seriesSymbol: m ?? p,
      element: S,
      colorMatch: s,
      rendererSymbol: f
    }), Bo(S, y.stylingInfo), d.add(JSON.stringify(y.symbolWithColorInfo)));
  }), n > 1) {
    const S = tf(e);
    if (S !== void 0)
      Pt({
        ...g,
        seriesSymbol: m ?? p,
        element: S,
        colorMatch: s,
        rendererSymbol: f
      }), Bo(S, y.stylingInfo);
    else if (e.chart instanceof Te) {
      const x = e.chart.children.values.find((C) => C instanceof $f);
      x !== void 0 && x.events.once(Se.BoundsChanged, () => {
        Bo(tf(e), y.stylingInfo);
      });
    }
    Pt({
      ...g,
      seriesSymbol: y.symbolWithColorInfo ?? m ?? p,
      element: e,
      colorMatch: s,
      rendererSymbol: f,
      keepCurrentVisibility: !0
      // we prevent the series visibility to be reset, for instance when the series has been hidden from the legend
    }), Pt({
      ...g,
      seriesSymbol: y.symbolWithColorInfo ?? m ?? p,
      element: e.columns.template,
      colorMatch: s,
      rendererSymbol: f
    });
  }
  return d.size <= 1 && (u = y.symbolWithColorInfo ?? m), lw(e, c), u;
}
function uw(t) {
  const { series: e, seriesSymbolMapForEvent: i, seriesIndexMapper: a, seriesIndex: n, colorMatch: o, rendererType: s } = t, r = t.seriesConfig, l = e.chart;
  if (l !== void 0) {
    const c = V(l.uid, "config"), d = c?.series.length ?? 0, u = H(c?.series), f = dw({
      series: e,
      seriesConfig: r,
      seriesIndex: n,
      numberOfSeries: d,
      chartSubType: u,
      colorMatch: o,
      rendererType: s
    });
    i.set(a?.get(r.id) ?? n, f), i.size === d && zi({
      data: i,
      htmlContainer: e.root.dom,
      chartId: l.get("id"),
      colorMatchApplied: Yr(l)
    });
  }
}
function fw(t) {
  const {
    columnSeries: e,
    data: i,
    seriesIndex: a,
    chartConfig: n,
    dataWasUpdated: o,
    seriesWereReinitialized: s,
    rotationChanged: r,
    timeZoneChanged: l,
    sortChanged: c,
    loaderHandle: d
  } = t, u = n.series[a];
  if (i && u?.type === b.BarSeries && (r === !0 || o === !0 || c === !0 || l || s === !0)) {
    const { xField: f, yField: m, xAxisField: g, yAxisField: y } = bo(n, u);
    e.setAll({
      [g]: f,
      [y]: m
    }), e.events.once(Se.DataValidated, () => {
      d.hideLoader();
    }), e.data.setAll(i.dataItems);
  }
}
function mw(t) {
  const {
    series: e,
    data: i,
    chartConfig: a,
    options: n,
    seriesIndex: o,
    dataWasUpdated: s,
    rotationChanged: r,
    timeZoneChanged: l,
    queryObject: c,
    commonStrings: d,
    seriesWereReinitialized: u,
    subtypeInfo: f,
    fieldList: m,
    sortChanged: g,
    loaderHandle: y
  } = t, p = a.series[o], S = a.rotated, x = a.axes;
  let C;
  x?.[1] && (C = x[1]), e.set("id", p.id), ed({
    series: e,
    chartConfig: a,
    isRotated: S
  }), rw({
    seriesType: b.BarSeries,
    series: e,
    seriesConfig: p,
    isRotated: S,
    dataLabelsConfig: p.dataLabels,
    yAxisValueFormat: C?.valueFormat,
    externalDataLabelFormatter: n?.dataLabelFormatter
  }), fw({
    columnSeries: e,
    data: i,
    seriesIndex: o,
    chartConfig: a,
    dataWasUpdated: s,
    timeZoneChanged: l,
    seriesWereReinitialized: u,
    rotationChanged: r,
    sortChanged: g,
    loaderHandle: y
  }), Kc({
    series: e,
    seriesConfig: p,
    fieldList: m,
    queryObject: c,
    seriesIndex: o,
    tooltipFormatter: n?.tooltipFormatter,
    commonStrings: d
  }), ba(t) && Sa({
    // TODO: Remove the type assertion and correct the typings
    styleCallback: uw,
    callbackProps: t,
    series: e,
    seriesConfig: p
  }), td({
    chartConfig: a,
    series: e,
    seriesIndex: o,
    subtypeInfo: f,
    fieldList: m
  });
}
function gw(t) {
  const { chartConfig: e, seriesConfig: i } = t, a = di(e), n = e.showOutliers, o = e.standardizeValues, s = qe(e), { y: r } = i, l = Or(e), c = H(l.series), d = s ? void 0 : i?.query?.where, u = {
    y: c === L.BoxPlotMultiFieldsAndCategory && typeof r == "string" ? r : void 0,
    chartSubType: c,
    splitBy: d,
    showOutliers: n,
    standardizeValues: Hn(c) ? o : !1
  }, f = Ur({
    chartConfig: e,
    seriesConfig: i,
    key: Y.ThirdQuartile
  });
  return {
    properties: {
      ...f.properties,
      low: oe({
        ...u,
        key: Y.Min
      }),
      open: oe({
        ...u,
        key: Y.FirstQuartile
      }),
      high: oe({
        ...u,
        key: Y.Max
      })
    },
    dataFields: {
      ...f.dataFields,
      low: a ? "lowValueXField" : "lowValueYField",
      open: a ? "openValueXField" : "openValueYField",
      high: a ? "highValueXField" : "highValueYField"
    }
  };
}
function hw(t) {
  const {
    candleStickSeries: e,
    data: i,
    rotationChanged: a,
    sortChanged: n,
    dataWasUpdated: o,
    seriesWereReinitialized: s,
    loaderHandle: r
  } = t;
  (a === !0 || o === !0 || n === !0 || s === !0) && (e.events.once(Se.DataValidated, () => {
    r.hideLoader();
  }), e.data.setAll(i?.dataItems ?? []));
}
function pw(t) {
  const { candleStickSeries: e, seriesConfig: i, seriesIndex: a, chartSubType: n, colorMatch: o, showMean: s, rendererType: r } = t, { root: l } = e, c = i.fillSymbol ?? hc(a);
  let d = {};
  const u = {
    root: l,
    seriesConfig: i,
    seriesIndex: a,
    colorMatch: o,
    isChartFillSymbol: !0
  };
  e.columns.length === 0 ? d = Pt({
    ...u,
    seriesSymbol: c,
    element: ga.new(l, {})
  }) : e.columns.each((f) => {
    d = Pt({
      ...u,
      seriesSymbol: c,
      element: f,
      rendererSymbol: s ? void 0 : Wt({
        dataItem: f.dataItem?.dataContext,
        seriesConfig: i,
        chartSubType: n,
        colorMatch: o,
        rendererType: r
      })
    });
  }), Pt({
    ...u,
    seriesSymbol: d?.symbolWithColorInfo ?? c,
    element: e.columns.template,
    colorMatch: o
  });
}
function yw(t) {
  const { candleStickSeries: e, seriesConfig: i } = t;
  So(e, i.name), hw(t), ba(t) && Sa({
    // TODO: Remove the type assertion and correct the typings
    styleCallback: pw,
    callbackProps: t,
    series: e,
    seriesConfig: i
  });
}
function bw(t) {
  const { root: e, xAxis: i, yAxis: a, chartConfig: n, seriesIndex: o, options: s } = t, r = n.series[o];
  let l;
  if (r.type === b.BoxPlotSeries) {
    const c = gw({ chartConfig: n, seriesConfig: r });
    l = bn.new(e, {
      id: r.id,
      xAxis: i,
      yAxis: a,
      [c.dataFields.low]: c.properties.low,
      [c.dataFields.open]: c.properties.open,
      [c.dataFields.high]: c.properties.high,
      [c.dataFields.value]: c.properties.value,
      [c.dataFields.category]: c.properties.category
    }), l.columns.template.setAll({ themeTags: [], width: Ni(80) }), na(l.columns.template, s?.selectionTheme), oa(l.columns.template, l);
  }
  return l;
}
function Sw(t) {
  const { chartConfig: e, seriesConfig: i } = t, a = H(e.series), { showOutliers: n, standardizeValues: o } = e, { y: s } = i, r = i?.query?.where, l = Or(e), c = Ur({
    chartConfig: l,
    seriesConfig: i,
    key: Y.Average
  }), d = oe({
    y: a === L.BoxPlotMultiFieldsAndCategory && typeof s == "string" ? s : void 0,
    chartSubType: a,
    splitBy: r,
    showOutliers: n,
    standardizeValues: Hn(a) ? o : !1,
    key: Y.Average
  });
  return c.properties.value = d, c;
}
function xw(t) {
  const { meanLineSeries: e, data: i, rotationChanged: a, sortChanged: n, dataWasUpdated: o, seriesWereReinitialized: s } = t;
  (a === !0 || o === !0 || n === !0 || s === !0) && e.data.setAll(i?.meanLines ?? []);
}
function Cw(t) {
  const { meanLineSeries: e, seriesConfig: i, data: a, dataWasUpdated: n, sortChanged: o, rotationChanged: s, seriesWereReinitialized: r } = t;
  So(e, i?.name), xw({
    meanLineSeries: e,
    data: a,
    dataWasUpdated: n,
    sortChanged: o,
    rotationChanged: s,
    seriesWereReinitialized: r
  });
}
function vw(t) {
  const { root: e, xAxis: i, yAxis: a, chartConfig: n, seriesIndex: o, options: s } = t, r = n.series[o];
  let l;
  if (r.type === b.LineSeries) {
    const c = Sw({ chartConfig: n, seriesConfig: r });
    l = Ae.new(e, {
      id: r.id,
      xAxis: i,
      yAxis: a,
      [c.dataFields.value]: c.properties.value,
      [c.dataFields.category]: c.properties.category
    }), l.appear();
    const d = Jn.new({});
    st(l.uid, { bulletTemplate: d }), l.bullets.push((u) => {
      const f = ga.new(
        u,
        {
          tooltipText: " ",
          // necessary to trigger the adapter
          focusable: !0
          // necessary for accessibility on bullets
        },
        d
      ), m = za.new(u, {
        sprite: f
      });
      return na(f, s?.selectionTheme), l && oa(f, l), m;
    }), st(l.uid, { isBoxPlotMeanLineSeries: !0 });
  }
  return l;
}
function Fw(t, e) {
  return t.get("id") === `${e}_${ve.Outliers}`;
}
function Lw(t) {
  const { chartConfig: e, seriesConfig: i } = t;
  return Ur({
    chartConfig: e,
    seriesConfig: i,
    key: Y.Outlier
  });
}
function Aw(t) {
  const { outlierSeries: e, data: i, rotationChanged: a, sortChanged: n, dataWasUpdated: o, seriesWereReinitialized: s } = t;
  (a === !0 || o === !0 || n === !0 || s === !0) && e.data.setAll(i?.outliers ?? []);
}
function Tw(t, e) {
  return (t ?? D.boxPlot.boxPlotOutliersVisibility) && e !== !1;
}
function ww(t) {
  const { outlierSeries: e, chartSubType: i, seriesConfig: a, colorMatch: n, showOutliers: o } = t;
  if ($e(e.uid, "bulletTemplate") && a.type === b.BoxPlotSeries) {
    const l = a.fillSymbol, c = {
      type: re.SMS,
      style: Xt.Circle,
      color: l?.color,
      size: D.boxPlot.boxPlotOutliersSize
    };
    e.dataItems.forEach((d) => {
      const u = d.bullets?.[0]?.get("sprite");
      if (u !== void 0) {
        const f = Wt({
          dataItem: d.dataContext,
          seriesConfig: a,
          chartSubType: i,
          colorMatch: n
        });
        Pt({
          root: e.root,
          seriesSymbol: c,
          element: u,
          colorMatch: n,
          rendererSymbol: f
        });
      }
    });
  }
  const r = Tw(o, a.visible);
  _e(e, r);
}
function kw(t) {
  const { outlierSeries: e, data: i, seriesConfig: a, sortChanged: n, dataWasUpdated: o, rotationChanged: s, seriesWereReinitialized: r } = t;
  e && a.type === b.BoxPlotSeries && (Aw({
    outlierSeries: e,
    data: i,
    rotationChanged: s,
    sortChanged: n,
    dataWasUpdated: o,
    seriesWereReinitialized: r
  }), ba(t) && Sa({
    // TODO: Remove the type assertion and correct the typings
    styleCallback: ww,
    callbackProps: t,
    series: e,
    seriesConfig: a
  }));
}
function Iw(t) {
  const { root: e, xAxis: i, yAxis: a, chartConfig: n, seriesIndex: o, options: s } = t, r = n.series[o];
  let l;
  if (r.type === b.BoxPlotSeries) {
    const c = Lw({ chartConfig: n, seriesConfig: r });
    l = Ae.new(e, {
      id: `${r.id}_${ve.Outliers}`,
      xAxis: i,
      yAxis: a,
      [c.dataFields.value]: c.properties.value,
      [c.dataFields.category]: c.properties.category
    }), l.strokes.template.set("forceHidden", !0);
    const d = Jn.new({});
    st(l.uid, { bulletTemplate: d }), l.bullets.push((u) => {
      const f = ga.new(
        u,
        {
          tooltipText: " ",
          // necessary to trigger the adapter
          focusable: !0
          // necessary for accessibility on bullets
        },
        d
      ), m = za.new(u, {
        sprite: f
      });
      return na(f, s?.selectionTheme), l && oa(f, l), $w({ outlierSeries: l, bullet: m, seriesConfigId: r.id }), m;
    }), st(l.uid, { isBoxPlotOutliersSeries: !0 }), l.appear();
  }
  return l;
}
function Sp(t) {
  const { data: e, colorMatch: i, chartSubType: a, rendererType: n } = t;
  return e !== void 0 && i && n !== void 0 && (a === L.BoxPlotMultiFields && (n === qt.UniqueValue || n === qt.PieChart) || a === L.BoxPlotMonoFieldAndCategory && n === qt.UniqueValue) && e.some(
    (o) => Object.keys(o).some((s) => s.includes(k.rendererSymbolField))
  );
}
function Ow(t) {
  const { chartConfig: e, seriesConfig: i, type: a } = t;
  let n = "";
  switch (a) {
    case ve.Top:
      n = Y.Max;
      break;
    case ve.Median:
      n = Y.Median;
      break;
    case ve.Bottom:
      n = Y.Min;
      break;
  }
  return Ur({
    chartConfig: e,
    seriesConfig: i,
    key: n
  });
}
function Bw(t) {
  const { stepLineSeries: e, data: i, rotationChanged: a, sortChanged: n, dataWasUpdated: o, seriesWereReinitialized: s } = t;
  (a === !0 || o === !0 || n === !0 || s === !0) && e.data.setAll(i?.dataItems ?? []);
}
function Dw(t) {
  const { stepLineSeries: e, data: i, seriesConfig: a, seriesIndex: n, colorMatch: o, chartSubType: s, rendererType: r } = t;
  if (a.type === b.BoxPlotSeries) {
    const { root: l } = e, c = Sp({
      data: i.dataItems,
      colorMatch: o,
      chartSubType: s,
      rendererType: r
    }), d = (a.fillSymbol ?? hc(n)).color, u = {
      type: re.SLS,
      width: D.boxPlot.boxPlotLineWidth,
      color: c ? D.boxPlot.boxPlotWhiskersColor : d
    };
    Pt({
      root: l,
      seriesIndex: n,
      seriesSymbol: u,
      element: e,
      colorMatch: o
    });
  }
}
function Nw(t) {
  const { stepLineSeries: e, data: i, seriesConfig: a, rotationChanged: n, sortChanged: o, dataWasUpdated: s, seriesWereReinitialized: r } = t, l = a.visible !== !1;
  e !== void 0 && a.type === b.BoxPlotSeries && (_e(e, l), ba(t) && Sa({
    // TODO: Remove the type assertion and correct the typings
    styleCallback: Dw,
    callbackProps: t,
    series: e,
    seriesConfig: a
  }), Bw({
    stepLineSeries: e,
    data: i,
    rotationChanged: n,
    sortChanged: o,
    dataWasUpdated: s,
    seriesWereReinitialized: r
  }));
}
function Fl(t) {
  const { root: e, xAxis: i, yAxis: a, chartConfig: n, seriesIndex: o, type: s, options: r } = t, l = n.series[o];
  let c;
  if (l.type === b.BoxPlotSeries) {
    const d = Ow({ chartConfig: n, seriesConfig: l, type: s });
    c = gr.new(e, {
      id: `${l.id}_${s}`,
      xAxis: i,
      yAxis: a,
      noRisers: !0,
      [d.dataFields.value]: d.properties.value,
      [d.dataFields.category]: d.properties.category
    }), na(c.strokes.template, r?.selectionTheme), oa(c.strokes.template, c);
  }
  return c;
}
function Ur(t) {
  const { chartConfig: e, seriesConfig: i, key: a } = t, n = di(e), o = e.showOutliers, s = e.standardizeValues, r = qe(e), l = H(e.series), { x: c, y: d } = i, u = r ? void 0 : i?.query?.where, f = {
    y: l === L.BoxPlotMultiFieldsAndCategory && typeof d == "string" ? d : void 0,
    chartSubType: l,
    splitBy: u,
    showOutliers: o,
    standardizeValues: Hn(l) ? s : !1
  }, m = l === L.BoxPlotMonoField || l === L.BoxPlotMultiFields || l === L.BoxPlotMonoFieldAndSplitBy || l === L.BoxPlotMultiFieldsAndSplitBy ? jo : c;
  return {
    dataFields: {
      value: n ? "valueXField" : "valueYField",
      category: n ? "categoryYField" : "categoryXField"
    },
    properties: {
      value: oe({
        key: a,
        ...f
      }),
      category: m
    }
  };
}
function Mw(t, e) {
  return t.series.values.find((i) => Fw(i, e));
}
function xp(t, e) {
  const i = t.series.values.find(
    (o) => o.get("id") === `${e}_${ve.Top}`
  ), a = t.series.values.find(
    (o) => o.get("id") === `${e}_${ve.Median}`
  ), n = t.series.values.find(
    (o) => o.get("id") === `${e}_${ve.Bottom}`
  );
  return { topStepLineSeries: i, medianStepLineSeries: a, bottomStepLineSeries: n };
}
function Cp(t) {
  return t !== L.BoxPlotMonoField && t !== L.BoxPlotMultiFields && t !== L.BoxPlotMonoFieldAndCategory;
}
function vp(t) {
  const { chart: e, candleSeriesIndex: i, numberOfCandleStickSeries: a } = t;
  let n, o;
  const s = V(e.uid, "config");
  if (s) {
    const r = di(s), l = qe(s), c = r ? e.yAxes.getIndex(0)?.get("renderer") : e.xAxes.getIndex(0)?.get("renderer"), d = c?.get("cellStartLocation"), u = c?.get("cellEndLocation");
    if (d && u) {
      const f = d / (l ? 1 : s.series.length);
      n = d + i / a * (u - d) + f, o = d + (i + 1) / a * (u - d) - f;
    }
  }
  return { startLocation: n, endLocation: o };
}
function $w(t) {
  const { outlierSeries: e, bullet: i, seriesConfigId: a } = t;
  if (e) {
    const { chart: n } = e;
    if (n) {
      const o = V(n.uid, "config");
      if (o) {
        const s = H(o.series);
        if (Cp(s)) {
          const r = n.series.values.filter((c) => c instanceof bn), l = r?.findIndex((c) => c.get("id") === a);
          if (l && l !== -1 && r[l]) {
            const { startLocation: d, endLocation: u } = vp({
              chart: n,
              candleSeriesIndex: l,
              numberOfCandleStickSeries: r.length
            });
            d !== void 0 && u !== void 0 && i.set("locationX", (d + u) / 2);
          }
        }
      }
    }
  }
}
function Pw(t) {
  const e = V(t.uid, "config");
  if (e) {
    const i = H(e.series), a = e.series.length, o = di(e) ? t.yAxes.getIndex(0)?.get("renderer") : t.xAxes.getIndex(0)?.get("renderer"), s = o?.get("cellStartLocation"), r = o?.get("cellEndLocation");
    if (s && r) {
      const l = t.series.values.filter((c) => c instanceof bn);
      l.forEach((c, d) => {
        const { topStepLineSeries: u, medianStepLineSeries: f, bottomStepLineSeries: m } = xp(
          t,
          c.get("id") ?? ""
        );
        if (Cp(i)) {
          const { startLocation: g, endLocation: y } = vp({
            chart: t,
            candleSeriesIndex: d,
            numberOfCandleStickSeries: l.length
          });
          [u, f, m].forEach((p) => {
            p !== void 0 && (p.set("stepWidth", Ni(60 / a)), g && y && p.set("locationX", (g + y) / 2));
          });
        } else
          [u, f, m].forEach((g) => {
            g !== void 0 && g.setAll({
              stepWidth: Ni(60 / a)
            });
          });
      });
    }
  }
}
function Rw(t) {
  const { chartConfig: e, seriesIndex: i } = t, a = e.series[i], n = z([a]), o = [];
  if (n === b.BoxPlotSeries)
    [
      bw(t),
      Fl({
        ...t,
        type: ve.Top
      }),
      Fl({
        ...t,
        type: ve.Median
      }),
      Fl({
        ...t,
        type: ve.Bottom
      }),
      Iw(t)
    ].forEach((s) => {
      s && o.push(s);
    });
  else if (n === b.LineSeries) {
    const s = vw(t);
    s && o.push(s);
  }
  return o;
}
function Vw(t) {
  const { chart: e, chartConfig: i, series: a, seriesConfig: n } = t;
  if (e && i)
    if (Pw(e), a instanceof bn && n.type === b.BoxPlotSeries) {
      a.set("id", n.id);
      const o = a.get("id") ?? "";
      yw({ ...t, series: a, seriesConfig: n, candleStickSeries: a });
      const { topStepLineSeries: s, medianStepLineSeries: r, bottomStepLineSeries: l } = xp(
        e,
        o
      ), c = [
        ve.Top,
        ve.Median,
        ve.Bottom
      ];
      [s, r, l].forEach((u, f) => {
        u && (u.set("id", `${n.id}_${c[f]}`), Nw({ ...t, stepLineSeries: u }));
      });
      const d = Mw(e, o);
      d && (d.set("id", `${n.id}_${ve.Outliers}`), kw({ ...t, outlierSeries: d }));
    } else a instanceof Ae && n.type === b.LineSeries && Cw({ ...t, meanLineSeries: a });
}
function Fp(t) {
  const { chart: e, chartData: i, chartConfig: a } = t;
  if (e && i?.length > 1 && a?.showMean === !0) {
    const n = a.series[0].x ?? D.originalCategoryValue, o = V(e.uid, "boxPlotMeanLinesData");
    if (o !== void 0 && o.length > 1) {
      const s = [];
      for (const r of i) {
        const l = o.find(
          (c) => n in c && c[n] === r[n]
        );
        l !== void 0 && s.push(l);
      }
      Le(e.uid, { boxPlotMeanLinesData: s });
    }
  }
}
function Ew(t) {
  Gh(t);
}
function sd(t) {
  const { isLineSmoothed: e, isRadarLineSeries: i, isRotated: a } = t;
  let n = i ? rS : lS;
  return e && (n = i ? cS : a ? dS : uS), n;
}
function Ww(t) {
  const { series: e, seriesConfig: i, chartSubType: a, colorMatch: n, rendererType: o } = t;
  let s;
  for (const r of e.dataItems) {
    const l = r.dataContext;
    if (s = Wt({
      seriesConfig: i,
      dataItem: l,
      chartSubType: a,
      colorMatch: n,
      rendererType: o
    }), s !== void 0)
      break;
  }
  return s;
}
function zw(t) {
  const { series: e, seriesConfig: i, seriesIndex: a, chartSubType: n, colorMatch: o, rendererType: s } = t, r = e.root, l = Ww({
    series: e,
    seriesConfig: i,
    chartSubType: n,
    colorMatch: o,
    rendererType: s
  }), c = Pt({
    root: r,
    seriesIndex: a,
    seriesSymbol: i.lineSymbol ?? _f(a),
    element: e,
    colorMatch: o,
    rendererSymbol: l
  });
  return _e(e, i.visible), c.symbolWithColorInfo;
}
function Hw(t) {
  const { series: e, seriesIndex: i, chartSubType: a, seriesConfig: n, colorMatch: o, lineColor: s } = t;
  let r = !1, l;
  const c = $e(e.uid, "bulletTemplate");
  if (c !== void 0) {
    n.markerVisible !== !1 && n.visible !== !1 ? e.bulletsContainer.show() : e.bulletsContainer.hide();
    let { markerSymbol: d } = n;
    d === void 0 && (d = Zf(), d.color = s), o ? d.color = s : d.color ??= s;
    const u = Wt({
      dataItem: e.dataItems[0]?.dataContext,
      seriesConfig: n,
      chartSubType: a,
      colorMatch: o
    });
    u && u.outline && (d.outline ??= u.outline, d.outline.color = u.outline.color), rh({
      element: c,
      markerSymbol: d
    });
    const f = /* @__PURE__ */ new Set();
    let m;
    e.dataItems.forEach((g) => {
      const y = g.bullets?.[0]?.get("sprite");
      if (y !== void 0) {
        const p = Wt({
          dataItem: g?.dataContext,
          seriesConfig: n,
          chartSubType: a,
          colorMatch: o
        }), S = Pt({
          root: e.root,
          seriesIndex: i,
          seriesSymbol: d,
          element: y,
          colorMatch: o,
          rendererSymbol: p
        });
        l = S.symbolWithColorInfo, m = S.stylingInfo, Bo(y, m), f.add(JSON.stringify(m));
      }
    }), r = f.size > 1;
  }
  return r ? void 0 : l;
}
function qw(t, e) {
  if (t.showArea === !0)
    if (t.areaColor !== void 0) {
      const { color: i, opacity: a } = je(t.areaColor);
      e.set("fill", i), e.fills.template.setAll({ fillOpacity: a, visible: !0 });
    } else
      e.set("fill", e.get("stroke")), e.fills.template.setAll({
        fillOpacity: D.lineSeries.areaOpacity,
        visible: !0
      });
  else
    e.fills.template.set("visible", !1);
}
function Lp(t) {
  const {
    series: e,
    seriesConfig: i,
    seriesIndex: a,
    numberOfSeries: n,
    colorMatch: o,
    rendererType: s,
    chartSubType: r,
    seriesIndexMapper: l,
    seriesSymbolMapForEvent: c,
    isRotated: d
  } = t, u = e.root, f = e.chart;
  if (f) {
    const m = e instanceof sc;
    _e(e, i.visible);
    const g = sd({
      isRadarLineSeries: m,
      isLineSmoothed: i.lineSmoothed,
      isRotated: d
    });
    e.set("curveFactory", g);
    const y = zw({
      series: e,
      seriesConfig: i,
      seriesIndex: a,
      chartSubType: r,
      colorMatch: o,
      rendererType: s
    }), p = Hw({
      series: e,
      seriesConfig: i,
      seriesIndex: a,
      chartSubType: r,
      colorMatch: o,
      lineColor: y.color
    });
    c.set(l?.get(i.id) ?? a, {
      lineSymbol: y,
      markerSymbol: p
    }), qw(i, e), c.size === n && (zi({
      data: Ee(c),
      htmlContainer: u.dom,
      chartId: e.chart?.get("id"),
      colorMatchApplied: Yr(f)
    }), c.clear());
  }
}
function Gw(t) {
  const { root: e, chartConfig: i, xAxis: a, yAxis: n, seriesConfig: o, options: s } = t, { id: r, name: l } = o, { xField: c, yField: d, xAxisField: u, yAxisField: f } = bo(i, o), m = Ae.new(e, {
    id: r,
    name: l,
    xAxis: a,
    yAxis: n,
    [u]: c,
    [f]: d,
    maskBullets: !1,
    curveFactory: sd({
      isRadarLineSeries: !1,
      isLineSmoothed: o.lineSmoothed,
      isRotated: i.rotated
    })
  });
  m.appear();
  const g = Jn.new({});
  return st(m.uid, { bulletTemplate: g }), m.bullets.push((y) => {
    const p = ga.new(
      y,
      {
        focusable: !0,
        // necessary for accessibility on bullets
        role: D.aria.defaultChartItemRole,
        // assigning role to bullets
        ariaLabel: _s(),
        // adding aria label to bullets
        hoverOnFocus: !0,
        // necessary for tooltip to show on focus
        tooltip: Qc(y, m),
        tooltipText: " ",
        // necessary to trigger the adapter
        layer: D.zIndexes.bulletMarkers
      },
      g
    );
    return na(p, s?.selectionTheme), oa(p, m), _h(p, m), za.new(y, { sprite: p });
  }), id(m), ds(m), m;
}
function Yw(t) {
  const {
    lineSeries: e,
    data: i,
    seriesIndex: a,
    chartConfig: n,
    dataWasUpdated: o,
    seriesWereReinitialized: s,
    rotationChanged: r,
    timeZoneChanged: l,
    sortChanged: c,
    loaderHandle: d
  } = t, u = n.series[a];
  if (i !== void 0 && a >= 0 && a < n.series.length && u.type === b.LineSeries && (r === !0 || o === !0 || l || s === !0 || c === !0)) {
    const { xField: f, yField: m, xAxisField: g, yAxisField: y } = bo(n, u);
    e.setAll({ [g]: f, [y]: m }), e.events.once(Se.DataValidated, () => {
      d.hideLoader();
    }), e.data.setAll(i.dataItems);
  }
}
function Xw(t) {
  const {
    series: e,
    seriesConfig: i,
    seriesIndex: a,
    numberOfSeries: n,
    colorMatch: o,
    rendererType: s,
    seriesIndexMapper: r,
    seriesSymbolMapForEvent: l
  } = t, { chart: c } = e;
  if (c !== void 0) {
    const d = V(c.uid, "config"), u = V(c.uid, "isRotated") ?? !1, f = H(d?.series);
    Lp({
      series: e,
      seriesConfig: i,
      seriesIndex: a,
      numberOfSeries: n,
      colorMatch: o,
      chartSubType: f,
      rendererType: s,
      seriesIndexMapper: r,
      seriesSymbolMapForEvent: l,
      isRotated: u
    });
  }
}
function Uw(t, e) {
  const { connectLines: i, temporalBinning: a } = e, n = a?.nullPolicy;
  t.set("connect", i !== !1 && n !== on.Null);
}
function jw(t) {
  const {
    series: e,
    data: i,
    chartConfig: a,
    options: n,
    seriesIndex: o,
    dataWasUpdated: s,
    queryObject: r,
    subtypeInfo: l,
    fieldList: c,
    commonStrings: d,
    rotationChanged: u,
    seriesWereReinitialized: f,
    timeZoneChanged: m,
    sortChanged: g,
    loaderHandle: y
  } = t, p = a.series[o], S = a.rotated, x = a.axes;
  let C;
  x?.[1] && (C = x[1]), e.set("id", p.id), Ew({
    seriesType: b.LineSeries,
    series: e,
    seriesConfig: p,
    isRotated: S,
    dataLabelsConfig: p.dataLabels,
    yAxisValueFormat: C?.valueFormat,
    externalDataLabelFormatter: n?.dataLabelFormatter
  }), ed({ series: e, chartConfig: a, isRotated: S }), Uw(e, p), Yw({
    lineSeries: e,
    seriesIndex: o,
    data: i,
    chartConfig: a,
    dataWasUpdated: s,
    rotationChanged: u,
    seriesWereReinitialized: f,
    timeZoneChanged: m,
    sortChanged: g,
    loaderHandle: y
  }), Kc({
    series: e,
    seriesConfig: p,
    fieldList: c,
    queryObject: r,
    seriesIndex: o,
    tooltipFormatter: n?.tooltipFormatter,
    commonStrings: d
  }), ba(t) && Sa({
    // TODO: Remove the type assertion and correct the typings
    styleCallback: Xw,
    callbackProps: t,
    series: e,
    seriesConfig: p
  }), td({ chartConfig: a, series: e, seriesIndex: o, subtypeInfo: l, fieldList: c });
}
function _w(t) {
  t.labels.template.adapters.add("text", (e, i) => {
    let a = e;
    const n = $e(
      t.uid,
      "pieChartDataLabelFormatter"
    );
    if (n) {
      const o = i.dataItem;
      if (o) {
        const s = o?.get("valuePercentTotal"), r = o?.get("value"), l = o?.get("category") ?? e ?? "";
        a = n(l, r, s);
      }
    }
    return a;
  });
}
function Zw(t) {
  const e = t.labels.template;
  e.set("cursorOverStyle", "pointer"), e.setAll({
    cursorOverStyle: "pointer",
    maxWidth: D.pieChart.dataLabels.maxWidth ?? Number.NaN,
    oversizedBehavior: D.pieChart.dataLabels.wrap ?? !0 ? "wrap" : "none",
    centerX: Re,
    centerY: Re
  }), _w(t);
}
function Qw(t, e) {
  const {
    numericValueFormat: i,
    percentValueFormat: a,
    displayNumericValueOnDataLabel: n,
    displayCategoryOnDataLabel: o,
    displayPercentageOnDataLabel: s,
    valuePrefix: r,
    valueSuffix: l,
    percentagePrefix: c,
    percentageSuffix: d,
    dataLabelsCharacterLimit: u
  } = e, { chart: f } = t;
  let m;
  if (f) {
    const g = Nh({
      pieChart: f,
      valueIntlOptions: i?.intlOptions,
      percentageIntlOptions: a?.intlOptions,
      displayNumericValue: n ?? D.pieChart.displayNumericValueOnDataLabel,
      displayPercentage: s ?? D.pieChart.displayPercentageOnDataLabel,
      valuePrefix: r,
      valueSuffix: l,
      percentagePrefix: c,
      percentageSuffix: d
    }), y = Hc(u), p = ai(
      V(t.chart?.uid ?? Number.NaN, "rtl") ?? !1,
      " "
    );
    m = (S, x, C) => {
      const F = g(S, x, C), A = o ?? D.pieChart.displayCategoryOnDataLabel ? y(S) : "";
      let w = be(A) ? "" : `${A}${p}`;
      return w = `${w}${F}`, e.dataLabels?.content !== void 0 && (w = Ht({
        textSymbol: { ...e.dataLabels.content, text: w },
        format: "amChartsV5",
        defaults: {
          ...D.pieChart.dataLabels,
          wrap: e.optimizeDataLabelsOverlapping ?? D.pieChart.dataLabels.wrap
        }
      })), w;
    };
  }
  return m;
}
function Kw(t) {
  const { pieSeries: e, seriesConfig: i, dataLabelFormatter: a } = t, { dataLabels: n } = i, o = i.dataLabelsOffset ?? D.pieChart.dataLabelsOffset, s = i.dataLabelsInside ?? D.pieChart.dataLabelsInside;
  st(e.uid, {
    pieChartDataLabelFormatter: a ?? Qw(e, i)
  }), Zi({
    label: e.labels.template,
    labelConfig: n,
    defaults: {
      ...D.pieChart.dataLabels,
      wrap: i.optimizeDataLabelsOverlapping ?? D.pieChart.alignDataLabels
    }
  }), e.set(
    "alignLabels",
    !s && (i.alignDataLabels ?? D.pieChart.alignDataLabels)
  );
  const r = e.labels.template.get("radius"), l = e.labels.template.get("baseRadius");
  s && l !== Ni(60) ? e.labels.template.setAll({
    radius: void 0,
    baseRadius: Ni(60),
    textType: "regular"
  }) : s || (e.labels.template.setAll({ baseRadius: ct, textType: "adjusted" }), o !== void 0 && Number.isFinite(o) && r !== o && e.labels.template.set("radius", o));
}
function Jw(t) {
  const { chartConfig: e, chartData: i } = t;
  if (e.orderOptions?.data !== void 0) {
    Hi({
      arrayToSort: i,
      chartConfig: e
    });
    const { slices: a } = e.series[0];
    a !== void 0 && a.sort((n, o) => {
      const s = i.findIndex(
        (l) => l[D.pieChart.technicalFieldSliceId] === n.sliceId
      ), r = i.findIndex(
        (l) => l[D.pieChart.technicalFieldSliceId] === o.sliceId
      );
      return s - r;
    });
  }
}
function ek(t) {
  const { root: e, dataContext: i, seriesConfig: a, isGroupOfSlices: n, sliceFromConfig: o, dataIndex: s, colorMatch: r } = t, l = H([a]), c = zn.new(e, {});
  c.dataItem = {
    dataContext: i
  };
  const d = o?.fillSymbol, u = n ? {
    ...D.pieChart.sliceGrouping.fillSymbol,
    ...a.sliceGrouping?.fillSymbol
  } : Ee(d ?? a.fillSymbol), f = Wt({
    dataItem: i,
    seriesConfig: a,
    chartSubType: l,
    colorMatch: r
  }), { symbolWithColorInfo: m } = Pt({
    root: e,
    element: c,
    seriesSymbol: u ?? Hs(),
    seriesIndex: s,
    rendererSymbol: f,
    colorMatch: r,
    isChartFillSymbol: !0
  });
  return m;
}
function af(t, e, i) {
  const {
    root: a,
    x: n,
    isNonAggregatedChart: o,
    objectIdField: s,
    isPieFromFields: r,
    seriesConfig: l,
    fieldList: c,
    labelUpdateNeeded: d,
    colorMatch: u,
    commonStrings: f
  } = e, m = [];
  let g, y;
  return t.forEach((p, S) => {
    const x = _g({
      dataContext: p,
      x: n,
      isNonAggregatedChart: o,
      dataIndex: S,
      objectIdField: s,
      isPieFromFields: r
    });
    p[D.pieChart.technicalFieldSliceId] = x;
    const C = ar(l.slices, x), F = qi(p), v = ek({
      root: a,
      dataContext: p,
      seriesConfig: l,
      isGroupOfSlices: F,
      sliceFromConfig: C,
      dataIndex: S,
      colorMatch: u
    }), A = Zg({
      dataContext: p,
      sliceFromConfig: C,
      isGroupOfSlices: F,
      seriesConfig: l,
      fieldList: c,
      isPieFromFields: r,
      labelUpdateNeeded: d,
      colorMatch: u,
      commonStrings: f
    }), w = {
      sliceId: x,
      label: A,
      fillSymbol: v
    };
    w.originalLabel = C?.originalLabel ?? (p?.[D.originalCategoryValue] !== void 0 ? p?.[D.originalCategoryValue] : w.label), Jw({ chartConfig: i, chartData: t }), F ? (y = p[D.pieChart.technicalFieldGroupedSlices], l.sliceGrouping !== void 0 && (g = {
      sliceId: l.sliceGrouping.sliceId,
      percentageThreshold: l.sliceGrouping.percentageThreshold,
      label: A,
      originalLabel: l.sliceGrouping.originalLabel ?? A,
      fillSymbol: v
    })) : m.push(w);
  }), { slices: m, groupOfSlicesSymbols: g, groupOfSlices: y };
}
async function Ap(t) {
  const { data: e } = t, i = e && "dataItems" in e ? e.dataItems : [], { root: a, chartConfig: n, queryObject: o, usePopupTemplateFieldsInfo: s, labelUpdateNeeded: r, commonStrings: l } = t, c = n.series[0], { x: d } = c, u = !Ac({ chartConfig: n }), m = H([c]) === L.PieFromFields, y = we(o).objectIdField, p = await At(o, s), S = {
    root: a,
    x: d,
    isNonAggregatedChart: u,
    objectIdField: y,
    isPieFromFields: m,
    seriesConfig: c,
    fieldList: p,
    labelUpdateNeeded: r,
    colorMatch: Ri(n),
    commonStrings: l
  }, { slices: x, groupOfSlicesSymbols: C, groupOfSlices: F } = af(
    i,
    S,
    n
  ), { slices: v } = af(
    F ?? [],
    S,
    n
  );
  return {
    slices: x,
    groupedSlices: v,
    groupOfSlices: C
  };
}
function tk(t, e) {
  const { ticks: i } = e, a = i?.visible === !1 || e.dataLabelsInside === !0 || e.dataLabels === void 0 || e.dataLabels?.visible === !1 || e.dataLabelsOffset !== void 0 && e.dataLabelsOffset <= 0;
  t.ticks.template.set("visible", !a);
}
function ik(t) {
  const { series: e, pieSlicesSymbols: i, seriesConfig: a } = t;
  e.slices.each((n, o) => {
    const s = n.dataItem?.dataContext, r = Yc({
      dataContext: s,
      pieSlicesSymbols: i,
      seriesConfig: a
    });
    Zn({
      element: n,
      fillSymbol: r,
      defaultToColorFromRamp: !0,
      colorRampIndex: o,
      isChartFillSymbol: !0
    });
  });
}
function ak(t) {
  const { series: e, data: i, seriesConfig: a, dataWasUpdated: n, sortChanged: o, seriesWereReinitialized: s, loaderHandle: r } = t, { x: l, y: c } = a;
  if (i && (n === !0 || s === !0 || o === !0)) {
    const d = H([a]);
    e.setAll({
      categoryField: d === L.PieFromFields ? tt : l,
      valueField: d === L.PieFromFields ? Rt : c
    }), e.events.once(Se.DataValidated, () => {
      r.hideLoader();
    }), e.data.setAll(i.dataItems);
  }
}
function nk(t, e) {
  const { innerRadius: i } = e;
  t.set("innerRadius", i ? Ni(i) : 0);
}
function ok(t, e) {
  const { startAngle: i, endAngle: a } = e;
  t.setAll({
    startAngle: i ?? D.pieChart.min,
    endAngle: a ?? 360 + (t.get("startAngle") ?? 0)
  });
}
function sk(t) {
  const { root: e, seriesConfig: i, options: a } = t, { id: n, name: o, x: s, y: r } = i, l = H([i]), c = Jt.new(e, {
    id: n,
    name: o,
    categoryField: l === L.PieFromFields ? tt : s,
    valueField: l === L.PieFromFields ? Rt : r
  });
  return Zw(c), Mh(c), c.slices.template.states.create("hover", {
    scale: 1,
    // Prevent scaling on hover
    stateAnimationDuration: 0
    // Remove animation
  }), na(c.slices.template, a?.selectionTheme), oa(c.slices.template, c), c.appear(), c;
}
function rk(t) {
  const { series: e, seriesConfig: i, seriesWereReinitialized: a, dataWasUpdated: n, sortChanged: o, data: s, options: r, loaderHandle: l } = t, { dataLabelFormatter: c, tooltipFormatter: d } = r ?? {};
  e.set("id", i.id), ak({
    series: e,
    seriesConfig: i,
    seriesWereReinitialized: a,
    dataWasUpdated: n,
    sortChanged: o,
    data: s,
    loaderHandle: l
  }), ba(t) && Sa({
    // TODO: Remove the type assertion and correct the typings
    styleCallback: ik,
    callbackProps: t,
    series: e,
    seriesConfig: i
  }), nk(e, i), ok(e, i), tk(e, i), DL({
    series: e,
    seriesConfig: i,
    tooltipFormatter: d
  }), Kw({
    pieSeries: e,
    seriesConfig: i,
    dataLabelFormatter: c
  });
}
function lk(t) {
  const { root: e, chartConfig: i, xAxis: a, yAxis: n, seriesConfig: o, options: s } = t, { id: r, name: l } = o, { xField: c, yField: d, xAxisField: u, yAxisField: f } = bo(i, o), m = sc.new(e, {
    id: r,
    name: l,
    xAxis: a,
    yAxis: n,
    [u]: c,
    [f]: d,
    curveFactory: sd({
      isRadarLineSeries: !0,
      isLineSmoothed: o.lineSmoothed,
      isRotated: i.rotated
    }),
    layer: D.zIndexes.bulletMarkers
  });
  m.appear();
  const g = Jn.new({});
  return st(m.uid, { bulletTemplate: g }), m.bullets.push((y) => {
    const p = ga.new(
      y,
      { tooltip: Qc(y, m), tooltipText: " " },
      g
    );
    return na(p, s?.selectionTheme), oa(p, m), za.new(y, { sprite: p });
  }), id(m), ds(m), m;
}
function ck(t) {
  const {
    radarLineSeries: e,
    data: i,
    seriesIndex: a,
    chartConfig: n,
    dataWasUpdated: o,
    seriesWereReinitialized: s,
    timeZoneChanged: r,
    loaderHandle: l
  } = t, c = n.series[a];
  if (i !== void 0 && c?.type === b.RadarSeries && (o || r || s)) {
    const { xField: d, yField: u, xAxisField: f, yAxisField: m } = bo(n, c);
    e.setAll({ [f]: d, [m]: u }), e.events.once(Se.DataValidated, () => {
      l.hideLoader();
    }), e.data.setAll(i.dataItems);
  }
}
function dk(t) {
  const {
    series: e,
    seriesConfig: i,
    seriesIndex: a,
    numberOfSeries: n,
    colorMatch: o,
    rendererType: s,
    seriesIndexMapper: r,
    seriesSymbolMapForEvent: l
  } = t, { chart: c } = e;
  if (c !== void 0) {
    const d = V(c.uid, "config"), u = V(c.uid, "isRotated") ?? !1, f = H(d?.series);
    Lp({
      series: e,
      seriesConfig: i,
      seriesIndex: a,
      numberOfSeries: n,
      colorMatch: o,
      chartSubType: f,
      rendererType: s,
      seriesIndexMapper: r,
      seriesSymbolMapForEvent: l,
      isRotated: u
    });
  }
}
function uk(t) {
  const {
    series: e,
    data: i,
    seriesWereReinitialized: a,
    chartConfig: n,
    options: o,
    seriesIndex: s,
    dataWasUpdated: r,
    timeZoneChanged: l,
    fieldList: c,
    queryObject: d,
    subtypeInfo: u,
    loaderHandle: f,
    commonStrings: m
  } = t, g = n.series[s];
  e.set("id", g.id), ed({ series: e, chartConfig: n, isRotated: !1 }), Kc({
    series: e,
    seriesConfig: g,
    fieldList: c,
    queryObject: d,
    seriesIndex: s,
    tooltipFormatter: o?.tooltipFormatter,
    commonStrings: m
  }), ba(t) && Sa({
    // TODO: Remove the type assertion and correct the typings
    styleCallback: dk,
    callbackProps: t,
    series: e,
    seriesConfig: g
  }), td({ chartConfig: n, series: e, seriesIndex: s, subtypeInfo: u, fieldList: c }), ck({
    radarLineSeries: e,
    data: i,
    seriesIndex: s,
    chartConfig: n,
    dataWasUpdated: r,
    timeZoneChanged: l,
    seriesWereReinitialized: a,
    loaderHandle: f
  });
}
async function rd(t) {
  const { chart: e, chartConfig: i, options: a, commonStrings: n } = t, { rotated: o } = i, { root: s } = e, r = z(i.series);
  e.series.clear();
  const l = [], c = { root: s, chartConfig: i, options: a, chart: e, commonStrings: n };
  let d = [];
  for (let u = 0; u < i.series.length; u += 1) {
    const f = i.series[u], { assignToSecondValueAxis: m, type: g } = f, y = e instanceof Te ? MA({ chart: e, chartType: r, rotated: o, assignToSecondValueAxis: m }) : void 0, { xAxis: p, xAxisForHistogramOverlaySeries: S, yAxis: x } = y ?? {};
    switch (!0) {
      case r === b.BoxPlotSeries: {
        p && x && (g === b.BoxPlotSeries || g === b.LineSeries) && d.push(
          ...Rw({
            ...c,
            xAxis: p,
            yAxis: x,
            seriesIndex: u,
            seriesConfig: f,
            chartConfig: i
          })
        );
        break;
      }
      case g === b.HistogramSeries: {
        p && x && d.push(
          ...yA({
            ...c,
            seriesConfig: f,
            xAxis: p,
            xAxisForOverlaySeries: S,
            yAxis: x
          })
        );
        break;
      }
      case g === b.PieSeries: {
        d.push(
          sk({
            ...c,
            seriesConfig: f
          })
        );
        break;
      }
      case (r === b.ComboLineAndBarSeries || r === b.BarSeries || r === b.LineSeries): {
        p && x && (g === b.BarSeries ? d.push(
          cw({
            ...c,
            seriesConfig: f,
            xAxis: p,
            yAxis: x
          })
        ) : g === b.LineSeries && d.push(
          Gw({
            ...c,
            seriesConfig: f,
            xAxis: p,
            yAxis: x
          })
        ));
        break;
      }
      case g === b.RadarSeries: {
        p && x && d.push(
          lk({
            ...c,
            seriesConfig: f,
            xAxis: p,
            yAxis: x
          })
        );
        break;
      }
      case g === b.ScatterSeries: {
        p && x && d.push(
          ...UL({
            ...c,
            seriesConfig: f,
            xAxis: p,
            yAxis: x
          })
        );
        break;
      }
    }
    d = [...d, ...await Promise.all(l)].flat();
  }
  d.forEach((u) => {
    u instanceof rc && u.setPrivate("doNotUpdateLegend", !0);
  }), e.series.pushAll(d);
}
async function jr(t) {
  const {
    chart: e,
    chartConfig: i,
    options: a,
    data: n,
    seriesIndexMapper: o,
    dataWasUpdated: s,
    sortChanged: r,
    seriesWereReinitialized: l,
    rotationChanged: c,
    colorMatchChanged: d,
    seriesStyleChanged: u,
    timeZoneChanged: f,
    pieSlicesSymbols: m,
    queryObject: g,
    loaderHandle: y,
    commonStrings: p,
    errorStrings: S
  } = t, { chartRenderer: x } = i, { root: C } = e, { series: F } = i, v = z(i.series), A = H(i.series), w = e.series.values, O = Ri(i), I = i.series.length, N = /* @__PURE__ */ new Map(), M = uc(g), P = await At(g, a?.usePopupTemplateFieldsInfo), R = we(g), $ = os(x, R.renderer), W = l || s || r || c, U = {
    root: C,
    chartConfig: i,
    queryObject: g,
    options: a,
    colorMatch: O,
    dataWasUpdated: s,
    sortChanged: r,
    seriesWereReinitialized: l,
    subtypeInfo: M,
    fieldList: P,
    rendererType: $,
    dataLabelFormatter: a?.dataLabelFormatter,
    commonStrings: p,
    chartSubType: A,
    loaderHandle: y
  }, q = {
    ...U,
    numberOfSeries: I,
    rotationChanged: c,
    colorMatchChanged: d,
    seriesStyleChanged: u,
    seriesIndexMapper: o,
    seriesSymbolMapForEvent: N,
    timeZoneChanged: f
  };
  for (let Z = 0; Z < F.length; Z++) {
    const ee = F[Z];
    let j = w[Z];
    const ie = ee.type;
    switch (!0) {
      case v === b.BoxPlotSeries: {
        j = w.find((ge) => ge.get("id") === ee.id), e instanceof Te && (j instanceof bn || j instanceof Ae) && (ie === b.BoxPlotSeries || ie === b.LineSeries) && Vw({
          ...q,
          chart: e,
          series: j,
          data: n,
          seriesIndex: Z,
          seriesConfig: ee,
          chartConfig: i,
          showMean: qe(i),
          showOutliers: Mi(i)
        });
        break;
      }
      case ie === b.HistogramSeries: {
        j instanceof Ft && e instanceof Te && Ob(n) && await CA({
          ...q,
          series: j,
          allChartSeries: w,
          data: n,
          seriesIndex: Z,
          seriesConfig: ee,
          chartRenderer: x,
          axes: i.axes
        });
        break;
      }
      case ie === b.PieSeries: {
        j instanceof Jt && e instanceof sn && ul(n) && rk({
          ...U,
          series: j,
          seriesConfig: ee,
          data: n,
          pieSlicesSymbols: m
        });
        break;
      }
      case (v === b.ComboLineAndBarSeries || v === b.BarSeries || v === b.LineSeries):
        e instanceof Te && ul(n) && (ie === b.BarSeries && j instanceof Ft ? mw({
          ...q,
          series: j,
          data: n,
          seriesIndex: Z,
          seriesConfig: ee
        }) : ie === b.LineSeries && j instanceof Ae && jw({
          ...q,
          series: j,
          seriesIndex: Z,
          seriesConfig: ee,
          data: n
        }));
        break;
      case ie === b.ScatterSeries: {
        j = Eh(e);
        const ge = Wh(e);
        j instanceof Ae && ge instanceof Ae && Ib(n) && QL({
          ...q,
          series: j,
          seriesConfig: ee,
          trendLineSeries: ge,
          data: n
        });
        break;
      }
      case ie === b.RadarSeries: {
        j instanceof sc && e instanceof Ra && ul(n) && uk({
          ...q,
          series: j,
          data: n,
          seriesIndex: Z,
          seriesConfig: ee,
          chartConfig: i
        });
        break;
      }
    }
    W && v && j && VL(v, j);
  }
  await BA({
    chart: e,
    options: a,
    dataWasUpdated: s,
    data: n,
    chartConfig: i,
    queryObject: g,
    errorStrings: S
  });
}
function Tp(t) {
  const { data: e, seriesConfig: i, commonStrings: a } = t, n = i[0], o = e?.reduce((m, g) => {
    let y = g[Rt] ?? g[n.y];
    return Number.isFinite(y) || (y = 0), y + m;
  }, 0), s = n?.sliceGrouping?.percentageThreshold ?? 0, r = [];
  let l, c = 0;
  const d = e?.find((m) => m[Ut.defaultGroupOfSlicesId] === !0)?.[k.pieChart.technicalFieldGroupedSlices] ?? [], f = [...e, ...d].filter((m) => {
    let g = !0;
    const y = m[Rt] ?? m[n.y];
    if (Number.isFinite(y)) {
      const p = y / o * 100;
      m[k.pieChart.technicalFieldSlicePercent] = p, p <= s && m[Ut.defaultGroupOfSlicesId] !== !0 && (c += y, r.push(m), g = !1);
    } else m[Ut.defaultGroupOfSlicesId] !== !0 && (r.push(m), g = s === 0 || s === void 0);
    return m[Ut.defaultGroupOfSlicesId] === !0 && (l = m, g = !1), g;
  });
  if (s > 0 && r.length > 0) {
    const m = c / o * 100, g = H(i) === L.PieFromFields, y = {
      ...l,
      [Ut.defaultGroupOfSlicesId]: !0,
      [g ? tt : n.x]: n.sliceGrouping?.label ?? a?.pieChart.defaultSliceGroupingLabel,
      [g ? Rt : n.y]: c,
      [k.pieChart.technicalFieldSlicePercent]: m,
      [k.pieChart.technicalFieldGroupedSlices]: r
    };
    f.push(y);
  }
  return f;
}
function wp(t) {
  const { chart: e, seriesConfig: i, commonStrings: a } = t, n = e.series.getIndex(0);
  if (n) {
    const o = n?.data.values, s = Tp({ data: o, seriesConfig: i, commonStrings: a });
    n?.data.setAll(s);
  }
}
function fk(t) {
  ya(t) || t.dataItems.forEach((e) => {
    const i = e.bullets?.[0];
    if (i) {
      const a = i.get("sprite"), n = pa(a.uid, "selected") !== !0;
      Dt({ element: a, selected: n });
    }
  });
}
function mk(t) {
  t.columns.each((e) => {
    const i = pa(e.uid, "selected") !== !0;
    Dt({ element: e, selected: i });
  });
}
function gk(t) {
  t.slices.each((e) => {
    const i = pa(e.uid, "selected") !== !0;
    Dt({ element: e, selected: i });
  });
}
async function hk(t) {
  if (Hr(t)) {
    const e = V(t.uid, "actionMode");
    e !== ne.MonoSelection && e !== ne.None && (t.series.each((i) => {
      switch (!0) {
        case i instanceof Ft:
          mk(i);
          break;
        case i instanceof Ae:
          fk(i);
          break;
        case i instanceof Jt:
          gk(i);
          break;
      }
    }), await Jc(t, Ue.ProgrammaticSelection));
  }
}
function pk(t) {
  const e = Uy.new(t, {});
  return e.getPrivate("content").classList.add("arcgis-charts-modal"), e;
}
function nf(t) {
  let e = "";
  for (let i = 0; i < t.length; i += 1) {
    const a = t[i];
    e += `<li>${a.message}</li>`;
  }
  return `<ol>${e}</ol>`;
}
function Ul(t) {
  t.set("content", void 0), t.cancel();
}
function ld(t) {
  const { chartModal: e, message: i, title: a, closable: n } = t;
  e.set(
    "content",
    a !== void 0 ? `<div class="arcgis-charts-modal-header">${a}</div><br />${i}<br />` : `${i}`
  ), n && e.events.once(Se.Opened, () => {
    const o = document.createElement("input");
    o.type = "button", o.value = "OK", o.addEventListener("click", () => {
      e.close();
    }), e.getPrivate("content").appendChild(o);
  }), e.open();
}
async function kp(t) {
  const { chartModal: e, chartConfig: i, createMessage: a, status: n, errorStrings: o } = t, { schemaErrors: s, customErrors: r, warnings: l } = n;
  if (e !== void 0) {
    let c, d;
    i === void 0 ? (d = a === void 0 ? o.modalHeaders.newChart : void 0, c = a ?? o.errors.newChartRequest) : s.length > 0 ? (d = o.modalHeaders.error, c = o.errors.simpleError) : r.length > 0 ? (d = o.modalHeaders.error, c = nf(r)) : l.length > 0 && (d = o.modalHeaders.warning, c = `<p>${o.errors.warningRequest}</p>${nf(l)}`), (c !== void 0 || d !== void 0) && ld({ chartModal: e, message: c, title: d, closable: !1 });
  }
}
async function _r(t) {
  const { chart: e, chartModal: i, chartConfig: a, invalidType: n, elementCount: o, seriesCount: s, openModal: r, errorStrings: l } = t, c = V(e.uid, "queryObject"), d = V(e.uid, "options"), u = V(e.uid, "formatLocale"), f = a !== void 0 && ei({
    seriesConfig: a.series[0],
    xAxisValueFormatType: ii(a)
  }), m = await wm({
    invalidType: n,
    elementCount: o,
    seriesCount: s,
    chartLimits: d?.chartLimits,
    filterBySelection: d?.filterBySelection,
    queryObject: c,
    formatLocale: u,
    isTemporalLineChart: f,
    errorStrings: l
  });
  Cm(m, e.root.dom), i && r !== !1 && Hr(e) && ld({
    chartModal: i,
    title: m.header,
    message: m.message,
    closable: !1
  });
}
async function Ip(t) {
  const { chart: e, chartModal: i, data: a, errorStrings: n } = t;
  if (e instanceof Te) {
    const o = V(e.uid, "isRotated"), s = V(e.uid, "options"), r = [];
    [
      { axis: e.xAxes.getIndex(0) },
      { axis: e.yAxes.getIndex(0) },
      { axis: e.xAxes.getIndex(1), isSecondValueAxis: !0 },
      { axis: e.yAxes.getIndex(1), isSecondValueAxis: !0 }
    ].forEach((l) => {
      const { axis: c, isSecondValueAxis: d } = l;
      if (c !== void 0) {
        const u = _a(c.get("renderer"), o);
        Kh({ axis: c, isSecondValueAxis: d, data: a }) || r.push(
          _r({
            chart: e,
            chartModal: i,
            openModal: s?.messageOptions?.displayMessageWhenLogAxisNotPossible !== !1,
            invalidType: u ? de.NegativeValueInXAxisLogScale : de.NegativeValueInYAxisLogScale,
            errorStrings: n
          })
        );
      }
    }), await Promise.all(r);
  }
}
async function Op(t) {
  const { chart: e, chartModal: i, chartConfig: a, data: n, errorStrings: o } = t, s = V(e.uid, "options"), r = Vi(n);
  (i?.get("content") === void 0 || i?.get("content") === "") && Qf({
    chartConfig: a,
    nullAsValid: s?.messageOptions?.nullAsValid,
    dataSet: r
  }) && await _r({
    chart: e,
    chartModal: i,
    invalidType: de.EmptyDataSet,
    openModal: s?.messageOptions?.displayMessageWhenNoData !== !1,
    chartConfig: a,
    errorStrings: o
  });
}
function yk(t) {
  const { chart: e, chartModal: i, message: a, heading: n, options: o } = t;
  i !== void 0 && !e.isDisposed() && (a !== void 0 ? ld({
    chartModal: i,
    message: a,
    title: n,
    closable: o?.closable ?? !1
  }) : Ul(i));
}
function Bp(t) {
  const { chart: e, data: i, config: a, hideEmptySeries: n } = t, o = a.series.length, s = Ee(a);
  let r = !1;
  if (n && e instanceof Te && o > 1) {
    const l = z(a?.series), c = H(a?.series), d = /* @__PURE__ */ new Set();
    switch (l) {
      case b.ComboLineAndBarSeries:
      case b.BarSeries:
      case b.RadarSeries:
      case b.LineSeries: {
        s.series.forEach((f) => {
          let m = "";
          "y" in f && (m = Array.isArray(f.y) ? f.y[0] : f.y, c === L.BarAndLineSplitByNoAggregation && (m = `${m}_${Lt({ where: f.query?.where })}`), Array.isArray(i) && i.some(
            (y) => fc({ dataItem: y, x: f.x, y: m })
          ) && d.add(f));
        });
        break;
      }
      case b.BoxPlotSeries:
        break;
    }
    const u = Array.from(d.values());
    r = u.length > 0 && u.length < o, r ? (Le(e.uid, { unfilteredConfig: Ee(a) }), s.series = u, Le(e.uid, { config: Ee(s) })) : Le(e.uid, { unfilteredConfig: void 0 });
  }
  return Le(e.uid, { seriesFilteredOut: r }), { seriesFilteredOut: r, updatedConfig: s };
}
function bk(t, e) {
  let i = !1;
  const a = t.series, n = e.series, o = z(n), s = (u, f) => u.filter((m) => m.type === f).flatMap((m) => {
    const g = [];
    switch (f) {
      case b.BarSeries:
      case b.HistogramSeries:
        g.push(m.fillSymbol);
        break;
      case b.LineSeries:
      case b.RadarSeries:
        g.push(
          m.lineSymbol,
          m.markerSymbol
        );
        break;
      case b.ScatterSeries:
        g.push(m.markerSymbol);
        break;
    }
    return g;
  });
  let r, l;
  o === b.ComboLineAndBarSeries ? (r = s(a, b.BarSeries).concat(
    s(a, b.LineSeries)
  ), l = s(n, b.BarSeries).concat(
    s(n, b.LineSeries)
  )) : (r = s(a, a[0].type), l = s(n, n[0].type));
  const c = !Di(r, l);
  let d = !1;
  switch (o) {
    case b.LineSeries:
    case b.RadarSeries:
    case b.ComboLineAndBarSeries:
      d = n.filter(
        (u) => u.type === b.LineSeries || u.type === b.RadarSeries
      ).some((u) => {
        const f = a.find((m) => m.id === u.id);
        return (u.showArea ?? D.lineSeries.showArea) !== (f?.showArea ?? D.lineSeries.showArea) || (u.lineSmoothed ?? D.lineSeries.lineSmoothed) !== (f?.lineSmoothed ?? D.lineSeries.lineSmoothed) || (u.markerVisible ?? D.lineSeries.markerVisible) !== (f?.markerVisible ?? D.lineSeries.markerVisible) || u.showArea && !Di(u.areaColor, f?.areaColor);
      });
      break;
  }
  return i = c || d, i;
}
function Sk(t, e) {
  for (let i = 0; i < e.length; i += 1) {
    const a = e[i][0], n = e[i][1], o = t.length;
    a >= 0 && a < o && n >= 0 && n < o && t.swap(e[i][0], e[i][1]);
  }
}
function xk() {
  jy(wF);
}
function Ck(t) {
  t.dispose();
}
async function vk(t, e) {
  const { root: i } = t, a = ia(e), n = await UF(a.locale);
  i.locale = n, Le(t.uid, {
    locale: a.locale,
    formatLocale: a.formatLocale,
    rtl: a.rtl
  });
}
function jl(t) {
  const { chart: e, actionMode: i, cursorRange: a } = t;
  if (Hr(e)) {
    const n = i ?? V(e.uid, "actionMode") ?? D.actionMode;
    Le(e.uid, { actionMode: n }), n === ne.None && Wa({ chart: e, selectionSource: Ue.ClearSelection }), UT({ chart: e, actionMode: n, cursorRange: a });
  }
}
function Fk(t) {
  return _y.rootElements.find((e) => e.dom === t)?.dispose(), Zy.new(t);
}
function Lk(t, e) {
  t.container.children.clear();
  const i = z(e?.series);
  let a;
  switch (i) {
    case b.RadarSeries:
    case b.GaugeSeries:
      a = Ra;
      break;
    case b.PieSeries:
      a = sn;
      break;
    default:
      a = Te;
  }
  return t.container.children.push(
    a.new(t, {
      id: `${e?.id}`,
      layout: t.verticalLayout,
      paddingBottom: D.chartPadding,
      paddingTop: D.chartPadding,
      paddingRight: D.chartPadding,
      paddingLeft: D.chartPadding
    })
  );
}
async function Ak(t) {
  const {
    chart: e,
    chartConfig: i,
    data: a,
    dataWasUpdated: n,
    sortChanged: o,
    slicesConfigChangedSinceLastUpdate: s,
    chartRendererChanged: r,
    options: l,
    queryObject: c,
    loaderHandle: d,
    commonStrings: u,
    errorStrings: f
  } = t, m = await Ap({
    root: e.root,
    data: a,
    chartConfig: i,
    queryObject: c,
    labelUpdateNeeded: n || s || r,
    usePopupTemplateFieldsInfo: l?.usePopupTemplateFieldsInfo,
    commonStrings: u
  });
  await jr({
    chart: e,
    chartConfig: i,
    options: l,
    data: a,
    dataWasUpdated: n,
    sortChanged: o,
    queryObject: c,
    pieSlicesSymbols: m,
    loaderHandle: d,
    commonStrings: u,
    errorStrings: f
  }), wp({
    chart: e,
    seriesConfig: i.series,
    commonStrings: u
  });
  const g = a && "dataItems" in a ? a.dataItems : [];
  Wr({ data: g, newChartConfig: i, pieSlicesSymbols: m });
}
async function Tk(t) {
  const {
    chart: e,
    chartConfig: i,
    data: a,
    anyGuideAboveChanged: n,
    dataWasUpdated: o,
    updateNeededDetails: s,
    seriesFilteredOut: r,
    sortChanged: l,
    options: c,
    queryObject: d,
    rotationChanged: u,
    colorMatchChanged: f,
    seriesStyleChanged: m,
    timeZoneChanged: g,
    timeIntervalInfoWasReset: y,
    loaderHandle: p,
    commonStrings: S,
    errorStrings: x
  } = t;
  let { axisLabelsBehaviorChanged: C } = t;
  const F = qA({
    chart: e,
    chartConfig: i,
    rotationChanged: u,
    axisLabelsBehaviorChanged: C,
    timeIntervalInfoWasReset: y
  }), v = F || PA({ chart: e, chartConfig: i, updateNeededDetails: s, seriesFilteredOut: r });
  F && (await lp({ chart: e, chartConfig: i, errorStrings: x }), C = [!0, !0]), v && (e.series.clear(), await rd({ chart: e, chartConfig: i, options: c, commonStrings: S })), await cp({
    chart: e,
    chartConfig: i,
    queryObject: d,
    data: a,
    timeIntervalInfo: a?.timeIntervalInfo ?? V(e.uid, "timeIntervalInfo"),
    axisLabelsBehaviorChanged: C,
    anyGuideAboveChanged: n,
    xAxisLabelFormatter: c?.xAxisLabelFormatter,
    yAxisLabelFormatter: c?.yAxisLabelFormatter,
    secondaryYAxisLabelFormatter: c?.secondaryYAxisLabelFormatter,
    guideTooltipFormatter: c?.guideTooltipFormatter,
    gaugeInnerLabelFormatter: c?.gaugeInnerLabelFormatter,
    commonStrings: S,
    errorStrings: x
  }), await jr({
    chart: e,
    chartConfig: i,
    options: c,
    data: a,
    dataWasUpdated: o,
    sortChanged: l,
    seriesIndexMapper: /* @__PURE__ */ new Map(),
    // TODO: to be adjusted when issue https://devtopia.esri.com/WebGIS/arcgis-charts/issues/8434 is resolved
    seriesWereReinitialized: v,
    rotationChanged: u,
    colorMatchChanged: f,
    seriesStyleChanged: m,
    timeZoneChanged: g,
    queryObject: d,
    loaderHandle: p,
    commonStrings: S,
    errorStrings: x
  }), bp({
    chart: e,
    scrollbarXConfig: i.axes?.[0]?.scrollbar,
    scrollbarYConfig: i.axes?.[1]?.scrollbar
  });
}
async function wk(t) {
  const { chart: e, queryObject: i, legend: a, chartModal: n, loaderHandle: o, updateProps: s } = t, { newChartConfig: r, updateOptions: l, t9nStrings: c } = s, { commonStrings: d, errorStrings: u } = c, { root: f } = e, {
    createMessage: m,
    layer: g,
    view: y,
    usePopupTemplateFieldsInfo: p
  } = l ?? {};
  if (r === void 0)
    throw new Error();
  let S = r, x = V(e.uid, "config");
  const C = V(e.uid, "initialized");
  if (e.isDisposed() || C === !1 || !fm(x, S))
    throw new ln(nn.ChartDisposed);
  S !== void 0 && !Xi(S) && (S = Gs({
    chartConfig: S,
    queryObject: g
  })), S = await $o(S, g);
  const F = x === void 0;
  x ??= S;
  const v = await pc({
    input: S,
    queryObject: g,
    allowUsingObjectIdStat: l?.messageOptions?.allowUsingObjectIdStat
  });
  if (v.valid) {
    x !== void 0 && Lm(x, S) && (S = Ir(S, f.dom));
    const A = H(S.series), w = z(S.series), O = Po(V(e.uid, "queryObject"));
    let I = i;
    (g !== void 0 || Xi(S)) && (I = await qn({ layer: g, view: y, chartConfig: S }), Le(e.uid, { queryObject: I })), Ul(n);
    const N = di(S), M = V(e.uid, "filterBySelection"), P = V(e.uid, "seriesFilteredOut"), R = V(e.uid, "unfilteredConfig");
    Le(e.uid, {
      config: Ee(S),
      options: l,
      isNonAggregatedChart: !dn(A),
      isRotated: N,
      filterBySelection: l?.filterBySelection
    }), iw(e, l);
    let { dataUpdateNeeded: $, updateNeededDetails: W } = wr({
      forceDataUpdate: l?.dataUpdated || F,
      options: l,
      oldConfig: P ? R : x,
      newConfig: S,
      formerFilterBySelection: M,
      timeIntervalInfo: V(e.uid, "data")?.timeIntervalInfo,
      currentSelectionDataItems: V(e.uid, "currentSelectionDataItems"),
      currentSelectionOIDs: V(e.uid, "currentSelectionOIDs"),
      currentSelectionIndexes: V(e.uid, "currentSelectionIndexes")
    });
    const U = Po(I);
    $ = $ || O !== U;
    const q = lx(x, S), Z = Fm(x, S), ee = hm(x, S), j = bk(x, S), ie = wc(x, S), ge = fx(x, S), yt = vm(x, S), Nt = kc({
      oldConfig: P ? R : x,
      newConfig: S,
      dataUpdateNeeded: $
    }), Mt = um({
      oldConfig: x,
      newConfig: S,
      rotationChanged: Z
    }), Oe = x.series, Fi = S.series;
    let Be;
    if ($) {
      o.showLoader(l?.hideLoaderAnimation !== !0);
      const va = await At(i, p);
      Be = await uo({
        chartConfig: S,
        queryObject: I,
        options: l,
        currentSelectionDataItems: V(e.uid, "currentSelectionDataItems"),
        binnedServerData: V(e.uid, "binnedServerData"),
        fieldList: va,
        errorStrings: u,
        abortKey: Oh(e)
      });
      const { data: Qa, queryConfig: My, valid: Md, count: $d, invalidType: $y } = Be;
      Le(e.uid, {
        queryConfig: My,
        initialized: Md,
        elementCount: $d,
        boxPlotMeanLinesData: Qa !== void 0 && "meanLines" in Qa ? Qa.meanLines : void 0,
        timeIntervalInfo: Qa !== void 0 && "timeIntervalInfo" in Qa ? Qa.timeIntervalInfo : void 0
      }), Md ? (un({ data: Qa, seriesConfig: S.series, htmlContainer: f.dom }), Ul(n)) : (await _r({
        chart: e,
        chartModal: n,
        invalidType: $y,
        elementCount: $d,
        seriesCount: S.series.length,
        chartConfig: r,
        errorStrings: u
      }), o.hideLoader());
    }
    if (e instanceof Wn) {
      const va = Am(Oe, Fi);
      va.length > 0 && (Sk(e.series, va), a && vh({
        chart: e,
        legend: a,
        chartConfig: S,
        hideEmptySeries: l?.hideEmptySeries
      }));
    }
    const le = Be?.data ?? V(e.uid, "data"), bt = Vi(le), Qe = await At(I, l?.usePopupTemplateFieldsInfo), $t = e instanceof sn ? Qg(
      Oe,
      Fi
    ) : !1;
    (Nt || $t) && (Hi({
      arrayToSort: bt,
      chartConfig: S,
      fieldList: Qe,
      isTimeBinningSeries: ei({
        seriesConfig: ha(r),
        xAxisValueFormatType: ii(r),
        setTimeBinningInfoWhenNotProvided: l?.setTimeBinningInfoWhenNotProvided
      })
    }), w === b.BoxPlotSeries && Fp({
      chart: e,
      chartData: $ ? bt : le,
      chartConfig: S
    }), Le(e.uid, { fieldList: Qe }), le && "dataItems" in le && (le.dataItems = bt)), ($ || Nt) && un({ data: le, seriesConfig: S.series, htmlContainer: f.dom });
    const Li = Nl({ oldConfig: x, newConfig: S }), vo = ja({ chartConfig: S, queryObject: I }), ys = qe(S), Nd = Bp({
      chart: e,
      data: ys ? le : bt,
      config: S,
      hideEmptySeries: l?.hideEmptySeries ?? D.options.hideEmptySeries
    });
    if (S = Nd.updatedConfig, le && "dataItems" in le && ($ || ie)) {
      const va = await fo({
        data: ys && "meanLines" in le && le.meanLines !== void 0 ? le.meanLines : le.dataItems,
        chartConfig: S,
        queryObject: I,
        allowColorMatch: vo
      });
      le.dataItems = va.dataItems, Le(e.uid, {
        colorMatchApplied: va.colorMatchApplied,
        rendererFieldNames: va.rendererFieldNames
      });
    }
    switch (Le(e.uid, { data: le }), dp(e, S.background), hp(e, { title: S.title, subtitle: S.subtitle }), pp(e, S.footer), gp({
      root: f,
      chart: e,
      cursorCrosshair: S.cursorCrosshair,
      config: S
    }), z(S.series)) {
      case b.PieSeries: {
        e instanceof sn && await Ak({
          chart: e,
          chartConfig: S,
          options: l,
          data: le,
          dataWasUpdated: $,
          slicesConfigChangedSinceLastUpdate: Li,
          chartRendererChanged: ie,
          sortChanged: Nt,
          queryObject: I,
          loaderHandle: o,
          commonStrings: d,
          errorStrings: u
        });
        break;
      }
      case b.BarSeries:
      case b.LineSeries:
      case b.ComboLineAndBarSeries:
      case b.ScatterSeries:
      case b.RadarSeries:
      case b.GaugeSeries:
      case b.HistogramSeries:
      case b.BoxPlotSeries:
        e instanceof Te && await Tk({
          chart: e,
          chartConfig: S,
          options: l,
          data: le,
          dataWasUpdated: $,
          updateNeededDetails: W,
          seriesFilteredOut: Nd.seriesFilteredOut,
          sortChanged: Nt,
          axisLabelsBehaviorChanged: Mt,
          anyGuideAboveChanged: q,
          rotationChanged: Z,
          colorMatchChanged: ee,
          seriesStyleChanged: j,
          timeZoneChanged: ge,
          timeIntervalInfoWasReset: yt,
          queryObject: I,
          loaderHandle: o,
          commonStrings: d,
          errorStrings: u
        });
        break;
    }
    e instanceof Wn && Ah({
      chart: e,
      chartConfig: S,
      legend: a,
      hideEmptySeries: l?.hideEmptySeries
    }), jl({ chart: e, actionMode: l?.actionMode, cursorRange: l?.cursorRange }), $ || o.hideLoader(), await Op({ chart: e, chartModal: n, chartConfig: S, data: le, errorStrings: u }), await Ip({ chart: e, chartModal: n, data: le, errorStrings: u });
  } else
    await kp({
      chartModal: n,
      chartConfig: S,
      createMessage: m,
      status: v,
      errorStrings: u
    });
  Ua(v, f.dom);
}
async function kk(t) {
  const { chart: e, data: i, chartConfig: a, options: n, queryObject: o, loaderHandle: s, commonStrings: r, errorStrings: l } = t;
  await rd({ chart: e, chartConfig: a, options: n, commonStrings: r });
  const c = await Ap({
    root: e.root,
    data: i,
    chartConfig: a,
    queryObject: o,
    labelUpdateNeeded: !0,
    usePopupTemplateFieldsInfo: n?.usePopupTemplateFieldsInfo,
    commonStrings: r
  });
  await jr({
    chart: e,
    chartConfig: a,
    options: n,
    data: i,
    dataWasUpdated: !0,
    pieSlicesSymbols: c,
    queryObject: o,
    loaderHandle: s,
    commonStrings: r,
    errorStrings: l
  }), wp({
    chart: e,
    seriesConfig: a.series,
    commonStrings: r
  });
  const d = i && "dataItems" in i ? i.dataItems : [];
  Wr({ data: d, newChartConfig: a, pieSlicesSymbols: c });
}
async function Ik(t) {
  const { chart: e, data: i, chartConfig: a, options: n, queryObject: o, loaderHandle: s, commonStrings: r, errorStrings: l } = t;
  yp(e), bp({
    chart: e,
    scrollbarXConfig: a.axes?.[0]?.scrollbar,
    scrollbarYConfig: a.axes?.[1]?.scrollbar
  }), await lp({ chart: e, chartConfig: a, errorStrings: l }), await cp({
    chart: e,
    chartConfig: a,
    queryObject: o,
    axisLabelsBehaviorChanged: [!0, !0],
    data: i,
    timeIntervalInfo: i?.timeIntervalInfo,
    xAxisLabelFormatter: n?.xAxisLabelFormatter,
    yAxisLabelFormatter: n?.yAxisLabelFormatter,
    secondaryYAxisLabelFormatter: n?.secondaryYAxisLabelFormatter,
    guideTooltipFormatter: n?.guideTooltipFormatter,
    gaugeInnerLabelFormatter: n?.gaugeInnerLabelFormatter,
    commonStrings: r,
    errorStrings: l
  }), await rd({ chart: e, chartConfig: a, options: n, commonStrings: r }), await jr({
    chart: e,
    chartConfig: a,
    seriesIndexMapper: /* @__PURE__ */ new Map(),
    // TODO: to be adjusted when issue https://devtopia.esri.com/WebGIS/arcgis-charts/issues/8434 is resolved
    options: n,
    data: i,
    dataWasUpdated: !0,
    timeZoneChanged: !0,
    queryObject: o,
    loaderHandle: s,
    commonStrings: r,
    errorStrings: l
  });
}
async function Ok(t) {
  const { chartContainer: e, chartConfig: i, options: a, globalOptions: n, t9nStrings: o } = t, { errorStrings: s, commonStrings: r } = o, { layer: l, view: c, createMessage: d } = a ?? {};
  xk(), e == null && await Ga("divNode", s);
  let u;
  i !== void 0 && (Xi(i) ? u = i : u = Gs({ chartConfig: i, queryObject: l })), u = await $o(u, l);
  let f;
  (Xi(u) || l !== void 0) && (f = await qn({ chartConfig: u, layer: l, view: c }));
  const m = Fk(e);
  BF(m, n?.enableResponsiveFeatures);
  const g = Lk(m, u);
  await vk(g, e);
  let y;
  const p = tw({ root: m, chart: g, options: a }), S = pk(m);
  DF(m, n?.useAnimatedCharts);
  const x = await pc({
    input: u,
    queryObject: f,
    allowUsingObjectIdStat: a?.messageOptions?.allowUsingObjectIdStat
  });
  if (x.valid && !g.isDisposed()) {
    u = Ir(u, e), p.showLoader(a?.hideLoaderAnimation !== !0);
    const F = p.hideLoader, v = H(u.series), A = di(u);
    Le(g.uid, {
      options: a,
      filterBySelection: a?.filterBySelection,
      config: u,
      queryObject: f,
      isNonAggregatedChart: !dn(v),
      isRotated: A
    }), mp({ root: m, chart: g, config: u }), gp({
      root: m,
      chart: g,
      cursorCrosshair: u.cursorCrosshair,
      config: u
    });
    const { title: w, subtitle: O, footer: I } = u;
    _T(m, g), hp(g, { title: w, subtitle: O }), ZT(g), pp(g, I), GT(m, g), dp(g, u.background);
    const N = await At(f, a?.usePopupTemplateFieldsInfo);
    Le(g.uid, { fieldList: N });
    const {
      data: M,
      queryConfig: P,
      valid: R,
      invalidType: $,
      count: W
    } = await uo({
      chartConfig: u,
      queryObject: f,
      options: a,
      fieldList: N,
      errorStrings: s,
      abortKey: Oh(g)
    });
    if (!R)
      await _r({
        chart: g,
        chartModal: S,
        invalidType: $,
        elementCount: W,
        seriesCount: u.series.length,
        chartConfig: i,
        errorStrings: s
      }), p.hideLoader();
    else {
      Le(g.uid, {
        options: a,
        queryConfig: P,
        initialized: R,
        elementCount: W,
        boxPlotMeanLinesData: M !== void 0 && "meanLines" in M ? M.meanLines : void 0,
        timeIntervalInfo: M !== void 0 && "timeIntervalInfo" in M ? M.timeIntervalInfo : void 0
      });
      const U = Vi(M), q = qe(u);
      if (u = Bp({
        chart: g,
        hideEmptySeries: a?.hideEmptySeries ?? D.options.hideEmptySeries,
        data: q ? M : U,
        config: u
      }).updatedConfig, M && "dataItems" in M) {
        const j = await fo({
          data: q && "meanLines" in M && M.meanLines !== void 0 ? M.meanLines : M.dataItems,
          queryObject: f,
          chartConfig: u,
          allowColorMatch: ja({ chartConfig: u, queryObject: f })
        });
        M.dataItems = j.dataItems, Le(g.uid, {
          colorMatchApplied: j.colorMatchApplied,
          rendererFieldNames: j.rendererFieldNames
        });
      }
      Le(g.uid, { queryConfig: P, initialized: R, elementCount: W, data: M });
      const Z = H(u.series);
      z(u.series) === b.BoxPlotSeries && Z !== L.BoxPlotMonoField && Z !== L.BoxPlotMonoFieldAndSplitBy && (Hi({ arrayToSort: U, chartConfig: u, fieldList: N }), Fp({
        chart: g,
        chartData: U,
        chartConfig: u
      })), un({ data: M, seriesConfig: u.series, htmlContainer: e }), aw(m, F), g instanceof Te ? await Ik({
        chart: g,
        data: {
          ...M,
          dataItems: U,
          // get the updated mean lines data from the memory storage that was sorted earlier
          meanLines: V(g.uid, "boxPlotMeanLinesData")
        },
        chartConfig: u,
        options: a,
        queryObject: f,
        loaderHandle: p,
        commonStrings: r,
        errorStrings: s
      }) : g instanceof sn && await kk({
        chart: g,
        data: M,
        chartConfig: u,
        options: a,
        queryObject: f,
        loaderHandle: p,
        commonStrings: r,
        errorStrings: s
      }), g instanceof Wn && (y = Ru(g, u.series), Ah({ chart: g, chartConfig: u, legend: y, hideEmptySeries: a?.hideEmptySeries })), jl({ chart: g, actionMode: a?.actionMode, cursorRange: a?.cursorRange }), nA(g);
    }
    await Op({ chart: g, chartModal: S, chartConfig: u, data: M, errorStrings: s }), await Ip({ chart: g, chartModal: S, data: M, errorStrings: s });
  } else
    Le(g.uid, { initialized: !1 }), g.isDisposed() || await kp({
      chartModal: S,
      chartConfig: u,
      createMessage: d,
      status: x,
      errorStrings: s
    });
  Ua(x, m.dom);
  function C() {
    iT(g);
  }
  return {
    update: async (F) => {
      y === void 0 && (y = Ru(g, F.newChartConfig.series)), await wk({ chart: g, queryObject: f, legend: y, chartModal: S, loaderHandle: p, updateProps: F });
    },
    dispose: () => Ck(m),
    notify: (F, v, A) => yk({ chartModal: S, chart: g, message: F, heading: v, options: A }),
    resetZoom: C,
    clearSelection: () => Wa({ chart: g }),
    switchSelection: async () => await hk(g),
    exportImage: async (F) => await cL({ root: m, exportOptions: F }),
    setActionMode: (F, v) => jl({ chart: g, actionMode: F, cursorRange: v })
  };
}
const rr = /* @__PURE__ */ new Map();
function pi(t) {
  t !== void 0 && rr.delete(t);
}
function Cn(t, e) {
  const i = rr.get(t) ?? {};
  rr.set(t, { ...i, ...e });
}
function vn(t, e) {
  return rr.get(t)?.[e];
}
function Bk(t, e) {
  return vn(t, e);
}
function Dk(t, e) {
  Cn(t, e);
}
function Nk(t, e) {
  return vn(t, e);
}
function Mk(t, e) {
  Cn(t, e);
}
function B(t, e) {
  return vn(t, e);
}
function J(t, e) {
  Cn(t, e);
}
function te(t, e) {
  return vn(t, e);
}
function et(t, e) {
  Cn(t, e);
}
function vt(t, e) {
  return vn(t, e);
}
function ht(t, e) {
  Cn(t, e);
}
function $k(t, e) {
  return vn(t, e);
}
function Pk(t, e) {
  Cn(t, e);
}
function dt(t, e) {
  return vn(t, e);
}
function Ji(t, e) {
  Cn(t, e);
}
const T = {
  ...k
};
async function Rk(t = ia().locale) {
  let e = await import("@amcharts/amcharts5/locales/en_US.js"), i = await import("../../chunks/messages.en-US4.js");
  switch (t) {
    case G.Arabic:
      e = await import("@amcharts/amcharts5/locales/ar.js"), i = await import("../../chunks/messages.ar4.js");
      break;
    case G.Bosnian:
      e = await import("@amcharts/amcharts5/locales/bs_BA.js"), i = await import("../../chunks/messages.bs4.js");
      break;
    case G.Bulgarian:
      e = await import("../../chunks/bg_BG2.js"), i = await import("../../chunks/messages.bg4.js");
      break;
    case G.Catalan:
      e = await import("@amcharts/amcharts5/locales/ca_ES.js"), i = await import("../../chunks/messages.ca4.js");
      break;
    case G.Czech:
      e = await import("@amcharts/amcharts5/locales/cs_CZ.js"), i = await import("../../chunks/messages.cs4.js");
      break;
    case G.Danish:
      break;
    case G.German:
      e = await import("@amcharts/amcharts5/locales/de_DE.js"), i = await import("../../chunks/messages.de4.js");
      break;
    case G.Greek:
      e = await import("@amcharts/amcharts5/locales/el_GR.js"), i = await import("../../chunks/messages.el4.js");
      break;
    case G.EnglishUSA:
      e = await import("@amcharts/amcharts5/locales/en_US.js"), i = await import("../../chunks/messages.en-US4.js");
      break;
    case G.Spanish:
      e = await import("@amcharts/amcharts5/locales/es_ES.js"), i = await import("../../chunks/messages.es4.js");
      break;
    case G.Estonian:
      e = await import("@amcharts/amcharts5/locales/et_EE.js"), i = await import("../../chunks/messages.et4.js");
      break;
    case G.Finnish:
      e = await import("@amcharts/amcharts5/locales/fi_FI.js"), i = await import("../../chunks/messages.fi4.js");
      break;
    case G.French:
      e = await import("@amcharts/amcharts5/locales/fr_FR.js"), i = await import("../../chunks/messages.fr4.js");
      break;
    case G.Hebrew:
      e = await import("@amcharts/amcharts5/locales/he_IL.js"), i = await import("../../chunks/messages.he4.js");
      break;
    case G.Croatian:
      e = await import("@amcharts/amcharts5/locales/hr_HR.js"), i = await import("../../chunks/messages.hr4.js");
      break;
    case G.Hungarian:
      e = await import("@amcharts/amcharts5/locales/hu_HU.js"), i = await import("../../chunks/messages.hu4.js");
      break;
    case G.Indonesian:
      e = await import("@amcharts/amcharts5/locales/id_ID.js"), i = await import("../../chunks/messages.id4.js");
      break;
    case G.Italian:
      e = await import("@amcharts/amcharts5/locales/it_IT.js"), i = await import("../../chunks/messages.it4.js");
      break;
    case G.Japanese:
      e = await import("@amcharts/amcharts5/locales/ja_JP.js"), i = await import("../../chunks/messages.ja4.js");
      break;
    case G.Korean:
      e = await import("@amcharts/amcharts5/locales/ko_KR.js"), i = await import("../../chunks/messages.ko4.js");
      break;
    case G.Lithuanian:
      e = await import("@amcharts/amcharts5/locales/lt_LT.js"), i = await import("../../chunks/messages.lt4.js");
      break;
    case G.Latvian:
      e = await import("@amcharts/amcharts5/locales/lv_LV.js"), i = await import("../../chunks/messages.lv4.js");
      break;
    case G.NorwegianBokml:
      e = await import("@amcharts/amcharts5/locales/nb_NO.js");
      break;
    case G.Dutch:
      e = await import("@amcharts/amcharts5/locales/nl_NL.js"), i = await import("../../chunks/messages.nl4.js");
      break;
    case G.Polish:
      e = await import("@amcharts/amcharts5/locales/pl_PL.js"), i = await import("../../chunks/messages.pl4.js");
      break;
    case G.PortugueseBrazil:
      e = await import("@amcharts/amcharts5/locales/pt_BR.js"), i = await import("../../chunks/messages.pt-BR4.js");
      break;
    case G.PortuguesePortugal:
      e = await import("@amcharts/amcharts5/locales/pt_PT.js"), i = await import("../../chunks/messages.pt-PT4.js");
      break;
    case G.Romanian:
      e = await import("@amcharts/amcharts5/locales/ro_RO.js"), i = await import("../../chunks/messages.ro4.js");
      break;
    case G.Russian:
      e = await import("@amcharts/amcharts5/locales/ru_RU.js"), i = await import("../../chunks/messages.ru4.js");
      break;
    case G.Serbian:
      e = await import("@amcharts/amcharts5/locales/sr_RS.js"), i = await import("../../chunks/messages.sr4.js");
      break;
    case G.Slovak:
      e = await import("../../chunks/sk_SK2.js"), i = await import("../../chunks/messages.sk4.js");
      break;
    case G.Slovenian:
      e = await import("@amcharts/amcharts5/locales/sl_SL.js"), i = await import("../../chunks/messages.sl4.js");
      break;
    case G.Swedish:
      e = await import("@amcharts/amcharts5/locales/sv_SE.js"), i = await import("../../chunks/messages.sv4.js");
      break;
    case G.Thai:
      e = await import("@amcharts/amcharts5/locales/th_TH.js"), i = await import("../../chunks/messages.th4.js");
      break;
    case G.Turkish:
      break;
    case G.Ukrainian:
      e = await import("@amcharts/amcharts5/locales/uk_UA.js"), i = await import("../../chunks/messages.uk4.js");
      break;
    case G.Vietnamese:
      e = await import("@amcharts/amcharts5/locales/vi_VN.js"), i = await import("../../chunks/messages.vi4.js");
      break;
    case G.ChineseChina:
      e = await import("@amcharts/amcharts5/locales/zh_Hans.js"), i = await import("../../chunks/messages.zh-CN4.js");
      break;
    case G.ChineseHongKong:
      e = await import("@amcharts/amcharts5/locales/zh_Hant.js"), i = await import("../../chunks/messages.zh-HK4.js");
      break;
    case G.ChineseTaiwan:
      e = await import("@amcharts/amcharts5/locales/zh_Hant.js"), i = await import("../../chunks/messages.zh-TW4.js");
      break;
    case G.English:
  }
  return { ...e.default, ...i.default };
}
function ui(t) {
  const { type: e, iLocale: i, formatLocale: a = ia().formatLocale } = t;
  let n;
  switch (e) {
    case b.NumberAxisFormat: {
      n = new nm(), n.language.locale = i, n.intlLocales = a;
      break;
    }
    case b.DateAxisFormat: {
      n = new am(), n.language !== void 0 && (n.language.locale = i), n.intlLocales = a;
      break;
    }
  }
  return n;
}
function Vk(t) {
  let e = !1;
  return t instanceof fe && (e = B(t.uid, "isRotated") === !0 ? t.yAxes.getIndex(0) instanceof Ge : t.xAxes.getIndex(0) instanceof Ge), e;
}
function _l(t) {
  const { axis: e, valueFormat: i, chartType: a } = t, n = Tr({
    isXAxis: !0,
    chartType: a,
    valueFormat: i
  }), o = mi(i) && e instanceof Ge, s = Pe(i) && e instanceof Ne && !(e instanceof Ge), r = n && e instanceof kt;
  return !o && !s && !r;
}
function cd(t, e) {
  let i = typeof e == "number" ? `${e}` : e;
  const a = vt(t.uid, "numberFormatter");
  return a !== void 0 && (i = a(e)), be(i) && (i = T.htmlEmptyContent), rt(i);
}
function Ek(t) {
  t.renderer.labels.template.html = T.htmlEmptyContent, t.renderer.labels.template.adapter.add(
    "htmlOutput",
    (i, a) => cd(t, a?.dataItem?.value ?? i),
    0
  );
}
function Dp(t) {
  const { axis: e, defaultOutput: i, dataItem: a } = t;
  let n = i;
  const o = vt(e.uid, "categoryFormatter"), s = vt(e.uid, "numberFormatter");
  if ((s !== void 0 || o !== void 0) && a instanceof Gn) {
    const r = B(e.chart.uid, "config"), l = B(e.chart.uid, "rendererFieldNames");
    let c = Zt({
      value: a.category,
      dataContext: a.dataContext,
      useRendererLabel: Er(r, l)
    });
    if (typeof c == "number" && s !== void 0)
      n = s(c);
    else if (o !== void 0) {
      const d = H(r?.series);
      if ([
        L.BoxPlotMonoField,
        L.BoxPlotMultiFields,
        L.BoxPlotMonoFieldAndSplitBy,
        L.BoxPlotMultiFieldsAndSplitBy,
        L.BarAndLineFromFields
      ].includes(d) && typeof c == "string") {
        const m = B(e.chart.uid, "fieldList");
        c = Ve(m, c);
      }
      let f = $i(a.dataContext);
      f === void 0 && (f = c), n = o(c, f);
    }
  }
  return be(n) && (n = T.htmlEmptyContent), rt(n);
}
function Wk(t) {
  t.renderer.labels.template.html = T.htmlEmptyContent, t.renderer.labels.template.adapter.add(
    "htmlOutput",
    (i, a) => Dp({
      axis: t,
      defaultOutput: i,
      dataItem: a?.dataItem
    }),
    0
  );
}
function zk(t) {
  const { axis: e, defaultOutput: i, dataItem: a } = t;
  let n = i;
  const o = vt(e.uid, "dateFormatter");
  return o !== void 0 && a instanceof Fr && (n = o(a.value ?? i)), be(n) && (n = T.htmlEmptyContent), rt(n);
}
function Hk(t) {
  t.renderer.labels.template.adapter.add(
    "htmlOutput",
    (i, a) => zk({
      axis: t,
      dataItem: a?.dataItem,
      defaultOutput: i
    }),
    0
  ), t.renderer.labels.template.adapter.disableKey("htmlOutput");
}
function qk(t) {
  t.renderer.labels.template.adapter.add(
    "htmlOutput",
    (i) => {
      let a = i;
      const n = vt(t.uid, "fontStyleCallback");
      return n !== void 0 && (a = n(a)), rt(a);
    },
    1
  );
}
function Gk(t) {
  t instanceof Ne && !(t instanceof Ge) ? Ek(t) : t instanceof kt ? Wk(t) : t instanceof Ge && Hk(t), qk(t);
}
function Yk(t) {
  const { axis: e, formatOptions: i, dateAxisFormatter: a } = t;
  if (ht(e.uid, { dateFormatter: a }), a === void 0) {
    e.renderer.labels.template.adapter.isEnabled("htmlOutput") && (e.renderer.labels.template.adapter.disableKey("htmlOutput"), e.renderer.labels.each((s) => {
      s.element instanceof fS && s.element.removeChildren();
    }));
    const n = { ..._i(i) }, o = [
      "year",
      "month",
      "day",
      "hour",
      "minute",
      "second"
    ];
    e.timezone !== n.timeZone && (e.setPropertyValue("timezone", n.timeZone), e.chart.validateData()), e.dateFormatter.timezone = n.timeZone, delete n.timeZone;
    for (let s = 0; s < o.length; s += 1) {
      const r = o[s], l = s === 0 ? r : o[s - 1], c = i?.formatPerDateTimeUnit?.[r] ?? n, d = i?.formatPerDateTimeUnit?.[l];
      tn(c) || (e.dateFormats.setKey(r, c), e.periodChangeDateFormats.setKey(r, d ?? c));
    }
    e.dateFormats.getKey("day") || e.dateFormats.setKey("day", T.dayDefaultFormat), e.periodChangeDateFormats.getKey("day") || e.periodChangeDateFormats.setKey("day", T.dayDefaultFormat), e.dateFormats.getKey("week") || e.dateFormats.setKey("week", e.dateFormats.getKey("day") ?? T.weekDefaultFormat), e.periodChangeDateFormats.getKey("week") || e.periodChangeDateFormats.setKey(
      "week",
      e.periodChangeDateFormats.getKey("day") ?? T.weekDefaultFormat
    ), e.invalidateLabels();
  } else
    e.renderer.labels.template.html = T.htmlEmptyContent, e.renderer.labels.template.adapter.enableKey("htmlOutput");
}
function Xk(t, e, i, a) {
  const n = ui({
    type: b.NumberAxisFormat,
    iLocale: e,
    formatLocale: i
  });
  return n.numberFormat = t, (o) => {
    let s = 0;
    return o instanceof Date ? o.toLocaleString(void 0, t) : (s = typeof o != "string" ? o ?? 0 : Uf(o, n.intlLocales), a === !0 && t.style === "percent" && (s /= 100), n.format(s));
  };
}
function of(t) {
  const { axis: e, formatOptions: i, overridePercentMultiplication: a, valueAxisFormatter: n } = t, o = _i(i), s = B(e.chart.uid, "formatLocale");
  ht(e.uid, {
    numberFormatter: n ?? Xk(
      o,
      e.chart.language.locale,
      s,
      a
    )
  });
}
function Uk(t) {
  const { axis: e, formatOptions: i, categoryAxisFormatter: a } = t, n = a !== void 0 ? a : Hc(i.characterLimit);
  ht(e.uid, { categoryFormatter: n });
}
function jk(t) {
  const { axis: e, labelsTextSymbol: i, axisValueFormatter: a } = t, o = B(e.chart.uid, "config")?.horizontalAxisLabelsBehavior;
  if (ht(e.uid, { axisLabelsBehavior: o }), a !== void 0)
    ht(e.uid, { fontStyleCallback: void 0 });
  else if (vt(e.uid, "fontStyleCallback") === void 0) {
    const s = (r) => {
      const l = vt(e.uid, "axisLabelsBehavior");
      return Ht({
        textSymbol: i,
        placeholderString: r,
        format: "html",
        axisLabelsBehavior: l,
        defaults: { maxWidth: e.renderer.labels.template.maxWidth }
      });
    };
    ht(e.uid, { fontStyleCallback: s });
  }
}
async function _k(t) {
  const {
    axis: e,
    isXAxis: i,
    formatOptions: a,
    labelsTextSymbol: n,
    overridePercentMultiplication: o,
    chartType: s,
    axisValueFormatter: r,
    errorStrings: l
  } = t, c = Tr({
    isXAxis: i,
    chartType: s,
    valueFormat: a
  });
  let d = !1;
  !(e instanceof Ge) && Pe(a) ? of({
    axis: e,
    formatOptions: a,
    overridePercentMultiplication: o,
    valueAxisFormatter: r
  }) : e instanceof Ge && mi(a) ? Yk({
    axis: e,
    formatOptions: a,
    dateAxisFormatter: r
  }) : e instanceof kt ? Ya(a) || c ? (Uk({
    axis: e,
    formatOptions: a,
    categoryAxisFormatter: r
  }), ht(e.uid, { numberFormatter: void 0 })) : Pe(a) ? (of({
    axis: e,
    formatOptions: a,
    overridePercentMultiplication: o,
    valueAxisFormatter: r
  }), ht(e.uid, { categoryFormatter: void 0 })) : d = !0 : d = !0, d && await Ga("mismatchAxisAndValueFormat", l), jk({ axis: e, labelsTextSymbol: n, axisValueFormatter: r }), e.invalidateLabels();
}
const E = {
  Ready: "ready",
  Hidden: "hidden",
  Shown: "shown",
  Hit: "hit",
  DoubleHit: "doublehit",
  Up: "up",
  SelectEnded: "selectended",
  Over: "over",
  Out: "out",
  SizeChanged: "sizechanged",
  VisibilityChanged: "visibilitychanged",
  PositionChanged: "positionchanged",
  Validated: "validated",
  DataItemsValidated: "dataitemsvalidated",
  Inited: "inited",
  Opened: "opened",
  Closed: "closed",
  ChildAdded: "childadded",
  DataRangeChanged: "datarangechanged",
  LayoutValidated: "layoutvalidated"
};
function se(t, e) {
  e === !1 && !t.isHiding ? (t.visible = !1, t.hide()) : t.isShowing || (t.visible = !0, t.show());
}
function Zk(t, e) {
  for (let i = 0; i < e.length; i += 1) {
    const a = e[i][0], n = e[i][1], o = t.length;
    a >= 0 && a < o && n >= 0 && n < o && t.swap(e[i][0], e[i][1]);
  }
}
function Np(t, e) {
  let i;
  if (t !== void 0 && "rgb" in t && t.rgb !== void 0) {
    const a = t.rgb;
    if (a !== void 0) {
      const { r: n, g: o, b: s } = a;
      i = [n, o, s, 255];
    }
  }
  return i;
}
function mn(t) {
  const e = t ?? [0, 0, 0, 255];
  return new Us({
    a: e[3] / 255,
    b: e[2],
    g: e[1],
    r: e[0]
  });
}
function He(t) {
  return t.bullets.values.find(
    (i) => $k(i.uid, "isBulletMarker")
  );
}
function us(t) {
  return Xs(t.uid.toString(), Kg);
}
function gi(t) {
  return t != null && !t.isDisposed();
}
function qo(t) {
  return (t.isShowing || t.visible) && !t.isHidden && !t.isHiding && !t.disabled && !t.__disabled;
}
function Mp(t, e) {
  return t.pixelX < 0 || t.pixelX > e?.plotContainer?.measuredWidth || t.pixelY < 0 || t.pixelY > e?.plotContainer?.measuredHeight;
}
function Qk(t) {
  let e;
  return t.baseSprite instanceof fe || t.baseSprite instanceof Me ? e = t.baseSprite : (t instanceof Kb || t instanceof Jb) && (e = t.axis.chart), e;
}
function Kk(t) {
  return Np(t.background.fill);
}
function gn(t) {
  const { value: e, valueFormat: i, iLocale: a, formatLocale: n } = t;
  let o = e?.toString();
  const s = ui({
    type: i.type,
    iLocale: a,
    formatLocale: n
  });
  return (typeof e == "number" && i.type === b.NumberAxisFormat || (typeof e == "number" || e instanceof Date) && i.type === b.DateAxisFormat) && (o = s.format(e, _i(i))), o;
}
function fi(t) {
  const { chart: e, config: i } = t;
  let a = i;
  return i === void 0 && e !== void 0 && (a = B(e.uid, "config")), di(a);
}
function Jk(t) {
  t instanceof tm && t.series.each((e) => {
    pi(e.uid), e instanceof ye && pi(He(e)?.uid), e.bullets.each((i) => {
      pi(i.uid);
    }), e instanceof it && e.columns.template.children.each((i) => {
      pi(i.uid);
    });
  }), t instanceof fe && [t.xAxes.getIndex(0), t.xAxes.getIndex(1), t.yAxes.getIndex(0), t.yAxes.getIndex(1)].forEach(
    (e) => {
      e !== void 0 && (pi(e.uid ?? ""), e.axisRanges.each((i) => {
        pi(i.label?.uid);
      }));
    }
  ), t instanceof zt && t.radarContainer.children.each((e) => {
    pi(e.uid);
  }), t instanceof Me && t.series.getIndex(0)?.slices.each((e) => {
    pi(e.uid);
  }), "cursor" in t && t.cursor instanceof eS && pi(t.cursor?.uid), "legend" in t && t.legend !== void 0 && (pi(t.legend.uid), pi(t.legend.valueLabels?.template?.uid)), pi(t.uid);
}
function Is(t) {
  return typeof t == "number" ? t : t.value;
}
async function eI(t) {
  const { chart: e, exportOptions: i } = t, { format: a, quality: n = 1, ...o } = i, s = n < 0 || n > 1 ? 1 : n, r = await e.exporting.getImage(a, {
    quality: s,
    ...o
  }), l = gh(r), c = a === "jpg" ? "image/jpeg" : "image/png";
  return new File([l], `chart.${a}`, { type: c });
}
function tI(t) {
  const { fill: e, rotation: i, isLinePattern: a, chartBackgroundColor: n } = t;
  let o;
  return a !== !1 ? (o = new om(), o.width = T.patternLineProperties.width ?? Number.NaN, o.height = T.patternLineProperties.height ?? Number.NaN, o.strokeWidth = T.patternLineProperties.strokeWidth ?? Number.NaN, o.stroke = e, o.rotation = i ?? Number.NaN) : (o = new sm(), o.rectWidth = T.patternRectProperties.rectWidth ?? Number.NaN, o.rectHeight = T.patternRectProperties.rectHeight ?? Number.NaN, o.width = T.patternRectProperties.width ?? Number.NaN, o.height = T.patternRectProperties.height ?? Number.NaN, o.fillOpacity = T.patternRectProperties.fillOpacity ?? Number.NaN, o.strokeWidth = T.patternRectProperties.strokeWidth ?? Number.NaN, o.fill = mn(n), o.stroke = e, o.rotation = i ?? Number.NaN), o;
}
function sf(t) {
  let e = Number.NaN;
  if (typeof t == "number")
    e = t;
  else if (t.includes("%")) {
    const i = Number.parseFloat(t.trim().replace("%", "").trim());
    Number.isFinite(i) && (e = Ct(i));
  }
  return e;
}
function iI(t) {
  const { fill: e, style: i, chartBackgroundColor: a } = t;
  let n, o, s = !0;
  switch (i) {
    case Ot.Horizontal: {
      o = 0;
      break;
    }
    case Ot.Vertical: {
      o = 90;
      break;
    }
    case Ot.ForwardDiagonal: {
      o = 45;
      break;
    }
    case Ot.BackwardDiagonal: {
      o = 135;
      break;
    }
    case Ot.DiagonalCross:
    case Ot.Cross: {
      o = 0, s = !1;
      break;
    }
    case Ot.Solid:
  }
  return o !== void 0 && (n = tI({ fill: e, rotation: o, isLinePattern: s, chartBackgroundColor: a })), n;
}
function wt(t, e) {
  let i;
  e !== void 0 && (i = mn(e));
  let a = i ?? new Us({ r: 0, g: 0, b: 0, a: 0 });
  if (t != null) {
    const [n, o, s, r] = t;
    a = new Us({ r: n, g: o, b: s, a: r / 255 });
  }
  return a;
}
function $p(t, e = 0) {
  return (t ?? e) % 360;
}
function aI(t, e) {
  return e !== !0 || t?.includes("Dot") === !0 ? "round" : "square";
}
function nI(t, e) {
  let i = "";
  const o = (e ?? 0) / 2, s = 0 - o, r = 0 + o, l = 0 - o, c = 0 + o;
  switch (t) {
    case Xt.Circle:
      i = `M ${s},0 a ${o},${o} 0 1,0 ${o * 2},0 a ${o},${o} 0 1,0 ${-o * 2},0`;
      break;
    case Xt.Cross:
      i = `M ${s},0 L ${r},0 M 0,${l} L 0,${c} E`;
      break;
    case Xt.Diamond:
      i = `M ${s},0 L 0,${l} L ${r},0 L 0,${c} L ${s},0 Z`;
      break;
    case Xt.Square:
      i = `M ${s},${c} L ${s},${l} L ${r},${l} L ${r},${c} L ${s},${c} Z`;
      break;
    case Xt.Triangle:
      i = `M ${s},${c} L 0,${l} L ${r},${c} L ${s},${c} Z`;
      break;
    case Xt.X:
      i = `M ${s},${c} L ${r},${l} M ${s},${l} L ${r},${c} E`;
      break;
  }
  return i;
}
function Pp(t, e) {
  let i = "none";
  switch (t ?? e) {
    case he.Justify:
    case he.Center:
      i = "center";
      break;
    case he.Left:
      i = "left";
      break;
    case he.Right:
      i = "right";
      break;
  }
  return i;
}
function dd(t, e) {
  let i = "middle";
  switch (t ?? e) {
    case he.Right:
      i = "left";
      break;
    case he.Left:
      i = "right";
      break;
    case he.Center:
    case he.Justify:
  }
  return i;
}
function oI(t, e) {
  let i = "none";
  switch (t ?? e) {
    case ce.Baseline:
    case ce.Middle:
      i = "middle";
      break;
    case ce.Top:
      i = "top";
      break;
    case ce.Bottom:
      i = "bottom";
      break;
  }
  return i;
}
function Rp(t, e) {
  let i = ce.Middle;
  switch (t ?? e) {
    case ce.Top:
      i = "bottom";
      break;
    case ce.Bottom:
      i = "top";
      break;
    case ce.Baseline:
    case ce.Middle:
    default:
      i = "middle";
      break;
  }
  return i;
}
function sI(t, e) {
  const i = t ?? xt.Solid, a = e ?? T.lineWidth, n = {
    [xt.Solid]: "none",
    [xt.Dot]: [1, a],
    [xt.DashDotDot]: [4 * a, a, 1, a, 1, a],
    [xt.Dash]: [4 * a, 3 * a],
    [xt.DashDot]: [4 * a, 3 * a, 1, 3 * a],
    [xt.Null]: "none"
  };
  return (n[i] ?? n[xt.Null]).toString();
}
function Vp(t, e) {
  const i = {
    stroke: wt(),
    strokeWidth: T.lineWidth,
    strokeDasharray: "",
    strokeLinecap: e !== !0 ? "round" : "square",
    strokeOpacity: Qo
  };
  return t != null && (i.stroke = wt(t.color), i.strokeOpacity = 1, t.width !== void 0 && (i.strokeWidth = t.width), t.style !== void 0 && t.style !== xt.Null && (i.strokeDasharray = sI(t.style, i.strokeWidth), i.strokeLinecap = aI(t.style, e))), i;
}
function Ep(t, e) {
  let i = t;
  const [a, n, o, s] = t?.color ?? e ?? T.color, r = [a, n, o, s];
  return i == null ? i = { type: re.SLS, color: r } : i.color === void 0 && (i.color = r), Vp(i, !1);
}
function rI(t, e) {
  const { color: i, outline: a, style: n } = t, o = wt(i);
  return {
    pattern: iI({ fill: o, style: n, chartBackgroundColor: e }),
    fill: o,
    outline: Ep(a, i)
  };
}
function lI(t) {
  const { color: e, outline: i, xoffset: a, yoffset: n, style: o, size: s, angle: r } = t, l = o !== void 0 ? nI(o, s) : "", c = $p(r);
  return {
    path: l,
    fill: wt(e),
    outline: Ep(i, e),
    xOffset: a ?? 0,
    yOffset: n ?? 0,
    angle: c
  };
}
function ud(t) {
  const { symbol: e, defaultToColorFromRamp: i, colorRampIndex: a, isChartFillSymbol: n = !1, chartBackgroundColor: o } = t;
  let s;
  if (i === !0) {
    const r = n ? io : Qo;
    if (e.color = e.color ?? Si({ colorIndex: a, opacity: r }), Ys(e) || $n(e)) {
      const { outline: l } = e;
      l !== void 0 && (l.color = l?.color ?? Si({ colorIndex: a }), e.outline = { ...l });
    }
  }
  return $n(e) && (e.style ??= T.lineMarker.markerStyle, e.size ??= T.lineMarker.markerSize), Jf(e) ? s = Vp(e, !0) : $n(e) ? s = lI(e) : Ys(e) && (s = rI(e, o)), s;
}
function lr(t, e, i) {
  const a = dd(t.horizontalAlignment, i?.horizontalCenter), n = Pp(t.horizontalAlignment, i?.align), o = Rp(t.verticalAlignment, i?.verticalCenter), s = oI(t.verticalAlignment, i?.valign);
  return {
    fill: wt(t.color, T.color),
    fontFamily: t.font?.family ?? "Arial, Helvetica, sans-serif",
    fontSize: t.font?.size ?? T.generalFontSize,
    fontWeight: t.font?.weight ?? "400",
    textDecoration: t.font?.decoration ?? "none",
    align: n,
    valign: s,
    verticalCenter: o,
    horizontalCenter: a,
    text: Ht({ textSymbol: t, format: "amChartsV4" }),
    angle: $p(t.angle, i?.rotation),
    xOffset: t.xoffset ?? i?.dx ?? 0,
    yOffset: t.yoffset ?? i?.dy ?? 0,
    backgroundFill: wt(t.backgroundColor),
    borderFill: wt(t.borderLineColor),
    borderWidth: t.borderLineSize ?? 1,
    haloSize: t.haloSize ?? -1,
    haloColor: wt(t.haloColor),
    rtl: t.rightToLeft ?? e,
    wrap: i?.wrap ?? !1,
    maxWidth: i?.maxWidth ?? Number.NaN
  };
}
function Zr(t, e) {
  e !== void 0 && (e.marginBottom !== void 0 && (t.marginBottom = e.marginBottom), e.marginTop !== void 0 && (t.marginTop = e.marginTop), e.marginRight !== void 0 && (t.marginRight = e.marginRight), e.marginLeft !== void 0 && (t.marginLeft = e.marginLeft), e.verticalCenter !== void 0 && (t.verticalCenter = Rp(e.verticalCenter)), e.horizontalCenter !== void 0 && (t.horizontalCenter = dd(e.horizontalCenter)), e.strokeWidth !== void 0 && (t.strokeWidth = e.strokeWidth), e.wrap !== void 0 && (t.wrap = e.wrap), e.truncate !== void 0 && (t.truncate = e.truncate), e.maxWidth !== void 0 && (t.maxWidth = e.maxWidth), e.applyOnClones !== void 0 && (t.applyOnClones = e.applyOnClones, t.background.applyOnClones = e.applyOnClones));
}
function Ci(t, e) {
  const i = e?.createChild(Vo) ?? new Vo();
  return Zr(i, t), i;
}
function cI(t) {
  const e = t.push(new mS());
  e.dx = 1, e.dy = 1, e.opacity = 1;
}
function dI(t, e, i) {
  if (i.alpha > 0 && e >= 0) {
    t.length === 0 && cI(t);
    const a = t.getIndex(0);
    a.blur = e, a.color = i;
  } else
    t.clear();
}
function uI(t, e) {
  const i = dt(t.uid, "isGuide");
  let a = e.visible === !1;
  return !a && (i === !0 || !(t instanceof yc)) && e.content.text === "" && (a = !0), a;
}
function rf(t) {
  const { label: e, offset: i, offsetProperty: a } = t, n = 99;
  if (e.adapter.remove(a, n), typeof i == "string" && !Number.isFinite(Number(i))) {
    let o = kr(i);
    o !== void 0 && (o /= 100, e.adapter.add(
      a,
      () => (e.parent?.[a === "dx" ? "measuredWidth" : "measuredHeight"] ?? 0) * o,
      n
    ));
  } else
    e[a] = i;
}
function Kt(t) {
  const { label: e, labelConfig: i, defaults: a, skipSettingText: n } = t;
  if (i !== void 0) {
    const o = lr(i.content, e.rtl, a);
    e.fill = o.fill, e.fontFamily = o.fontFamily, e.fontWeight = o.fontWeight, e.fontSize = o.fontSize, e.textDecoration = o.textDecoration, e.align = o.align, e.valign = o.valign, e.verticalCenter = o.verticalCenter, e.horizontalCenter = o.horizontalCenter, e.background.fill = o.backgroundFill, e.background.stroke = o.borderFill, e.background.strokeWidth = o.borderWidth, e.rotation = o.angle, rf({ label: e, offset: o.xOffset, offsetProperty: "dx" }), rf({ label: e, offset: o.yOffset, offsetProperty: "dy" }), e.rtl = o.rtl, e.wrap = o.wrap, e instanceof yc || (e.maxWidth = o.maxWidth), n || (e.text = o.text), dI(e.filters, o.haloSize, o.haloColor);
    const s = uI(e, i);
    e.disabled = s, se(e, i.visible !== !1 && !s);
  } else
    e.disabled = !0;
}
function fd(t, e) {
  e !== void 0 && (t === b.BarSeries || t === b.LineSeries || t === b.HistogramSeries) && e.adapter.add("dy", (i, a) => {
    const n = a.dataItem, { chart: o } = n?.component ?? {};
    return o instanceof fe && (a.visible = !Mp(a, o)), i ?? 0;
  });
}
function Wp(t, e) {
  e !== void 0 && (t === b.BarSeries && e.adapter.add("dx", (i, a) => {
    let n = i ?? 0;
    const o = a.dataItem, { chart: s } = o?.component ?? {};
    return (s !== void 0 ? B(s.uid, "isRotated") : !1) === !0 && (o.valueX ?? o.valueY) < 0 && (n -= a.measuredWidth + T.dataLabelNegative.paddingRight), n;
  }), (t === b.BarSeries || t === b.LineSeries) && e.adapter.add("dy", (i, a) => {
    let n = i ?? 0;
    const o = a.dataItem, { chart: s } = o?.component ?? {};
    return (s !== void 0 ? B(s.uid, "isRotated") : !1) !== !0 && (o.valueX ?? o.valueY) < 0 && (n += a.measuredHeight + T.dataLabelNegative.paddingTop), n;
  }));
}
function Zl(t) {
  t.bulletsContainer.invalidateLabels(), t instanceof it && t.columns?.template.invalidateLabels();
}
function Ql(t) {
  const { dataValue: e, series: i, seriesType: a, stackedType: n, axisMin: o } = t;
  let s = e === void 0;
  return e !== void 0 && (o !== void 0 && e < o ? s = !0 : i instanceof it && (a === b.BarSeries || a === b.ComboLineAndBarSeries) && (s = e === 0 && n !== void 0 && n !== Ie.Side)), s;
}
function Go(t, e) {
  let i;
  const a = (n) => dt(n.uid, "isDataLabel") ?? !1;
  return e === "bullets" ? i = t.bullets.values.find(a) : t instanceof it && (i = t.columns.template.children.values.find(a)), i;
}
function Kl(t, e) {
  t.adapter.add(
    "htmlOutput",
    (i, a) => {
      let n = i;
      const { dataItem: o } = a;
      if (qo(t) && (e instanceof it && o instanceof Ko || e instanceof ye && o instanceof Ha)) {
        const s = te(
          e.uid,
          e instanceof it ? "barSeriesDataLabelFormatter" : "lineSeriesDataLabelFormatter"
        );
        if (s !== void 0) {
          const r = B(e.chart.uid, "isRotated"), l = te(e.uid, "stackedType"), c = r === !0 ? o.valueX : o.valueY, d = r === !0 ? o.values?.valueX?.totalPercent : o.values?.valueY?.totalPercent, u = r === !0 ? (o.component?.xAxis).min : (o.component?.yAxis).min;
          n = Ql({
            dataValue: c,
            series: e,
            seriesType: e instanceof it ? b.BarSeries : b.LineSeries,
            stackedType: l,
            axisMin: u
          }) ? "" : s(c, d);
        }
      }
      return rt(n);
    },
    0
    // 0 = high priority
  );
}
function zp(t) {
  const { numberFormatter: e, dataLabelsConfigContent: i, stackedType: a } = t;
  return (n, o) => {
    let s = a === Ie.Stacked100 && o !== void 0 ? o : n;
    return e.numberFormat.style === "percent" && (s /= 100), Ht({
      textSymbol: {
        ...i,
        text: e.format(s)
      },
      format: "html"
    });
  };
}
function md(t) {
  t.tabindex = -1;
}
function Qr(t) {
  const {
    series: e,
    seriesType: i,
    dataLabel: a,
    labelDefaults: n,
    dataLabelsConfig: o,
    yAxisValueFormat: s,
    stackedType: r,
    isRotated: l,
    defaultDataLabelFormatter: c,
    customDataLabelFormatter: d
  } = t;
  if (a !== void 0) {
    let u = d;
    const f = o?.content ?? { type: re.TS };
    if (d === void 0 && c !== void 0 && s?.type === b.NumberAxisFormat) {
      const g = B(e.chart.uid, "formatLocale"), y = ui({
        type: s.type,
        iLocale: e.chart.language.locale,
        formatLocale: g
      });
      y.numberFormat = s.intlOptions, u = c({
        numberFormatter: y,
        dataLabelsConfigContent: f,
        stackedType: r
      });
    }
    let m;
    switch (i) {
      case b.BarSeries:
        m = "barSeriesDataLabelFormatter";
        break;
      case b.LineSeries:
        m = "lineSeriesDataLabelFormatter";
        break;
      case b.HistogramSeries:
        m = "histogramDataLabelFormatter";
        break;
      case b.ScatterSeries:
        m = "scatterplotDataLabelFormatter";
        break;
    }
    m !== void 0 && et(e.uid, {
      [m]: u
    }), o !== void 0 && (o.content.text = l === !0 ? "{valueX}" : "{valueY}", o.visible = o.visible !== !1), Kt({
      label: a,
      labelConfig: o,
      defaults: n ?? T.dataLabel
    }), Zl(e);
  }
}
function Fn(t, e) {
  let i = e;
  i === void 0 && (i = B(t.uid, "config"));
  const a = B(t.uid, "colorMatchApplied") ?? !1;
  return (i?.colorMatch ?? !1) && a;
}
function Hp(t, e) {
  let i;
  return t instanceof Ge ? i = e === !0 ? "dateY" : "dateX" : t instanceof kt ? i = e === !0 ? "categoryY" : "categoryX" : i = e === !0 ? "valueY" : "valueX", i;
}
function Gi(t, e) {
  t.name = e;
}
function qp(t) {
  const { axes: e, currentSeries: i, tooltipValueFormat: a } = t, n = e[1].valueFormat, o = e[0].valueFormat, s = B(i.chart.uid, "formatLocale");
  if (n?.type === b.NumberAxisFormat) {
    const r = ui({
      type: n.type,
      iLocale: i.chart.language.locale,
      formatLocale: s
    });
    r.numberFormat = n.intlOptions, et(i.uid, {
      tooltipValueYNumberFormatCallback: (l) => r.format(l, a?.intlOptions)
    });
  }
  if (o?.type === b.NumberAxisFormat) {
    const r = ui({
      type: o.type,
      iLocale: i.chart.language.locale,
      formatLocale: s
    });
    r.numberFormat = o.intlOptions, et(i.uid, {
      tooltipValueXNumberFormatCallback: (l) => r.format(l, a?.intlOptions)
    });
  }
}
function Kr(t) {
  const { chart: e, lineSeries: i, applyPropertiesToClones: a } = t, n = i.bullets.push(new xc());
  return Pk(n.uid, { isBulletMarker: !0 }), a !== !1 && (n.applyOnClones = !0), i.bulletsContainer.parent = e.seriesContainer, n;
}
function gd(t) {
  const { series: e, seriesConfig: i, rotationChanged: a, stackedType: n, isRotated: o } = t;
  switch (n) {
    case Ie.Stacked: {
      e.stacked = !0, e instanceof ye && (e.stackToNegative = i.stackNegativeValuesToBaseline ?? T.lineSeries.stackNegativeValuesToBaseline), a === o ? e.dataFields.valueYShow = void 0 : e.dataFields.valueXShow = void 0, e.updateStacking();
      break;
    }
    case Ie.Stacked100: {
      e.stacked = !0, o ? e.dataFields.valueXShow = "totalPercent" : e.dataFields.valueYShow = "totalPercent", e.updateStacking();
      break;
    }
    case Ie.Side:
    default: {
      e.stacked = !1, a === o ? e.dataFields.valueYShow = void 0 : e.dataFields.valueXShow = void 0;
      break;
    }
  }
}
function fI(t) {
  return () => {
    const { chart: e, marker: i } = t;
    i.clones.each((a) => {
      se(a, !Mp(a, e));
    });
  };
}
function Gp(t) {
  const { chart: e, series: i, seriesType: a, marker: n, numberOfChartSeries: o, ignoreSmoothRenderingLimit: s } = t;
  let r = fI({ marker: n, chart: e });
  const l = o ?? 1, c = e.data.length * l + l;
  s !== !0 && c > T.elementLimitForSmoothRendering && (r = at(r, T.debounceTime)), e.xAxes.getIndex(0)?.events.on(E.Validated, r), e.yAxes.getIndex(0)?.events.on(E.Validated, r), a === b.LineSeries && (e.xAxes.getIndex(0)?.events.on(E.Validated, () => {
    Zl(i);
  }), e.yAxes.getIndex(0)?.events.on(E.Validated, () => {
    Zl(i);
  }));
}
function Yp(t, e) {
  t.series.each((i) => {
    const a = te(i.uid, e);
    a !== void 0 && !a.isDisposed() && a.dispose();
  });
}
function mI(t) {
  let e;
  return t !== void 0 && t.series.length > 0 && (e = t.series.values.map((i) => i.visible ? i.id : "").filter((i) => i !== "")), e;
}
function Ll(t) {
  const { dataItem: e, y: i, splitBy: a, showOutliers: n } = t, o = oe({ key: Y.Min, y: i, splitBy: a, showOutliers: n }), s = oe({ key: Y.Max, y: i, splitBy: a, showOutliers: n }), r = oe({ key: Y.FirstQuartile, y: i, splitBy: a, showOutliers: n }), l = oe({ key: Y.ThirdQuartile, y: i, splitBy: a, showOutliers: n });
  return Number.isFinite(e[o]) && Number.isFinite(e[s]) && Number.isFinite(e[r]) && Number.isFinite(e[l]);
}
function gI(t, e) {
  let i = !1;
  if (e !== void 0) {
    const a = oe({ key: Y.Average, splitBy: e });
    i = Number.isFinite(t[a]);
  }
  return i;
}
function hI(t, e) {
  let i = 0;
  if (t !== void 0 && e !== void 0) {
    const a = pt(e.series), n = H(e.series), o = Mi(e);
    t.data.forEach((s) => {
      switch (n) {
        case L.BoxPlotMonoField:
        case L.BoxPlotMultiFields:
        case L.BoxPlotMonoFieldAndCategory:
          Ll({ dataItem: s, showOutliers: o }) && (i += 1);
          break;
        case L.BoxPlotMultiFieldsAndCategory:
          a.forEach((r) => {
            Ll({ dataItem: s, y: r, showOutliers: o }) && (i += 1);
          });
          break;
        case L.BoxPlotMonoFieldAndSplitBy:
        case L.BoxPlotMultiFieldsAndSplitBy:
        case L.BoxPlotMonoFieldAndCategoryAndSplitBy:
          e.series.forEach((r) => {
            Ll({ dataItem: s, splitBy: r.query?.where, showOutliers: o }) && (i += 1);
          });
          break;
      }
    });
  }
  return i;
}
function lf() {
  return (t) => {
    const e = B(t.chart.uid, "config");
    let i = !1;
    if (e !== void 0 && t instanceof ca) {
      const a = hI(t.chart, e);
      let n = 0, o = 0, s = 0, r = 0, l = 0;
      t.chart.series.values.forEach((u) => {
        if (u instanceof ut)
          n += u.columns.length;
        else if (u instanceof ye && !(u instanceof _t)) {
          const f = He(u);
          if (f !== void 0 && !f.disabled) {
            const m = f.clones.values.filter((g) => !(g.dataItem instanceof qa))?.length ?? 0;
            if (te(u.uid, "isBoxPlotMeanLineSeries") === !0) {
              r += m;
              const g = u.data.filter(
                (y) => Number.isFinite(y[u.dataFields.valueX ?? u.dataFields.valueY ?? ""])
              ).length;
              l += g;
            } else {
              const g = u.data.filter(
                (y) => Number.isFinite(y[u.dataFields.valueX ?? u.dataFields.valueY ?? ""])
              ).length;
              s += g, o += m;
            }
          }
        }
      });
      const c = s === 0 || o >= s, d = l === 0 || r >= l;
      i = n >= a && c && d && t.chart.appeared && t.isReady() && t.chart.isReady();
    }
    return i;
  };
}
function pI(t, e) {
  let i;
  switch (t) {
    case b.BarSeries:
      i = (a, n) => {
        if (a instanceof it) {
          const o = fi({ chart: a.chart });
          let s = 0;
          if (n.type === b.BarSeries) {
            const r = (o ? a.dataFields.valueX : a.dataFields.valueY) ?? n.y;
            s = a.chart?.data?.filter(
              (l) => Number.isFinite(l[r])
            ).length;
          }
          return a.chart.isReady() && a.columns.length === s;
        }
        return !1;
      };
      break;
    case b.LineSeries:
      e === !0 ? i = lf() : i = (a, n) => {
        if (a instanceof ye) {
          const o = fi({ chart: a.chart }), s = He(a);
          let r = 0;
          if (n.type === b.LineSeries) {
            const { y: l } = n, c = (o ? a.dataFields.valueX : a.dataFields.valueY) ?? [l].flat()[0];
            r = a.chart?.data?.filter(
              (d) => Number.isFinite(d[c])
            ).length;
          }
          return a.chart.appeared && a.chart.isReady() && s !== void 0 && s.clones.values.length >= r;
        }
        return !1;
      };
      break;
    case b.PieSeries:
      i = (a) => a instanceof xi && a.slices.length > 0;
      break;
    case b.ScatterSeries:
      i = (a) => {
        const n = a instanceof ye ? He(a) : void 0, o = te(a.uid, "isOverlay") === !0;
        return a.chart.appeared && a.chart.isReady() && (o || n !== void 0 && a.chart.data.length === n.clones.length);
      };
      break;
    case b.HistogramSeries:
      i = (a) => a instanceof it && a.columns.length > 0;
      break;
    case b.BoxPlotSeries:
      i = lf();
      break;
  }
  return i;
}
function Xp(t) {
  const { series: e, callbackInfo: i, seriesConfig: a, onReadyEvent: n } = t, { type: o } = i, s = z([a]), r = te(e.uid, "isBoxPlotMeanLineSeries"), l = o === "style" ? "updateStyleCallbackDisposer" : "updateSelectionCallbackDisposer", c = async (m) => {
    const { type: g, callbackProps: y } = m;
    g === "selection" ? aB(y) : m.styleCallback !== void 0 && (se(e, a.visible), await m.styleCallback(y));
  };
  n === !0 && e.events.once(E.Ready, async () => await c(i));
  let d = te(e.uid, l);
  d !== void 0 && d.dispose();
  const u = pI(s, r);
  d = (s === b.PieSeries ? e.chart : e).events.on(E.Validated, async () => {
    u !== void 0 && u(e, a) && (d !== void 0 && d.dispose(), await c(i));
  }), e.dispatchImmediately(E.Validated), et(e.uid, { [l]: d });
}
function hn(t) {
  const { series: e, styleCallback: i, callbackProps: a, onReadyEvent: n, seriesConfig: o } = t;
  Xp({
    callbackInfo: { styleCallback: i, callbackProps: a, type: "style" },
    series: e,
    seriesConfig: o,
    onReadyEvent: n
  });
}
function yI(t) {
  const { series: e, callbackProps: i, seriesConfig: a, onReadyEvent: n } = t;
  Xp({
    callbackInfo: { callbackProps: i, type: "selection" },
    series: e,
    seriesConfig: a,
    onReadyEvent: n
  });
}
function xa(t) {
  const { defaultChartItemRole: e } = T.aria;
  t instanceof ut || t instanceof it ? (t.columns.template.properties.role = e, t.columns.template.focusable = !0, t.columns.template.hoverOnFocus = !0, t.itemReaderText = _s()) : t instanceof _t ? t.segments.template.properties.role = e : t instanceof ye ? t.bullets.values.forEach((i) => {
    i.focusable = !0, i.properties.role = e, i.readerTitle = _s(), i.hoverOnFocus = !0;
  }) : t instanceof xi && (t.slices.template.properties.role = e, t.slices.template.hoverOnFocus = !0, t.itemReaderText = "{category} {value.formatNumber('#.#')} {value.percent.formatNumber('#.#')}%");
}
function bI(t) {
  const e = B(t.uid, "config");
  t.series.each((i) => {
    const a = e?.series?.find((n) => n.id === i.id);
    a !== void 0 && a.visible !== !1 && !i.visible && se(i);
  });
}
function Jr(t, e) {
  const i = z(e?.series);
  return e?.series.find((a) => {
    let n = !1;
    return i !== b.BoxPlotSeries || t instanceof ut ? n = t.id === a.id : t instanceof _t ? n = t.id.replace(`_${ve.Top}`, "") === a.id || t.id.replace(`_${ve.Median}`, "") === a.id || t.id.replace(`_${ve.Bottom}`, "") === a.id : t instanceof ye && (n = t.id.replace(`_${ve.Outliers}`, "") === a.id), n;
  });
}
function Up(t) {
  let e = "";
  return t instanceof ca ? e = t.dataFields?.categoryX ?? t.dataFields?.dateX ?? t.dataFields?.valueX ?? "" : t instanceof xi && (e = t.dataFields?.category ?? ""), e;
}
function jp(t) {
  let e = "";
  return t instanceof ca ? e = t.dataFields?.categoryY ?? t.dataFields?.dateY ?? t.dataFields?.valueY ?? "" : t instanceof xi && (e = t.dataFields?.value ?? ""), e;
}
function _p(t) {
  return B(t.chart.uid, "isRotated") === !0 ? jp(t) : Up(t);
}
function Za(t) {
  return B(t.chart.uid, "isRotated") === !0 ? Up(t) : jp(t);
}
function fs(t, e = 0) {
  const i = B(t.chart.uid, "config");
  return z(i?.series, e);
}
function Zp(t, e, i) {
  i !== void 0 && t.tooltip !== void 0 && (t.tooltip.getFillFromObject = !1, t.tooltip.background.fill = e), t.fill = i ?? e, t.fillOpacity = Ar(t.fill.toString()).alpha === 0 ? 0 : 1;
}
function Vn(t, e) {
  t.stroke = e.stroke, t.strokeOpacity = e.stroke.alpha === 0 ? 0 : 1, t.strokeDasharray = e.strokeDasharray, t.strokeLinecap = e.strokeLinecap, t.strokeWidth = e.strokeWidth;
}
function hd(t) {
  const { element: e, markerSymbol: i, visible: a, defaultToColorFromRamp: n, colorRampIndex: o } = t;
  let s;
  return i !== void 0 ? (s = ud({
    symbol: { ...i, size: e.minWidth ?? i.size },
    defaultToColorFromRamp: n,
    colorRampIndex: o
  }), s !== void 0 && (e.path = s.path, e.rotation = s.angle, e.dx = s.xOffset, e.dy = s.yOffset, Zp(e, s.fill), Vn(e, s.outline)), se(e, a), e.disabled = a === !1) : e.disabled = !0, s;
}
function Bi(t) {
  const { element: e, lineSymbol: i, visible: a, defaultToColorFromRamp: n, colorRampIndex: o } = t;
  let s;
  return i !== void 0 ? (s = ud({
    symbol: i,
    defaultToColorFromRamp: n,
    colorRampIndex: o
  }), s !== void 0 && Vn(e, s), se(e, a)) : se(e, !1), s;
}
function Yo(t) {
  const { element: e, fillSymbol: i, visible: a, defaultToColorFromRamp: n, colorRampIndex: o, isChartFillSymbol: s } = t;
  let r, l;
  if (i !== void 0) {
    if (i.style === Ot.Cross || i.style === Ot.DiagonalCross) {
      const c = Qk(e);
      c !== void 0 && (l = Kk(c));
    }
    r = ud({
      symbol: i,
      defaultToColorFromRamp: n,
      colorRampIndex: o,
      isChartFillSymbol: s,
      chartBackgroundColor: l
    }), r !== void 0 && (Zp(e, r.fill, r.pattern), Vn(e, r.outline)), e.disabled = a === !1;
  } else
    e.disabled = !0;
  return r;
}
function ma(t) {
  const { element: e, seriesIndex: i, colorMatch: a, seriesSymbol: n, isChartFillSymbol: o, rendererSymbol: s, seriesConfig: r } = t;
  let l, c;
  a === !0 && s && (l = jg({
    rendererSymbol: s,
    seriesSymbol: n,
    colorIndex: i
  }));
  const d = {
    element: e,
    defaultToColorFromRamp: !0,
    colorRampIndex: i,
    seriesConfig: r
  }, u = l ?? { ...n };
  switch (n.type) {
    case re.SLS:
      c = Bi({
        ...d,
        lineSymbol: u
      });
      break;
    case re.SFS:
      c = Yo({
        ...d,
        fillSymbol: u,
        isChartFillSymbol: o
      });
      break;
    case re.SMS:
      c = hd({
        ...d,
        markerSymbol: u
      });
      break;
  }
  return { symbolWithColorInfo: u, stylingInfo: c };
}
function cf(t, e) {
  if (e !== void 0) {
    const i = t.properties, { elementColor: a, elementOutlineColor: n, elementOutlineWidth: o, rotation: s, transformation: r } = e, { opacity: l, scale: c } = r ?? {};
    a !== void 0 && (i.fill = mn(a), i.fillOpacity = Ar(i.fill.toString()).alpha === 0 ? 0 : 1), n !== void 0 && (i.stroke = mn(n)), o !== void 0 && (i.strokeWidth = o), s !== void 0 && (i.rotation = s), c !== void 0 && (i.scale = c), l !== void 0 && (i.fillOpacity = (i.fillOpacity ?? 1) * l, i.strokeOpacity = (i.strokeOpacity ?? 1) * l);
  }
}
function SI(t, e) {
  let i = !1;
  if (e !== void 0 && qo(t)) {
    const a = rm.spriteRectToSvg(t.bbox, t), n = e.x, o = e.y, s = e.x + e.width, r = e.y + e.height, l = a.x, c = a.y, d = a.x + a.width, u = a.y + a.height;
    i = !(l > s || d < n || c > r || u < o);
  }
  return i;
}
function Ca(t) {
  const { element: e, customSelectionTheme: i, useNativeState: a } = t, n = a === !0 ? Tt.Active : Tt.CustomActive, o = e.states.getKey(n) ?? e.states.create(n), s = e.states.getKey(Tt.CustomInactive) ?? e.states.create(Tt.CustomInactive), { selectedElementsTheme: r, nonSelectedElementsTheme: l } = i ?? T.selectionTheme ?? {};
  cf(o, r), cf(s, l);
}
function vi(t) {
  const { element: e, selected: i, multiSelect: a, isDateOrCategoryAxis: n, useNativeState: o, backToDefaultState: s } = t;
  if (e !== void 0) {
    let r = e.isActive;
    a !== !0 ? n === !0 ? r = e.isActive ? !1 : e.isActive !== i : r = i : r = e.isActive !== i, r !== e.isActive && (e.isActive = r);
    const l = o === !0 ? Tt.Active : Tt.CustomActive, c = s === !0 ? Tt.Default : Tt.CustomInactive;
    e.setState(e.isActive ? l : c, 0);
  }
  return e?.isActive ?? !1;
}
function el(t, e) {
  let i = !1;
  if (e instanceof fe || e instanceof Me) {
    const a = B(e.uid, "actionMode");
    a !== void 0 && (i = a === ne.MultiSelection || a === ne.MultiSelectionWithCtrlKey && (t?.event?.ctrlKey || t?.event?.metaKey));
  }
  return i;
}
function Qp(t) {
  const e = B(t.uid, "config"), i = qe(e), a = t instanceof fe && t.zoomOutButton.isHover, n = t.legend.isHover;
  let o = !1, s = !1, r = !1, l = !1;
  return t instanceof fe && (o = t.xAxes.values.some(
    (c) => c.renderer.labels.template.events.has(E.Hit) && c.renderer.isHover
  ), s = t.yAxes.values.some(
    (c) => c.renderer.labels.template.events.has(E.Hit) && c.renderer.isHover
  ), r = o || s, i && (l = t.series.values.find((d) => d instanceof ut)?.isHover ?? !1)), !a && !n && !r && !l;
}
function pd(t, e) {
  return t.values.filter((i) => {
    let a = !1;
    const n = !i.isActive;
    if (!(i.dataItem instanceof qa)) {
      i.isActive = !i.isActive;
      const s = B(e.uid, "filterBySelection") !== !0 && n;
      vi({ element: i, selected: s }), a = n;
    }
    return a;
  });
}
function df(t, e) {
  let i = [];
  const { columns: a, chart: n } = t, o = B(n.uid, "config");
  if (o && a !== void 0 && t.visible) {
    const s = o?.series[0].x, r = t?.dataFields?.customValue ?? "", l = fs(t, e), c = Jr(t, o), d = l === b.BoxPlotSeries ? c?.y : Za(t), u = {
      element: {},
      yAxisField: d,
      xAxisField: s,
      splitBy: r,
      chartType: l,
      seriesIndex: e
    };
    l === b.HistogramSeries && e === 0 && (u.xAxisField = r, u.dataTransformationType = (o?.series[0]).dataTransformationType), i = pd(a, n).map(
      (f) => ({
        ...u,
        element: f,
        elementDataContext: f.dataItem?.dataContext,
        elementIndex: f.dataItem?.index
      })
    );
  }
  return i;
}
function uf(t, e) {
  let i = [];
  if (t.visible) {
    const a = He(t)?.clones;
    if (a !== void 0) {
      const { chart: n } = t, o = B(n.uid, "config"), s = z(o?.series, e), r = o?.series[0].x ?? "", l = Za(t), c = t?.dataFields?.customValue ?? "", d = {
        element: {},
        xAxisField: r,
        yAxisField: l,
        splitBy: c,
        chartType: s,
        uniqueFeature: s === b.ScatterSeries,
        // a line series marker can be aggregated
        seriesIndex: e
      };
      i = pd(a, n).map(
        (u) => ({
          ...d,
          element: u,
          elementDataContext: u.dataItem?.dataContext,
          elementIndex: u.dataItem?.index
        })
      );
    }
  }
  return i;
}
function xI(t) {
  let e = [];
  if (t.visible) {
    const { chart: i } = t, a = _p(t), n = Za(t), o = {
      element: {},
      xAxisField: a,
      yAxisField: n,
      chartType: b.PieSeries,
      seriesIndex: 0
    };
    let s;
    e = pd(t.slices, i).map(
      (r) => {
        const l = r.dataItem?.dataContext ?? {};
        return qi(l) && (s = ss({
          groupOfSlicesDataContext: l
        })), {
          ...o,
          element: r,
          elementIndex: r.dataItem?.index,
          elementDataContext: l
        };
      }
    ), s !== void 0 && s.forEach((r, l) => {
      e.push({
        ...o,
        elementIndex: l,
        elementDataContext: r
      });
    });
  }
  return e;
}
function CI(t) {
  const { chart: e, selectionSource: i, chartConfig: a } = t, n = qe(a);
  let o = [];
  if (z(a?.series) === b.BoxPlotSeries) {
    if (o = e.series.values.filter((s) => !(s instanceof _t)), i === Ue.SelectionByClick) {
      const s = /* @__PURE__ */ new Set(), r = o.find(
        (l) => l instanceof ut && l.isHover
      );
      r === void 0 ? o.forEach((l) => {
        l instanceof ye && (l.id.includes(ve.Outliers) && l.tooltip?.visible === !0 || te(l.uid, "isBoxPlotMeanLineSeries")) && s.add(l);
      }) : s.add(r), o = Array.from(s);
    }
  } else
    o = e.series.values;
  return o = o.filter(
    (s) => s.visible && te(s.uid, "isOverlay") !== !0 && (!n || !(s instanceof ut || te(s.uid, "isBoxPlotOutliersSeries")))
  ), o;
}
async function Kp(t) {
  const { chart: e, cursorSelectionRectangle: i, multiSelect: a, selectionSource: n, hitElement: o } = t, s = B(e.uid, "config"), r = z(s?.series), l = s?.series[0]?.x ?? "";
  let c = [];
  J(e.uid, { pendingSelectionQueries: !0 });
  let d = [], u = !0;
  CI({
    chart: e,
    selectionSource: n,
    chartConfig: s
  }).forEach((m, g) => {
    const y = Jr(m, s);
    if (m.visible && te(m.uid, "isOverlay") !== !0 && m instanceof ca) {
      const p = fs(m, g), S = p === b.BoxPlotSeries ? y?.y : Za(m), x = m.dataFields?.customValue ?? "", C = {
        element: {},
        yAxisField: S,
        xAxisField: l,
        splitBy: x,
        chartType: r,
        seriesIndex: g
      };
      let F;
      m instanceof it || m instanceof ut ? (F = m.columns?.values, p === b.HistogramSeries && (C.xAxisField = x, C.dataTransformationType = (s?.series[0]).dataTransformationType)) : m instanceof _t ? F = m.segments.values : m instanceof ye && (F = He(m)?.clones?.values, C.uniqueFeature = !0), F !== void 0 && (d = [...d, ...F], F.forEach((v, A) => {
        if (!(v.dataItem instanceof qa)) {
          const w = v.isActive, O = v === o || SI(v, i);
          O && (u = !1);
          let I = !1;
          w ? O ? I = n !== Ue.SelectionByClick : I = a === !0 : I = O, I && c.push({
            ...C,
            element: v,
            elementDataContext: v.dataItem?.dataContext,
            elementIndex: A
          }), vi({ element: v, selected: I });
        }
      }));
    }
  }), u && (c = []), await ps({
    chart: e,
    listSelectedElements: c,
    selectionSource: n
  });
}
function vI(t) {
  const e = async (i) => {
    const a = i.target.cursor;
    if (a.xRange !== void 0) {
      a.selection.isMeasured = !0, a.validate(), a.selection.validate();
      const n = rm.spriteRectToSvg(
        a.selection.bbox,
        a.selection
      );
      if (a.selection.hide(), n.width > 0 || n.height > 0) {
        const o = el(i, t);
        await Kp({
          chart: t,
          cursorSelectionRectangle: n,
          multiSelect: o,
          selectionSource: Ue.SelectionByRange
        });
      }
    }
    a.selection.hide();
  };
  gi(t) && t.events.on(E.Up, async (i) => {
    const a = i.target.cursor, n = Bk(t.uid, "selectEndedCallbackDisposer");
    if (n !== void 0 && n.dispose(), a.xRange !== void 0 && i.event instanceof TouchEvent)
      await e(i);
    else {
      const o = a.events.once(E.SelectEnded, async () => {
        await e(i);
      });
      Dk(t.uid, {
        selectEndedCallbackDisposer: o
      });
    }
  });
}
async function cr(t, e) {
  const { target: i } = t, a = B(e.uid, "actionMode");
  if (e !== void 0 && Qp(e) && a !== ne.None && a !== ne.Zoom && (i instanceof fe || t.point === void 0)) {
    const n = t.svgPoint ? { x: t.svgPoint.x, y: t.svgPoint.y, width: 0, height: 0 } : void 0, o = el(t, e);
    await Kp({
      chart: e,
      cursorSelectionRectangle: n,
      multiSelect: o,
      selectionSource: Ue.SelectionByClick,
      hitElement: i
    });
  }
}
function FI(t) {
  gi(t) && (t.zoomOutButton.hoverable = !0, t.events.on(E.Hit, async (e) => await cr(e, t)), t.events.on(E.DoubleHit, async (e) => await cr(e, t)));
}
function Ln(t, e) {
  e.events.on(E.Hit, async (i) => await cr(i, t)), e.events.on(E.DoubleHit, async (i) => await cr(i, t));
}
async function LI(t) {
  const { series: e } = t;
  if (e.length > 0) {
    J(t.uid, { pendingSelectionQueries: !0 });
    const i = B(t.uid, "config"), n = e.values.map(
      (o, s) => {
        let r = [];
        if (o.visible && te(o.uid, "isOverlay") !== !0) {
          const l = z(i?.series, s);
          l === b.BarSeries || l === b.HistogramSeries ? r = df(o, s) : l === b.LineSeries || l === b.ScatterSeries && te(o.uid, "isOverlay") !== !0 ? r = uf(o, s) : l === b.PieSeries ? r = xI(o) : l === b.BoxPlotSeries && (o instanceof ut ? r = df(o, s) : o instanceof ye && !(o instanceof _t) && (r = uf(o, s)));
        }
        return r;
      }
    ).flat();
    await ps({
      chart: t,
      listSelectedElements: n,
      selectionSource: Ue.ProgrammaticSelection
    }), t instanceof Me && t.feedLegend();
  }
}
function Al(t) {
  if (gi(t))
    if (t.events.disableType(E.Hit), t.events.disableType(E.DoubleHit), t instanceof Me) {
      const e = t.series.getIndex(0);
      e !== void 0 && (e.slices.template.clickable = !1, e.slices.template.togglable = !1, e.slices.template.events.disableType(E.Hit), e.slices.template.events.disableType(E.DoubleHit), e.labels.template.clickable = !1, e.labels.template.togglable = !1, e.labels.template.events.disableType(E.Hit), e.labels.template.events.disableType(E.DoubleHit));
    } else t instanceof fe && (t.xAxes.each((e) => dr(e, !0)), t.yAxes.each((e) => dr(e, !0)), t.events.disableType(E.Up));
}
function AI(t) {
  if (gi(t))
    if (t.events.enableType(E.Hit), t.events.enableType(E.DoubleHit), t instanceof Me) {
      const e = t.series.getIndex(0);
      e !== void 0 && (e.slices.template.clickable = !0, e.slices.template.togglable = !0, e.slices.template.events.enableType(E.Hit), e.slices.template.events.enableType(E.DoubleHit), e.labels.template.clickable = !0, e.labels.template.togglable = !0, e.labels.template.events.enableType(E.Hit), e.labels.template.events.enableType(E.DoubleHit));
    } else t instanceof fe && (t.xAxes.each((e) => dr(e, !1)), t.yAxes.each((e) => dr(e, !1)), t.events.enableType(E.Up));
}
function ea(t) {
  const { element: e, stylingInfo: i, stateKey: a = "default" } = t;
  if (e !== void 0 && i !== void 0) {
    const n = e.states.getKey(a)?.properties ?? e.defaultState.properties;
    if (n.fill = i.pattern ?? i.fill, n.fillOpacity = Ar(n.fill.toString()).alpha === 0 ? 0 : 1, i.outline !== void 0) {
      const { outline: o } = i;
      n.stroke = o.stroke, n.strokeOpacity = o.stroke.alpha === 0 ? 0 : 1, n.strokeDasharray = o.strokeDasharray, n.strokeLinecap = o.strokeLinecap, n.strokeWidth = o.strokeWidth;
    }
  }
}
function TI(t, e) {
  const i = new Cc();
  return i.width = Ct(100), i.height = Ct(100), i.background.fill = wt(e ?? T.loaderBackground), i.parent = t, i;
}
function wI(t) {
  const e = new Vo();
  return e.valign = ce.Middle, e.align = he.Center, e.fontSize = T.loaderLabelFontSize, e.dy = 40, e.text = "", e.parent = t, e;
}
function kI(t, e) {
  const i = new lm();
  return i.parent = t, i.align = he.Center, i.valign = ce.Middle, i.path = "M2.2 16A13.81 13.81 0 0 1 14 2.362v1.01a12.8 12.8 0 1 0 4 0v-1.01A13.792 13.792 0 1 1 2.2 16z", i.stroke = wt(e ?? T.loaderSpinnerColor), i.strokeWidth = 2, i;
}
function II(t) {
  return window.setInterval(() => {
    t.animate({ from: 0, to: 360, property: "rotation" }, T.loaderRotationSpeed);
  }, T.loaderIntervalTimeout);
}
function OI(t, e) {
  const i = TI(t, e?.loaderColors?.curtainColor);
  return wI(i), { loaderPolygon: kI(i, e?.loaderColors?.spinnerColor), loaderContainer: i };
}
function BI(t, e) {
  t.preloader !== void 0 && (t.preloader.disabled = !0);
  let i, a, n;
  if (t.tooltipContainer !== void 0) {
    const c = OI(t.tooltipContainer, e);
    i = c.loaderContainer, a = c.loaderPolygon;
  }
  function o() {
    n !== void 0 && (window.clearInterval(n), n = void 0), i !== void 0 && (se(i, !1), t instanceof fe && (t.zoomOutButton.disabled = !1));
  }
  function s(c) {
    c && (n === void 0 && a !== void 0 && (n = II(a)), i !== void 0 && (se(i), t instanceof fe && (t.zoomOutButton.disabled = !0)));
  }
  return o(), { loaderElements: {
    loaderContainer: i ?? new Cc(),
    loaderPolygon: a ?? new lm()
  }, loaderHandle: {
    hideLoader: o,
    showLoader: s
  } };
}
function DI(t, e) {
  const { loaderContainer: i, loaderPolygon: a } = t;
  i !== void 0 && (i.background.fill = wt(
    e?.loaderColors?.curtainColor ?? T.loaderBackground
  )), a !== void 0 && (a.stroke = wt(e?.loaderColors?.spinnerColor ?? T.loaderSpinnerColor));
}
function ms(t) {
  return t.values.every((i) => i.isReady());
}
function Yi(t, e) {
  t.events.on(E.Ready, () => {
    const { chart: i } = t;
    i !== void 0 && ms(t.chart.series) && (bI(i), e(), no(t.chart.htmlContainer));
  });
}
function Jp(t, e) {
  const { dataTooltipStyle: i, dataTooltipStyleReversed: a } = T;
  if (e === !0) {
    const n = t.background.fill;
    if (n !== void 0) {
      t.background.stroke = n, t.background.strokeWidth = a?.outline?.width ?? Number.NaN, t.background.fill = wt(a?.color);
      const o = t.background.fill.rgb;
      if (o !== void 0) {
        const s = t.label.fill;
        t.label.fill = yS(o) ? s?.darkColor : s?.lightColor;
      }
    }
  } else
    t.getStrokeFromObject = !0, t.getFillFromObject = !0, t.background.strokeWidth = i?.outline?.width ?? Number.NaN, t.background.stroke = wt(i?.outline?.color);
}
function En(t) {
  const { series: e, callbackName: i, value: a } = t, n = te(e.uid, i);
  return n !== void 0 ? n(a) : a.toString();
}
function NI(t) {
  const e = t.tooltip ?? new cm();
  e.pointerOrientation = "vertical", t instanceof ut || t instanceof _t ? e.label.maxWidth = T.boxPlot.boxPlotTooltipLabelWidth : e.label.maxWidth = T.tooltipWidth, e.label.wrap = !0, e.events.on(E.Shown, (i) => {
    const a = B(t.chart.uid, "config");
    if (a !== void 0) {
      const n = Jr(t, a), { dataTooltipReverseColor: o } = n ?? {};
      Jp(i.target, o);
    }
  });
}
function MI(t) {
  t instanceof zt || t.series.each((e) => {
    te(e.uid, "isOverlay") !== !0 && NI(e);
  });
}
function ey(t, e) {
  t.tooltipHTML = T.htmlEmptyContent, t.adapter.add("tooltipHTML", (i, a) => {
    let n = i ?? "";
    const { chart: o } = e;
    if (o !== void 0) {
      const s = B(o.uid, "config"), { dataTooltipVisible: r } = s?.series[0] ?? {};
      if (r === !1)
        n = "";
      else {
        const l = te(
          e.uid,
          "barAndLineTooltipFormatter"
        );
        if (l !== void 0 && e.isReady()) {
          const { dataItem: c } = a;
          if (c instanceof Ko || c instanceof Ha) {
            const d = s?.series.find((u) => u.id === e.id);
            if (d !== void 0) {
              const u = fi({ config: s }), f = u ? c.valueX : c.valueY, m = (u ? c.values.valueX.totalPercent : c.values.valueY.totalPercent) / 100, g = c.dataContext ?? {};
              if (g !== void 0) {
                const y = B(o.uid, "rendererFieldNames"), p = Zt({
                  value: g[d.x],
                  dataContext: g,
                  useRendererLabel: Er(s, y)
                });
                let S = $i(g);
                S === void 0 && (S = p);
                const x = g[T.dateBinningRange];
                n = l({
                  seriesName: e.name,
                  xValue: p,
                  originalXValue: S,
                  dateBinningRange: x,
                  statValue: f,
                  percentValue: m
                });
              }
            }
          }
        }
      }
    }
    return rt(n);
  }), t.tooltipPosition = e instanceof ye ? T.markerTooltipPosition : T.columnTooltipPosition, e.cursorTooltipEnabled = !1;
}
function $I(t) {
  const {
    isStacked100: e,
    series: i,
    statValue: a,
    percentValue: n,
    yAxisValueFormat: o,
    dataTooltipValueFormat: s,
    dataTooltipPercentFormat: r
  } = t;
  let l = s;
  l === void 0 && (Pe(o) && o ? (l = o, e && (l.intlOptions.style = "decimal")) : l = mc());
  const c = B(i.chart.uid, "formatLocale"), d = a !== void 0 ? gn({
    value: a,
    valueFormat: l,
    iLocale: i.chart.language.locale,
    formatLocale: c
  }) : "";
  let u = "";
  if (e && n !== void 0) {
    let f = r;
    f === void 0 && (f = Gf(), f.intlOptions.minimumFractionDigits = 2, f.intlOptions.maximumFractionDigits = 2), u = gn({
      value: n,
      valueFormat: f,
      iLocale: i.chart.language.locale,
      formatLocale: c
    });
  }
  return { formattedStatValue: d, formattedPercentValue: u };
}
function PI(t) {
  const { series: e, dateRange: i, xAxisValueFormat: a } = t;
  let n;
  const o = B(e.chart.uid, "timeIntervalInfo");
  if (i !== void 0 && i.length > 0) {
    let s = {};
    switch (o?.unit) {
      case Q.Second:
        s = {
          month: "numeric",
          day: "numeric",
          year: "numeric",
          hour: "numeric",
          minute: "numeric",
          second: "numeric"
        };
        break;
      case Q.Minute:
        s = {
          month: "numeric",
          day: "numeric",
          year: "numeric",
          hour: "numeric",
          minute: "numeric"
        };
        break;
      case Q.Hour:
        s = {
          month: "numeric",
          day: "numeric",
          year: "numeric",
          hour: "numeric",
          minute: "numeric"
        };
        break;
      case Q.Day:
      case Q.Week:
      case Q.Month:
      case Q.Year:
        s = {
          month: "numeric",
          day: "numeric",
          year: "numeric"
        };
        break;
    }
    s.timeZone = a.intlOptions.timeZone;
    const r = new Date(i[0]), l = new Date(i[1]);
    if (!Number.isNaN(r.valueOf())) {
      const c = B(e.chart.uid, "formatLocale"), d = ui({
        type: b.DateAxisFormat,
        iLocale: e.chart.language.locale,
        formatLocale: c
      }), u = d.format(r, s);
      if (n = u, !Number.isNaN(l.valueOf())) {
        const f = d.format(l, s);
        f !== u && (n = `${n} - ${f}`);
      }
    }
  }
  return n?.toString() ?? "";
}
function ty(t) {
  const {
    seriesConfig: e,
    xAxisValueFormat: i,
    setTimeBinningInfoWhenNotProvided: a,
    dataTooltipValueFormat: n,
    dataTooltipDateFormat: o,
    series: s,
    xValue: r,
    dateBinningRange: l
  } = t;
  let c;
  const d = B(s.chart.uid, "formatLocale");
  return /* case 1: time binning chart */ ei({
    seriesConfig: e,
    xAxisValueFormatType: i?.type,
    setTimeBinningInfoWhenNotProvided: a
  }) && l !== void 0 && i?.type === b.DateAxisFormat ? c = PI({
    series: s,
    dateRange: l,
    xAxisValueFormat: i
  }) : mi(i) && r !== void 0 ? c = gn({
    value: r,
    valueFormat: o ?? i,
    iLocale: s.chart.language.locale,
    formatLocale: d
  }) : typeof r == "number" && Pe(i) ? c = gn({
    value: r,
    valueFormat: n ?? i,
    iLocale: s.chart.language.locale,
    formatLocale: d
  }) : c = r, c?.toString() ?? "";
}
function RI(t) {
  const {
    series: e,
    fieldList: i,
    queryObject: a,
    setTimeBinningInfoWhenNotProvided: n,
    seriesIndex: o,
    seriesConfig: s,
    commonStrings: r
  } = t, { dataTooltipValueFormat: l, dataTooltipPercentFormat: c, dataTooltipDateFormat: d } = s;
  let u = () => "";
  const { chart: f } = e;
  if (f !== void 0) {
    const m = B(f.uid, "config");
    if (m !== void 0) {
      const { dataTooltipVisible: g } = s, y = e instanceof ye ? s.markerVisible : void 0;
      if (g === !1 || y === !1)
        u = () => "";
      else {
        const p = m.axes, S = p[0].valueFormat, x = p[1].valueFormat, C = H(m.series), F = ti(m) === Ie.Stacked100, v = we(a)?.objectIdField, A = Ve(i, s.x), w = Ki(A, p[0].title?.content.text), O = Ih({
          config: m,
          fieldList: i,
          objectIdField: v,
          seriesIndex: o,
          commonStrings: r,
          isStacked100: F
        }), I = ai(f.rtl);
        u = (N) => {
          const { statValue: M, percentValue: P, xValue: R, dateBinningRange: $ } = N, W = ty({
            seriesConfig: s,
            xAxisValueFormat: S,
            dataTooltipValueFormat: l,
            dataTooltipDateFormat: d,
            setTimeBinningInfoWhenNotProvided: n,
            series: e,
            xValue: R,
            dateBinningRange: $
          }), { formattedStatValue: U, formattedPercentValue: q } = $I({
            isStacked100: F,
            yAxisValueFormat: x,
            dataTooltipValueFormat: l,
            dataTooltipPercentFormat: c,
            series: e,
            statValue: M,
            percentValue: P
          }), Z = [`<b>${w}${I} </b>${W}`];
          switch (C) {
            case L.BarAndLineFromFields: {
              Z.pop();
              const ee = kh({
                config: m,
                fieldName: Ve(i, W ?? ""),
                commonStrings: r
              });
              Z.push(`<b>${ee}${I} </b>${U}`);
              break;
            }
            case L.BarAndLineMonoField:
            case L.BarAndLineNoAggregation:
            case L.BarAndLineMultiFields:
              Z.push(`<b>${O}${I} </b>${U}`);
              break;
            case L.BarAndLineSplitByNoAggregation:
            case L.BarAndLineSplitBy:
              {
                const ee = Ze(s.query?.where, !1), j = qf({
                  value: Ve(i, ee)
                });
                Z.push(
                  `<b>${j}${I} </b>${e.name}<br /><b>${O}${I} </b>${U}`
                );
              }
              break;
          }
          return F && Z.push(`<b>${r.statistics.percent}${I} </b>${q}`), Z.join("<br />");
        };
      }
    }
  }
  return u;
}
function iy(t) {
  const { series: e, tooltipFormatter: i } = t;
  et(e.uid, {
    barAndLineTooltipFormatter: i ?? RI(t)
  });
}
function yd(t) {
  const { target: e, defaultTooltipHTML: i, candleStickSeries: a, meanLineSeries: n, outliersSeries: o, tooltipCallback: s } = t;
  let r = i;
  const l = a ?? n;
  if (l !== void 0) {
    const { chart: c } = l;
    if (c !== void 0) {
      const d = B(c.uid, "config"), { dataTooltipVisible: u } = d?.series[0] ?? {};
      if (u === !1)
        r = "";
      else {
        const f = te(
          l.uid,
          "boxPlotTooltipFormatter"
        );
        f !== void 0 && l.isReady() && d && (r = s({
          target: e,
          defaultTooltipHTML: i,
          config: d,
          candleStickSeries: a,
          meanLineSeries: n,
          outliersSeries: o,
          boxPlotTooltipFormatter: f
        }));
      }
    }
  }
  return rt(r);
}
function VI(t) {
  const { target: e, defaultTooltipHTML: i, config: a, candleStickSeries: n, outliersSeries: o, boxPlotTooltipFormatter: s } = t;
  let r = i;
  if (n !== void 0 && o !== void 0) {
    const l = n.dataItems.values.find(
      (d) => (d.categories.categoryX ?? d.categories.categoryY) === (e.dataItem?.categories.categoryX ?? e.dataItem?.categories.categoryY)
    ), c = a.series.find((d) => d.id === n.id);
    if (c !== void 0) {
      const d = l?.dataContext ?? {};
      if (d !== void 0) {
        const u = Zt({
          value: d[c.x],
          dataContext: d,
          useRendererLabel: Ri(a)
        });
        let f = $i(d);
        f === void 0 && (f = u), r = s({
          seriesName: o.name,
          xValue: u,
          originalXValue: f,
          dataContext: d
        });
      }
    }
  }
  return r;
}
function EI(t) {
  const { target: e, defaultTooltipHTML: i, config: a, meanLineSeries: n, boxPlotTooltipFormatter: o } = t;
  let s = i;
  if (n !== void 0) {
    const r = n.dataItems.values.find(
      (l) => (l.categories.categoryX ?? l.categories.categoryY) === (e.dataItem?.categories.categoryX ?? e.dataItem?.categories.categoryY)
    );
    if (r instanceof Ha) {
      const l = a.series.find((c) => c.id === n.id);
      if (l !== void 0) {
        const c = r.dataContext ?? {};
        if (c !== void 0) {
          const d = Zt({
            value: c[l.x],
            dataContext: c,
            useRendererLabel: Ri(a)
          });
          let u = $i(c);
          u === void 0 && (u = d), s = o({
            seriesName: n.name,
            xValue: d,
            originalXValue: u,
            dataContext: c
          });
        }
      }
    }
  }
  return s;
}
function WI(t) {
  const { target: e, defaultTooltipHTML: i, config: a, candleStickSeries: n, boxPlotTooltipFormatter: o } = t;
  let s = i;
  if (n !== void 0) {
    const r = e.dataItem;
    if (r instanceof tS) {
      const l = a.series.find(
        (c) => c.id === n.id
      );
      if (l !== void 0) {
        const c = r.dataContext ?? {};
        if (c !== void 0) {
          const d = Zt({
            value: c[l.x],
            dataContext: c,
            useRendererLabel: Ri(a)
          });
          let u = $i(c);
          u === void 0 && (u = d), s = o({
            seriesName: n.name,
            xValue: d,
            originalXValue: u,
            dataContext: c
          });
        }
      }
    }
  }
  return s;
}
function zI(t) {
  t.cursorTooltipEnabled = !1, t.tooltipPosition = T.columnTooltipPosition, t.columns.template.tooltipHTML = T.htmlEmptyContent, t.columns.template.adapter.add(
    "tooltipHTML",
    (e, i) => yd({
      target: i,
      defaultTooltipHTML: e ?? "",
      candleStickSeries: t,
      tooltipCallback: WI
    })
  );
}
function HI(t, e) {
  const i = He(t);
  i !== void 0 && (i.tooltipPosition = T.markerTooltipPosition, i.tooltipHTML = T.htmlEmptyContent, t.cursorTooltipEnabled = !1, i.adapter.add(
    "tooltipHTML",
    (a, n) => yd({
      target: n,
      defaultTooltipHTML: a ?? "",
      candleStickSeries: e,
      outliersSeries: t,
      tooltipCallback: VI
    })
  ));
}
function qI(t) {
  const e = He(t);
  e !== void 0 && (t.cursorTooltipEnabled = !1, e.tooltipPosition = T.markerTooltipPosition, e.tooltipHTML = T.htmlEmptyContent, e.adapter.add(
    "tooltipHTML",
    (i, a) => yd({
      target: a,
      defaultTooltipHTML: i ?? "",
      meanLineSeries: t,
      tooltipCallback: EI
    })
  ));
}
function Ta(t) {
  const { label: e, value: i, strongColon: a, useTable: n } = t, o = `<b>${e}${a}</b> ${i}`;
  return n !== !1 ? `<tr><td>${o}</td></tr>` : o;
}
function GI(t) {
  const { dataContext: e, series: i, dataTooltipValueFormat: a, y: n, splitBy: o, commonStrings: s, useTable: r } = t, l = a ?? mc(), c = Object.values(Y), d = ai(i.rtl), u = r !== !1 ? ['<tr><td colspan="2"><hr style="border-top: solid black;"></td></tr>'] : [""];
  return c.forEach((f) => {
    const m = oe({ key: f, y: n, splitBy: o }), g = e[m];
    if (g != null && typeof g == "number") {
      const y = B(i.chart.uid, "formatLocale"), p = gn({
        value: g,
        valueFormat: l,
        iLocale: i.chart.language.locale,
        formatLocale: y
      });
      let S = "";
      switch (f) {
        case Y.Min:
          S = s.statistics.minimum;
          break;
        case Y.FirstQuartile:
          S = s.statistics.firstQuartile;
          break;
        case Y.Median:
          S = s.statistics.median;
          break;
        case Y.ThirdQuartile:
          S = s.statistics.thirdQuartile;
          break;
        case Y.Max:
          S = s.statistics.maximum;
          break;
        case Y.IQR:
          S = s.statistics.iqr;
          break;
        case Y.Average:
          S = s.statistics.mean;
          break;
        case Y.StandardDeviation:
      }
      tn(S) || u.push(
        Ta({
          label: S,
          value: p,
          strongColon: d,
          useTable: r
        })
      );
    }
  }), u;
}
function YI(t) {
  const { series: e, fieldList: i, seriesConfig: a, commonStrings: n } = t, { dataTooltipValueFormat: o } = a;
  let s = () => "";
  const { chart: r } = e;
  if (r !== void 0) {
    const l = B(r.uid, "config");
    if (l !== void 0) {
      const c = l.axes, d = c?.[0].valueFormat, { showMean: u } = l, f = H(l.series), m = Ze(a.query?.where), g = Ve(i, m), y = Lt({
        where: a.query?.where,
        escape: !1
      }), p = Ve(i, a.x);
      let S;
      a.x !== jo && (S = Ki(p, c?.[0].title?.content.text));
      const x = ai(r.rtl);
      s = (C) => {
        const { dataContext: F, xValue: v } = C, A = ty({
          seriesConfig: a,
          xAxisValueFormat: d,
          series: e,
          xValue: v
        }), w = [], O = A !== void 0 && !tn(A) ? Ve(i, A) : "", I = u === !0 ? [l.series[0].y].flat()[0] : [a.y].flat()[0], N = Ve(i, I);
        switch (f) {
          case L.BoxPlotMonoField:
          case L.BoxPlotMultiFields:
          case L.BoxPlotMonoFieldAndSplitBy:
          case L.BoxPlotMultiFieldsAndSplitBy: {
            if (A !== void 0 && !tn(A)) {
              const U = f === L.BoxPlotMonoField ? a.name ?? O : O;
              w.push(
                Ta({
                  label: n.field,
                  strongColon: x,
                  value: U
                })
              );
            }
            be(g) || w.push(
              Ta({
                label: g,
                strongColon: x,
                value: a.name ?? y?.toString()
              })
            );
            break;
          }
          case L.BoxPlotMonoFieldAndCategory:
          case L.BoxPlotMultiFieldsAndCategory: {
            w.push(
              Ta({
                label: n.field,
                strongColon: x,
                value: a.name ?? N
              })
            ), A !== void 0 && !tn(A) && w.push(
              Ta({
                label: S,
                strongColon: x,
                value: O
              })
            );
            break;
          }
          case L.BoxPlotMonoFieldAndCategoryAndSplitBy:
            w.push(
              Ta({
                label: n.field,
                strongColon: x,
                value: N
              })
            ), A !== void 0 && !tn(A) && w.push(
              Ta({
                label: S,
                strongColon: x,
                value: O
              })
            ), be(g) || w.push(
              Ta({
                label: g,
                strongColon: x,
                value: a.name ?? y?.toString()
              })
            );
            break;
        }
        const M = [L.BoxPlotMultiFieldsAndCategory], P = F[T.boxPlot.boxPlotMeanLineMarkerId] !== void 0, R = w.length > 0 && !P, $ = GI({
          dataContext: F,
          series: e,
          dataTooltipValueFormat: o,
          splitBy: a.query?.where,
          y: M.includes(f) ? [a.y].flat()[0] : void 0,
          commonStrings: n,
          useTable: R
        });
        return R ? `${w.join("<br>")}<table>${$.join("")}</table>` : `${w.join("<br>")}${$.join("<br>")}`;
      };
    }
  }
  return s;
}
function XI(t) {
  const { series: e, tooltipFormatter: i } = t;
  et(e.uid, {
    boxPlotTooltipFormatter: i ?? YI(t)
  });
}
function UI(t) {
  const e = Ci(T.dataLabelInitialize);
  return Ji(e.uid, { isDataLabel: !0 }), t.bullets.push(e), md(e), fd(b.LineSeries, e), Wp(b.LineSeries, e), Kl(e, t), e.html = "{valueX}", e;
}
function jI(t) {
  const { series: e } = t, i = Go(e, "bullets");
  Qr({
    ...t,
    dataLabel: i,
    defaultDataLabelFormatter: zp,
    seriesType: b.LineSeries
  });
}
function _I(t, e) {
  e !== void 0 && (e.layout !== void 0 && (t.layout = e.layout), e.width !== void 0 && (t.width = sf(e.width)), e.height !== void 0 && (t.height = sf(e.height)), e.paddingTop !== void 0 && (t.paddingTop = e.paddingTop), e.paddingBottom !== void 0 && (t.paddingBottom = e.paddingBottom));
}
function ZI(t) {
  let e = !1;
  const i = t.legend?.visible, a = t.legend?.title?.content.text, n = t.legend?.title?.visible;
  return e = i !== !1 && n !== !1 && a !== void 0 && a.length > 0, e;
}
function ay(t, e) {
  const i = new Cc();
  return _I(i, t), i.parent = e, i;
}
function ny(t, e) {
  t.disabled = e;
}
function QI(t, e) {
  t.toBack();
}
function KI(t) {
  if (t instanceof zt) {
    const { paddingTop: e, paddingRight: i, paddingBottom: a, paddingLeft: n } = T.gauge;
    t.padding(e, i, a, n);
  } else {
    const { paddingMinSize: e, marginMinSize: i, chartPaddingMinSize: a, chartContainer: n } = T;
    t.padding(a, a, a, a), t.chartAndLegendContainer.margin(i, i, i, i), t.chartAndLegendContainer.padding(e, e, e, e), t.chartContainer.margin(i, i, i, i), t.chartContainer.padding(n.paddingTop, e, e, e);
  }
}
function JI(t, e) {
  const i = (a, n) => {
    const { chartContainer: o, chartAndLegendContainer: s } = T, r = B(a.uid, "config");
    if (r !== void 0) {
      const l = ZI(r), c = r.legend?.position;
      if (l)
        switch (c) {
          case me.Top:
            a.chartAndLegendContainer.paddingTop = n.bbox.height ?? 0, a.chartContainer.paddingBottom = o.paddingBottom ?? 0;
            break;
          case me.Bottom:
            a.chartContainer.paddingBottom = n.bbox.height ?? 0, a.chartAndLegendContainer.paddingTop = s.paddingTop ?? 0;
            break;
          default:
            a.chartAndLegendContainer.paddingTop = s.paddingTop ?? 0, a.chartContainer.paddingBottom = o.paddingBottom ?? 0;
            break;
        }
      else
        a.chartAndLegendContainer.paddingTop = s.paddingTop ?? 0, a.chartContainer.paddingBottom = o.paddingBottom ?? 0;
    }
  };
  e.events.on(E.PositionChanged, () => {
    i(t, e);
  });
}
function bd(t) {
  const {
    iLocale: e,
    pieChart: i,
    valueIntlOptions: a,
    percentageIntlOptions: n,
    displayNumericValue: o,
    displayPercentage: s,
    valuePrefix: r,
    valueSuffix: l,
    percentagePrefix: c,
    percentageSuffix: d
  } = t, u = B(i.uid, "formatLocale"), f = ui({
    type: b.NumberAxisFormat,
    iLocale: e,
    formatLocale: u
  }), m = ui({
    type: b.NumberAxisFormat,
    iLocale: e,
    formatLocale: u
  });
  f.numberFormat = { ...a }, m.numberFormat = { ...n, style: "percent" };
  const g = ai(i.rtl, " ");
  return (p, S, x) => {
    let C = "";
    if (S !== void 0 && x !== void 0) {
      const F = `${r ?? ""}${f.format(S)}${l ?? ""}`, v = `${c ?? ""}${m.format(Math.abs(x / 100))}${d ?? ""}`;
      Number.isFinite(S) ? o === !0 && s === !0 ? C = `${v}${g}(${F})` : o === !0 ? C = F : s === !0 && (C = v) : C = "";
    }
    return C;
  };
}
function oy(t) {
  let e = !1;
  if (t.position === me.Right || t.position === me.Left)
    e = !0;
  else {
    const i = t.labels.getIndex(0)?.parent?.x;
    i !== void 0 && (e = !t.labels.values.some((a) => a.parent?.x !== i));
  }
  return e;
}
function eO(t) {
  let e = !1;
  const i = t.labels.getIndex(0)?.parent?.y;
  return i !== void 0 && (e = !t.labels.values.some((a) => a.parent?.y !== i)), e;
}
function tO(t) {
  t.events.on(E.LayoutValidated, () => {
    const e = oy(t), i = eO(t), a = e || !i ? he.Right : he.Center;
    t.valueLabels.template.horizontalCenter = dd(a), t.valueLabels.template.align = Pp(a);
  });
}
function iO(t) {
  Ji(t.valueLabels.template.uid, { isLegendValueLabel: !0 }), t.valueLabels.template.adapter.add("htmlOutput", (e, i) => {
    let a = e;
    const n = Nk(
      t.uid,
      "pieChartLegendValueLabelsFormatter"
    );
    if (n !== void 0 && (a = n(
      i.dataItem?.values?.value?.value ?? 0,
      i.dataItem?.values?.value?.percent ?? 0
    )), be(a) && (a = T.htmlEmptyContent), t.baseSprite instanceof tm) {
      const o = B(t.baseSprite.uid, "config");
      o?.legend?.body !== void 0 && (a = Ht({
        textSymbol: { ...o.legend.body, text: a },
        format: "html"
      }));
    }
    return rt(a);
  }), t.valueLabels.template.html = T.htmlEmptyContent, tO(t);
}
function aO(t) {
  const {
    legendElements: { legend: e },
    seriesConfig: i,
    webChartLegend: a,
    pieChartLegendValueLabelFormatter: n
  } = t, {
    visible: o,
    body: s,
    displayNumericValue: r,
    displayPercentage: l,
    displayCategory: c
  } = a ?? {};
  if (z(i) === b.PieSeries) {
    const { numericValueFormat: u, percentValueFormat: f, valuePrefix: m, valueSuffix: g, percentagePrefix: y, percentageSuffix: p } = i[0], S = c ?? T.pieChart.displayCategoryOnLegend, x = r ?? T.pieChart.displayNumericValueOnLegend, C = l ?? T.pieChart.displayPercentageOnLegend;
    let F = n;
    if (n === void 0) {
      const w = bd({
        iLocale: e.language.locale,
        pieChart: e.baseSprite,
        valueIntlOptions: u?.intlOptions,
        percentageIntlOptions: f?.intlOptions,
        displayNumericValue: x,
        displayPercentage: C,
        valuePrefix: m,
        valueSuffix: g,
        percentagePrefix: y,
        percentageSuffix: p
      });
      F = (O, I) => w("", O, I);
    }
    Mk(e.uid, {
      pieChartLegendValueLabelsFormatter: F
    });
    const v = oy(e), A = {
      type: b.Text,
      visible: o,
      content: {
        ...s,
        type: re.TS,
        text: ".",
        verticalAlignment: ce.Middle,
        // The horizontalAlignment value needs to be consistent with the one set by `handleValueLabelsRightAlignment()`. It avoids flickering the labels.
        horizontalAlignment: v ? he.Right : he.Center
      }
    };
    Kt({
      label: e.valueLabels.template,
      labelConfig: A,
      defaults: T.legendProperties.valueLabels
    }), e.labels.template.disabled = S === !1, e.valueLabels.template.disabled = x === !1 && C === !1;
  }
}
function nO(t) {
  const { dataContext: e } = t.target.dataItem ?? {};
  if (e instanceof ji) {
    const { component: i } = e;
    i instanceof xi && i.showTooltip();
  }
}
function oO(t) {
  const e = () => {
    const i = t.children.values.find(
      (a) => a.className === "Container"
    );
    if (i?.children.length === 3) {
      const a = i.children.values.findIndex((n) => n.className === "Container");
      if (a !== -1) {
        const o = a !== 0 ? 0 : 2, s = i.children.getIndex(o)?.clonedFrom;
        s !== void 0 && dt(s.uid, "isLegendValueLabel") !== !0 && t.children.each((r) => {
          r.className === "Container" && r.children.swap(1, o);
        });
      }
    }
  };
  t.events.on(E.Validated, e), e();
}
function ff(t, e) {
  const { legendLabelReducedOpacity: i } = T.legendProperties;
  t !== void 0 && (t.fillOpacity = e === !1 ? i : 1);
}
function Bn(t) {
  const { labels: e, seriesId: i, sliceCategory: a } = t;
  e.each((n) => {
    a !== void 0 ? a === n.dataItem.category && ff(n, n.dataItem.slice.visible ?? !0) : i === n.dataItem?.component?.id && ff(n, n.dataItem?.component?.visible ?? !0);
  });
}
function gs(t) {
  t instanceof xi ? (t.slices.template.events.on(E.Shown, (e) => {
    const i = e.target.dataItem.category;
    Bn({
      labels: t.chart?.legend?.labels,
      sliceCategory: i
    }), Bn({
      labels: t.chart?.legend?.valueLabels,
      sliceCategory: i
    });
  }), t.slices.template.events.on(E.Hidden, (e) => {
    const i = e.target.dataItem.category;
    Bn({
      labels: t.chart?.legend?.labels,
      sliceCategory: i
    }), Bn({
      labels: t.chart?.legend?.valueLabels,
      sliceCategory: i
    });
  })) : t.events.on(E.VisibilityChanged, (e) => {
    const i = e.target.id;
    Bn({ labels: t.chart?.legend?.labels, seriesId: i });
  });
}
function sy(t) {
  const { title: e, visible: i } = t;
  return e !== void 0 && i !== !1 && e?.visible !== !1;
}
function sO(t, e) {
  const { legendProperties: i } = T;
  if (t.position === me.Bottom)
    t.marginTop = i.marginTop ?? 0, t.marginBottom = 0, t.dy = 0;
  else if (t.position === me.Top)
    t.marginBottom = i.marginBottom ?? 0, t.marginTop = 0, t.dy = 0;
  else if (t.marginTop = 0, t.marginBottom = 0, !(t.baseSprite instanceof Me)) {
    const a = sy(e), n = e.title?.content?.font?.size ?? T.generalFontSize;
    t.dy = -(a ? n : 15);
  }
}
function rO(t) {
  const e = t.baseSprite;
  let i;
  if (e !== void 0) {
    const a = B(e?.uid, "config");
    i = e?.rtl && (a?.legend?.position === me.Top || a?.legend?.position === me.Bottom);
  }
  return i ?? !1;
}
function lO(t) {
  const e = t.baseSprite;
  let i = "";
  if (e instanceof fe) {
    const a = B(e.uid, "config"), n = di(a), o = n ? h.Rotated : h.NonRotated, s = ti(a);
    let r = h.SideBySide;
    s === Ie.Stacked ? r = h.Stacked : s === Ie.Stacked100 && (r = h.Stacked100);
    const l = e.rtl ? h.RTL : h.LTR;
    let c;
    switch (a?.legend?.position) {
      case me.Left:
        c = h.LegendLeft;
        break;
      case me.Top:
        c = h.LegendTop;
        break;
      case me.Bottom:
        c = h.LegendBottom;
        break;
      case me.Right:
      default:
        c = h.LegendRight;
        break;
    }
    const d = n ? e.yAxes.getIndex(0) : e.xAxes.getIndex(0);
    let u;
    d instanceof Ge ? u = h.DateAxis : d instanceof Ne ? u = h.ValueAxis : u = h.CategoryAxis;
    const m = a?.orderOptions?.data?.orderBy === ri.Descending ? h.OrderByFieldsDESC : h.OrderByFieldsASC;
    i = `${o}-${l}-${r}-${c}-${u}-${m}`;
  }
  return i;
}
function cO(t) {
  const e = lO(t);
  return hh.has(e);
}
function ry(t, e) {
  const { legend: i, legendTitle: a } = t ?? {};
  switch (e) {
    case b.HistogramSeries:
    case b.PieSeries:
      i.reverseOrder = rO(i);
      break;
    case b.BarSeries:
    case b.LineSeries:
    case b.ComboLineAndBarSeries:
      i.reverseOrder = cO(i);
      break;
  }
  const n = i.reverseOrder === !0 ? i.children.length - 1 : 0;
  i.children.moveValue(a, n);
}
function dO(t) {
  if (t.visible) {
    const i = B(t.chart.uid, "config")?.series.find(
      (a) => a.id === t.id
    );
    if (i !== void 0 && z([i]) === b.LineSeries) {
      const { markerVisible: n } = i;
      n !== !1 && t.bulletsContainer.show();
    }
  }
}
function uO(t, e) {
  const i = t.target.dataItem, a = t.target.isActive;
  if (i?.dataContext !== void 0) {
    const { dataContext: n } = i, o = { visible: a };
    if (te(n.uid, "isOverlay") === !0)
      o.overlayType = te(n.uid, "type");
    else if (n instanceof ji)
      B(e.uid, "isNonAggregatedChart") === !0 ? o.sliceData = n.dataContext : o.sliceId = n.category;
    else if (n instanceof ut) {
      const r = n.id, l = hs(e, r);
      if (l !== void 0) {
        const f = B(e.uid, "config"), m = xd(f?.showOutliers, a), g = He(l);
        g !== void 0 && (g.disabled = !m), se(l, m);
      }
      const { topStepLineSeries: c, medianStepLineSeries: d, bottomStepLineSeries: u } = tl(
        e,
        r
      );
      c !== void 0 && se(c, a), d !== void 0 && se(d, a), u !== void 0 && se(u, a), o.seriesId = n.id;
    } else
      o.seriesId = n.id;
    const s = n instanceof ji ? n.component : n;
    (s instanceof ca || s instanceof xi) && te(s.uid, "isOverlay") !== !0 && s.events.once(E.Validated, () => {
      s instanceof ca && (vy(s), s.events.dispatchImmediately(E.Validated, {
        type: E.Validated,
        target: s
      }));
      const r = s instanceof xi, l = B(
        e.uid,
        "currentSelectionDataItems"
      ), c = l !== void 0 && l.length > 0, d = B(e.uid, "actionMode") ?? T.actionMode;
      let u;
      s instanceof it ? u = s.columns : r ? u = s.slices : s instanceof ye && (dO(s), u = He(s)?.clones), u?.each((f) => {
        f.dataItem instanceof qa || (vi({
          element: f,
          selected: f.isActive,
          useNativeState: r,
          backToDefaultState: !c
          // back to default state when there's no selection at all
        }), r && d === ne.None && (f.clickable = !1));
      });
    }), bm(o, e.htmlContainer);
  }
}
function fO(t) {
  const { legendProperties: e, legendProperties: i } = T;
  t.adapter.add(
    "paddingRight",
    () => t.scrollbar.visible ? i.legendPaddingRightWithScrollbarVisible : e.paddingRight
  ), t.adapter.add("paddingLeft", () => e.paddingLeft), t.adapter.add("paddingTop", () => e.paddingTop), t.adapter.add("paddingBottom", () => e.paddingBottom);
}
function mO(t) {
  t.scrollable = !0;
}
function gO(t) {
  const e = Ci(void 0, t);
  return e.adapter.add("paddingTop", (i) => {
    let a = i;
    const n = e.bbox.height;
    return n > 0 && (a = -n), a;
  }), e.adapter.add("x", (i) => {
    let a = i;
    const { marginLeft: n, marginRight: o } = T.legendProperties.legendTitle;
    switch (B(t.baseSprite.uid, "config")?.legend?.title?.content?.horizontalAlignment) {
      case he.Left:
        a = e.measuredWidth + (n ?? 0);
        break;
      case he.Right:
        a = t.measuredWidth - e.measuredWidth - (o ?? 0);
        break;
      case he.Center:
      case he.Justify:
      default:
        a = t.measuredWidth / 2;
        break;
    }
    return a;
  }), e.adapter.add("disabled", (i) => (i === !1 && e.validate(), i)), e;
}
function hO(t) {
  const { legendConfig: e, legendTitle: i } = t, { title: a, position: n } = e, { legendTitle: o } = T.legendProperties, s = sy(e);
  if (a !== void 0) {
    const r = {
      ...a,
      visible: s
    };
    Kt({ label: i, labelConfig: r, defaults: o }), i.marginLeft = o.marginLeft ?? 0;
  }
  n === me.Top || n === me.Bottom ? (i.maxWidth = Number.NaN, i.isMeasured = !1) : (i.maxWidth = o.maxWidth ?? Number.NaN, i.marginTop = s ? i.bbox?.height ?? a?.content?.font?.size ?? T.generalFontSize : 0, i.isMeasured = !0);
}
function pO(t) {
  const e = T.legendProperties;
  t.labels.template = Ci(e.legendLabels), t.valueLabels.template = Ci(e.legendLabels), t.markers.template.width = e.legendMarkersSize, t.markers.template.height = e.legendMarkersSize, t.labels.template.adapter.add("wrap", () => !0), t.labels.template.adapter.add("maxWidth", (i) => {
    let a = i, n;
    if (t.baseSprite instanceof Me && (n = B(t.baseSprite.uid, "config")?.legend?.labelMaxWidth), t.position === me.Right || t.position === me.Left)
      a = n ?? T.legendProperties.legendLabels.maxWidth;
    else if (n !== void 0)
      a = n;
    else {
      let o = 0;
      t.valueLabels.template.disabled || t.valueLabels.each((s) => {
        o = Math.max(o, s.measuredWidth);
      }), a = t.measuredWidth - o - 45;
    }
    return a;
  }), t.labels.template.adapter.add("textOutput", (i, a) => {
    const n = a.dataItem?.label?.currentText;
    let o;
    const s = B(t.baseSprite.uid, "config");
    if (s !== void 0) {
      const { series: l } = s;
      if (z(l) === b.PieSeries) {
        const d = H(l) === L.PieFromFields ? tt : l[0].x, u = a.dataItem?.dataContext?.[d];
        typeof u == "string" ? o = u : u && typeof u != "object" && (o = u.toString());
      } else a.dataItem?.component instanceof aS && (o = a.dataItem.component.name);
    }
    return (o !== void 0 && !be(o) ? Vr(o) : o) ?? n;
  }), t.valueLabels.template.adapter.add("maxWidth", (i) => {
    let a = i, n;
    return t.baseSprite instanceof Me && (n = B(t.baseSprite.uid, "config")?.legend?.valueLabelMaxWidth), t.position === me.Right || t.position === me.Left ? a = n ?? T.legendProperties.valueLabels.maxWidth : a = n ?? Number.NaN, a;
  });
}
function yO(t, e) {
  t.itemContainers.template.events.on(E.Hit, (i) => uO(i, e)), e instanceof Me && t.itemContainers.template.events.on(E.Over, (i) => nO(i));
}
function bO(t) {
  t.itemContainers.template.reverseOrder = t.rtl;
}
function Os(t, e) {
  t.adapter.keys().includes(e) || t.adapter.add(e, (i) => {
    let a = i;
    const n = t.dataItem?.dataContext;
    if (n !== void 0) {
      const o = n instanceof ji ? n.component?.chart : n.chart;
      if (o !== void 0) {
        const s = B(o.uid, "config"), { rectangleMarkerRadius: r, roundedMarkerRadius: l } = T.legendProperties;
        a = s?.legend?.roundMarkers === !0 ? l : r;
      }
    }
    return a;
  });
}
function mf(t) {
  t.markers.each((e) => {
    const i = e.children.getIndex(0);
    i instanceof gS && (Os(i, "cornerRadiusBottomLeft"), Os(i, "cornerRadiusBottomRight"), Os(i, "cornerRadiusTopLeft"), Os(i, "cornerRadiusTopRight"), i.validate());
  });
}
function SO(t) {
  t.markers.template.events.on(E.Inited, () => {
    mf(t);
  }), t.events.once(E.Validated, () => {
    mf(t);
  });
}
function xO(t) {
  const {
    legendElements: { legend: e },
    seriesConfig: i,
    webChartLegend: a
  } = t, { visible: n, body: o } = a ?? {}, s = z(i), r = {
    type: b.Text,
    visible: n,
    content: {
      ...o,
      type: re.TS,
      text: " "
      // using a non empty string to kick in the adapter on `textOutput`
    }
  };
  Kt({ label: e.labels.template, labelConfig: r, defaults: T.legendProperties.legendLabels }), e.labels.template.valign = ce.Middle, e.valueLabels.template.valign = ce.Middle, s === b.PieSeries && aO(t), e.valueLabels.template.width = Number.NaN;
}
function CO(t, e) {
  e.chartContainer.events.on(
    E.SizeChanged,
    at(() => {
      let a = B(e.uid, "config")?.legend?.maxHeight ?? Number.NaN;
      Number.isFinite(a) || (t.position === me.Top || t.position === me.Bottom ? a = T.legendProperties.maxHeight : a = e instanceof Me ? e.chartContainer.measuredHeight : e.seriesContainer.measuredHeight), t.maxHeight = a, t.invalidateLayout();
    }),
    T.debounceTime
  );
}
function vO(t, e) {
  const { position: i } = e;
  i === me.Top || i === me.Bottom ? t.contentAlign = he.Center : t.contentAlign = "none";
}
function FO(t, e) {
  const { legend: i } = t;
  i.events.on(E.DataItemsValidated, () => {
    i.dataItems.length > 0 && ry(t, e);
  });
}
function LO(t, e) {
  e === me.Right || e === me.Left ? t.width = Number.NaN : t.maxWidth = Number.MAX_SAFE_INTEGER;
}
function ly(t, e) {
  let i = ki.pointer;
  e === !0 ? (t.itemContainers.template.clickable = !1, t.itemContainers.template.focusable = !1, i = ki.default) : (t.itemContainers.template.clickable = !0, t.itemContainers.template.focusable = !0), t.itemContainers.values.forEach((a) => {
    a.cursorOverStyle = i;
  });
}
function AO(t, e) {
  const i = new iS();
  t.legend = i, mO(i);
  const a = gO(i);
  return pO(i), iO(i), yO(i, t), bO(i), fO(i), FO({ legend: i, legendTitle: a }, z(e)), CO(i, t), JI(t, a), oO(i), t.legend.events.on(E.ChildAdded, () => {
    const n = B(t.uid, "options");
    ly(i, n?.disableTogglingLegendItems);
  }), { legend: i, legendTitle: a };
}
function Sd(t) {
  const { legendElements: e, seriesConfig: i, webChartLegend: a } = t, { legend: n, legendTitle: o } = e, s = n.baseSprite, l = (s === void 0 ? !0 : Hf(i)) && a?.visible !== !1;
  if (s !== void 0 && a !== void 0 && l) {
    const { position: c = T.legendProperties.position } = a;
    se(n, !0), hO({
      legendConfig: a,
      legendTitle: o
    }), SO(n), xO(t), vO(n, a), ry(e, z(i)), n.position = c, LO(n, c), sO(n, a);
    const d = B(s.uid, "options");
    ly(n, d?.disableTogglingLegendItems), n.events.once(E.Validated, () => {
      n.baseSprite instanceof Me && n.invalidateDataItems();
    });
  } else
    n.position = me.Right, n.width = 0, se(n, !1);
}
function TO(t) {
  const {
    chart: e,
    chartConfig: i,
    seriesIndex: a,
    axisList: n = [],
    hideLoaderHandle: o,
    selectionTheme: s,
    ignoreSmoothRenderingLimit: r
  } = t, l = i.series.length, { rotated: c } = i, d = i.series[a], { y: u, name: f, id: m, assignToSecondValueAxis: g } = d, y = new ye();
  y.id = m, Yi(y, o), Gi(y, f);
  let p, S;
  c !== !0 ? (p = n[0], S = g === !0 && n[2] ? n[2] : n[1]) : (p = g === !0 && n[2] ? n[2] : n[0], S = n[1]), p !== void 0 && (y.xAxis = p), S !== void 0 && (y.yAxis = S);
  const x = fi({ chart: e }), F = H(i.series) === L.BarAndLineSplitByNoAggregation ? `${u.toString()}_${Lt({ where: d.query?.where })}` : [u].flat()[0];
  x ? y.dataFields.valueX = F : y.dataFields.valueY = F;
  const v = x ? n[1] : n[0];
  if (v !== void 0) {
    const w = Hp(v, x);
    y.dataFields[w] = T.xAxisField;
  }
  y.dataFields.customValue = d?.query?.where;
  const A = Kr({ chart: e, lineSeries: y, applyPropertiesToClones: !1 });
  return ey(A, y), UI(y), Ca({ element: A, customSelectionTheme: s }), Ln(e, A), Gp({
    chart: e,
    numberOfChartSeries: l,
    series: y,
    seriesType: b.LineSeries,
    marker: A,
    ignoreSmoothRenderingLimit: r
  }), gs(y), xa(y), y;
}
function wO(t) {
  const { series: e, seriesIndex: i, chartSubType: a, seriesConfig: n, colorMatch: o, lineColor: s, rendererType: r } = t, l = He(e);
  let c = !1, d;
  if (l !== void 0) {
    n.markerVisible !== !1 && n.visible !== !1 ? e.bulletsContainer.show() : e.bulletsContainer.hide();
    let { markerSymbol: u } = n;
    const f = Zf();
    u === void 0 && (u = f, u.color = s), o ? u.color = s : u.color ??= s;
    const m = /* @__PURE__ */ new Set();
    let g;
    hd({ element: l, markerSymbol: u }), l.clones.each((y) => {
      if (y.dataItem instanceof qa)
        y.states.getKey(Tt.CustomActive)?.reset(), y.states.getKey(Tt.CustomInactive)?.reset();
      else {
        const p = y.dataItem?.dataContext, S = Wt({
          seriesConfig: n,
          dataItem: p,
          chartSubType: a,
          colorMatch: o,
          rendererType: r
        }), x = ma({
          seriesConfig: n,
          seriesIndex: i,
          seriesSymbol: u,
          element: y,
          colorMatch: o,
          rendererSymbol: S
        });
        d = x.symbolWithColorInfo, g = x.stylingInfo, ea({ element: y, stylingInfo: g }), m.add(JSON.stringify(g));
      }
    }), c = m.size > 1, c || ea({ element: l, stylingInfo: g });
  }
  return c ? void 0 : d;
}
function kO(t) {
  const { series: e, seriesConfig: i, chartSubType: a, colorMatch: n, rendererType: o } = t;
  let s;
  return e.dataItems?.values.every((r) => {
    let l = !0;
    const c = r.dataContext;
    return s = Wt({
      seriesConfig: i,
      dataItem: c,
      chartSubType: a,
      colorMatch: n,
      rendererType: o
    }), s !== void 0 && (l = !1), l;
  }), s;
}
function IO(t) {
  const { series: e, seriesIndex: i, seriesConfig: a, chartSubType: n, colorMatch: o, rendererType: s } = t, r = e, l = kO({
    series: r,
    seriesConfig: a,
    chartSubType: n,
    colorMatch: o,
    rendererType: s
  }), c = ma({
    seriesConfig: a,
    seriesIndex: i,
    seriesSymbol: a.lineSymbol ?? _f(i),
    element: r,
    colorMatch: o,
    rendererSymbol: l
  });
  return se(r, a.visible), c.symbolWithColorInfo;
}
function OO(t, e) {
  t.showArea === !0 ? t.areaColor !== void 0 ? (e.fill = wt(t.areaColor), e.fillOpacity = e.fill.alpha === 0 ? 0 : 1) : (e.fill = Ar(e.stroke.hex, 1), e.fillOpacity = T.lineSeries.areaOpacity) : e.fillOpacity = 0;
}
function cy(t) {
  const { series: e, seriesIndexMapper: i, seriesSymbolMapForEvent: a, seriesIndex: n, colorMatch: o, rendererType: s } = t, r = t.seriesConfig, l = B(e.chart.uid, "config"), c = l?.series.length ?? 0, d = H(l?.series);
  se(e, r.visible);
  const u = IO({
    series: e,
    seriesConfig: r,
    seriesIndex: n,
    chartSubType: d,
    colorMatch: o,
    rendererType: s
  }), f = wO({
    series: e,
    seriesIndex: n,
    seriesConfig: r,
    chartSubType: d,
    colorMatch: o,
    lineColor: u.color,
    rendererType: s
  });
  a.set(i.get(r.id) ?? n, {
    lineSymbol: u,
    markerSymbol: f
  }), OO(r, e), a.size === c && (zi({
    data: a,
    htmlContainer: e.chart.htmlContainer,
    chartId: e.chart.id,
    colorMatchApplied: Fn(e.chart)
  }), e.chart.feedLegend());
}
function BO(t) {
  const { seriesConfig: e, lineSeries: i, isRotated: a } = t;
  e.lineSmoothed === !0 ? i.smoothing = a ? Rd.MonotoneY : Rd.MonotoneX : i.smoothing = T.lineSeries.lineSmoothedKind;
}
function gf(t, e) {
  const { connectLines: i, temporalBinning: a } = e, n = a?.nullPolicy;
  t.connect = i !== !1 && n !== on.Null;
}
function DO(t) {
  const {
    seriesConfig: e,
    series: i,
    axes: a,
    rotationChanged: n,
    seriesIndex: o,
    subtypeInfo: s,
    fieldList: r,
    stackedType: l,
    queryObject: c,
    options: d,
    commonStrings: u
  } = t, { visible: f, name: m } = e, g = a[1].valueFormat, y = B(i.chart.uid, "config"), p = fi({ config: y }), S = H(y?.series);
  i.id = e.id, se(i, f);
  let x = m;
  const C = i.dataFields?.customValue ?? "";
  (S === L.BarAndLineSplitBy || S === L.BarAndLineSplitByNoAggregation) && (x = br({
    subtypeInfo: s,
    fieldList: r,
    fieldName: Ze(C),
    fieldValueToMatch: x
  }) ?? x), Gi(i, x), gf(i, e), gd({ series: i, seriesConfig: e, rotationChanged: n, stackedType: l, isRotated: p }), gf(i, e), hn({
    // TODO: Remove the type assertion and correct the typings
    styleCallback: cy,
    callbackProps: t,
    series: i,
    seriesConfig: e,
    onReadyEvent: !0
  }), BO({ seriesConfig: e, lineSeries: i, isRotated: p }), iy({
    series: i,
    seriesConfig: e,
    fieldList: r,
    queryObject: c,
    seriesIndex: o,
    setTimeBinningInfoWhenNotProvided: d?.setTimeBinningInfoWhenNotProvided,
    commonStrings: u,
    tooltipFormatter: d?.tooltipFormatter
  }), jI({
    series: i,
    seriesType: b.LineSeries,
    stackedType: l,
    dataLabelsConfig: e.dataLabels,
    yAxisValueFormat: g,
    customDataLabelFormatter: d?.dataLabelFormatter
  });
}
function tl(t, e) {
  const i = t.series.values.find(
    (o) => o.id === `${e}_${ve.Top}`
  ), a = t.series.values.find(
    (o) => o.id === `${e}_${ve.Median}`
  ), n = t.series.values.find(
    (o) => o.id === `${e}_${ve.Bottom}`
  );
  return { topStepLineSeries: i, medianStepLineSeries: a, bottomStepLineSeries: n };
}
function hs(t, e) {
  return t.series.values.find((i) => i.id === `${e}_${ve.Outliers}`);
}
function xd(t, e) {
  return (t ?? T.boxPlot.boxPlotOutliersVisibility) && e !== !1;
}
function NO(t) {
  const { chart: e, axisList: i = [], chartConfig: a, seriesIndex: n, hideLoaderHandle: o, selectionTheme: s } = t, r = qe(a), l = a.series[n], [c, d] = i, u = new ut();
  return u.hoverable = !0, Yi(u, o), r || (Ca({
    element: u.columns.template,
    customSelectionTheme: s
  }), Ln(e, u.columns.template)), u.id = l.id, c !== void 0 && (u.xAxis = c), d !== void 0 && (u.yAxis = d), u.simplifiedProcessing = !0, u.columns.template.applyOnClones = !0, u.riseFromOpenState.reset(), u.riseFromPreviousState.reset(), u.dropFromOpenState.reset(), u.dropFromPreviousState.reset(), Gi(u, l.name), xa(u), u;
}
function Tl(t) {
  const { axisList: e = [], chartConfig: i, seriesIndex: a, type: n, hideLoaderHandle: o, selectionTheme: s } = t, r = i.series[a], [l, c] = e, d = new _t();
  return d.hoverable = !0, Yi(d, o), d.id = `${r.id}_${n}`, l !== void 0 && (d.xAxis = l), c !== void 0 && (d.yAxis = c), d.noRisers = !0, d.simplifiedProcessing = !0, Ca({
    element: d.segments.template,
    customSelectionTheme: s
  }), d.hiddenInLegend = !0, xa(d), d;
}
function MO(t) {
  const { chart: e, axisList: i = [], chartConfig: a, hideLoaderHandle: n, seriesIndex: o, selectionTheme: s } = t, r = a.series[o], l = qe(a), [c, d] = i, u = new ye();
  et(u.uid, { isBoxPlotOutliersSeries: !0 }), Yi(u, n), u.id = `${r.id}_${ve.Outliers}`, c !== void 0 && (u.xAxis = c), d !== void 0 && (u.yAxis = d), u.simplifiedProcessing = !0, u.hiddenInLegend = !0, u.strokeOpacity = 0;
  const f = Kr({ chart: e, lineSeries: u });
  return l || (Ca({
    element: f,
    customSelectionTheme: s
  }), Ln(e, f)), xa(u), u;
}
function xo(t) {
  const {
    chartConfig: e,
    seriesConfig: i,
    meanLineSeries: a,
    candleStickSeries: n,
    topStepLineSeries: o,
    medianStepLineSeries: s,
    bottomStepLineSeries: r,
    outliersSeries: l,
    creation: c = !1,
    rotationChanged: d,
    outliersVisibilityChanged: u,
    standardizeValuesVisibilityChanged: f
  } = t, { x: m, y: g } = i, y = c || d === !0 || f === !0, p = y || u === !0, S = y, x = y;
  if (e !== void 0) {
    const { showOutliers: C, standardizeValues: F, showMean: v } = e, A = fi({ config: e });
    if (a instanceof ye && x) {
      const P = H(e.series), R = i?.query?.where, $ = oe({
        y: P === L.BoxPlotMultiFieldsAndCategory ? g : void 0,
        chartSubType: P,
        splitBy: R,
        showOutliers: C,
        standardizeValues: Hn(P) ? F : !1,
        key: Y.Average
      });
      A ? (a.dataFields.valueX = $, a.dataFields.categoryY = m) : (a.dataFields.valueY = $, a.dataFields.categoryX = m), a.dataFields.customValue = R;
    }
    const w = Or(e), O = H(w.series), I = v === !0 ? void 0 : i?.query?.where, N = {
      y: O === L.BoxPlotMultiFieldsAndCategory ? g : void 0,
      chartSubType: O,
      splitBy: I,
      showOutliers: C,
      standardizeValues: Hn(O) ? F : !1
    };
    if (p) {
      if (n instanceof ut) {
        const P = oe({
          ...N,
          key: Y.Min
        }), R = oe({
          ...N,
          key: Y.FirstQuartile
        }), $ = oe({
          ...N,
          key: Y.Max
        }), W = oe({
          ...N,
          key: Y.ThirdQuartile
        });
        A ? (n.dataFields.lowValueX = P, n.dataFields.openValueX = R, n.dataFields.highValueX = $, n.dataFields.valueX = W, n.dataFields.categoryY = m) : (n.dataFields.lowValueY = P, n.dataFields.openValueY = R, n.dataFields.highValueY = $, n.dataFields.valueY = W, n.dataFields.categoryX = m), n.dataFields.customValue = I;
      }
      if (o instanceof _t && s instanceof _t && r instanceof _t) {
        const P = oe({
          key: Y.Max,
          ...N
        }), R = oe({
          key: Y.Median,
          ...N
        }), $ = oe({
          key: Y.Min,
          ...N
        });
        A ? (o.dataFields.valueX = P, s.dataFields.valueX = R, r.dataFields.valueX = $, o.dataFields.categoryY = m, s.dataFields.categoryY = m, r.dataFields.categoryY = m) : (o.dataFields.valueY = P, s.dataFields.valueY = R, r.dataFields.valueY = $, o.dataFields.categoryX = m, s.dataFields.categoryX = m, r.dataFields.categoryX = m), o.dataFields.customValue = I, r.dataFields.customValue = I, s.dataFields.customValue = I;
      }
    }
    if (l instanceof ye && S) {
      const P = oe({
        ...N,
        key: Y.Outlier
      });
      A ? (l.dataFields.valueX = P, l.dataFields.categoryY = m) : (l.dataFields.valueY = P, l.dataFields.categoryX = m), l.dataFields.customValue = I, l.invalidateRawData();
    }
    const M = a?.chart ?? n?.chart;
    M !== void 0 && (p || x) && M.invalidateRawData();
  }
}
function $O(t) {
  const { chart: e, axisList: i = [], chartConfig: a, hideLoaderHandle: n, seriesIndex: o, selectionTheme: s } = t, r = a.series[o], [l, c] = i, d = new ye();
  et(d.uid, { isBoxPlotMeanLineSeries: !0 }), Yi(d, n), d.id = r.id, l !== void 0 && (d.xAxis = l), c !== void 0 && (d.yAxis = c), d.simplifiedProcessing = !0;
  const u = Kr({ chart: e, lineSeries: d });
  return Ca({ element: u, customSelectionTheme: s }), Ln(e, u), xa(d), qI(d), xo({
    chartConfig: a,
    seriesConfig: r,
    meanLineSeries: d,
    creation: !0
  }), d;
}
function PO(t) {
  const { chartConfig: e, seriesIndex: i } = t, a = e.series[i], n = z([a]), o = [];
  if (n === b.BoxPlotSeries) {
    const s = NO(t), r = Tl({
      ...t,
      type: ve.Top
    }), l = Tl({
      ...t,
      type: ve.Median
    }), c = Tl({
      ...t,
      type: ve.Bottom
    }), d = MO(t);
    zI(s), HI(d, s), xo({
      chartConfig: e,
      seriesConfig: a,
      candleStickSeries: s,
      topStepLineSeries: r,
      medianStepLineSeries: l,
      bottomStepLineSeries: c,
      outliersSeries: d,
      creation: !0
    }), o.push(
      s,
      r,
      l,
      c,
      d
    );
  } else if (n === b.LineSeries) {
    const s = $O(t);
    o.push(s);
  }
  return o;
}
function dy(t) {
  const { chart: e, chartData: i, chartConfig: a } = t;
  if (e && i?.length > 1 && a?.showMean === !0) {
    const n = a.series[0].x ?? T.originalCategoryValue, o = B(e.uid, "boxPlotMeanLinesData");
    if (o !== void 0 && o.length > 1) {
      const s = [];
      for (const r of i) {
        const l = o.find(
          (c) => n in c && c[n] === r[n]
        );
        l !== void 0 && s.push(l);
      }
      J(e.uid, { boxPlotMeanLinesData: s });
    }
  }
}
function RO(t) {
  const { candleStickSeries: e, seriesConfig: i, stylingInfo: a, chartSubType: n, colorMatch: o, rendererType: s } = t;
  if (a !== void 0) {
    const r = { ...a }, l = Sp({
      data: e.chart.data,
      colorMatch: o,
      chartSubType: n,
      rendererType: s
    });
    a?.outline !== void 0 && l && (r.outline.stroke = mn(T.boxPlot.boxPlotWhiskersColor));
    const { topStepLineSeries: c, medianStepLineSeries: d, bottomStepLineSeries: u } = tl(
      e.chart,
      e.id
    );
    if (c !== void 0 && d !== void 0 && u !== void 0 && r.outline !== void 0) {
      r.outline.strokeWidth = T.boxPlot.boxPlotLineWidth, Vn(c, r.outline), Vn(d, r.outline), Vn(u, r.outline);
      const f = i.visible !== !1;
      se(c, f), se(d, f), se(u, f);
    }
  }
}
function VO(t) {
  const { candleStickSeries: e, seriesConfig: i, showOutliers: a, seriesSymbol: n } = t;
  if (n !== void 0) {
    const o = hs(e.chart, e.id);
    if (o !== void 0) {
      const s = He(o);
      if (s !== void 0) {
        const r = xd(a, i.visible), l = {
          type: re.SMS,
          style: Xt.Circle,
          color: n.color,
          size: T.boxPlot.boxPlotOutliersSize
        };
        s.clones.each((c) => {
          const d = e.dataItems.values.find(
            (u) => (u.categories.categoryX ?? u.categories.categoryY) === (c.dataItem?.categories.categoryX ?? c.dataItem?.categories.categoryY)
          )?.column.fill;
          hd({
            element: c,
            markerSymbol: {
              ...l,
              color: Np(d) ?? l.color
            },
            visible: r
          });
        });
      }
    }
  }
}
function EO(t) {
  const { series: e, seriesConfig: i, seriesIndex: a, numberOfSeries: n, chartSubType: o, colorMatch: s, showMean: r, rendererType: l } = t;
  let c, d, u;
  const f = /* @__PURE__ */ new Set();
  let m = !1;
  const g = i.fillSymbol ?? hc(a);
  if (e.columns.length === 0 ? (u = ma({
    seriesConfig: i,
    seriesIndex: a,
    seriesSymbol: g,
    element: new xc(),
    colorMatch: s,
    isChartFillSymbol: !0
  }), c = u.symbolWithColorInfo, d = u.stylingInfo) : e.columns.each((y) => {
    u = ma({
      seriesConfig: i,
      seriesIndex: a,
      seriesSymbol: g,
      element: y,
      colorMatch: s,
      isChartFillSymbol: !0,
      rendererSymbol: r ? void 0 : Wt({
        dataItem: y.dataItem?.dataContext,
        seriesConfig: i,
        chartSubType: o,
        colorMatch: s,
        rendererType: l
      })
    }), c = u.symbolWithColorInfo, d = u.stylingInfo, f.add(JSON.stringify(c));
  }), m = f.size > 1, n > 1) {
    const y = e.legendDataItem?.marker.children.getIndex(0);
    y !== void 0 ? ea({ element: y, stylingInfo: d }) : e.chart.legend.events.once(E.Validated, () => {
      ea({
        element: e.legendDataItem?.marker.children.getIndex(0),
        stylingInfo: d
      }), e.chart.legend.invalidate();
    });
  }
  return {
    multipleSymbolsForOneSeries: m,
    seriesSymbol: c,
    stylingInfo: d
  };
}
function WO(t) {
  const {
    series: e,
    showOutliers: i,
    colorMatch: a,
    seriesIndex: n,
    seriesIndexMapper: o,
    seriesSymbolMapForEvent: s,
    seriesConfig: r,
    rendererType: l
  } = t, c = B(e.chart.uid, "config"), d = qe(c), u = c?.series.length ?? 0, f = H(c?.series);
  let m = !1, g;
  if (e instanceof ut && r.type === b.BoxPlotSeries) {
    const y = EO({
      series: e,
      seriesConfig: r,
      seriesIndex: n,
      numberOfSeries: u,
      chartSubType: f,
      colorMatch: a,
      showMean: d,
      rendererType: l
    }), { stylingInfo: p } = y;
    ({ multipleSymbolsForOneSeries: m, seriesSymbol: g } = y), s.set(
      o.get(r.id) ?? n,
      m ? void 0 : { fillSymbol: g ?? r.fillSymbol }
    ), RO({
      candleStickSeries: e,
      seriesConfig: r,
      colorMatch: a,
      stylingInfo: p,
      chartSubType: f,
      rendererType: l
    }), VO({
      candleStickSeries: e,
      seriesConfig: r,
      showOutliers: i,
      seriesSymbol: g
    });
  } else e instanceof ye && r.type === b.LineSeries && cy({
    series: e,
    seriesConfig: r,
    seriesIndexMapper: o,
    seriesSymbolMapForEvent: s,
    seriesIndex: n,
    colorMatch: a,
    rendererType: l
  });
  s.size === u && zi({
    data: s,
    htmlContainer: e.chart.htmlContainer,
    chartId: e.chart.id,
    colorMatchApplied: Fn(e.chart)
  });
}
function zO(t) {
  const { numberOfSeries: e, chart: i, showMean: a } = t, n = fi({ chart: i }), o = n ? i.yAxes.getIndex(0)?.renderer : i.xAxes.getIndex(0)?.renderer;
  if (o !== void 0) {
    const { cellStartLocation: s, cellEndLocation: r } = o, l = s / (a === !0 ? 1 : e), c = i.series.values.filter((d) => d instanceof ut);
    c.forEach((d, u) => {
      const f = s + u / c.length * (r - s) + l, m = s + (u + 1) / c.length * (r - s) - l, { topStepLineSeries: g, medianStepLineSeries: y, bottomStepLineSeries: p } = tl(
        i,
        d.id
      );
      g !== void 0 && (g.startLocation = f, g.endLocation = m), y !== void 0 && (y.startLocation = f, y.endLocation = m), p !== void 0 && (p.startLocation = f, p.endLocation = m);
      const S = hs(i, d.id);
      if (S !== void 0) {
        const x = (f + m) / 2;
        n ? S.dataItems.template.locations.categoryY = x : S.dataItems.template.locations.categoryX = x;
      }
    });
  }
}
function HO(t) {
  const { outliersSeries: e, chartData: i, dataWasUpdated: a, rotationChanged: n } = t;
  (n === !0 || a === !0) && (e.data = i?.outliers ?? []);
}
function qO(t) {
  const { meanLineSeries: e, chartData: i, rotationChanged: a, sortChanged: n, dataWasUpdated: o } = t;
  (a === !0 || o === !0 || n === !0) && (e.data = i?.meanLines ?? [], e.invalidateData());
}
function GO(t) {
  const {
    chart: e,
    chartConfig: i,
    seriesConfig: a,
    chartData: n,
    candleStickSeriesId: o,
    showOutliers: s,
    dataWasUpdated: r,
    rotationChanged: l,
    outliersVisibilityChanged: c,
    standardizeValuesVisibilityChanged: d
  } = t, u = hs(e, o);
  if (u !== void 0) {
    const f = He(u);
    if (f !== void 0) {
      const m = xd(s, a.visible);
      f.disabled = !m, HO({
        outliersSeries: u,
        chartData: n,
        dataWasUpdated: r,
        rotationChanged: l
      });
    }
    xo({
      chartConfig: i,
      seriesConfig: a,
      outliersVisibilityChanged: c,
      standardizeValuesVisibilityChanged: d,
      rotationChanged: l,
      outliersSeries: u
    });
  }
}
function YO(t) {
  const {
    meanLineSeries: e,
    seriesConfig: i,
    chartData: a,
    dataWasUpdated: n,
    sortChanged: o,
    rotationChanged: s,
    chartConfig: r,
    outliersVisibilityChanged: l,
    standardizeValuesVisibilityChanged: c
  } = t;
  Gi(e, i?.name), xo({
    chartConfig: r,
    seriesConfig: i,
    meanLineSeries: e,
    outliersVisibilityChanged: l,
    standardizeValuesVisibilityChanged: c,
    rotationChanged: s
  }), qO({
    meanLineSeries: e,
    chartData: a,
    dataWasUpdated: n,
    sortChanged: o,
    rotationChanged: s
  });
}
function XO(t) {
  const {
    series: e,
    chartConfig: i,
    seriesConfig: a,
    rotationChanged: n,
    outliersVisibilityChanged: o,
    standardizeValuesVisibilityChanged: s
  } = t;
  Gi(e, a?.name), e.hiddenInLegend = qe(i), xo({
    chartConfig: i,
    seriesConfig: a,
    candleStickSeries: e,
    outliersVisibilityChanged: o,
    standardizeValuesVisibilityChanged: s,
    rotationChanged: n
  });
}
function UO(t) {
  const {
    chart: e,
    chartConfig: i,
    seriesConfig: a,
    candleStickSeriesId: n,
    outliersVisibilityChanged: o,
    standardizeValuesVisibilityChanged: s,
    rotationChanged: r
  } = t, l = a.visible !== !1, { topStepLineSeries: c, medianStepLineSeries: d, bottomStepLineSeries: u } = tl(
    e,
    n
  );
  c !== void 0 && se(c, l), d !== void 0 && se(d, l), u !== void 0 && se(u, l), xo({
    chartConfig: i,
    seriesConfig: a,
    outliersVisibilityChanged: o,
    standardizeValuesVisibilityChanged: s,
    rotationChanged: r,
    topStepLineSeries: c,
    medianStepLineSeries: d,
    bottomStepLineSeries: u
  });
}
function jO(t) {
  const {
    chart: e,
    series: i,
    chartData: a,
    commonStrings: n,
    dataWasUpdated: o,
    sortChanged: s,
    fieldList: r,
    outliersVisibilityChanged: l,
    showMean: c,
    seriesConfig: d,
    showOutliers: u,
    standardizeValuesVisibilityChanged: f,
    rotationChanged: m,
    options: g
  } = t, { tooltipFormatter: y } = g ?? {};
  zO({
    numberOfSeries: t.numberOfSeries,
    chart: e,
    showMean: c
  });
  const p = B(e.uid, "config");
  if (p !== void 0) {
    if (i instanceof ut && d.type === b.BoxPlotSeries) {
      const { id: S } = i;
      XO({
        series: i,
        chartConfig: p,
        seriesConfig: d,
        rotationChanged: m,
        outliersVisibilityChanged: l,
        standardizeValuesVisibilityChanged: f
      }), UO({
        chart: e,
        chartConfig: p,
        seriesConfig: d,
        candleStickSeriesId: S,
        outliersVisibilityChanged: l,
        standardizeValuesVisibilityChanged: f,
        rotationChanged: m
      }), GO({
        chart: e,
        chartConfig: p,
        seriesConfig: d,
        chartData: a,
        showOutliers: u,
        candleStickSeriesId: S,
        dataWasUpdated: o,
        rotationChanged: m,
        outliersVisibilityChanged: l,
        standardizeValuesVisibilityChanged: f
      });
    } else i instanceof ye && d.type === b.LineSeries && YO({
      chartConfig: p,
      chartData: a,
      meanLineSeries: i,
      seriesConfig: d,
      dataWasUpdated: o,
      sortChanged: s,
      rotationChanged: m,
      outliersVisibilityChanged: l,
      standardizeValuesVisibilityChanged: f
    });
    hn({
      // TODO: Remove the type assertion and correct the typings
      styleCallback: WO,
      callbackProps: t,
      series: i,
      seriesConfig: d,
      onReadyEvent: !0
    }), XI({
      series: i,
      seriesConfig: d,
      fieldList: r,
      tooltipFormatter: y,
      commonStrings: n
    });
  }
}
function _O(t) {
  const e = t.series.getIndex(0);
  e !== void 0 && (e.slices.each((i) => {
    vi({
      element: i,
      selected: !1,
      backToDefaultState: !0
    });
  }), t.feedLegend());
}
function ZO(t, e = !0) {
  let i;
  t.series.each((a, n) => {
    if ((!e || a.visible) && (i === void 0 || i !== b.HistogramSeries && i !== b.ScatterSeries)) {
      i = fs(a, n);
      let o = [];
      if (i === b.HistogramSeries || i === b.BarSeries)
        o = a.columns?.values;
      else if (i === b.ScatterSeries || i === b.LineSeries)
        o = He(a)?.clones?.values;
      else if (i === b.BoxPlotSeries) {
        if (a instanceof ut)
          o.push(...a.columns.values);
        else if (a instanceof _t)
          o.push(...a.segments.values);
        else if (a instanceof ye) {
          const s = He(a)?.clones?.values;
          s !== void 0 && o.push(...s);
        }
      }
      o !== void 0 && o.forEach((s) => {
        vi({
          element: s,
          selected: !1,
          backToDefaultState: !0
        });
      });
    }
  });
}
function Co(t) {
  const { chart: e, selectionSource: i, clearOnlyVisibleSeries: a, disposeStyleAndSelection: n } = t, o = B(
    e.uid,
    "currentSelectionDataItems"
  );
  n !== !1 && Yp(e, "updateSelectionCallbackDisposer"), J(e.uid, {
    currentSelectionDataItems: void 0,
    currentSelectionOIDs: void 0,
    currentSelectionIndexes: void 0,
    computedSelectionDataItems: void 0,
    computedSelectionIndexes: void 0,
    pendingSelectionQueries: !1
  }), gi(e) && (e instanceof fe ? ZO(e, a ?? !0) : e instanceof Me && _O(e)), o && oo({
    data: {
      selectionSource: i ?? Ue.ClearSelection
    },
    htmlContainer: e.htmlContainer
  });
}
function QO(t) {
  dc(), Sm(t.htmlContainer), Co({ chart: t });
}
function KO(t) {
  const { chart: e, chartType: i, showMean: a } = t;
  return e.series.values.filter(
    (o) => te(o.uid, "isOverlay") !== !0 && (i !== b.BoxPlotSeries || !a && o instanceof ut || a && te(o.uid, "isBoxPlotMeanLineSeries"))
  ).every((o) => te(o.uid, "isSelectionApplied") === !0);
}
function JO(t) {
  t.series.each((e) => et(e.uid, { isSelectionApplied: void 0 }));
}
function uy(t, e) {
  const i = B(t.uid, "actionMode");
  if ((i === ne.MonoSelection || i === ne.None) && e.length > 1)
    Co({ chart: t });
  else {
    const n = t instanceof Me;
    e.forEach((o) => {
      vi({
        element: o,
        useNativeState: n,
        selected: !0
      });
    });
  }
}
function eB(t) {
  const {
    chart: e,
    chartConfig: i,
    series: a,
    options: n,
    elementsToApplySelectionTo: o,
    selectionDataItems: s,
    layerOidField: r,
    xAxisField: l,
    yAxisField: c
  } = t, d = z(i.series), u = H(i.series), f = Mi(i), m = B(e.uid, "queryObject"), g = [], y = [], p = [], S = pt(i.series), x = a instanceof ca ? a.dataFields?.customValue ?? "" : "";
  return o.forEach((C) => {
    if (!(C instanceof qa)) {
      let F = C.dataItem?.dataContext;
      if (F !== void 0 && (d === b.BoxPlotSeries && F[T.boxPlot.boxPlotOutlierId] !== !0 || u === L.BarAndLineMultiFields) && (F = fa({
        dataContext: F,
        yAxisField: c,
        yList: S,
        xAxisField: l,
        splitBy: x,
        chartType: d,
        chartSubType: u,
        showOutliers: f,
        isFeatureCollectionLayer: la(m)
      })), zr({
        elementDataContext: F,
        options: n,
        selectionDataItems: s,
        layerOidField: r,
        xAxisField: l,
        yAxisField: c,
        chartType: d,
        chartSubType: u,
        showOutliers: f
      }))
        if (g.push(C), C.dataItem !== void 0 && y.push(C.dataItem.index), C?.dataItem instanceof Ha && F !== void 0)
          p.push(F);
        else {
          const A = /* @__PURE__ */ new Set();
          d === b.PieSeries && qi(F) ? (ss({
            groupOfSlicesDataContext: F
          }) ?? []).forEach((O) => {
            s.forEach((I) => {
              Uc({
                layerOidField: r,
                sliceDataContext: O,
                selectionDataContext: I,
                xAxisField: l
              }) && A.add(O);
            });
          }) : A.add(F), Array.from(A)?.forEach((w) => {
            const O = fa({
              dataContext: w,
              yAxisField: c,
              yList: S,
              xAxisField: l,
              splitBy: x,
              chartType: d,
              chartSubType: u,
              showOutliers: f,
              isFeatureCollectionLayer: la(m)
            });
            O !== void 0 && p.push(O);
          });
        }
      else
        vi({
          element: C,
          useNativeState: e instanceof Me,
          selected: !1
        });
    }
  }), uy(e, g), { selectedIndexes: y, newSelectionDataItems: p };
}
function tB(t, e) {
  const i = [], a = [], n = B(t.uid, "config"), o = B(t.uid, "queryObject"), s = Mi(n), r = pt(n?.series ?? []), l = H(n?.series);
  return t.series.each((c, d) => {
    if (n && c.visible && te(c.uid, "isOverlay") !== !0) {
      const u = n.series[0].x, f = Za(c), m = c instanceof ca ? c.dataFields?.customValue ?? "" : "", g = fs(c, d), y = e.get(d);
      if (y !== void 0) {
        let p;
        if (c instanceof it ? p = c.columns : c instanceof xi ? p = c.slices : p = He(c)?.clones, p !== void 0) {
          const { indexesToSelect: S } = y;
          p.each((x, C) => {
            if (x && (S === void 0 || S.includes(C))) {
              let F;
              g === b.BoxPlotSeries && x.dataItem instanceof Ha ? F = x.dataItem.dataContext : x.dataItem instanceof qa || (F = fa({
                dataContext: x.dataItem?.dataContext,
                yList: r,
                yAxisField: f,
                xAxisField: u,
                splitBy: m,
                chartType: g,
                chartSubType: l,
                showOutliers: s,
                isFeatureCollectionLayer: la(o)
              })), F !== void 0 && i.push(F), a.push(x);
            } else
              vi({
                element: x,
                useNativeState: t instanceof Me,
                selected: !1
              });
          });
        }
      }
    }
  }), uy(t, a), i;
}
function iB(t) {
  const { series: e, chartType: i, showMean: a } = t;
  let n;
  switch (i) {
    case b.ComboLineAndBarSeries:
      if (e instanceof it)
        n = e.columns.values;
      else if (e instanceof ye) {
        const o = He(e);
        o !== void 0 && (n = o.clones.values);
      }
      break;
    case b.BarSeries:
    case b.HistogramSeries:
      e instanceof it && (n = e.columns.values);
      break;
    case b.LineSeries:
    case b.ScatterSeries:
      if (e instanceof ye) {
        const o = He(e);
        o !== void 0 && (n = o.clones.values);
      }
      break;
    case b.PieSeries:
      n = e.slices.values;
      break;
    case b.BoxPlotSeries:
      if (e.chart instanceof fe) {
        if (e instanceof ut && a !== !0) {
          n = [...e.columns.values];
          const o = hs(e.chart, e.id);
          if (o !== void 0 && o.visible) {
            const s = He(o);
            s !== void 0 && n.push(...s.clones.values);
          }
        } else if (a === !0 && e instanceof ye && te(e.uid, "isBoxPlotMeanLineSeries")) {
          const o = He(e);
          o !== void 0 && (n = o.clones.values);
        }
      }
      break;
  }
  return n;
}
function aB(t) {
  const {
    series: e,
    seriesIndex: i,
    queryObject: a,
    options: n,
    dataWasUpdated: o,
    sortChanged: s,
    groupOfSlicesWasUpdated: r,
    xAxisField: l,
    yAxisField: c,
    rotationChanged: d
  } = t, { filterBySelection: u, selectionData: f, returnSelectionIndexes: m, returnSelectionOIDs: g } = n ?? {}, { selectionIndexes: y } = f ?? {}, { chart: p } = e, S = B(p.uid, "config"), x = S && "showOutliers" in S && typeof S.showOutliers == "boolean" ? S.showOutliers : !1, C = qe(S), F = z(S?.series);
  if (u !== !0 && S !== void 0) {
    const v = iB({
      series: e,
      chartType: F,
      showMean: C
    }), A = H(S?.series);
    let w;
    a !== void 0 && (w = we(a).objectIdField);
    const O = B(
      p.uid,
      "currentSelectionDataItems"
    );
    let I = !1, N = !1, M, P = !1;
    if (v?.[0] !== void 0) {
      if (n?.viewExtentUpdated !== !0) {
        M = n?.selectionData?.selectionItems ?? O;
        const R = B(
          p.uid,
          "currentSelectionIndexes"
        );
        P = Vc({
          itemsA: M,
          itemsB: O,
          isPieFromFields: A === L.PieFromFields
        });
        const $ = !Di(y, R);
        I = s === !0 || o === !0 || r === !0 || d === !0 || M !== void 0 && P;
        let W = !0;
        if (y !== void 0 && y.size > 0) {
          const { indexesToSelect: U } = y.get(i ?? 0) ?? {};
          W = U !== void 0 && U[0] === void 0;
        }
        N = o === !0 || r === !0 || d === !0 || !W && $;
      }
      if (I && M !== void 0 && M.length > 0) {
        const { selectedIndexes: R, newSelectionDataItems: $ } = eB({
          chart: p,
          chartConfig: S,
          options: n,
          series: e,
          elementsToApplySelectionTo: v,
          selectionDataItems: M,
          layerOidField: w,
          xAxisField: l,
          yAxisField: c
        });
        let W = B(p.uid, "computedSelectionDataItems") ?? [];
        if (W.push(...$), S.series.length > 1 && A !== L.BarAndLineNoAggregation && A !== L.BarAndLineSplitByNoAggregation && (W = ns({
          data: W,
          x: S.series[0].x,
          splitByField: Ze(S.series[0].query?.where)
        })), J(p.uid, { computedSelectionDataItems: W }), m === !0) {
          const U = Array.from(new Set(R));
          let q = B(
            p.uid,
            "computedSelectionIndexes"
          );
          q === void 0 && (q = /* @__PURE__ */ new Map()), U.length === v.length ? q.set(i ?? 0, {}) : q.set(i ?? 0, {
            indexesToSelect: U
          }), J(p.uid, { computedSelectionIndexes: q });
        }
      } else if (y !== void 0 && N)
        M = tB(p, y);
      else {
        const R = M === void 0 || M.length === 0, $ = e instanceof ca ? e.dataFields?.customValue ?? "" : "", W = (U) => {
          let q = U.dataItem?.dataContext;
          return q !== void 0 && F === b.BoxPlotSeries && q[T.boxPlot.boxPlotOutlierId] !== !0 && (q = fa({
            dataContext: q,
            yAxisField: c,
            yList: pt(S.series),
            xAxisField: l,
            splitBy: $,
            chartType: F,
            chartSubType: A,
            showOutliers: x,
            isFeatureCollectionLayer: la(a)
          })), zr({
            elementDataContext: q,
            options: n,
            selectionDataItems: M ?? O ?? [],
            layerOidField: w,
            xAxisField: l,
            yAxisField: c,
            chartType: F,
            chartSubType: A,
            showOutliers: x
          });
        };
        v.forEach((U) => {
          const q = U.isActive || W(U);
          vi({
            element: U,
            selected: q,
            useNativeState: p instanceof Me,
            backToDefaultState: R
          });
        });
      }
    }
    if (et(e.uid, { isSelectionApplied: !0 }), KO({ chart: p, chartType: F, showMean: C }) && (JO(p), P || N)) {
      let R = B(p.uid, "computedSelectionDataItems") ?? M;
      R = Array.from(
        new Set(R?.map((W) => JSON.stringify(W)))
      ).map((W) => JSON.parse(W)), M !== void 0 && J(p.uid, {
        currentSelectionDataItems: R
      }), f?.selectionOIDs !== void 0 && J(p.uid, {
        currentSelectionOIDs: f.selectionOIDs
      });
      let $;
      if (m === !0 && ($ = B(p.uid, "computedSelectionIndexes") ?? y, $ !== void 0 && J(p.uid, {
        currentSelectionIndexes: $
      })), R === void 0 || R.length === 0)
        Co({
          chart: p,
          selectionSource: Ue.ProgrammaticSelection
        });
      else {
        const W = {
          selectionItems: R,
          selectionSource: Ue.ProgrammaticSelection
        };
        m === !0 && (W.selectionIndexes = $), g !== !1 && (W.selectionOIDs = f?.selectionOIDs ?? B(p.uid, "currentSelectionOIDs")), oo({
          data: W,
          seriesConfig: S.series,
          htmlContainer: p.htmlContainer
        });
      }
      J(p.uid, {
        computedSelectionIndexes: void 0,
        computedSelectionDataItems: void 0
      });
    }
  }
}
async function nB(t) {
  const { chart: e, options: i, dataWasUpdated: a, chartData: n, chartConfig: o, queryObject: s, rotationChanged: r, errorStrings: l } = t, c = B(e.uid, "currentSelectionOIDs"), d = B(e.uid, "queryConfig"), u = await lh({
    chartConfig: o,
    queryConfig: d,
    chartData: n,
    currentSelectionOIDs: c,
    dataWasUpdated: a,
    queryObject: s,
    options: i,
    errorStrings: l
  });
  u !== void 0 && i !== void 0 && (i.selectionData = {
    ...i?.selectionData,
    selectionItems: u
  });
  for (let f = 0; f < e.series.length; f += 1) {
    let m = e.series.getIndex(f);
    if (m) {
      const g = Jr(m, o);
      if (g) {
        const y = z([g]);
        if (y === b.ScatterSeries ? m = e.series.values.find((p) => te(p.uid, "isOverlay") !== !0) : y === b.BoxPlotSeries && (m = e.series.values.find((p) => p.id === g.id)), m !== void 0) {
          const p = g.x, S = y === b.BoxPlotSeries ? g.y.toString() : Za(m);
          yI({
            callbackProps: {
              ...t,
              series: m,
              seriesIndex: f,
              xAxisField: p,
              yAxisField: S
            },
            series: m,
            seriesConfig: g,
            onReadyEvent: r === !0
          });
        }
      }
    }
  }
}
async function ps(t) {
  const { chart: e, listSelectedElements: i, selectionSource: a } = t, n = B(e.uid, "options"), o = B(e.uid, "config"), s = B(e.uid, "queryObject");
  if (i.length === 0)
    Co({
      chart: e,
      selectionSource: a,
      clearOnlyVisibleSeries: !1,
      disposeStyleAndSelection: !1
    });
  else
    try {
      Yp(e, "updateSelectionCallbackDisposer");
      const r = Mi(o), l = [], c = [];
      let d = [];
      const u = /* @__PURE__ */ new Map(), { xAxisField: f } = i[0] ?? {}, m = H(o?.series), g = pt(o?.series ?? []), y = Vk(e);
      let p;
      if (s !== void 0 && (p = (await At(s)).find((C) => C.name === f)?.type), i.forEach((x) => {
        const { elementDataContext: C, yAxisField: F, chartType: v, splitBy: A, dataTransformationType: w } = x, O = fa({
          dataContext: C,
          yAxisField: F,
          yList: g,
          xAxisField: f,
          splitBy: A,
          chartType: v,
          chartSubType: m,
          showOutliers: r,
          isFeatureCollectionLayer: la(s)
        });
        O !== void 0 && c.push(O);
        const { seriesIndex: I, elementIndex: N } = x;
        if (N !== void 0) {
          const M = u.get(I)?.indexesToSelect ?? [];
          M.push(N), u.set(I, {
            indexesToSelect: Array.from(new Set(M))
          });
        }
        if (C !== void 0) {
          const M = C[ot.uniqueIdsName] !== void 0 ? [C[ot.uniqueIdsName]].flat() : [];
          if (M.length > 0)
            d.push(...M);
          else if (n?.returnSelectionOIDs !== !1) {
            const P = Eg({
              chartType: v,
              dataContext: C,
              options: n,
              xAxisField: f,
              yAxisField: F ?? "",
              splitBy: A,
              dataTransformationType: w,
              isDateAxis: y,
              xAxisFieldType: p,
              chartSubType: m,
              showOutliers: o?.showOutliers
            });
            l.push(P);
          }
        }
      }), n?.returnSelectionOIDs !== !1 && s !== void 0 && l.length > 0) {
        const C = { ...B(e.uid, "queryConfig") };
        delete C.groupByFieldsForStatistics, delete C.orderByFields, delete C.outStatistics;
        const F = await ch({
          whereList: l,
          queryObject: s,
          queryConfig: C
        });
        if (l.length === i.length)
          d = F;
        else
          for (let v = 0; v < F.length; v += 1)
            d.push(F[v]);
      }
      J(e.uid, {
        currentSelectionDataItems: c,
        currentSelectionOIDs: d,
        currentSelectionIndexes: u
      });
      const S = {
        selectionItems: c,
        selectionSource: a
      };
      n?.returnSelectionIndexes === !0 && (S.selectionIndexes = u), n?.returnSelectionOIDs !== !1 && (S.selectionOIDs = d), oo({
        data: S,
        seriesConfig: o?.series,
        htmlContainer: e.htmlContainer
      });
    } catch (r) {
      J(e.uid, { pendingSelectionQueries: !1 });
      const { httpStatus: l } = r instanceof ln ? r.details.details : r.details ?? {};
      if (l === 429)
        QO(e);
      else
        throw r;
    }
  J(e.uid, { pendingSelectionQueries: !1 });
}
function oB(t, e) {
  const i = T.cursorCrosshair.style, a = {
    type: re.SLS,
    style: e.style ?? i.style,
    color: e.color ?? i.color,
    width: e.width ?? i.width
  };
  Bi({ element: t.cursor.lineX, lineSymbol: a }), Bi({ element: t.cursor.lineY, lineSymbol: a });
}
function fy(t) {
  !(t instanceof zt) && !(t instanceof Me) && (t.cursor = new im());
}
function my(t, e) {
  if (!(t instanceof zt) && !(t instanceof Me)) {
    const i = t, a = i.cursor ?? new im();
    e?.style !== void 0 && oB(i, e.style);
    const n = T.cursorCrosshair;
    a.lineX.disabled = n.verticalLineVisible ? e?.verticalLineVisible === !1 : e?.verticalLineVisible !== !0, a.lineY.disabled = n.horizontalLineVisible ? e?.horizontalLineVisible === !1 : e?.horizontalLineVisible !== !0, i.cursor = a;
  }
}
function sB(t) {
  return !(t instanceof zt) && t.cursor === void 0 && fy(t), t.cursor;
}
function Jl(t, e) {
  const i = t.renderer.labels.template;
  i.events.hasListenersByType(E.Hit) && (i.cursorOverStyle = e), t.renderer.labels.each((a) => {
    a.cursorOverStyle = e;
  });
}
function rB(t) {
  const { chart: e, chartType: i, showMean: a, enabled: n } = t, o = n ? ki.pointer : ki.default;
  switch (i) {
    case b.HistogramSeries:
    case b.ComboLineAndBarSeries:
    // CT: for combo, we won't have a line with value x-axis
    case b.BarSeries:
    case b.PieSeries:
      e.series.each((s) => {
        (s instanceof it || s instanceof xi) && (s.cursorOverStyle = o);
      });
      break;
    case b.BoxPlotSeries:
      e.series.each((s) => {
        let r = o;
        if (s instanceof ye) {
          const l = He(s);
          l !== void 0 && (a && te(s.uid, "isBoxPlotOutliersSeries") && (r = ki.default), l.cursorOverStyle = r, l.clones.each((c) => {
            c.cursorOverStyle = r;
          }));
        } else
          s.cursorOverStyle = a ? ki.default : o;
      });
      break;
    case b.LineSeries:
    case b.ScatterSeries:
      e.series.each((s) => {
        if (s instanceof ye && te(s.uid, "isOverlay") !== !0) {
          const r = He(s);
          r !== void 0 && (r.cursorOverStyle = o, r.clones.each((l) => {
            l.cursorOverStyle = o;
          }));
        }
      });
      break;
  }
}
function lB(t) {
  const { chart: e, actionMode: i, cursorRange: a } = t, n = B(e.uid, "isRotated"), o = B(e.uid, "config"), s = qe(o), r = z(o?.series), l = r === b.ScatterSeries, c = r === b.LineSeries && Pe(o?.axes?.[0]?.valueFormat), d = r === b.LineSeries && Ya(o?.axes?.[0]?.valueFormat), u = r === b.LineSeries && mi(o?.axes?.[0]?.valueFormat);
  let f, m = !1;
  const g = i ?? B(e.uid, "actionMode") ?? T.actionMode;
  if (B(e.uid, "filterBySelection") === !0)
    f = Ce.None, m = !1;
  else if (a !== void 0)
    f = up({ actionMode: g, cursorRange: a, isRotated: n });
  else
    switch (g) {
      case ne.Zoom:
        l || c || u ? f = Ce.ZoomXY : f = n === !0 ? Ce.ZoomY : Ce.ZoomX, m = !1;
        break;
      case ne.MultiSelection:
      case ne.MultiSelectionWithCtrlKey:
        d ? f = n === !0 ? Ce.SelectY : Ce.SelectX : f = Ce.SelectXY, m = !0;
        break;
      case ne.MonoSelection:
        f = Ce.None, m = !0;
        break;
      case ne.None:
        f = Ce.None, m = !1;
        break;
    }
  e instanceof fe && e.cursor !== void 0 && f !== void 0 && (e.cursor.behavior = f), rB({ chart: e, chartType: r, enabled: m, showMean: s });
}
function cB(t) {
  const { axis: e } = t, i = e.chart;
  return { axis: e, chart: i };
}
async function dB(t) {
  const e = t.target, { axis: i, chart: a } = cB(e), n = [], { seriesDataItems: o } = t.target.dataItem;
  Object.keys(o).forEach((u) => {
    if (Object.hasOwn(o, u)) {
      const f = o[u];
      for (const m of f)
        if (m instanceof Ko)
          n.push(m.column);
        else {
          const g = m.sprites.find((y) => !(y instanceof Vo));
          g !== void 0 && n.push(g);
        }
    }
  });
  const s = el(t, a), r = i instanceof Ge || i instanceof kt, l = [], d = B(a.uid, "config")?.series[0].x ?? "";
  a.series.each((u, f) => {
    let m;
    if (u instanceof it ? m = u.columns : m = He(u)?.clones, u.visible) {
      const g = Za(u), y = u.dataFields?.customValue ?? "", p = fs(u, f);
      m?.each((S, x) => {
        const C = n.includes(S);
        vi({
          element: S,
          selected: C,
          multiSelect: s,
          isDateOrCategoryAxis: r
        }) && l.push({
          element: S,
          elementDataContext: S.dataItem?.dataContext,
          yAxisField: g,
          xAxisField: d,
          splitBy: y,
          chartType: p,
          seriesIndex: f,
          elementIndex: x
        });
      });
    }
  }), await ps({
    chart: a,
    listSelectedElements: l,
    selectionSource: Ue.SelectionByClick
  });
}
function uB(t) {
  if (gi(t.renderer.labels.template)) {
    t.renderer.labels.template.events.on(E.Hit, async (a) => {
      t.renderer.labels.template.events.isEnabled(E.Hit) && await dB(a);
    });
    const i = B(t.chart.uid, "filterBySelection") === !0 ? ki.default : ki.pointer;
    Jl(t, i);
  }
}
function dr(t, e) {
  if (gi(t?.renderer?.labels?.template) && (t instanceof kt || t instanceof Ge))
    if (e)
      t.renderer.labels.template.events.disableType(E.Hit), Jl(t, ki.default);
    else {
      t.renderer.labels.template.events.enableType(E.Hit);
      const a = B(t.chart.uid, "filterBySelection") === !0 ? ki.default : ki.pointer;
      Jl(t, a);
    }
}
function pn(t) {
  const { chart: e, label: i, labelType: a } = t;
  let n = Number.NaN;
  switch (a) {
    case ue.GuideLabel:
      !(e instanceof zt) && e instanceof fe && (i.rotation === 90 || i.rotation === 270 ? n = e.seriesContainer.measuredHeight : n = e.seriesContainer.measuredWidth);
      break;
    case ue.XAxisTitle:
      e instanceof fe && (n = e.seriesContainer.measuredWidth);
      break;
    case ue.YAxisTitle:
      e instanceof fe && (n = e.seriesContainer.measuredHeight);
      break;
    case ue.ChartTitle:
    case ue.ChartSubTitle:
    case ue.ChartFooter:
      n = e.measuredWidth - 20;
      break;
  }
  n > 0 && (i.maxWidth = n, e.invalidateLabels(), e instanceof fe && (e.xAxes.getIndex(0)?.invalidateLabels(), e.xAxes.getIndex(1)?.invalidateLabels(), e.yAxes.getIndex(0)?.invalidateLabels(), e.yAxes.getIndex(1)?.invalidateLabels()));
}
function Xo(t) {
  const { chart: e, labelType: i } = t;
  pn(t);
  const a = i === ue.YAxisTitle ? 1 : 0;
  e.events.on(
    E.Validated,
    at(() => pn(t), T.debounceTime),
    a
  );
}
function fB(t, e) {
  t.chart instanceof zt || (e.adapter.add("dx", (i) => {
    let a = i;
    return (e.rotation === 90 || e.rotation === 270) && (a = e.bbox.height, e.dataItem.value !== e.dataItem.endValue && (a /= 2)), a;
  }), e.padding(0, 10, 0, 10));
}
function mB(t, e) {
  const i = t.renderer instanceof Lr ? new bc() : new yc();
  return i.disabled = !0, i.axis = t, Zr(i), Ji(i.uid, { isGuide: e }), Xo({ chart: t.chart, label: i, labelType: ue.GuideLabel }), e && fB(t, i), i;
}
function gB(t) {
  const { label: e, labelConfig: i, guideType: a } = t, n = e.axis.renderer instanceof oi;
  let o;
  e instanceof bc || (n ? a === re.SFS ? o = T.verticalSurfaceGuideLabels : o = T.verticalLineGuideLabels : a === re.SFS ? o = T.horizontalSurfaceGuideLabels : o = T.horizontalLineGuideLabels);
  const s = { ...i };
  s.content.rightToLeft = e.axis.rtl, Kt({ label: e, labelConfig: s, defaults: o }), e.axis.invalidateLabels();
}
function hB(t, e, i) {
  const a = i.chart;
  t.axisFill.tooltip = new cm(), t.axisFill.interactionsEnabled = !0, t.axisFill.tooltipPosition = T.columnTooltipPosition, t.axisFill.tooltip.label.wrap = !0, t.axisFill.tooltip.adapter.add(
    "maxWidth",
    () => Math.min(T.tooltipWidth, a.seriesContainer.maxWidth)
  ), t.axisFill.tooltip.boundingContainer = a.chartAndLegendContainer, t.axisFill.adapter.add("tooltipHTML", (n, o) => {
    let s = n;
    const { dataItem: r, axis: l } = o;
    if (!(l.renderer instanceof Lr)) {
      const c = vt(
        l.uid,
        "guideTooltipFormatter"
      );
      if (c !== void 0) {
        let d = "", u;
        r instanceof Sc ? (d = r.value, u = r.endValue) : r instanceof Gn ? (d = r.category, u = r.endCategory) : r instanceof Fr && (d = r.date, u = r.endDate), s = c({
          guideName: r.id ?? "",
          start: d,
          end: u,
          guideIndex: e
        });
      }
    }
    return s;
  }), t.axisFill.tooltip.events.on(E.Shown, (n) => {
    const o = B(t.axisFill.axis.chart.uid, "config");
    if (o !== void 0) {
      const s = B(t.axisFill.axis.chart.uid, "isRotated"), l = !An(t.axisFill.axis.renderer, s) ? 1 : 0, d = o.axes?.[l]?.guides, { tooltipReverseColor: u } = d?.[e] ?? {};
      Jp(n.target, u);
    }
  });
}
function pB(t, e) {
  return (i) => {
    const { guideName: a, start: n, end: o, guideIndex: s } = i, { chart: r } = t;
    let l = "";
    if (r !== void 0) {
      const c = B(r.uid, "config"), d = B(r.uid, "isRotated"), f = !An(t.renderer, d) ? 1 : 0, g = c?.axes?.[f]?.guides;
      let y = n, p = o;
      if (t instanceof Ge) {
        let F = new am(), v;
        if (r !== void 0) {
          const A = B(t.chart.uid, "formatLocale");
          F = ui({
            type: b.DateAxisFormat,
            iLocale: r.language.locale,
            formatLocale: A
          }), v = c?.axes?.[0]?.valueFormat?.intlOptions;
        }
        y = F.format(n, v), o !== void 0 && (p = F.format(o, v));
      } else if (t instanceof Ne && !(n instanceof Date) && !(o instanceof Date)) {
        const { start: F, end: v } = Cd(t, g?.[s]);
        Number.isFinite(F) && (y = F), Number.isFinite(v) && (p = v);
        const A = vt(t.uid, "numberFormatter") ?? ((w) => new nm().format(w));
        y = A(y), p !== void 0 && (p = A(p));
      } else t instanceof kt && (y = n, p = o);
      const S = y.toString(), x = p?.toString() ?? "";
      !be(x) && S !== x ? l = Gt(e.guideTooltipLabel, {
        guideStart: S,
        guideEnd: x
      }) : l = S;
      const C = ai(r.rtl);
      l = `${a}${C} ${l}`;
    }
    return l;
  };
}
function yB(t) {
  const { axis: e, guideTooltipFormatter: i, commonStrings: a } = t;
  ht(e.uid, {
    guideTooltipFormatter: i ?? pB(e, a)
  });
}
function bB(t) {
  let e = Nn.Value;
  return t instanceof Ge ? e = Nn.Date : t instanceof kt && (e = Nn.Category), e;
}
function hf(t) {
  const { inputValue: e, axisType: i, axisMin: a, axisMax: n } = t;
  let o = e;
  if (e != null)
    switch (i) {
      case Nn.Date:
        o = e instanceof Date ? e : new Date(e);
        break;
      case Nn.Category:
        o = e.toString();
        break;
      case Nn.Value:
        if (typeof e != "number") {
          const s = e.toString().trim(), r = kr(s);
          r !== void 0 ? a !== void 0 && n !== void 0 ? o = r / 100 * (n - a) + a : o = null : o = Number.parseFloat(s);
        }
        break;
    }
  return o;
}
function Cd(t, e) {
  const { start: i, end: a } = e ?? {};
  let n;
  if (e !== void 0 && i !== void 0 && i !== null) {
    const o = bB(t), s = t instanceof Ne ? t.min : void 0, r = t instanceof Ne ? t.max : void 0, l = hf({
      inputValue: i,
      axisType: o,
      axisMin: s,
      axisMax: r
    }), c = e.style?.type === re.SFS && a !== null && a !== void 0 ? hf({
      inputValue: a,
      axisType: o,
      axisMin: s,
      axisMax: r
    }) : l;
    n = {
      isValidGuide: l != null && c != null,
      start: l,
      end: c
    };
  } else
    n = { isValidGuide: !1, start: void 0, end: void 0 };
  return n;
}
function gy(t) {
  const { axis: e, tickOrGuide: i, numberOfElementsToBeDeleted: a } = t, n = [];
  let o = e.axisRanges.length - 1, s = a;
  for (; s > 0 && o >= 0; ) {
    const r = e.axisRanges.getIndex(o);
    if (r !== void 0) {
      const l = dt(r.label?.uid, "isGuide") ?? !1;
      (l !== !0 && i === pe.Ticks || l === !0 && i === pe.Guides) && (n.push(r), s -= 1);
    }
    o -= 1;
  }
  for (let r = 0; r < n.length; r += 1)
    e.axisRanges.removeValue(n[r]);
}
function ft(t, e) {
  return t.axisRanges?.values?.filter((a) => {
    const n = dt(a.label?.uid, "isGuide") ?? !1, o = dt(a.label?.uid, "isGaugeAxisLabel") ?? !1;
    let s = !1;
    switch (e) {
      case pe.Ticks:
        s = n === !1;
        break;
      case pe.Guides:
        s = n === !0;
        break;
      case pe.GaugeTicksWithLabels:
        s = o === !0 && a.value !== void 0;
        break;
      case pe.GaugeFirstAndLastGuides:
        s = n === !0 && (a.id === T.gaugeFirstLabelId || a.id === T.gaugeLastLabelId);
        break;
    }
    return s;
  }) ?? [];
}
function hy(t, e) {
  let i = t.axisRanges.length;
  if (e) {
    const n = t.axisRanges.values.findIndex(
      (o) => o.id === T.gaugeFirstLabelId
    );
    n !== -1 && (i = n);
  }
  let a;
  return t instanceof kt ? a = new Gn() : t instanceof Ge ? a = new Fr() : a = new Sc(), t.axisRanges.insertIndex(i, a), a.label = mB(t, e), a.axisFill.fillOpacity = 1, a.axisFill.disabled = !0, a.grid.strokeOpacity = 1, a;
}
function SB(t, e) {
  const i = hy(t, !0);
  hB(i, e, t), i.tick !== void 0 && (i.tick.disabled = !0), i.label !== void 0 && (i.label.inside = !0), i.grid !== void 0 && (i.grid.disabled = !0);
}
function xB(t, e) {
  const { start: i, end: a } = e, n = B(t.uid, "config"), o = Tc(n);
  let s = i !== null ? i : void 0;
  s = t.data.find((c) => c[T.originalCategoryValue] === i)?.[o] ?? s;
  let l = a !== null ? a : void 0;
  if (l !== void 0)
    for (let c = t.data.length - 1; c >= 0; c -= 1) {
      const d = t.data[c];
      if (d[T.originalCategoryValue] === a) {
        l = d[o];
        break;
      }
    }
  return { modifiedStart: s, modifiedEnd: l };
}
function CB(t, e) {
  const { start: i, end: a } = e;
  if (i !== void 0) {
    const { chart: n } = t?.component ?? {};
    let o;
    if (t instanceof Gn && n instanceof fe && B(n.uid, "isNonAggregatedChart") === !0) {
      const { modifiedStart: s, modifiedEnd: r } = xB(n, e);
      o = {
        isValidGuide: !0,
        start: s ?? i,
        end: r ?? a
      };
    } else
      o = Cd(t.axisFill.axis, e);
    o.isValidGuide && (t instanceof Gn ? (t.category = `${o.start?.toString()}`, t.endCategory = `${o.end?.toString()}`) : t instanceof Fr ? (t.date = o.start, t.endDate = o.end) : (t.value = o.start, t.endValue = o.end));
  }
}
function vB(t, e) {
  t.axisFill.above = e ?? T.guideAbove, t.grid.above = e ?? T.guideAbove;
}
function FB(t, e) {
  const { axisFill: i, label: a } = t;
  if (e !== void 0) {
    if (t.id = e.name, t.visible = e.visible !== void 0 ? e.visible : t.visible, CB(t, e), e.style.type === re.SLS ? Yo({
      element: i,
      fillSymbol: {
        type: re.SFS,
        color: e.style?.color,
        outline: e.style
      },
      visible: e.visible
    }) : e.style.type === re.SFS && Yo({
      element: i,
      fillSymbol: e.style,
      visible: e.visible
    }), vB(t, e.above), e.label !== void 0) {
      const o = {
        type: b.Text,
        visible: e.visible,
        content: e.label
      };
      gB({
        label: a,
        labelConfig: o,
        guideType: e.style.type
      });
    }
    const n = t.component?.chart;
    n !== void 0 && pn({
      chart: n,
      label: a,
      labelType: ue.GuideLabel
    });
  } else
    i.disabled = !0, a.disabled = !0;
}
function LB(t, e) {
  const a = ft(t, pe.Guides).length, n = e?.length ?? a;
  for (let o = a; o < n; o += 1)
    SB(t, o);
}
function AB(t) {
  const { axis: e, guides: i, guideTooltipFormatter: a, commonStrings: n } = t;
  if (i !== void 0) {
    for (let o = 0; o < i.length; o += 1) {
      const r = ft(e, pe.Guides)[o];
      r !== void 0 && FB(r, i[o]);
    }
    yB({ axis: e, guideTooltipFormatter: a, commonStrings: n });
  }
}
function TB(t, e) {
  const a = ft(t, pe.Guides).length, n = e?.length ?? 0, o = a - n;
  gy({
    axis: t,
    numberOfElementsToBeDeleted: o,
    tickOrGuide: pe.Guides
  });
}
function wB(t) {
  const { axis: e, guides: i } = t;
  LB(e, i), AB(t), TB(e, i);
}
function kB(t) {
  const e = hy(t, !1);
  e.label.inside = !1, e.grid.disabled = !0, e.label.html = T.htmlEmptyContent, e.label.adapter.add(
    "htmlOutput",
    (i, a) => cd(t, a?.dataItem?.value ?? i)
  );
}
function IB(t) {
  const { axisTick: e, value: i, axisConfig: a, numberFormatter: n } = t;
  e.value = i, a.labels.content.text = n.format(i), Bi({
    element: e.tick,
    lineSymbol: a.lineSymbol,
    visible: a.visible
  });
}
function OB(t, e) {
  const a = ft(t, pe.Ticks).length, o = (e?.length ?? a) - a;
  for (let s = 0; s < o; s += 1)
    kB(t);
}
function BB(t) {
  const { valueAxis: e, axisConfig: i, ticks: a } = t, n = B(e.chart.uid, "formatLocale"), o = ui({
    type: i.valueFormat.type,
    iLocale: e.chart.language.locale,
    formatLocale: n
  });
  if (o.numberFormat = _i(i.valueFormat), a !== void 0) {
    const s = ft(e, pe.Ticks);
    for (let r = 0; r < a.length; r += 1) {
      const l = s[r];
      if (l !== void 0) {
        const c = a[r];
        IB({ axisTick: l, value: c, axisConfig: i, numberFormatter: o });
      }
    }
  }
}
function DB(t, e) {
  const a = ft(t, pe.Ticks).length, n = e?.length ?? 0, o = a - n;
  gy({
    axis: t,
    numberOfElementsToBeDeleted: o,
    tickOrGuide: pe.Ticks
  });
}
function NB(t) {
  const { valueAxis: e, axisConfig: i, ticks: a } = t;
  OB(e, a), BB({ valueAxis: e, axisConfig: i, ticks: a }), DB(e, a);
}
function py(t) {
  const { axis: e, labels: i, restoreLabelsVisibility: a = !0 } = t;
  let n, o = 0;
  if ((i ?? e.renderer.labels.values).forEach((s) => {
    const r = s.x instanceof js ? s.x.value : s.x;
    r > o && (o = r, n = s), a && se(s, !0);
  }), n?.visible === !0) {
    const s = Math.max(1, n.measuredWidth) / 2, r = e.chart.leftAxesContainer.measuredWidth;
    if (Number.isFinite(o) && Number.isFinite(s) && Number.isFinite(r)) {
      const c = o + s + r > e.chart.measuredWidth && n.rotation === 0;
      se(n, !c);
    }
  }
}
function yy(t) {
  const e = t.renderer.labels.values.filter(
    (i) => dt(i.uid, "isGuide") !== !0 && i.measuredWidth > 0
  ).length;
  return t.pixelWidth / e;
}
function MB(t) {
  const { target: e } = t;
  if ((B(e.chart.uid, "config")?.horizontalAxisLabelsBehavior ?? De.Rotate) === De.Wrap) {
    let n = Number.MAX_SAFE_INTEGER;
    e.renderer.labels.each((s) => {
      dt(s.uid, "isGuide") !== !0 && s.measuredWidth > 0 && (n = Math.min(
        n,
        s.bbox.width
      ));
    });
    const o = e instanceof Ge ? e.pixelWidth / T.maxNumberOfXAxisLabelsInWrapModeForDateAxis : e.pixelWidth / T.maxNumberOfXAxisLabelsInWrapMode;
    e.renderer.minGridDistance = Math.max(n + 1, o);
  }
}
function $B(t) {
  const { axis: e, labelsConfig: i, horizontalAxisLabelsBehavior: a, isSecondValueAxis: n, tickSpacing: o } = t;
  let s = e.renderer.minGridDistance;
  if (typeof o == "number" && Number.isFinite(o))
    s = o;
  else if (e.renderer instanceof Lr)
    s = T.gauge.gaugeMinGridDistance;
  else if (e instanceof Ne)
    s = e.renderer instanceof oi ? T.xAxisMinGridDistance : T.yAxisMinGridDistance;
  else if (e.renderer instanceof oi)
    if (n === !0)
      s = T.secondRotatedValueAxisMinGridDistance;
    else if (a === void 0 || a === De.Rotate) {
      const r = i.content.font?.size ?? T.generalFontSize, l = e instanceof kt ? T.categoryAxisLabelPadding : T.axisLabelPadding;
      s = r * l;
    } else if (a === De.Wrap) {
      const r = at(
        MB,
        T.debounceTime
      );
      ht(e.uid, {
        debouncedUpdateMinGridDistanceForWrapBehavior: r
      }), e.events.on(E.SizeChanged, r), e.dispatchImmediately(E.SizeChanged);
    } else a === De.Stagger ? s = T.staggerMinGridDistance : s = e instanceof kt ? T.xCategoryAxisMinGridDistance : T.xAxisMinGridDistance;
  else
    s = e instanceof kt ? T.yCategoryAxisMinGridDistance : T.yAxisMinGridDistance;
  e.renderer.minGridDistance = s;
}
function PB(t) {
  const e = t.renderer.labels.template;
  gi(e) && (e.adapter.add(
    "rotation",
    (i, a) => dt(a.uid, "isGuide") !== !0 ? vt(t.uid, "labelsSymbol")?.angle ?? i : i
  ), e.adapter.add(
    "verticalCenter",
    (i, a) => dt(a.uid, "isGuide") !== !0 ? vt(t.uid, "labelsSymbol")?.verticalCenter ?? i : i
  ), e.adapter.add(
    "horizontalCenter",
    (i, a) => dt(a.uid, "isGuide") !== !0 ? vt(t.uid, "labelsSymbol")?.horizontalCenter ?? i : i
  ), e.adapter.add("dy", (i, a) => {
    let n = T.axisLabel.dy ?? i ?? 0;
    return a.dataItem?.tick?.length > T.axisTickLength ? n = i ?? 0 : n = Number(
      dt(a.uid, "isGuide") !== !0 ? vt(t.uid, "labelsSymbol")?.yOffset ?? n : n
    ), n;
  }));
}
function RB(t) {
  const { target: e } = t;
  if (e.chart !== void 0) {
    const a = B(e.chart.uid, "config")?.axes?.[0].labels;
    if ((a?.visible ?? !0) && a !== void 0 && e.renderer.labels.length > 1) {
      let o = 0;
      e.renderer.labels.each((c) => {
        if (dt(c.uid, "isGuide") !== !0 && c.measuredWidth > 0) {
          const d = c.bbox.width;
          d > o && (o = d);
        }
      });
      const s = vt(e.uid, "labelsSymbol")?.angle ?? 0, l = yy(e) >= o + 5;
      if (!l && s === 0 || l && s === T.rotatedAxisLabel.rotation) {
        const c = l ? lr(a.content, e.rtl, T.axisLabel) : lr({ type: re.TS }, e.rtl, T.rotatedAxisLabel);
        ht(e.uid, { labelsSymbol: c }), e.renderer.invalidateLabels();
      }
    }
  }
}
function VB(t, e = 1) {
  const { target: i } = t, a = yy(i);
  Number.isFinite(a) && (i.renderer.labels.template.maxWidth = Math.min(a * e, i.renderer.minGridDistance));
}
function EB(t) {
  const { target: e } = t;
  if (B(e.chart.uid, "config")?.axes?.[0].labels?.visible !== !1) {
    let n = 0;
    e.dataItems.each((o) => {
      const { label: s, itemIndex: r } = o;
      dt(s.uid, "isGuide") !== !0 && s.currentText !== void 0 && s.measuredWidth > 0 && r % 2 === 0 && s.bbox.height > n && (n = s.bbox.height);
    }), e.dataItems.each((o) => {
      const { tick: s, label: r, itemIndex: l } = o;
      if (dt(r.uid, "isGuide") !== !0 && r.currentText !== void 0 && r.measuredWidth > 0) {
        const c = l % 2 === 1;
        s.length = c ? n + 5 : T.axisTickLength, s.dataItem.label.dy = T.axisLabel.dy + (c ? n : 0);
      }
    }), n !== void 0 && (e.renderer.labels.template.paddingBottom = n + 5), e.validate();
  }
}
function WB(t) {
  const { chart: e } = t;
  t.renderer.labels.template.paddingLeft = Number.NaN, t.renderer.labels.template.paddingRight = Number.NaN;
  const i = vt(t.uid, "debouncedAxisLabelRotationCallback");
  if (i !== void 0 && (t.events.off(E.Validated, i), ht(t.uid, {
    debouncedAxisLabelRotationCallback: void 0
  })), e !== void 0) {
    const n = B(e.uid, "config")?.axes?.[0].labels;
    if (n !== void 0) {
      const o = lr(n.content, e.rtl, T.axisLabel), s = t.renderer.labels.template;
      s.rotation = o.angle, s.verticalCenter = o.verticalCenter, s.horizontalCenter = o.horizontalCenter, Number.isFinite(o.yOffset) && (s.dy = o.yOffset);
    }
    ht(t.uid, { labelsSymbol: void 0 });
  }
}
function by(t) {
  t.renderer.labels.template.wrap = !1, t.renderer.labels.template.textAlign = "start";
}
function zB(t) {
  by(t), t.renderer.labels.template.paddingLeft = Number.NaN, t.renderer.labels.template.paddingRight = Number.NaN;
  const e = vt(
    t.uid,
    "debouncedAxisLabelWrapCallback"
  );
  e !== void 0 && (t.events.off(E.DataRangeChanged, e), ht(t.uid, { debouncedAxisLabelWrapCallback: void 0 }));
}
function HB(t) {
  by(t);
  const e = vt(t.uid, "debouncedUpdateMinGridDistanceForWrapBehavior");
  e !== void 0 && (t.events.off(E.SizeChanged, e), ht(t.uid, {
    debouncedUpdateMinGridDistanceForWrapBehavior: void 0
  }));
}
function qB(t) {
  const e = vt(t.uid, "debouncedAxisLabelStaggerCallback");
  e !== void 0 && (t.events.off(E.DataRangeChanged, e), ht(t.uid, {
    debouncedAxisLabelStaggerCallback: void 0
  })), t.renderer.ticks.each((i) => {
    i.length = T.axisTickLength, i.dataItem?.label && (i.dataItem.label.dy = T.axisLabel.dy ?? 0);
  });
}
function GB(t) {
  WB(t), zB(t), qB(t);
}
function pf(t) {
  PB(t), t.renderer.labels.template.paddingLeft = 0, t.renderer.labels.template.paddingRight = 0, t.renderer.labels.template.maxWidth = Number.NaN;
  const e = at(RB, T.debounceTime, {
    leading: !0
  });
  ht(t.uid, { debouncedAxisLabelRotationCallback: e }), t.events.on(E.Validated, e), t.dispatchImmediately(E.Validated);
}
function yf(t, e = 1) {
  t.renderer.labels.template.wrap = !0, t.renderer.labels.template.paddingLeft = 0.5, t.renderer.labels.template.paddingRight = 0.5, t.renderer.labels.template.textAlign = "middle";
  const i = at((a) => VB(a, e), T.debounceTime);
  ht(t.uid, { debouncedAxisLabelWrapCallback: i }), t.events.on(E.DataRangeChanged, i);
}
function YB(t) {
  t.renderer.labels.template.maxWidth = T.yAxisLabelMaxWidth, t.renderer.labels.template.wrap = !0, t.renderer.labels.template.textAlign = "end";
}
function XB(t) {
  const e = at(EB, T.debounceTime);
  ht(t.uid, { debouncedAxisLabelStaggerCallback: e }), t.events.on(E.DataRangeChanged, e);
}
function UB(t) {
  const {
    axis: e,
    horizontalAxisLabelsBehavior: i,
    verticalAxisLabelsBehavior: a,
    labelsConfig: n,
    axisLabelsBehaviorChanged: o,
    isSecondValueAxis: s
  } = t;
  if (e.renderer instanceof oi && o?.[0] !== !1) {
    if (GB(e), s !== !0)
      switch (i) {
        case De.Hide:
          break;
        case De.Stagger:
          XB(e), yf(e, 1.5);
          break;
        case De.Wrap:
          yf(e);
          break;
        case De.Rotate:
          pf(e);
          break;
        default:
          n.content.angle !== null && n.content.angle === void 0 && pf(e);
          break;
      }
  } else e.renderer instanceof Yn && (a !== De.Hide ? YB(e) : HB(e));
}
function jB(t) {
  const {
    axis: e,
    axisConfig: i,
    chartType: a,
    horizontalAxisLabelsBehavior: n,
    verticalAxisLabelsBehavior: o,
    axisLabelsBehaviorChanged: s,
    isSecondValueAxis: r
  } = t;
  if (e.renderer instanceof Yn || a !== b.HistogramSeries) {
    const l = e.renderer.labels.template;
    l.axis = e;
    const { labels: c } = i, d = e.renderer instanceof oi && l.rotation === T.rotatedAxisLabel.rotation, u = c;
    let f;
    d ? (u.content.angle = void 0, u.content.horizontalAlignment = void 0, u.content.verticalAlignment = void 0, u.content.yoffset = void 0, f = T.rotatedAxisLabel) : e.renderer instanceof oi && (n === De.Stagger || n === De.Wrap) && (f = { wrap: !0, dy: T.axisLabel.dy }), e.renderer instanceof Yn && o !== De.Hide && (f = { wrap: !0 }), Kt({ label: l, labelConfig: u, defaults: f }), e.renderer.labels.template.paddingTop = e.renderer instanceof oi ? 0 : T.axisLabel.dy, l.align = "none", l.valign = "none", UB({
      axis: e,
      horizontalAxisLabelsBehavior: n,
      verticalAxisLabelsBehavior: o,
      labelsConfig: c,
      axisLabelsBehaviorChanged: s,
      isSecondValueAxis: r
    }), l.axis.invalidateLabels();
  }
}
function vd(t) {
  return (t ?? Kf()) === Ie.Side;
}
function Sy(t, e) {
  let i, a;
  const n = Go(t, "bullets"), o = Go(t, "columns"), s = vd(e);
  return s && n !== void 0 ? (i = n, a = o) : s || (i = o, a = n), { labelToRender: i, labelToHide: a };
}
function _B(t, e = !0) {
  t.hideOversized = e;
}
function ZB(t, e) {
  let i, a;
  const n = Ci(T.dataLabelInitialize);
  Ji(n.uid, { isDataLabel: !0 }), t.bullets.push(n);
  const o = Ci(T.dataLabelInitialize, t.columns.template);
  return Ji(o.uid, { isDataLabel: !0 }), Kl(o, t), Kl(n, t), t.events.on(
    E.Validated,
    at(() => {
      qo(o) && o.clones.each((s) => {
        qo(s) && s.validate();
      });
    }, T.debounceTime)
  ), o.html = "{valueX}", n.html = "{valueX}", md(n), vd(e) ? (i = n, a = o) : (i = o, a = n), fd(b.BarSeries, n), Wp(b.BarSeries, i), { newLabelToRender: i, newLabelToHide: a };
}
function QB(t) {
  const { series: e, stackedType: i, isRotated: a, hideOversizedStackedLabels: n, hideOversizedSideBySideLabels: o } = t;
  let { labelToRender: s, labelToHide: r } = Sy(e, i);
  if (s === void 0) {
    const { newLabelToRender: d, newLabelToHide: u } = ZB(e, i);
    s = d, r = u;
  }
  let l = T.dataLabel, c = !0;
  vd(i) ? (l = a === !0 ? T.dataLabelRotated : T.dataLabel, c = o === !0) : (l = a === !0 ? T.dataLabelStackedRotated : T.dataLabelStackedNonRotated, c = n !== !1), _B(s, c), r !== void 0 && (r.visible = !1, r.disabled = !0), s.html = "{valueX}", Qr({
    ...t,
    dataLabel: s,
    labelDefaults: l,
    defaultDataLabelFormatter: zp,
    seriesType: b.BarSeries
  });
}
function KB(t) {
  const e = t.tooltip;
  e !== void 0 && !(t instanceof Ge) && (e.label.adapter.add("html", (i, a) => {
    let n = i ?? "";
    return t instanceof Ne ? n = cd(t, a.properties?.text ?? i ?? "") : t instanceof kt && (n = Dp({
      axis: t,
      defaultOutput: i ?? "",
      dataItem: e.dataItem
    })), rt(n);
  }), e.label.html = T.htmlEmptyContent);
}
function ec(t) {
  const { axis: e, start: i, end: a } = t;
  e.zoom({ start: i ?? 0, end: a ?? 1 });
}
function bf(t) {
  t !== void 0 && (t.start = 0, t.end = 1);
}
function Fd(t) {
  t !== void 0 && (t.xAxes !== void 0 && t.xAxes.each((e) => ec({ axis: e })), t.yAxes !== void 0 && t.yAxes.each((e) => ec({ axis: e })), bf(t.scrollbarX), bf(t.scrollbarY), se(t.zoomOutButton, !1));
}
function An(t, e) {
  return t instanceof oi && e !== !0 || t instanceof Yn && e === !0;
}
function JB(t) {
  gi(t.labels.template) && (t.labels.template.events.on(E.Over, (e) => {
    const { axisLabelOveredOpacity: i } = T;
    e.target.fillOpacity = (e.target.fillOpacity ?? 1) * i;
  }), t.labels.template.events.on(E.Out, (e) => {
    const { axisLabelOveredOpacity: i } = T;
    e.target.fillOpacity = (e.target.fillOpacity ?? 0.5) / i;
  }));
}
function eD(t) {
  const { axis: e, valueFormat: i, axisRenderer: a, chartType: n } = t;
  a.grid.template.applyOnClones = !0, a.ticks.template.applyOnClones = !0, a.labels.template.applyOnClones = !0, a.hoverable = !0, a.line.strokeOpacity = 1, a.grid.template.strokeOpacity = 1, a.ticks.template.strokeOpacity = 1, Zr(a.labels.template, T.axisLabel), a.ticks.template.disabled = !1, a.labels.template.disabled = !0, KB(e), Ya(i) && (JB(a), uB(e)), Xo({
    chart: e.chart,
    label: e.title,
    labelType: e.renderer instanceof oi ? ue.XAxisTitle : ue.YAxisTitle
  }), e.renderer instanceof oi && n !== b.HistogramSeries && e.events.on(
    E.Validated,
    at(() => {
      py({ axis: e, restoreLabelsVisibility: !0 });
    }, T.debounceTime)
  );
}
function tD(t) {
  const e = t.target;
  e.maxZoomFactor = 1;
  const i = B(e.chart.uid, "isRotated");
  let a = [];
  if (e instanceof Ne) {
    if (e.renderer instanceof Lr)
      a.push({
        isXAxis: !0,
        minimum: e.min,
        maximum: e.max
      });
    else if (e.renderer instanceof (i !== !0 ? Yn : oi)) {
      const n = t.target, o = n.chart, s = i !== !0 ? o.xAxes.getIndex(0) : o.yAxes.getIndex(0), r = o.yAxes.getIndex(1) ?? o.xAxes.getIndex(1);
      a = [
        {
          isXAxis: !1,
          minimum: n.min,
          maximum: n.max
        },
        {
          isXAxis: !0,
          minimum: s instanceof Ne ? s.min : void 0,
          maximum: s instanceof Ne ? s.max : void 0
        }
      ], r instanceof Ne && a.push({
        isXAxis: !1,
        isSecondValueAxis: !0,
        minimum: r.min,
        maximum: r.max
      });
    }
    a.length > 0 && a.every((n) => Number.isFinite(n.minimum) && Number.isFinite(n.maximum)) && xm(a, e.chart.htmlContainer);
  }
}
function iD(t) {
  t.events.on(E.Validated, at(tD, T.debounceTime));
}
function aD(t) {
  const { axis: e, isNonAggregatedChart: i } = t;
  let a, n, o;
  const s = e.dataItems.values, r = e.axisRanges.values;
  if (e instanceof kt)
    for (let l = 0; l < r.length; l += 1) {
      a = !1, n = !1, o = !1;
      const c = r[l], { category: d, endCategory: u, axisFill: f, grid: m, label: g } = c;
      if (c instanceof Gn && c.visible)
        for (let y = 0; y < s.length; y += 1) {
          let p;
          i === !0 ? p = Zt({
            value: s[y].category,
            dataContext: s[y].dataContext
          }) : p = s[y].category.toString(), d === p && (n = !0), u === p && (o = !0);
        }
      n && o && (a = !0), se(f, a), se(m, a), se(g, a);
    }
}
function Sf(t) {
  const { axis: e, axisMinimum: i, axisMaximum: a } = t;
  let n;
  if (e instanceof Ne && a !== void 0 && i !== void 0) {
    const o = e.axisRanges.values, s = B(e.chart.uid, "config"), r = B(e.chart.uid, "isRotated"), c = !An(e.renderer, r) ? 1 : 0, u = s?.axes?.[c]?.guides;
    for (let f = 0; f < o.length; f += 1) {
      const m = o[f], { value: g, endValue: y, axisFill: p, grid: S, label: x } = m;
      if (dt(x?.uid, "isGuide") === !0) {
        if (n = m.visible, n && m instanceof Sc) {
          const { start: F, end: v } = Cd(e, u?.[f]), A = Math.min(g, y, F ?? g, v ?? y), w = Math.max(g, y, F ?? g, v ?? y);
          A < i && w < i || A > a && w > a ? n = !1 : (m.value = A < i ? i : A, m.endValue = w > a ? a : w);
        }
        se(p, n), se(S, n), se(x, n);
      }
    }
  }
}
function nD(t) {
  t instanceof Ne ? (t.adapter.add("min", (e) => (Sf({
    axis: t,
    axisMinimum: e,
    axisMaximum: t.max
  }), e)), t.adapter.add("max", (e) => (Sf({
    axis: t,
    axisMinimum: t.min,
    axisMaximum: e
  }), e))) : t instanceof kt && t.events.on(E.Validated, () => {
    const e = B(t.chart.uid, "isNonAggregatedChart");
    aD({ axis: t, isNonAggregatedChart: e });
  });
}
function Do(t) {
  const { axes: e, isSecondValueAxis: i = !1, isXAxis: a, valueFormat: n, chartType: o } = t;
  let s;
  if (Tr({ isXAxis: a, chartType: o, valueFormat: n }) && !i)
    s = e.push(new kt());
  else if (mi(n))
    s = e.push(new Ge());
  else if (Pe(n)) {
    s = e.push(new Ne());
    const r = B(s.chart.uid, "formatLocale");
    s.numberFormatter = ui({
      type: b.NumberAxisFormat,
      iLocale: s.chart.language.locale,
      formatLocale: r
    }), s.numberFormatter.numberFormat = "#", i ? (s.renderer.opposite = !0, s.renderer.grid.template.disabled = !0) : iD(s);
  }
  s !== void 0 && (Gk(s), eD({
    axis: s,
    valueFormat: n,
    axisRenderer: s.renderer,
    chartType: o
  }), nD(s));
}
function il(t) {
  const { chart: e, axesConfig: i, isRotated: a, chartType: n } = t;
  J(e.uid, { isRotated: a === !0 });
  const o = a === !0 ? i?.[1] : i?.[0], s = a === !0 ? i?.[0] : i?.[1], r = o?.valueFormat, l = s?.valueFormat;
  r !== void 0 && l !== void 0 && (e.xAxes.clear(), e.yAxes.clear(), Do({
    chartType: n,
    isXAxis: a !== !0,
    axes: e.xAxes,
    valueFormat: r
  }), Do({
    chartType: n,
    isXAxis: a === !0,
    axes: e.yAxes,
    valueFormat: l
  }), i?.[2] !== void 0 && Do({
    chartType: n,
    isXAxis: a === !0,
    axes: a === !0 ? e.xAxes : e.yAxes,
    valueFormat: i[2].valueFormat,
    isSecondValueAxis: !0
  }));
}
function xy(t, e) {
  const { chart: i } = t;
  let a = !0;
  if (i !== void 0) {
    const n = B(i.uid, "config"), o = B(i.uid, "isRotated");
    if (n !== void 0) {
      const s = An(t.renderer, o);
      let r = 0;
      s || (r = e === !0 ? 2 : 1);
      const { isLogarithmic: l } = n.axes?.[r] ?? {};
      if (l === !0) {
        const c = Jo({
          chartConfig: n,
          isSecondValueAxis: e
        }), { minY: d, maxY: u, minX: f, maxX: m } = xr({
          chartConfig: n,
          chartData: i.data,
          filteredSeriesIds: c
        }), g = s ? f : d, y = s ? m : u;
        Number.isFinite(g) && g !== Number.MAX_SAFE_INTEGER && Number.isFinite(y) && y !== Number.MIN_SAFE_INTEGER && (a = g > 0 && y > 0);
      }
    }
  }
  return a;
}
function oD(t) {
  const { axis: e, isLogarithmic: i, isSecondValueAxis: a } = t;
  (e instanceof Ge || e instanceof Ne) && (e.logarithmic = i === !0 && xy(e, a));
}
function sD(t, e) {
  const { minimum: i, maximum: a, isLogarithmic: n } = e ?? {};
  let { buffer: o } = e ?? {};
  return o ??= T.buffer, t instanceof Ne && !(t instanceof Ge) && !o && (n !== !0 || a != null || i != null);
}
function rD(t, e) {
  let i = !1;
  return t instanceof Ne && !(t instanceof Ge) && (i = sD(t, e), t.strictMinMax = i), i;
}
function lD(t) {
  let e;
  return t >= 1 ? e = 10 ** (t.toFixed(0).length - 1) : t < 1 && t > 0 && (e = 10 ** -Math.abs(Math.floor(Math.log10(t)))), e;
}
function cD(t) {
  const { axis: e, axisConfig: i, chartType: a, isSecondValueAxis: n } = t, o = i?.minimum, s = i?.maximum, r = i?.isLogarithmic ?? !1;
  let l = o, c = s;
  const { chart: d } = e, u = B(d.uid, "isRotated"), f = B(d.uid, "config");
  let m = 0;
  if (d instanceof fe && f !== void 0) {
    const g = ti(f), y = An(e.renderer, u), p = mI(d), S = Jo({
      chartConfig: f,
      isSecondValueAxis: n,
      seriesIds: p
    }), x = xr({
      chartConfig: f,
      chartData: d.data,
      filteredSeriesIds: S
    }), { minX: C, maxX: F, minY: v, maxY: A } = x, [w, O] = y ? [C ?? Number.NaN, F ?? Number.NaN] : [v, A];
    m = w, a === b.BarSeries || a === b.HistogramSeries || a === b.ComboLineAndBarSeries || a === b.LineSeries && g === Ie.Stacked && !y ? (l = Math.min(w, 0), c = Math.max(O, 0)) : (l = w, c = O);
  }
  return l = o ?? l, c = s ?? c, r && l !== void 0 && l !== null && l <= 0 && (l = lD(m)), { min: l, max: c };
}
function Cy(t) {
  const { axis: e, axisConfig: i, chartType: a, isSecondValueAxis: n } = t, { minimum: o, maximum: s, isLogarithmic: r } = i ?? {};
  if (e instanceof Ne || e instanceof Ge)
    if (rD(e, i)) {
      let c = o, d = s;
      if (
        // If both the min and max from the config are valid, we directly assign them.
        // Otherwise, if strictMinMax is true, or if logarithmic is on and minimum is set to 0, we add some logic to consider the chart's data
        a !== b.HistogramSeries && (o != null && o <= 0 && r === !0 || e.strictMinMax && (!Number.isFinite(o) || !Number.isFinite(s)))
      ) {
        const u = cD({
          axis: e,
          axisConfig: i,
          chartType: a,
          isSecondValueAxis: n
        });
        c = u.min, d = u.max;
      }
      c = c ?? Number.NaN, d = d ?? Number.NaN, Number.isNaN(c) || Number.isNaN(d) || c < d ? (e.min = c, e.max = d) : (e.min = Number.NaN, e.max = Number.NaN), a === b.GaugeSeries && e.validate();
    } else
      e.min = Number.NaN, e.max = Number.NaN;
}
function dD(t) {
  const { axis: e, timeIntervalInfo: i, dateBaseInterval: a } = t;
  if (e instanceof Ge) {
    let { size: n, unit: o } = i ?? {};
    if (o || ({ size: n, unit: o } = a ?? {}), n !== void 0 && o !== void 0) {
      let s;
      switch (o) {
        case Q.Second:
          s = "second";
          break;
        case Q.Minute:
          s = "minute";
          break;
        case Q.Hour:
          s = "hour";
          break;
        case Q.Day:
          s = "day";
          break;
        case Q.Week:
          s = "week";
          break;
        case Q.Month:
          s = "month";
          break;
        case Q.Year:
          s = "year";
          break;
      }
      s !== void 0 && (e.baseInterval = {
        timeUnit: s,
        count: n
      });
    }
  }
}
function uD(t, e) {
  t instanceof Ne && (t.renderer.baseGrid.disabled = e !== !0);
}
function fD(t, e) {
  t.cursorTooltipEnabled = e === !0;
}
function mD(t, e) {
  const i = t.renderer instanceof oi;
  t.events.once(E.Validated, () => {
    let a = t.renderer instanceof Yn ? T.yAxisTitleLabel : T.xAxisTitleLabel;
    i && (a = { ...a, dy: a.dy ?? 0 }), Kt({ label: t.title, labelConfig: e, defaults: a }), pn({
      chart: t.chart,
      label: t.title,
      labelType: t.renderer instanceof oi ? ue.XAxisTitle : ue.YAxisTitle
    });
  });
}
function gD(t, e) {
  let i = !0;
  switch (e) {
    case b.ScatterSeries:
    case b.HistogramSeries:
      i = te(t.uid, "isOverlay") !== !0;
      break;
    case b.BoxPlotSeries:
      i = t instanceof ut;
      break;
  }
  return i;
}
function vy(t) {
  const e = at(() => {
    const { chart: i } = t, a = B(i.uid, "config");
    if (i !== void 0 && a !== void 0) {
      const n = z(a?.series);
      if (gD(t, n)) {
        const o = B(i.uid, "isRotated"), s = te(t.uid, "stackedType");
        s === Ie.Stacked100 && !t.visible && se(t, !1);
        const l = i.xAxes.getIndex(0), c = i.yAxes.getIndex(0), d = i.yAxes.getIndex(1), u = o === !0 ? 1 : 0, f = a.axes?.[u], m = o === !0 ? 0 : 1, g = a.axes?.[m], y = a.axes?.[2];
        [
          { axis: l, axisConfig: f, updateLabels: !1 },
          { axis: c, axisConfig: g, updateLabels: !0 },
          {
            axis: d,
            axisConfig: y,
            updateLabels: !0,
            isSecondValueAxis: !0
          }
        ].forEach((p) => {
          const { axis: S, axisConfig: x, updateLabels: C, isSecondValueAxis: F } = p;
          S !== void 0 && (Cy({
            axis: S,
            chartType: n,
            axisConfig: x,
            isSecondValueAxis: F
          }), C !== void 0 && S.events.once(E.Validated, () => {
            const { labelToRender: v } = Sy(t, s);
            v && (v.html = o === !0 ? "{valueX}" : "{valueY}");
          }));
        });
      }
    }
  }, T.debounceTime);
  t.events.once(E.Validated, e);
}
function hD(t, e) {
  if (t instanceof Ne) {
    const { integerOnlyValues: i, valueFormat: a } = e, n = em(a) ? a.intlOptions.maximumFractionDigits : void 0;
    t.maxPrecision = i === !0 || n === 0 ? 0 : Number.NaN;
  }
}
async function zs(t) {
  const {
    axis: e,
    axisConfig: i,
    timeIntervalInfo: a,
    chartType: n,
    horizontalAxisLabelsBehavior: o,
    verticalAxisLabelsBehavior: s,
    axisLabelsBehaviorChanged: r,
    guideTooltipFormatter: l,
    stackedType: c,
    axisValueFormatter: d,
    isSecondValueAxis: u,
    isRotated: f,
    commonStrings: m,
    errorStrings: g
  } = t, {
    visible: y,
    isLogarithmic: p,
    title: S,
    grid: x,
    lineSymbol: C,
    labels: F,
    guides: v,
    valueFormat: A,
    displayZeroLine: w,
    displayCursorTooltip: O,
    tickSpacing: I,
    dateBaseInterval: N
  } = i;
  dD({ axis: e, timeIntervalInfo: a, dateBaseInterval: N }), Bi({
    element: e.renderer.grid.template,
    lineSymbol: x,
    visible: y
  }), Bi({
    element: e.renderer.line,
    lineSymbol: {
      color: [...T.color],
      ...C ?? Cr()
    },
    visible: y
  }), Bi({
    element: e.renderer.ticks.template,
    lineSymbol: C,
    visible: y
  }), jB({
    axis: e,
    axisConfig: i,
    chartType: n,
    horizontalAxisLabelsBehavior: o,
    verticalAxisLabelsBehavior: s,
    axisLabelsBehaviorChanged: r,
    isSecondValueAxis: u
  }), hD(e, i), $B({
    axis: e,
    labelsConfig: F,
    horizontalAxisLabelsBehavior: o,
    isSecondValueAxis: u,
    tickSpacing: I
  }), await _k({
    axis: e,
    isXAxis: An(e.renderer, f),
    chartType: n,
    labelsTextSymbol: i.labels.content,
    formatOptions: A,
    overridePercentMultiplication: c === Ie.Stacked100,
    axisValueFormatter: d,
    errorStrings: g
  }), Cy({
    axis: e,
    axisConfig: i,
    chartType: n,
    isSecondValueAxis: u
  }), oD({ axis: e, isLogarithmic: p, isSecondValueAxis: u }), mD(e, S), fD(e, O), u !== !0 && (wB({ axis: e, guides: v, guideTooltipFormatter: l, commonStrings: m }), uD(e, w));
}
async function Ld(t) {
  const {
    chart: e,
    axesConfig: i,
    rotationChanged: a,
    isRotated: n,
    dualAxisChanged: o,
    timeIntervalInfoWasReset: s,
    timeIntervalInfo: r,
    guideTooltipFormatter: l,
    xAxisLabelFormatter: c,
    yAxisLabelFormatter: d,
    secondaryYAxisLabelFormatter: u,
    commonStrings: f,
    errorStrings: m
  } = t;
  let { axisLabelsBehaviorChanged: g } = t;
  const y = B(e.uid, "config"), { horizontalAxisLabelsBehavior: p, verticalAxisLabelsBehavior: S } = y, x = z(y.series), C = ti(y), F = n === !0 ? 1 : 0, v = n === !0 ? 0 : 1, A = i?.[F], w = i?.[v];
  let O = e.xAxes.getIndex(0);
  Fy({
    chart: e,
    dualAxisChanged: o,
    rotationChanged: a,
    timeIntervalInfoWasReset: s,
    axisLabelsBehaviorChanged: g
  }) && (il({
    chart: e,
    axesConfig: i,
    isRotated: n,
    chartType: x
  }), g = [!0, !0]), O = e.xAxes.getIndex(0);
  const I = e.yAxes.getIndex(0), N = e.xAxes.getIndex(1) ?? e.yAxes.getIndex(1), M = O?.start, P = O?.end, R = I?.start, $ = I?.end, W = N?.start, U = N?.end, q = {
    timeIntervalInfo: r,
    chartType: x,
    horizontalAxisLabelsBehavior: p,
    verticalAxisLabelsBehavior: S,
    axisLabelsBehaviorChanged: g,
    guideTooltipFormatter: l,
    stackedType: C,
    isRotated: n,
    commonStrings: f,
    errorStrings: m
  };
  O !== void 0 && A !== void 0 && await zs({
    ...q,
    axis: O,
    axisConfig: A,
    axisValueFormatter: F === 0 ? c : d
  }), I !== void 0 && w !== void 0 && await zs({
    ...q,
    axis: I,
    axisConfig: w,
    axisValueFormatter: v === 1 ? d : c
  }), N !== void 0 && i?.[2] !== void 0 && await zs({
    ...q,
    axis: N,
    axisConfig: i[2],
    axisValueFormatter: u,
    isSecondValueAxis: !0
  }), a === !0 && [
    { axis: O, start: M, end: P },
    { axis: I, start: R, end: $ },
    { axis: N, start: W, end: U }
  ].forEach((Z) => {
    const { axis: ee, start: j, end: ie } = Z;
    ee !== void 0 && ee.events.once(E.Validated, () => {
      ec({ axis: ee, start: j, end: ie });
    });
  }), O !== void 0 && O.ghostLabel.setPropertyValue("disabled", !0), I !== void 0 && I.ghostLabel.setPropertyValue("disabled", !0), N !== void 0 && N.ghostLabel.setPropertyValue("disabled", !0);
}
function Fy(t) {
  const { chart: e, dualAxisChanged: i, rotationChanged: a, timeIntervalInfoWasReset: n, axisLabelsBehaviorChanged: o } = t, s = B(e.uid, "config"), { rotated: r, series: l } = s, c = s.axes, d = z(l), u = r === !0 ? 1 : 0, f = r === !0 ? 0 : 1, m = c?.[u]?.valueFormat, g = c?.[f]?.valueFormat, y = e.xAxes.getIndex(0), p = e.yAxes.getIndex(0), S = y === void 0 || a || m !== void 0 && _l({
    axis: y,
    valueFormat: m,
    chartType: d
  }), x = p === void 0 || a || g !== void 0 && _l({
    axis: p,
    valueFormat: g,
    chartType: d
  });
  return i === !0 || a === !0 || n === !0 || o?.[0] || o?.[1] || S || x;
}
function pD(t) {
  il(t);
}
async function yD(t) {
  const {
    chart: e,
    chartConfig: i,
    rotationChanged: a,
    axisLabelsBehaviorChanged: n,
    isRotated: o,
    dualAxisChanged: s,
    timeIntervalInfoWasReset: r,
    timeIntervalInfo: l,
    guideTooltipFormatter: c,
    xAxisLabelFormatter: d,
    yAxisLabelFormatter: u,
    secondaryYAxisLabelFormatter: f,
    commonStrings: m,
    errorStrings: g
  } = t, y = i.axes, p = ti(i);
  await Ld({
    chart: e,
    axesConfig: y,
    rotationChanged: a,
    axisLabelsBehaviorChanged: n,
    isRotated: o,
    dualAxisChanged: s,
    timeIntervalInfoWasReset: r,
    timeIntervalInfo: l,
    guideTooltipFormatter: c,
    xAxisLabelFormatter: d,
    yAxisLabelFormatter: u,
    secondaryYAxisLabelFormatter: f,
    commonStrings: m,
    errorStrings: g
  });
  const S = o === !0 ? e.yAxes.getIndex(0) : e.xAxes.getIndex(0);
  if (S !== void 0) {
    S instanceof kt && (S.dataFields.category = Tc(i));
    const F = S.renderer, v = F.grid.template;
    v.location = 0, F.cellStartLocation = 0.1, F.cellEndLocation = 0.9;
    const A = i.orderOptions?.data?.orderBy === ri.Descending;
    let w = o === !0;
    A && S instanceof Ge && (w = !w), F.inversed = w;
  }
  const x = o === !0 ? e.xAxes.getIndex(0) : e.yAxes.getIndex(0), C = o === !0 ? e.xAxes.getIndex(1) : e.yAxes.getIndex(1);
  p === Ie.Stacked100 ? (x instanceof Ne && (x.calculateTotals = !0), C instanceof Ne && (C.calculateTotals = !0)) : (x instanceof Ne && (x.calculateTotals = !1), C instanceof Ne && (C.calculateTotals = !1));
}
const gt = {
  InnerLabel: 0,
  InnerLabelSecondary: 1,
  AxisLabels: 2,
  FirstAndLastLabels: 3
};
function Ma(t, e) {
  let i;
  switch (e) {
    case gt.InnerLabel:
      i = "gaugeAutoResizeInnerLabelFirstDisposer";
      break;
    case gt.InnerLabelSecondary:
      i = "gaugeAutoResizeInnerLabelSecondDisposer";
      break;
    case gt.AxisLabels:
      i = "gaugeAutoResizeAxisLabelsDisposer";
      break;
    case gt.FirstAndLastLabels:
      i = "gaugeAutoResizeFirstAndLastLabelsDisposer";
      break;
  }
  if (i !== void 0) {
    let a = B(t.uid, i);
    a !== void 0 && (a.dispose(), a = void 0, J(t.uid, { [i]: void 0 }));
  }
}
function bD(t) {
  const { chart: e, labelList: i, scaleToAdjust: a, fontSize: n, type: o, axisConfig: s } = t;
  let r = Number.NaN, l = Number.NaN, c = a;
  if (o === gt.InnerLabel) {
    const u = i[0], f = s?.innerLabel?.content?.verticalAlignment ?? ce.Middle, m = u.dy ?? 0, g = Math.round(e.chartContainer.measuredHeight - e.radarContainer.pixelY - m), y = u.bbox.height * a;
    let p = 0;
    switch (f) {
      case ce.Bottom:
        p = y;
        break;
      case ce.Top:
        p = -y;
        break;
      case ce.Middle:
      case ce.Baseline:
        p = y * 0.5;
        break;
    }
    p > g && (c = a * (g / p)), r = T.gauge.innerLabelAutoMinFontSize, l = T.gauge.innerLabelAutoMaxFontSize;
  } else
    r = T.gauge.axisLabelAutoMinFontSize, l = T.gauge.axisLabelAutoMaxFontSize;
  const d = n * c;
  return d < r ? c *= r / d : d > l && (c *= l / d), c;
}
function Ad(t) {
  const { chart: e, type: i, labelList: a, currentScale: n, currentFontSize: o, axisConfig: s } = t;
  let r = Number.NaN, l = Number.NaN;
  if (i === gt.InnerLabel) {
    const c = typeof e.innerRadius == "number" ? e.innerRadius : e.innerRadius.value;
    l = (e.xAxes.getIndex(0)?.measuredWidth !== 0 ? e.xAxes.getIndex(0)?.measuredWidth ?? 1 : 1) * c;
  } else
    l = e.xAxes.getIndex(0)?.measuredHeight ?? 1;
  if (l > 1) {
    const c = i === gt.InnerLabel ? a[0]?.measuredWidth ?? 0 : a.find((d) => d.measuredWidth > 0 && d.measuredHeight > 0)?.measuredHeight ?? 0;
    if (c > 0) {
      const d = c / l;
      if (d > 0) {
        const { axisLabelToInnerChartRatio: u, innerLabelToInnerChartRatio: f } = T.gauge, m = i === gt.InnerLabel ? f : u;
        r = n * (m / d), r = bD({
          chart: e,
          labelList: a,
          axisConfig: s,
          scaleToAdjust: r,
          fontSize: o,
          type: i
        }), r = Number(r.toFixed(2));
      }
    }
  }
  return Number.isFinite(r) || (r = n), r;
}
function al(t) {
  return t.some((i) => vr(i) && i.value !== void 0);
}
function SD(t) {
  const { chart: e, axisConfig: i, axis: a } = t;
  if (i.labels.content.font?.size === void 0 && i.onlyShowFirstAndLastLabels !== !0) {
    Ma(e, gt.AxisLabels), Ma(e, gt.FirstAndLastLabels);
    const n = () => {
      a.events.once(E.Validated, () => {
        const s = ft(a, pe.GaugeTicksWithLabels);
        if (al(s)) {
          const r = s.map((f) => f.label), l = r[0].scale, c = r[0].fontSize, d = Ad({
            chart: e,
            type: gt.AxisLabels,
            labelList: r,
            currentScale: l,
            currentFontSize: c,
            axisConfig: i
          }), u = d / l;
          Number.isFinite(d) && d > 0 && (u <= 0.98 || u > 1.02) && r.forEach((f) => {
            f.scale = d;
          });
        }
      }), a.validate();
    };
    e.events.once(E.Validated, n);
    const o = e.events.on(E.SizeChanged, n);
    J(e.uid, { gaugeAutoResizeAxisLabelsDisposer: o }), n();
  } else {
    Ma(e, gt.AxisLabels);
    const n = ft(a, pe.GaugeTicksWithLabels);
    n.length > 0 && n.map((s) => s.label).forEach((s) => {
      s.scale = 1;
    });
  }
}
function xD(t, e) {
  Ma(t, gt.InnerLabel), Ma(t, gt.InnerLabelSecondary);
  const i = () => {
    const s = B(t.uid, "config")?.axes?.[0];
    if (s?.innerLabel?.visible !== !1 && s?.innerLabel?.content?.font?.size === void 0) {
      const r = t.xAxes.getIndex(0)?.measuredWidth;
      if (r !== void 0 && r > 0) {
        const l = Ad({
          chart: t,
          type: gt.InnerLabel,
          labelList: [e],
          currentScale: e.scale,
          currentFontSize: e.fontSize,
          axisConfig: s
        });
        Number.isFinite(l) && Math.abs(e.scale - l) > 0.25 && (e.scale = l, e.validate());
      }
    } else
      e.scale = 1;
  }, a = t.events.on(E.Validated, i), n = t.events.on(E.SizeChanged, i);
  J(t.uid, {
    gaugeAutoResizeInnerLabelFirstDisposer: n,
    gaugeAutoResizeInnerLabelSecondDisposer: a
  }), i();
}
function CD(t) {
  const { chart: e, axisConfig: i, axis: a } = t;
  if (i.labels.content.font?.size === void 0 && i.onlyShowFirstAndLastLabels === !0) {
    Ma(e, gt.AxisLabels), Ma(e, gt.FirstAndLastLabels);
    const n = () => {
      const s = ft(a, pe.GaugeFirstAndLastGuides);
      if (al(s)) {
        const r = s.map((f) => f.label), l = r[0].scale, c = r[0].fontSize, d = Ad({
          chart: e,
          type: gt.FirstAndLastLabels,
          labelList: r,
          currentScale: l,
          currentFontSize: c,
          axisConfig: i
        }), u = d / l;
        Number.isFinite(d) && d > 0 && (u <= 0.98 || u > 1.02) && r.forEach((f) => {
          Ji(f.uid, {
            originalWidth: f.measuredWidth / f.scale,
            originalHeight: f.measuredHeight / f.scale
          }), f.scale = d;
        });
      }
    };
    e.events.once(E.Validated, n);
    const o = e.events.on(
      E.SizeChanged,
      n
    );
    J(e.uid, { gaugeAutoResizeFirstAndLastLabelsDisposer: o }), n();
  } else
    Ma(e, gt.FirstAndLastLabels), ft(a, pe.GaugeFirstAndLastGuides).map(
      (o) => o.label
    ).forEach((o) => {
      o.scale = 1;
    });
}
function tc(t, e) {
  const i = t.xAxes.getIndex(0);
  if (i !== void 0) {
    const a = e ?? B(t.uid, "config"), { onlyShowFirstAndLastLabels: n } = a?.axes?.[0] ?? {};
    if (!i.renderer.labels.template.visible || n === !0)
      t.radius = new js(T.gauge.radius);
    else {
      const o = ft(i, pe.GaugeTicksWithLabels), { furthestLabelX: s, furthestLabelY: r } = o.reduce(
        ({ furthestLabelX: l, furthestLabelY: c, furthestPixelX: d, furthestPixelY: u }, { label: f }) => {
          if (f?.visible && f.bbox.width > 0 && f.bbox.height > 0) {
            const m = f.pixelX, g = f.bbox.width * f.scale;
            let y = 0;
            m < 0 ? y = Math.abs(m) : y = m + g, y > d && (d = y, l = f);
            const p = f.pixelY, S = f.bbox.height * f.scale;
            let x = 0;
            p < 0 ? x = Math.abs(p) : x = p + S, x > u && (u = x, c = f);
          }
          return {
            furthestLabelX: l,
            furthestLabelY: c,
            furthestPixelX: d,
            furthestPixelY: u
          };
        },
        {
          furthestLabelX: void 0,
          // the furthest X label from the center
          furthestPixelX: 0,
          // the furthest pixelX from the center
          furthestLabelY: void 0,
          // the furthest Y label from the center
          furthestPixelY: 0
          // the furthest pixelY from the center
        }
      );
      if (s !== void 0 && r !== void 0) {
        const c = (s.bbox.width + 5) * s.scale, d = (r.bbox.height + 5) * r.scale, u = typeof i.renderer.labels.template.radius == "number" ? i.renderer.labels.template.radius : i.renderer.labels.template.radius.value, f = (c + u) * 2 + t.radarContainer.measuredWidth + Is(t.paddingLeft) + Is(t.paddingRight), m = 80, g = 170, y = t.htmlContainer?.clientHeight ?? 0, p = Math.max(
          0,
          Math.min(1, (y - m) / (g - m))
        ), S = t.radarContainer.measuredHeight + (d + u * p) * 2 + Is(t.paddingTop) + Is(t.paddingBottom), x = t.measuredWidth, C = t.measuredHeight, F = x / f, v = C / S, A = (typeof t.radius == "number" ? t.radius : t.radius.value) * 100, w = Number((A * F).toFixed(2)), O = Number((A * v).toFixed(2)), I = w / A, N = O / A, M = t.radarContainer.measuredWidth * I, P = t.radarContainer.measuredWidth * N, [R, $] = M < P ? [w, I] : [O, N];
        Number.isFinite(R) && R >= 10 && R <= T.gauge.radius && ($ < 0.98 || $ > 1.02) && (t.radius = new js(R));
      }
    }
  }
}
function vD(t) {
  const e = t.xAxes.getIndex(0);
  e !== void 0 && (e.events.on(E.SizeChanged, () => tc(t)), e.events.on(
    E.Validated,
    at(() => tc(t), T.debounceTime)
  ));
}
function Ly(t) {
  const e = t.hands.push(new nS()), i = T.gaugeNeedle, { startWidth: a, endWidth: n, innerRadius: o } = i;
  e.pin.disabled = !0, e.startWidth = a ?? Number.NaN, e.endWidth = n ?? Number.NaN, e.innerRadius = Ct(o ?? Number.NaN);
  const s = t.xAxes.getIndex(0);
  return s !== void 0 && (e.axis = s), e;
}
function FD(t) {
  const { x: e, data: i, chart: a, valueFormat: n, minimum: o, maximum: s } = t;
  let r = Number.NaN;
  if (i !== void 0 && e !== void 0) {
    const l = i.find((d) => e in d), c = Number.parseFloat(l[e]);
    Number.isFinite(c) && (r = c, J(a.uid, { gaugeData: r }));
  } else {
    const l = B(a.uid, "gaugeData");
    Number.isFinite(l) && (r = l);
  }
  return ao(n) && o !== void 0 && s !== void 0 && o !== null && s !== null && r !== null && s - o !== 0 && (r = Ho({
    value: r,
    axisMin: o,
    axisMax: s
  })), r;
}
function LD(t, e) {
  let i = e ?? null;
  if (e != null) {
    const a = t.xAxes.getIndex(0), n = B(t.uid, "config"), o = a.min ?? n?.axes?.[0].minimum ?? T.gauge.axisMinimum, s = a.max ?? n?.axes?.[0].maximum ?? T.gauge.axisMaximum;
    e < o ? i = o : e > s && (i = s);
  }
  return i;
}
function AD(t) {
  const { chart: e, needle: i, gaugeValue: a } = t, n = e.hands.getIndex(0) ?? Ly(e);
  if (n !== void 0) {
    Yo({ element: n, fillSymbol: i?.symbol });
    const { startWidth: o, endWidth: s, innerRadius: r } = T.gaugeNeedle;
    n.value = LD(e, a), n.pin.disabled = i?.displayPin !== !0, n.visible = i?.visible ?? !0, n.startWidth = i?.startWidth ?? o, n.endWidth = i?.endWidth ?? s, n.innerRadius = Ct(i?.innerRadius ?? r);
  }
}
function TD(t) {
  const e = Ci(void 0, t.radarContainer);
  e.isMeasured = !1, Ji(e.uid, { isGaugeAxisInnerLabel: !0 }), xD(t, e);
}
function wD(t) {
  const { chart: e, innerLabelConfig: i, valueFormat: a, gaugeValue: n, gaugeInnerLabelFormatter: o } = t, s = e.radarContainer.children.values.find(
    (r) => dt(r.uid, "isGaugeAxisInnerLabel") === !0
  );
  if (s !== void 0) {
    Kt({ label: s, labelConfig: i, defaults: T.gaugeInnerLabel });
    const r = B(e.uid, "formatLocale");
    s.html = VD({
      valueFormat: a,
      iLocale: e.language.locale,
      formatLocale: r,
      gaugeValue: n,
      innerLabelConfigContent: i?.content,
      gaugeInnerLabelFormatter: o
    }), e.radarContainer.invalidateLabels();
  }
}
function kD(t) {
  const e = t.axisRanges.create();
  return e.axisFill.fillOpacity = 1, e.axisFill.disabled = !0, e.grid.strokeOpacity = 1, e.grid.disabled = !1, e.tick.length = T.gaugeTicksLength, e;
}
function ID(t) {
  const e = new bc();
  return e.disabled = !0, e.axis = t, Zr(e), e.padding(10, 10, 10, 10), Ji(e.uid, { isGaugeAxisLabel: !0 }), e;
}
function OD(t) {
  const { axis: e, min: i, max: a, labelsIncrement: n, numberOfIntervals: o, valueFormat: s } = t, r = ao(s);
  let l = 1;
  const c = ft(e, pe.Ticks);
  c.length > 0 && (l = c[0].label?.scale, c.forEach((f) => {
    if (vr(f)) {
      const m = e.axisRanges.values.indexOf(f);
      m >= 0 && e.axisRanges.removeIndex(m);
    }
  }));
  const d = T.gauge.numberOfTicksBetweenTwoLabels + 1, u = o * d + 1;
  for (let f = 0; f < u; f += 1) {
    const m = f === u - 1, g = kD(e), y = m ? a : i + f / d * n;
    g.value = r ? Ho({ value: y, axisMin: i, axisMax: a }) : y, f % d === 0 && (g.label = ID(e), g.label.text = String(y), g.grid.disabled = !0, Number.isFinite(l) && (g.label.scale = l));
  }
}
function BD(t) {
  const { chart: e, axis: i, onlyShowFirstAndLastLabels: a, valueFormat: n, axisLabelConfigContent: o, axisValueFormatter: s } = t;
  if (!a) {
    const r = ft(i, pe.GaugeTicksWithLabels);
    if (al(r)) {
      const l = B(e.uid, "formatLocale");
      r.forEach((c) => {
        Kt({ label: c.label, labelConfig: o }), vr(c) && (c.label.html = Ay({
          valueFormat: n,
          iLocale: e.language.locale,
          formatLocale: l,
          gaugeLabelConfigContent: o?.content,
          itemLabelValue: c.value,
          axisValueFormatter: s
        }));
      });
    }
  }
}
function DD(t, e) {
  const i = e?.ticks?.visible ?? !0, a = ft(t, pe.Ticks);
  for (let n = 0; n < a.length; n += 1) {
    const o = a[n];
    se(o.tick, i);
  }
}
function ND(t, e) {
  if (t instanceof Ne && t.chart instanceof zt) {
    const i = ft(t, pe.GaugeTicksWithLabels);
    if (al(i)) {
      const { onlyShowFirstAndLastLabels: a, labels: n } = e, o = (n?.visible ?? !0) && a !== !0;
      i.forEach((s) => {
        se(s.label, o);
      });
    }
  }
}
function MD(t) {
  const { labels: e, guides: i, onlyShowFirstAndLastLabels: a } = t, n = i ?? [];
  if (a === !0) {
    const o = {
      type: b.Guide,
      start: Number.NaN,
      style: {
        type: "esriSLS"
      },
      name: ""
    };
    n.push(
      {
        ...o,
        start: t.minimum ?? Number.NaN,
        name: T.gaugeFirstLabelId,
        label: { ...e.content, text: `${t.minimum}` }
      },
      {
        ...o,
        start: t.maximum ?? Number.NaN,
        name: T.gaugeLastLabelId,
        label: { ...e.content, text: `${t.maximum}` }
      }
    );
  }
  t.guides = n;
}
function $D(t) {
  ft(t, pe.GaugeFirstAndLastGuides).forEach((i) => {
    i.label.adapter.keys().includes("dx") || i.label.adapter.add("dx", (a) => {
      let n = a;
      return i.label.measuredWidth > 0 && (n = i.label.measuredWidth / 2, (i.id === T.gaugeLastLabelId || i.id === T.gaugeFirstLabelId) && i.label.scale && i.label.scale !== 1 && i.label.measuredWidth === dt(i.label.uid, "originalWidth") && (n *= i.label.scale), i.id === T.gaugeLastLabelId && (n *= -1)), n;
    }), i.label.adapter.keys().includes("dy") || i.label.adapter.add("dy", (a) => {
      let n = a;
      return i.label.measuredWidth > 0 && (n = i.label.measuredHeight / 2, (i.id === T.gaugeLastLabelId || i.id === T.gaugeFirstLabelId) && i.label.scale && i.label.scale !== 1 && i.label.measuredHeight === dt(i.label.uid, "originalHeight") && (n *= i.label.scale)), n;
    });
  });
}
function PD(t) {
  const { chart: e, axis: i, onlyShowFirstAndLastLabels: a, valueFormat: n, gaugeLabelConfigContent: o, axisValueFormatter: s } = t;
  if (a) {
    const r = ft(i, pe.GaugeFirstAndLastGuides), l = B(e.uid, "formatLocale");
    r.forEach((c) => {
      c?.label !== void 0 && vr(c) && (c.label.html = Ay({
        valueFormat: n,
        iLocale: e.language.locale,
        formatLocale: l,
        gaugeLabelConfigContent: o?.content,
        itemLabelValue: c.value,
        axisValueFormatter: s
      }));
    }), $D(i);
  }
}
function RD(t, e) {
  t.xAxes.clear(), Do({ isXAxis: !0, axes: t.xAxes, valueFormat: e });
  const i = t.xAxes.getIndex(0);
  i instanceof Ne && (i.renderer.labels.template.disabled = !0, i.renderer.ticks.template.disabled = !0, Ly(t), TD(t), vD(t), i.maxZoomFactor = 1);
}
function VD(t) {
  const { valueFormat: e, iLocale: i, formatLocale: a, innerLabelConfigContent: n, gaugeValue: o, gaugeInnerLabelFormatter: s } = t;
  let r = "";
  if (Number.isFinite(o))
    if (s !== void 0)
      r = s(o);
    else {
      const l = _i(e), c = ui({
        type: b.NumberAxisFormat,
        iLocale: i,
        formatLocale: a
      });
      c.numberFormat = l, r = c.format(`${o}`), r = Ht({
        textSymbol: {
          type: re.TS,
          ...n,
          text: r
        },
        format: "html"
      }), r = rt(r);
    }
  return r;
}
function Ay(t) {
  const { valueFormat: e, iLocale: i, formatLocale: a, gaugeLabelConfigContent: n, itemLabelValue: o, axisValueFormatter: s } = t;
  let r = "";
  if (Number.isFinite(o))
    if (s !== void 0)
      r = s(o);
    else {
      const l = _i(e), c = ui({
        type: b.NumberAxisFormat,
        iLocale: i,
        formatLocale: a
      });
      c.numberFormat = l, r = c.format(`${o}`), r = Ht({
        textSymbol: {
          type: re.TS,
          ...n,
          text: r
        },
        format: "html"
      }), r = rt(r);
    }
  return r;
}
async function ED(t) {
  const {
    chart: e,
    chartConfig: i,
    data: a,
    queryObject: n,
    axisValueFormatter: o,
    gaugeInnerLabelFormatter: s,
    commonStrings: r,
    errorStrings: l
  } = t, { axes: c, series: d } = i, u = _o(i), f = z(i.series), { featureIndex: m, x: g } = d[0], y = c?.[0], p = e.xAxes.getIndex(0), S = { ...y };
  if (p !== void 0 && S !== void 0) {
    const { valueFormat: x, needle: C, innerLabel: F, onlyShowFirstAndLastLabels: v } = S;
    _l({ axis: p, valueFormat: x, chartType: f }) && Do({ isXAxis: !0, axes: e.xAxes, valueFormat: x });
    const A = await op({
      featureIndex: m,
      chartData: e.data,
      chartConfig: i,
      queryObject: n,
      queryConfig: B(e.uid, "queryConfig")
    });
    S.minimum = A.minimum, S.maximum = A.maximum;
    const { min: w, max: O, labelsIncrement: I, numberOfIntervals: N } = ap(S);
    TT({
      oldConfig: B(p.chart.uid, "config"),
      axisMax: p.max,
      min: w,
      max: O,
      labelsIncrement: I,
      numberOfIntervals: N,
      valueFormat: x
    }) && OD({
      axis: p,
      min: w,
      max: O,
      labelsIncrement: I,
      numberOfIntervals: N,
      valueFormat: x
    });
    const P = { ...S };
    ao(x) ? (P.minimum = 0, P.maximum = 1, np({
      axisConfig: P,
      axisMin: S.minimum,
      axisMax: S.maximum
    })) : (P.minimum = w, P.maximum = O), MD(P), await zs({
      axis: p,
      axisConfig: P,
      chartType: b.GaugeSeries,
      axisValueFormatter: o,
      commonStrings: r,
      errorStrings: l
    }), p.renderer.labels.template.disabled || (p.renderer.labels.template.disabled = !0), p.renderer.ticks.template.disabled || (p.renderer.ticks.template.disabled = !0), SD({
      chart: p.chart,
      axis: p,
      axisConfig: S
    }), CD({
      chart: e,
      axis: p,
      axisConfig: S
    }), DD(p, S), BD({
      chart: e,
      axis: p,
      onlyShowFirstAndLastLabels: v ?? !1,
      valueFormat: x,
      axisLabelConfigContent: S.labels,
      axisValueFormatter: o
    }), PD({
      chart: e,
      axis: p,
      onlyShowFirstAndLastLabels: v ?? !1,
      valueFormat: x,
      gaugeLabelConfigContent: S.labels,
      axisValueFormatter: o
    });
    const R = u ? A?.dataValue : FD({
      x: g,
      data: a,
      chart: e,
      minimum: S.minimum,
      maximum: S.maximum,
      valueFormat: x
    });
    AD({
      chart: e,
      needle: C,
      gaugeValue: R
    }), wD({
      chart: e,
      innerLabelConfig: F,
      valueFormat: x,
      gaugeValue: R,
      gaugeInnerLabelFormatter: s
    }), ND(p, S), tc(e, i), e.validateData();
  }
}
function WD(t) {
  let e = [];
  if (t.length > 0) {
    e = t.map((a) => a.minValue);
    const i = t[t.length - 1].maxValue;
    e.push(i);
  }
  return e;
}
function zD(t) {
  let e = 0;
  return t.forEach((i) => {
    const { label: a } = i;
    e = Math.max(e, a?.bbox.width, a.measuredWidth);
  }), e;
}
function HD(t) {
  let e = t.axisRanges.length - 1;
  if (t.isReady()) {
    const i = ft(t, pe.Ticks), a = i[0]?.point?.x ?? 0, o = (i[1]?.point?.x ?? 0) - a, s = zD(i);
    if (s !== 0) {
      const r = T.histogramAxisLabel.paddingRight ?? 0;
      for (let l = 0; l < i.length; l += 1)
        if (l * o - s - r > 0) {
          e = l;
          break;
        }
    }
  }
  return e;
}
function ic(t) {
  const e = B(t.chart.uid, "config"), { axes: i } = e, a = i?.[0];
  if (a !== void 0) {
    const { visible: n, labels: o, guides: s } = a, { visible: r } = o, l = HD(t), c = ft(t, pe.Ticks);
    for (let u = 0; u < c.length; u += 1) {
      const { tick: f, label: m } = c[u], g = u % l === 0 && n === !0, y = u % l === 0 && r === !0, p = { ...a.labels };
      p.content.angle = void 0, p.content.yoffset = void 0, p.content.horizontalAlignment = void 0, p.content.verticalAlignment = void 0, Kt({ label: m, labelConfig: p, defaults: T.histogramAxisLabel }), se(f, g), se(m, y);
    }
    py({
      axis: t,
      labels: c.map((u) => u.label),
      restoreLabelsVisibility: !1
    });
    const d = ft(t, pe.Guides);
    for (let u = 0; u < d.length; u += 1) {
      const f = s?.[u]?.visible ?? !0;
      se(d[u].label, f), d[u].label.disabled = !f;
    }
    t.invalidateLabels();
  }
}
function qD(t) {
  const { chart: e, axesConfig: i } = t;
  il({ chart: e, axesConfig: i });
  const a = e.xAxes.getIndex(0);
  if (a !== void 0) {
    a.renderer.ticks.template.disabled = !0;
    const n = () => ic(a);
    a.events.once(E.DataItemsValidated, n), e.chartContainer.events.on(E.SizeChanged, at(n, T.debounceTime));
  }
}
function GD(t, e) {
  if (t.renderer.labels.template.disabled = !0, e.length !== 0) {
    t.strictMinMax = !0;
    const { 0: i, [e.length - 1]: a } = e;
    t.min = i, t.max = a;
  } else
    t.min = Number.NaN, t.max = Number.NaN, t.strictMinMax = !1;
}
async function YD(t) {
  const {
    chart: e,
    axesConfig: i,
    histogramBins: a,
    guideTooltipFormatter: n,
    xAxisLabelFormatter: o,
    yAxisLabelFormatter: s,
    commonStrings: r,
    errorStrings: l
  } = t, c = WD(a), d = i?.[0];
  await Ld({
    chart: e,
    axesConfig: i,
    guideTooltipFormatter: n,
    xAxisLabelFormatter: o,
    yAxisLabelFormatter: s,
    commonStrings: r,
    errorStrings: l
  });
  const u = e.xAxes.getIndex(0);
  u instanceof Ne && (GD(u, c), d !== void 0 && NB({
    valueAxis: u,
    axisConfig: d,
    ticks: c
  }), ic(u), u.events.once(
    E.DataItemsValidated,
    () => ic(u)
  ));
}
function XD(t, e) {
  il({ chart: t, axesConfig: e });
}
async function UD(t) {
  await Ld(t);
}
function jD(t) {
  t.background.fill = wt(T.backgroundColor);
}
function nl(t, e) {
  t.background.fill = wt(e ?? T.backgroundColor);
}
function _D(t) {
  const e = ay(T.headerContainer, t), i = Ci(T.title, e), a = Ci(T.subtitle, e);
  return Xo({ chart: t, label: i, labelType: ue.ChartTitle }), Xo({ chart: t, label: a, labelType: ue.ChartSubTitle }), QI(e), { headerContainer: e, title: i, subtitle: a };
}
function ol(t, e) {
  const { title: i, subtitle: a, headerContainer: n } = t;
  Kt({ label: i, labelConfig: e?.title, defaults: T.titleLabel }), Kt({ label: a, labelConfig: e?.subtitle, defaults: T.titleLabel }), ny(n, i.disabled && a.disabled), pn({
    chart: i.parent,
    label: i,
    labelType: ue.ChartTitle
  }), pn({
    chart: a.parent,
    label: a,
    labelType: ue.ChartSubTitle
  });
}
function ZD(t) {
  const e = ay(T.footerContainer, t), i = Ci(T.footer, e);
  return Xo({ chart: t, label: i, labelType: ue.ChartFooter }), { footerContainer: e, footer: i };
}
function sl(t, e) {
  const { footer: i, footerContainer: a } = t;
  Kt({ label: i, labelConfig: e, defaults: T.footer }), ny(a, i.disabled || e?.content.text === ""), pn({
    chart: i.parent,
    label: i,
    labelType: ue.ChartFooter
  });
}
function Ty(t) {
  if (t instanceof fe) {
    const e = new _d(), i = new _d();
    e.disabled = !0, i.disabled = !0, e.marginTop = -10, i.marginRight = 0, t.scrollbarX = e, t.scrollbarY = i;
  }
}
function QD(t, e) {
  const i = e ? 0 : -1;
  t.thumb.tabindex = i, t.startGrip.tabindex = i, t.endGrip.tabindex = i;
}
function KD(t, e) {
  if (e !== void 0) {
    const i = mn(e);
    [
      // applying color to grips and bar
      t.background,
      t.startGrip.background,
      t.endGrip.background,
      t.thumb.background,
      // applying color to hover and down states
      t.background.states.getKey("default")?.properties,
      t.startGrip.background.states.getKey("default")?.properties,
      t.endGrip.background.states.getKey("default")?.properties,
      t.thumb.background.states.getKey("default")?.properties,
      t.startGrip.background.states.getKey("hover")?.properties,
      t.endGrip.background.states.getKey("hover")?.properties,
      t.thumb.background.states.getKey("hover")?.properties,
      t.startGrip.background.states.getKey("down")?.properties,
      t.endGrip.background.states.getKey("down")?.properties,
      t.thumb.background.states.getKey("down")?.properties
    ].forEach((a) => {
      a !== void 0 && (a.fill = i);
    });
  }
}
function JD(t, e) {
  typeof e == "number" && Number.isFinite(e) && (t.orientation === "horizontal" ? (t.height = e, t.minHeight = e) : (t.width = e, t.minWidth = e));
}
function eN(t, e) {
  if (typeof e == "number" && Number.isFinite(e)) {
    const a = e / 30;
    t.startGrip.scale = a, t.endGrip.scale = a;
  }
}
function tN(t, e) {
  typeof e == "number" && Number.isFinite(e) && (t.orientation === "horizontal" ? t.marginBottom = e : t.marginLeft = e, t.parent?.invalidateLayout());
}
function wy(t) {
  const { chart: e, scrollbarXConfig: i, scrollbarYConfig: a } = t;
  if (e instanceof fe) {
    const n = B(e.uid, "isRotated");
    (e.scrollbarX === void 0 || e.scrollbarY === void 0) && Ty(e);
    const { scrollbarX: o, scrollbarY: s } = e;
    [o, s].forEach((r) => {
      const l = r.orientation === "horizontal" && n !== !0 || r.orientation === "vertical" && n === !0 ? i : a, c = l?.visible !== !0;
      if (r.disabled = c, QD(r, !c), l !== void 0 && !c) {
        const { width: d, color: u, gripSize: f, margin: m } = l;
        tN(r, m), KD(r, u), eN(r, f), JD(r, d);
      }
    });
  }
}
function iN(t, e) {
  t.columns.each((i) => {
    (i.dataItem?.dataContext)[e] === 0 && (i.strokeOpacity = 0);
  });
}
function aN(t, e) {
  t.chart.legend.events.once(E.Validated, () => {
    ea({
      element: t.legendDataItem?.marker.children.getIndex(0),
      stylingInfo: e
    }), t.chart.legend.invalidate();
  });
}
function nN(t) {
  const { series: e, seriesConfig: i, seriesIndex: a, numberOfSeries: n, chartSubType: o, colorMatch: s, rendererType: r } = t, l = e.dataFields.valueY ?? e.dataFields.valueX ?? i.y;
  let c = !1;
  const d = /* @__PURE__ */ new Set();
  let u;
  const f = i.fillSymbol, m = {
    seriesConfig: i,
    seriesIndex: a,
    seriesSymbol: f,
    colorMatch: s,
    isChartFillSymbol: !0
  };
  let g = {};
  const y = jf(a);
  if (e.columns.length === 0 ? g = ma({
    seriesConfig: i,
    seriesIndex: a,
    seriesSymbol: f ?? y,
    element: new xc(),
    colorMatch: s,
    isChartFillSymbol: !0
  }) : e.columns.each((p) => {
    const S = p.dataItem?.dataContext;
    if (Number.isFinite(S?.[l])) {
      const x = Wt({
        dataItem: S,
        seriesConfig: i,
        chartSubType: o,
        colorMatch: s,
        rendererType: r
      });
      g = ma({
        ...m,
        seriesSymbol: f ?? y,
        element: p,
        rendererSymbol: x
      }), ea({ element: p, stylingInfo: g.stylingInfo }), d.add(JSON.stringify(g.symbolWithColorInfo));
    }
  }), n > 1) {
    const p = e.chart.legend.markers.values;
    p.length !== 0 ? p.forEach((S) => {
      if (S.dataItem instanceof qa) {
        const x = S.dataItem.marker.children.getIndex(0);
        x !== void 0 && x.baseSprite?.parent instanceof it ? ea({
          element: x,
          stylingInfo: g.stylingInfo
        }) : c = !0;
      }
    }) : c = !0;
  }
  return c && aN(e, g.stylingInfo), d.size <= 1 && (u = g.symbolWithColorInfo ?? f), iN(e, l), u;
}
function oN(t) {
  const { series: e, seriesSymbolMapForEvent: i, seriesIndexMapper: a, seriesIndex: n, colorMatch: o, rendererType: s } = t, r = t.seriesConfig, l = B(e.chart.uid, "config"), c = l?.series.length ?? 0, d = H(l?.series), u = nN({
    series: e,
    seriesConfig: r,
    seriesIndex: n,
    numberOfSeries: c,
    chartSubType: d,
    colorMatch: o,
    rendererType: s
  });
  i.set(a.get(r.id) ?? n, u), i.size === c && zi({
    data: i,
    htmlContainer: e.chart.htmlContainer,
    chartId: e.chart.id,
    colorMatchApplied: Fn(e.chart)
  });
}
function ky(t) {
  const {
    seriesConfig: e,
    series: i,
    seriesIndexMapper: a,
    rotationChanged: n,
    subtypeInfo: o,
    colorMatch: s,
    stackedType: r,
    rendererType: l,
    fieldList: c,
    seriesIndex: d,
    seriesSymbolMapForEvent: u
  } = t, { name: f } = e, m = B(i.chart.uid, "config"), g = fi({ config: m }), y = H(m?.series);
  se(i, e.visible);
  let p = f;
  const S = i.dataFields?.customValue ?? "";
  (y === L.BarAndLineSplitBy || y === L.BarAndLineSplitByNoAggregation) && (p = br({
    subtypeInfo: o,
    fieldList: c,
    fieldName: Ze(S),
    fieldValueToMatch: p
  }) ?? p), Gi(i, p), gd({
    series: i,
    seriesConfig: e,
    rotationChanged: n,
    stackedType: r,
    isRotated: g
  }), oN({
    series: i,
    seriesConfig: e,
    seriesIndex: d,
    seriesIndexMapper: a,
    colorMatch: s,
    rendererType: l,
    seriesSymbolMapForEvent: u
  }), et(i.uid, {
    barSeriesLastUpdate: {
      numberOfColumnsUpdated: i.columns.length,
      updateProps: t
    }
  });
}
function sN(t) {
  t.events.on(E.Validated, () => {
    const e = te(
      t.uid,
      "barSeriesLastUpdate"
    );
    if (e !== void 0) {
      const { numberOfColumnsUpdated: i, updateProps: a } = e;
      t.columns.length > i && ky(a);
    }
  });
}
function rN(t) {
  const { chart: e, chartConfig: i, seriesIndex: a, axisList: n = [], hideLoaderHandle: o, selectionTheme: s } = t, { rotated: r } = i, l = i.series[a], { y: c, assignToSecondValueAxis: d } = l, u = new it();
  Yi(u, o), u.id = l.id;
  let f, m;
  r !== !0 ? (f = n[0], m = d === !0 && n[2] ? n[2] : n[1]) : (f = d === !0 && n[2] ? n[2] : n[0], m = n[1]), f !== void 0 && (u.xAxis = f), m !== void 0 && (u.yAxis = m);
  const g = e instanceof fe ? fi({ chart: e }) : !1, p = H(i.series) !== L.BarAndLineSplitByNoAggregation ? c : `${c}_${Lt({ where: l.query?.where })}`;
  g ? u.dataFields.valueX = p : u.dataFields.valueY = p;
  const S = g ? n[1] : n[0];
  if (S !== void 0) {
    const x = Hp(S, g);
    u.dataFields[x] = T.xAxisField, u.baseAxis = S;
  }
  return gd({
    series: u,
    seriesConfig: l,
    rotationChanged: !1,
    stackedType: i.stackedType,
    isRotated: g
  }), u.dataFields.customValue = l?.query?.where, ey(u.columns.template, u), u.columns.template.width = Ct(100), Ca({
    element: u.columns.template,
    customSelectionTheme: s
  }), Ln(e, u.columns.template), gs(u), sN(u), xa(u), u;
}
function lN(t) {
  const { seriesConfig: e, series: i, seriesIndex: a, axes: n, commonStrings: o, fieldList: s, queryObject: r, stackedType: l, options: c } = t;
  i.id = e.id;
  const d = fi({ chart: i.chart });
  QB({
    series: i,
    seriesType: b.BarSeries,
    isRotated: d,
    stackedType: l,
    hideOversizedSideBySideLabels: e.hideOversizedSideBySideLabels,
    hideOversizedStackedLabels: e.hideOversizedStackedLabels,
    dataLabelsConfig: e.dataLabels,
    yAxisValueFormat: n[1].valueFormat,
    customDataLabelFormatter: c?.dataLabelFormatter
  }), hn({
    // TODO: Remove the type assertion and correct the typings
    styleCallback: ky,
    callbackProps: t,
    series: i,
    seriesConfig: e,
    onReadyEvent: !0
  }), iy({
    series: i,
    seriesConfig: e,
    fieldList: s,
    queryObject: r,
    commonStrings: o,
    seriesIndex: a,
    tooltipFormatter: c?.tooltipFormatter
  });
}
function cN(t, e) {
  t.adapter.add(
    "htmlOutput",
    (i, a) => {
      let n = i;
      const o = te(
        e.uid,
        "histogramDataLabelFormatter"
      ), { dataItem: s } = a;
      if (o !== void 0 && s instanceof Ko) {
        const { valueY: r, openValueX: l, valueX: c } = s;
        n = o(r, l, c);
      }
      return rt(n);
    },
    0
    // 0 = high priority
  );
}
function dN(t) {
  const e = Ci(T.dataLabelInitialize);
  return Ji(e.uid, { isDataLabel: !0 }), t.bullets.push(e), md(e), fd(b.HistogramSeries, e), cN(e, t), e.html = "{valueX}", e;
}
function uN(t) {
  const { numberFormatter: e, dataLabelsConfigContent: i } = t;
  return (a, n, o) => Ht({
    textSymbol: {
      ...i,
      text: e.format(a)
    },
    format: "html"
  });
}
function fN(t) {
  const { series: e } = t, i = Go(e, "bullets");
  Qr({
    ...t,
    dataLabel: i,
    defaultDataLabelFormatter: uN,
    seriesType: b.HistogramSeries
  });
}
function mN(t) {
  const { axes: e, seriesConfig: i, series: a, fieldList: n, commonStrings: o } = t, { dataTooltipVisible: s } = i;
  let r;
  const l = ai(a.rtl);
  return s === !1 ? r = (c, d, u) => "" : r = (c, d, u) => {
    const f = Ve(n, i.x), m = Ki(f, e?.[0].title?.content?.text), g = Ki(o.statistics.count, e?.[1].title?.content?.text), y = En({
      series: a,
      callbackName: "tooltipValueYNumberFormatCallback",
      value: c
    }), p = En({
      series: a,
      callbackName: "tooltipValueXNumberFormatCallback",
      value: d
    }), S = En({
      series: a,
      callbackName: "tooltipValueXNumberFormatCallback",
      value: u
    });
    return `<b>${m}${l} </b>${p} - ${S}<br /><b>${g}${l} </b>${y}`;
  }, r;
}
function gN(t) {
  const e = t.columns.template;
  e.tooltipPosition = T.columnTooltipPosition, e.tooltipHTML = T.htmlEmptyContent, e.adapter.add("tooltipHTML", (i, a) => {
    let n = i ?? "";
    const { chart: o } = t;
    if (o !== void 0) {
      const s = B(o.uid, "config"), { dataTooltipVisible: r } = s?.series[0] ?? {};
      if (r === !1)
        n = "";
      else {
        const l = te(
          t.uid,
          "histogramTooltipFormatter"
        );
        if (l !== void 0) {
          const { dataItem: c } = a;
          if (c instanceof Ko) {
            const { valueY: d, openValueX: u, valueX: f } = c;
            n = l(d, u, f);
          }
        }
      }
    }
    return rt(n);
  });
}
function hN(t) {
  const { series: e, tooltipFormatter: i } = t;
  et(e.uid, {
    histogramTooltipFormatter: i ?? mN(t)
  });
}
const wl = {
  Count: "count",
  Start: "minValue",
  End: "maxValue"
}, mt = {
  Mean: "Mean",
  Median: "Median",
  StdDev: "Standard Deviation",
  Normal: "Normal Distribution",
  Trendline: "Trendline"
};
async function Bs(t) {
  const { xAxis: e, yAxis: i, type: a, hideLoaderHandle: n } = t, o = new ye();
  return o.id = a, Yi(o, n), et(o.uid, { isOverlay: !0, type: a }), o.dataFields.valueX = "x", o.dataFields.valueY = "y", e !== void 0 && (o.xAxis = e), i !== void 0 && (o.yAxis = i), o.hidden = !0, o;
}
function pN(t) {
  const { lineSeries: e, valueFormat: i, overlay: a, chartData: n, commonStrings: o } = t;
  if (!a)
    se(e, !1), e.hiddenInLegend = !0;
  else {
    const { symbol: s, created: r, visible: l } = a, c = r === !0 && l !== !1, d = te(e.uid, "type"), u = te(e.uid, "upper");
    if (Bi({
      element: e,
      lineSymbol: s,
      visible: c
    }), e.hiddenInLegend = r !== !0 || u === !0, n && "bins" in n) {
      const m = n.bins.map((w) => w.count), g = Math.max(...m), { mean: y, stddev: p, median: S } = n, x = y - p, C = y + p;
      let F = { x: Number.NaN, y: Number.NaN }, v = { x: Number.NaN, y: Number.NaN };
      switch (d) {
        case mt.Mean:
          F = { x: y, y: 0 }, v = { x: y, y: g };
          break;
        case mt.Median:
          F = { x: S, y: 0 }, v = { x: S, y: g };
          break;
        case mt.StdDev:
          u === !0 ? (F = { x: C, y: 0 }, v = { x: C, y: g }) : (F = { x, y: 0 }, v = { x, y: g });
          break;
      }
      const A = {
        data: [F, v]
      };
      e.data = A.data;
    }
    let f = e.data[0]?.x;
    if (d === mt.StdDev && (f = n?.stddev ?? te(e.uid, "stddev"), et(e.uid, { stddev: f })), f !== void 0) {
      let m = d;
      switch (d) {
        case mt.Mean:
          m = o.overlays.mean;
          break;
        case mt.Median:
          m = o.overlays.median;
          break;
        case mt.StdDev:
          m = o.overlays.stdDev;
          break;
        case mt.Trendline:
          m = o.overlays.trendline;
          break;
      }
      const g = B(e.chart.uid, "formatLocale");
      Gi(
        e,
        `${m}: ${gn({
          value: f,
          valueFormat: i,
          iLocale: e.chart.language.locale,
          formatLocale: g
        })}`
      );
    }
  }
}
async function yN(t, e, i) {
  const a = new ye();
  return et(a.uid, {
    isOverlay: !0,
    type: mt.Normal
  }), a.xAxis = t, a.yAxis = e, a.dataFields.valueX = "x", a.dataFields.valueY = "y", Gi(a, i.overlays.normal), a.hidden = !0, a.id = mt.Normal, a;
}
function bN(t) {
  const { lineSeries: e, overlay: i, seriesData: a, numberOfPoints: n } = t;
  if (!i)
    se(e, !1), e.hiddenInLegend = !0;
  else {
    const { symbol: o, created: s, visible: r } = i;
    if (Bi({
      element: e,
      lineSymbol: o,
      visible: s === !0 && r !== !1
    }), e.hiddenInLegend = s !== !0, a && "bins" in a) {
      const { mean: c, stddev: d, min: u, max: f } = a, m = fh(a.bins), g = dh(u, f, n ?? T.histogramSeries.normalDistribNumberOfPoints).map(
        (y) => ({
          x: y,
          y: uh({
            x: y,
            mean: c,
            stddev: d,
            scalingFactor: m
          })
        })
      );
      e.data = g;
    }
  }
}
async function SN(t) {
  const { chart: e, seriesConfig: i, axisList: a = [], hideLoaderHandle: n, commonStrings: o, selectionTheme: s } = t, r = [], l = new it();
  Yi(l, n), l.id = i.id, l.hiddenInLegend = !0;
  const [c, d] = a;
  if (c !== void 0 && (l.xAxis = c), d !== void 0 && (l.yAxis = d), gN(l), dN(l), l.dataItems.template.locations.valueX = 1, l.dataItems.template.locations.openValueX = 0, l.dataFields.openValueX = wl.Start, l.dataFields.valueX = wl.End, l.dataFields.valueY = wl.Count, l.dataFields.customValue = i.x, xa(l), Ca({
    element: l.columns.template,
    customSelectionTheme: s
  }), Ln(e, l.columns.template), r.push(l), c !== void 0 && d !== void 0) {
    r.push(
      await Bs({
        xAxis: c,
        yAxis: d,
        type: mt.Mean,
        hideLoaderHandle: n
      })
    ), r.push(
      await Bs({
        xAxis: c,
        yAxis: d,
        type: mt.Median,
        hideLoaderHandle: n
      })
    );
    const u = await Bs({
      xAxis: c,
      yAxis: d,
      type: mt.StdDev,
      hideLoaderHandle: n
    });
    et(u.uid, { upper: !1 });
    const f = await Bs({
      xAxis: c,
      yAxis: d,
      type: mt.StdDev,
      hideLoaderHandle: n
    });
    et(f.uid, { upper: !0 }), u.events.on(E.Hidden, () => {
      se(f, !1);
    }), u.events.on(E.Shown, () => {
      se(f);
    }), r.push(u), r.push(f), r.push(await yN(c, d, o));
  }
  return r.forEach((u) => {
    const f = te(u.uid, "isOverlay"), m = te(u.uid, "upper");
    f === !0 && m !== !0 && gs(u);
  }), r;
}
function xN(t) {
  const { series: e, seriesConfig: i, colorMatch: a, rendererSymbol: n } = t;
  let o;
  const s = i.fillSymbol ?? Xf();
  if (e.columns.each((r) => {
    const l = ma({
      element: r,
      seriesConfig: i,
      seriesSymbol: s,
      rendererSymbol: n,
      colorMatch: a,
      isChartFillSymbol: !0
    });
    o = l.symbolWithColorInfo;
    const c = l.stylingInfo;
    ea({ element: r, stylingInfo: c });
  }), o !== void 0) {
    const r = /* @__PURE__ */ new Map();
    r.set(0, o), zi({
      data: r,
      htmlContainer: e.chart.htmlContainer,
      chartId: e.chart.id,
      colorMatchApplied: Fn(e.chart)
    });
  }
}
async function CN(t) {
  const {
    chartConfig: e,
    seriesConfig: i,
    chartSeries: a,
    axes: n,
    chartData: o,
    fieldList: s,
    options: r,
    queryObject: l,
    chartRenderer: c,
    commonStrings: d
  } = t, { tooltipFormatter: u, dataLabelFormatter: f } = r ?? {}, m = 6, g = i.overlays;
  for (let y = 0; y < m; y += 1) {
    const p = a[y];
    if (te(p?.uid, "isOverlay") === !0 && p instanceof ye) {
      const S = te(p.uid, "type");
      if (S === mt.Normal) {
        if (g?.comparisonDistribution && g?.comparisonDistribution.symbol?.color === void 0) {
          const x = qs(S), C = g?.comparisonDistribution?.symbol ?? {
            type: re.SLS
          };
          g.comparisonDistribution.symbol = {
            ...C,
            color: Si({
              colorIndex: x,
              histogramOverlays: !0
            })
          };
        }
        bN({
          lineSeries: p,
          overlay: g?.comparisonDistribution,
          seriesData: o
        });
      } else {
        let x;
        switch (S) {
          case mt.Mean:
            x = g?.mean;
            break;
          case mt.Median:
            x = g?.median;
            break;
          case mt.StdDev:
            x = g?.standardDeviation;
            break;
        }
        if (x && x.symbol?.color === void 0) {
          x.symbol = { ...x.symbol, type: re.SLS };
          const C = qs(S);
          x.symbol.color = Si({
            colorIndex: C,
            histogramOverlays: !0
          });
        }
        pN({
          lineSeries: p,
          valueFormat: Sr(),
          overlay: x,
          chartData: o,
          commonStrings: d
        });
      }
      p.events.once(E.Validated, () => {
        te(p.uid, "upper") !== !0 && Bn({
          labels: p.chart?.legend?.labels,
          seriesId: p.id
        });
      });
    } else if (p instanceof it) {
      p.id = i.id, se(p, i.visible), Gi(p, i.name);
      const S = we(l), x = qc({
        chartRenderer: c,
        queryObject: l
      }), C = c ?? S?.renderer, F = os(c, S?.renderer);
      let v;
      if (ja({
        chartConfig: e,
        queryObject: l
      })) {
        const A = await Gc({
          seriesConfig: [i],
          dataItem: {},
          renderer: C,
          rendererOrigin: c !== void 0 ? Ui.ChartRenderer : Ui.LayerRenderer,
          rendererType: F,
          chartSubType: L.NonSpecific,
          graphicTemplate: x
        });
        v = A.rendererSymbol, J(p.chart.uid, { colorMatchApplied: A.colorMatchApplied });
      }
      hn({
        // TODO: Remove the type assertion and correct the typings
        styleCallback: xN,
        callbackProps: { ...t, rendererSymbol: v },
        series: p,
        seriesConfig: i
      }), fN({
        series: p,
        seriesType: b.HistogramSeries,
        dataLabelsConfig: i.dataLabels,
        yAxisValueFormat: n[1].valueFormat,
        customDataLabelFormatter: f
      }), hN({
        axes: n,
        series: p,
        seriesConfig: i,
        fieldList: s,
        tooltipFormatter: u,
        commonStrings: d
      }), qp({
        axes: n,
        currentSeries: p,
        tooltipValueFormat: i.dataTooltipValueFormat
      });
    }
  }
}
function vN(t) {
  t.labels.template.adapter.add("html", (e, i) => {
    const a = te(
      t.uid,
      "pieChartDataLabelFormatter"
    );
    let n = e ?? "";
    const { dataItem: o } = i;
    if (o instanceof ji) {
      const { slice: s } = o;
      if (s !== void 0 && !qo(s))
        n = "";
      else if (a !== void 0) {
        const { value: r, percent: l } = o.values?.value ?? {};
        if (r !== void 0 && r !== 0) {
          const c = `${o.properties?.category ?? e}`;
          n = a(c, r, l);
        }
      }
    }
    return be(n) && (n = T.htmlEmptyContent), rt(n);
  });
}
function FN(t) {
  const e = t.labels.template;
  e.maxWidth = T.pieChart.dataLabels.maxWidth ?? Number.NaN, e.wrap = T.pieChart.dataLabels.wrap ?? !0, e.events.on(E.Over, (i) => {
    const { dataItem: a } = i.target ?? {};
    a instanceof ji && a.slice.showTooltip();
  }), vN(t);
}
function LN(t, e) {
  const {
    numericValueFormat: i,
    percentValueFormat: a,
    displayCategoryOnDataLabel: n,
    displayNumericValueOnDataLabel: o,
    displayPercentageOnDataLabel: s,
    valuePrefix: r,
    valueSuffix: l,
    percentagePrefix: c,
    percentageSuffix: d,
    dataLabelsCharacterLimit: u
  } = e, f = bd({
    iLocale: t.chart.language.locale,
    pieChart: t.chart,
    valueIntlOptions: i?.intlOptions,
    percentageIntlOptions: a?.intlOptions,
    displayNumericValue: o ?? T.pieChart.displayNumericValueOnDataLabel,
    displayPercentage: s ?? T.pieChart.displayPercentageOnDataLabel,
    valuePrefix: r,
    valueSuffix: l,
    percentagePrefix: c,
    percentageSuffix: d
  }), m = Hc(u), g = ai(t.rtl, " ");
  return (y, p, S) => {
    const x = f(y, p, S), F = n ?? T.pieChart.displayCategoryOnDataLabel ? m(y) : "";
    let v = be(F) ? "" : `${F}${g}`;
    return v = `${v}${x}`, e.dataLabels?.content !== void 0 && (v = Ht({
      textSymbol: { ...e.dataLabels.content, text: v },
      format: "html",
      defaults: {
        ...T.pieChart.dataLabels,
        wrap: e.optimizeDataLabelsOverlapping ?? T.pieChart.dataLabels.wrap
      }
    })), v;
  };
}
function AN(t) {
  const { pieSeries: e, seriesConfig: i, dataLabelFormatter: a } = t, { dataLabels: n } = i, o = i.dataLabelsOffset ?? T.pieChart.dataLabelsOffset, s = i.dataLabelsInside ?? T.pieChart.dataLabelsInside;
  et(e.uid, {
    pieChartDataLabelFormatter: a ?? LN(e, i)
  }), Kt({
    label: e.labels.template,
    labelConfig: n,
    defaults: {
      ...T.pieChart.dataLabels,
      wrap: i.optimizeDataLabelsOverlapping ?? T.pieChart.alignDataLabels
    },
    skipSettingText: !0
  }), e.alignLabels = !s && (i.alignDataLabels ?? T.pieChart.alignDataLabels);
  const r = e.labels.template.radius;
  e.chart.invalidateData(), (s && r !== Ct(-40) || !s && r === Ct(-40) || o !== void 0 && Number.isFinite(o) && r !== o) && (e.labels.template.radius = s ? Ct(-40) : o, e.invalidate());
}
function TN(t, e) {
  let i = (g, y, p) => T.htmlEmptyContent;
  const {
    numericValueFormat: a,
    percentValueFormat: n,
    dataTooltipValueFormat: o,
    dataTooltipPercentFormat: s,
    displayCategoryOnTooltip: r,
    displayNumericValueOnTooltip: l,
    displayPercentageOnTooltip: c,
    valuePrefix: d,
    valueSuffix: u,
    percentagePrefix: f,
    percentageSuffix: m
  } = e;
  return i = (g, y, p) => {
    let S = T.htmlEmptyContent;
    const C = bd({
      iLocale: t.chart.language.locale,
      pieChart: t.chart,
      valueIntlOptions: (o ?? a)?.intlOptions,
      percentageIntlOptions: (s ?? n)?.intlOptions,
      displayNumericValue: l ?? T.pieChart.displayNumericValueOnTooltip,
      displayPercentage: c ?? T.pieChart.displayPercentageOnTooltip,
      valuePrefix: d,
      valueSuffix: u,
      percentagePrefix: f,
      percentageSuffix: m
    })("", y, p), F = !be(g) && (r ?? T.pieChart.displayCategoryOnTooltip);
    if (F && (S = `<b>${g}</b>`), !be(C)) {
      const v = Vr(C);
      S = F ? `${S}<br />${v}` : v;
    }
    return S;
  }, i;
}
function wN(t) {
  if (t.tooltip !== void 0) {
    let e = t.fill;
    e instanceof om ? e = e.stroke : e instanceof sm && (e = e.backgroundFill), t.tooltip.background.fill = e;
  }
}
function kN(t) {
  const e = t.slices.template;
  e.tooltipHTML = T.htmlEmptyContent, e.adapter.add("tooltipHTML", (i, a) => {
    let n = i ?? "";
    const { chart: o } = t;
    if (o !== void 0 && a.tooltip !== void 0) {
      const s = B(o.uid, "config"), { dataTooltipVisible: r } = s?.series[0] ?? {};
      if (r === !1)
        a.tooltip.disabled = !0;
      else {
        const l = te(
          t.uid,
          "pieChartTooltipFormatter"
        );
        if (l !== void 0) {
          const { dataItem: c } = a;
          if (c instanceof ji) {
            const d = c.properties.category ?? "", u = c.dataContext;
            let f = $i(u);
            f === void 0 && (f = d);
            const m = c.values?.value?.value, g = c.values?.value?.percent;
            typeof m == "number" && m !== 0 && s?.series?.[0]?.dataTooltipVisible !== !1 ? (a.tooltip.disabled = !1, wN(a), n = l(`${d}`, m, g, f)) : a.tooltip.disabled = !0;
          }
        }
      }
    }
    return rt(n);
  });
}
function IN(t) {
  const { series: e, seriesConfig: i, tooltipFormatter: a } = t;
  et(e.uid, {
    pieChartTooltipFormatter: a ?? TN(e, i)
  });
}
function ON(t) {
  t.ticks.template.adapter.add("disabled", (e, i) => i.dataItem?.values?.value?.value === 0 || !Number.isFinite(i.dataItem?.values?.value?.value) || e === !0);
}
function BN(t) {
  const { chartData: e, pieSeries: i, pieSlicesSymbols: a, seriesConfig: n } = t;
  if (i.slices.length === 0) {
    const o = [];
    e?.forEach((s) => {
      const r = Yc({
        dataContext: s,
        pieSlicesSymbols: a,
        seriesConfig: n
      });
      o.push(mn(r.color));
    }), o.length > 0 && (i.colors.list = o);
  }
}
function DN(t) {
  const { seriesConfig: e, hideLoaderHandle: i, selectionTheme: a } = t, { x: n, y: o, id: s, visible: r } = e, l = new xi();
  l.id = s, Yi(l, i), l.dataFields.value = o, l.dataFields.category = n;
  const c = T.pieChart;
  l.startAngle = c.min, l.endAngle = 360 + l.startAngle, ON(l), kN(l), FN(l);
  const d = a !== void 0 && a.selectedElementsTheme?.transformation?.opacity === void 0 ? {
    ...a,
    selectedElementsTheme: {
      ...a?.selectedElementsTheme,
      transformation: {
        ...a?.selectedElementsTheme?.transformation,
        opacity: 1
      }
    }
  } : a;
  return Ca({
    element: l.slices.template,
    useNativeState: !0,
    customSelectionTheme: d
  }), l.slices.template.states.removeKey("hover"), xa(l), l.hidden = r === !1, gs(l), l;
}
function NN(t) {
  const { series: e, pieSlicesSymbols: i, seriesConfig: a, selectionTheme: n } = t;
  e.defaultState.reset(), e.slices.each((o, s) => {
    const r = o.dataItem?.dataContext, l = Yc({
      dataContext: r,
      pieSlicesSymbols: i,
      seriesConfig: a
    }), c = Yo({
      element: o,
      fillSymbol: l,
      defaultToColorFromRamp: !0,
      colorRampIndex: s,
      isChartFillSymbol: !0
    });
    n !== void 0 && n.selectedElementsTheme === void 0 && ea({
      element: o,
      stylingInfo: c,
      stateKey: Tt.Active
    });
  });
}
async function MN(t) {
  const { chartConfig: e, queryObject: i, usePopupTemplateFieldsInfo: a, labelUpdateNeeded: n, commonStrings: o } = t, { series: s } = e, r = s[0], { x: l } = r, c = !Ac({ chartConfig: e }), d = H([r]), u = d === L.PieFromFields, m = we(i).objectIdField, g = await At(i, a);
  return {
    x: l,
    isNonAggregatedChart: c,
    objectIdField: m,
    isPieFromFields: u,
    seriesConfig: r,
    fieldList: g,
    labelUpdateNeeded: n,
    chartSubType: d,
    colorMatch: Ri(e),
    commonStrings: o
  };
}
function xf(t) {
  return `${t[0]},${t[1]},${t[2]}`;
}
function $N(t, e, i) {
  const a = new Set(Array.from(e).map(xf)), n = t.findIndex((o) => !a.has(xf(o)));
  return n !== -1 ? n : i;
}
function PN(t) {
  const {
    dataContext: e,
    seriesConfig: i,
    existingSlicesColors: a,
    isGroupOfSlices: n,
    sliceFromConfig: o,
    dataIndex: s,
    colorMatch: r,
    chartSubType: l
  } = t, c = n ? {
    ...T.pieChart.sliceGrouping.fillSymbol,
    ...i.sliceGrouping?.fillSymbol
  } : Ee(o?.fillSymbol ?? i.fillSymbol), d = Wt({
    dataItem: e,
    seriesConfig: i,
    chartSubType: l,
    colorMatch: r
  });
  let u = s;
  c?.color || (u = $N(bb, a, s));
  const f = new dm();
  f.dataItem = {
    dataContext: e
  };
  const { symbolWithColorInfo: m } = ma({
    element: f,
    seriesConfig: i,
    y: i.y,
    seriesSymbol: c ?? Hs(),
    seriesIndex: u,
    rendererSymbol: d,
    colorMatch: r,
    isChartFillSymbol: !0
  });
  return m;
}
function Cf(t, e) {
  const {
    x: i,
    isNonAggregatedChart: a,
    objectIdField: n,
    isPieFromFields: o,
    seriesConfig: s,
    fieldList: r,
    labelUpdateNeeded: l,
    colorMatch: c,
    chartSubType: d,
    commonStrings: u
  } = e, f = [];
  let m, g;
  const y = /* @__PURE__ */ new Set();
  return t.forEach((p, S) => {
    const x = _g({
      dataContext: p,
      x: i,
      isNonAggregatedChart: a,
      dataIndex: S,
      objectIdField: n,
      isPieFromFields: o
    });
    p[T.pieChart.technicalFieldSliceId] = x;
    const C = ar(s.slices, x);
    C?.fillSymbol?.color !== void 0 && y.add(C.fillSymbol.color);
  }), t.forEach((p, S) => {
    const x = p[T.pieChart.technicalFieldSliceId], C = ar(s.slices, x), F = qi(p), v = PN({
      dataContext: p,
      seriesConfig: s,
      existingSlicesColors: y,
      isGroupOfSlices: F,
      sliceFromConfig: C,
      dataIndex: S,
      colorMatch: c,
      chartSubType: d
    });
    v.color && y.add(v.color);
    const A = Zg({
      dataContext: p,
      sliceFromConfig: C,
      isGroupOfSlices: F,
      seriesConfig: s,
      fieldList: r,
      isPieFromFields: o,
      labelUpdateNeeded: l,
      colorMatch: c,
      commonStrings: u
    }), w = {
      sliceId: x,
      label: A,
      fillSymbol: v
    };
    w.originalLabel = C?.originalLabel ?? (p?.[T.originalCategoryValue] !== void 0 ? p?.[T.originalCategoryValue] : w.label), F ? (g = p[T.pieChart.technicalFieldGroupedSlices], s.sliceGrouping !== void 0 && (m = {
      sliceId: s.sliceGrouping.sliceId,
      percentageThreshold: s.sliceGrouping.percentageThreshold,
      label: A,
      originalLabel: s.sliceGrouping.originalLabel ?? A,
      fillSymbol: v
    })) : f.push(w);
  }), { slices: f, groupOfSlicesSymbols: m, groupOfSlices: g };
}
async function Td(t) {
  const { chart: e } = t, i = await MN(t), { slices: a, groupOfSlicesSymbols: n, groupOfSlices: o } = Cf(
    e.data,
    i
  ), { slices: s } = Cf(o ?? [], i);
  return {
    slices: a,
    groupedSlices: s,
    groupOfSlices: n
  };
}
function RN(t, e) {
  const { ticks: i } = e, a = i?.visible === !1 || e.dataLabelsInside === !0 || e.dataLabels === void 0 || e.dataLabels?.visible === !1 || e.dataLabelsOffset !== void 0 && e.dataLabelsOffset <= 0;
  t.ticks.template.disabled = a, t.ticks.template.strokeOpacity = T.pieChart.ticksOpacity;
  const n = i?.lineSymbol ?? Cr({ color: yb });
  a && (n.width = 0), Bi({
    element: t.ticks.template,
    lineSymbol: n,
    visible: !a
  });
}
function VN(t) {
  const { chart: e, seriesConfig: i, series: a, pieSlicesSymbols: n, options: o, commonStrings: s } = t, { tooltipFormatter: r, dataLabelFormatter: l } = o ?? {}, { x: c, y: d, id: u, innerRadius: f, startAngle: m, endAngle: g } = i;
  a.id = u;
  const y = H([i]), p = T.pieChart;
  a.dataFields.value = y !== L.PieFromFields ? d : Rt, a.dataFields.category = y !== L.PieFromFields ? c : tt;
  const S = e.radius instanceof js ? e.radius.value : e.radius;
  e.innerRadius = Ct((f ?? p.innerRadius) * S), a.startAngle = m ?? p.min, a.endAngle = g ?? 360 + a.startAngle, AN({
    pieSeries: a,
    seriesConfig: i,
    dataLabelFormatter: l
  }), BN({
    chartData: e.data,
    pieSeries: a,
    pieSlicesSymbols: n,
    seriesConfig: i
  }), hn({
    // TODO: Remove the type assertion and correct the typings
    styleCallback: NN,
    callbackProps: t,
    series: a,
    seriesConfig: i
  }), RN(a, i), IN({
    series: a,
    seriesConfig: i,
    tooltipFormatter: r
  });
}
function Iy(t) {
  const { chart: e, seriesConfig: i, commonStrings: a } = t, n = e.data, o = Tp({ data: n, seriesConfig: i, commonStrings: a });
  e.data = o;
}
function EN(t, e) {
  t.adapter.add(
    "htmlOutput",
    (i, a) => {
      let n = i;
      const o = te(
        e.uid,
        "scatterplotDataLabelFormatter"
      ), { dataItem: s } = a;
      if (s instanceof Ha && o !== void 0) {
        const { valueX: r, valueY: l, customValue: c } = s, d = (s.component?.xAxis).min, u = (s.component?.yAxis).min;
        n = Ql({
          dataValue: r,
          series: e,
          seriesType: b.ScatterSeries,
          axisMin: d
        }) || Ql({
          dataValue: l,
          series: e,
          seriesType: b.ScatterSeries,
          axisMin: u
        }) ? "" : o(r, l, c);
      }
      return rt(n);
    },
    0
    // 0 = high priority
  );
}
function WN(t) {
  const e = Ci(T.dataLabelInitialize);
  return Ji(e.uid, { isDataLabel: !0 }), t.bullets.push(e), EN(e, t), e.html = "{valueX} - {valueY}", e;
}
function zN(t) {
  const { numberFormatter: e, dataLabelsConfigContent: i } = t;
  return (a, n) => Ht({
    textSymbol: {
      ...i,
      text: `${e.format(a)} - ${e.format(n)}`
    },
    format: "html"
  });
}
function HN(t) {
  const { series: e } = t, i = Go(e, "bullets");
  Qr({
    ...t,
    dataLabel: i,
    defaultDataLabelFormatter: zN,
    seriesType: b.ScatterSeries
  });
}
function qN(t) {
  const { axes: e, seriesConfig: i, series: a, fieldList: n } = t, { dataTooltipVisible: o } = i;
  let s;
  const r = ai(a.rtl);
  return o === !1 ? s = (l, c, d) => "" : s = (l, c, d) => {
    const u = Ve(n, i.x), f = Ki(u, e?.[0].title?.content?.text), m = Ve(n, i.y), g = Ki(m, e?.[1].title?.content?.text), y = En({
      series: a,
      callbackName: "tooltipValueXNumberFormatCallback",
      value: l
    }), p = En({
      series: a,
      callbackName: "tooltipValueYNumberFormatCallback",
      value: c
    });
    let S = `<b>${f}${r} </b>${y}<br /><b>${g}${r} </b>${p}`;
    if (d !== void 0 && i.sizePolicy?.field !== void 0) {
      const x = Ve(n, i.sizePolicy?.field), C = En({
        series: a,
        callbackName: "tooltipValueYNumberFormatCallback",
        value: d
      });
      S += `<br /><b>${x}${r} </b>${C}<br /><b>`;
    }
    return S;
  }, s;
}
function GN(t, e) {
  t.tooltipHTML = T.htmlEmptyContent, t.adapter.add("tooltipHTML", (i, a) => {
    let n = i ?? "";
    const { chart: o } = e;
    if (o !== void 0) {
      const s = B(o.uid, "config"), { dataTooltipVisible: r } = s?.series[0] ?? {};
      if (r === !1)
        n = "";
      else {
        const l = te(
          e.uid,
          "scatterplotTooltipFormatter"
        );
        if (!a.isHidden && l !== void 0) {
          const { dataItem: c } = a;
          if (c instanceof Ha) {
            const { valueX: d, valueY: u, customValue: f } = c;
            n = l(d, u, f);
          }
        }
      }
    }
    return rt(n);
  });
}
function YN(t) {
  const { series: e, tooltipFormatter: i } = t;
  et(e.uid, {
    scatterplotTooltipFormatter: i ?? qN(t)
  });
}
function XN(t) {
  const { series: e, seriesConfig: i, newMin: a, newMax: n } = t, o = e.heatRules.getIndex(0);
  let s = o === void 0 && i.sizePolicy !== void 0 || o !== void 0 && i.sizePolicy === void 0;
  if (!s && o !== void 0) {
    const r = o.min === a && o.max === n, l = e.dataFields.customValue === i.sizePolicy?.field, c = i.sizePolicy?.scaleType === $a.Linear && o.logarithmic !== !0 || i.sizePolicy?.scaleType === $a.Logarithmic && o.logarithmic === !0;
    s = !(r && l && c);
  }
  return s;
}
function UN(t, e) {
  const { sizePolicy: i } = t, a = e.heatRules.getIndex(0);
  let n = !1;
  if (i !== void 0) {
    const { scaleType: o, field: s, minSize: r, maxSize: l } = i, c = He(e);
    if (c !== void 0) {
      const d = Yf(), u = r ?? d.minSize, f = l ?? d.maxSize;
      a !== void 0 ? XN({ series: e, seriesConfig: t, newMin: u, newMax: f }) && (n = !0, a.min = u, a.max = f, a.logarithmic = o === $a.Logarithmic) : (n = !0, e.heatRules.push({
        target: c,
        property: "minWidth",
        min: u,
        max: f,
        dataField: "customValue",
        // this is a static value, to be kept in sync with the code below `series.dataFields.customValue = field`
        logarithmic: o === $a.Logarithmic
      })), e.dataFields.customValue = s;
    }
  } else a !== void 0 && (e.heatRules.pop(), e.dataFields.customValue = void 0, n = !0);
  return n;
}
function jN(t) {
  t !== void 0 && t.validateData();
  const e = t?.series?.values?.find((i) => te(i.uid, "isOverlay") === !0);
  e !== void 0 && e.validateData();
}
async function _N(t) {
  const { xAxis: e, yAxis: i, x: a, y: n, name: o, hideLoaderHandle: s } = t, r = new ye();
  return Gi(r, o), Yi(r, s), r.ignoreMinMax = !0, et(r.uid, {
    isOverlay: !0,
    type: mt.Trendline
  }), r.dataFields.valueX = a, r.dataFields.valueY = n, r.xAxis = e, r.yAxis = i, r.hidden = !0, r;
}
function ZN(t) {
  const { trendLine: e, seriesConfig: i, valueFormat: a, chartData: n, defaultR2Value: o } = t, s = T.scatterplotSeries;
  if (n?.trendLinePoints) {
    e.data = n.trendLinePoints;
    const c = B(e.chart.uid, "formatLocale"), d = Number.isFinite(n.r2) ? gn({
      value: n.r2 ?? s.r2,
      valueFormat: a,
      iLocale: e.chart.language.locale,
      formatLocale: c
    }) : void 0, u = d !== void 0 ? `R² = ${d}` : o;
    Gi(e, u);
  }
  e.hiddenInLegend = i.overlays?.trendLine?.created !== !0;
  const r = i.overlays?.trendLine?.created === !0 && i.overlays.trendLine.visible !== !1, l = i.overlays?.trendLine?.symbol ?? {
    type: re.SLS
  };
  l.color === void 0 && (l.color = Si({ colorIndex: 1 })), Bi({
    element: e,
    lineSymbol: l ?? Cr(),
    visible: r
  });
}
async function QN(t) {
  const { chart: e, seriesConfig: i, axisList: a = [], hideLoaderHandle: n, selectionTheme: o, ignoreSmoothRenderingLimit: s } = t, r = T.scatterplotSeries, [l, c] = a, { x: d, y: u, overlays: f, name: m, id: g } = i, y = [], p = new ye();
  et(p.uid, { type: b.ScatterSeries }), p.id = g, Yi(p, n), p.hiddenInLegend = !0, p.dataFields.valueX = d, p.dataFields.valueY = u, l !== void 0 && (p.xAxis = l), c !== void 0 && (p.yAxis = c);
  const S = Kr({ chart: e, lineSeries: p });
  GN(S, p), WN(p), p.strokeOpacity = r.strokeOpacity, p.minDistance *= Math.ceil(p.data.length / 1e4), p.hidden = !0, Ca({ element: S, customSelectionTheme: o }), Ln(e, S), Gp({
    chart: e,
    series: p,
    seriesType: b.ScatterSeries,
    marker: S,
    ignoreSmoothRenderingLimit: s
  }), y.push(p);
  const x = f?.trendLine, C = await _N({
    xAxis: l,
    yAxis: c,
    x: d,
    y: u,
    hideLoaderHandle: n,
    name: m,
    visible: x?.visible
  });
  return gs(C), y.push(C), xa(p), y;
}
function KN(t) {
  const { seriesConfig: e, series: i, colorMatch: a } = t, { chart: n } = i, o = He(i), s = UN(e, i), r = () => {
    if (o !== void 0) {
      let l, c;
      const d = e.markerSymbol ?? gc(), u = /* @__PURE__ */ new Set();
      o.clones.each((m) => {
        const g = Wt({
          dataItem: m.dataItem?.dataContext,
          seriesConfig: e,
          chartSubType: L.NonSpecific,
          colorMatch: a
        }), y = ma({
          element: m,
          seriesSymbol: d,
          seriesConfig: e,
          colorMatch: a,
          rendererSymbol: g
        });
        l = y.symbolWithColorInfo, c = y.stylingInfo, ea({ element: m, stylingInfo: c }), u.add(JSON.stringify(c));
      }), l = u.size > 1 ? void 0 : l;
      const f = /* @__PURE__ */ new Map();
      f.set(0, l), zi({
        data: f,
        htmlContainer: n.htmlContainer,
        chartId: n.id,
        colorMatchApplied: Fn(n)
      });
    }
  };
  s ? (i.events.disableType(E.Validated), jN(n), n.events.once(E.Validated, () => {
    r(), i.events.enableType(E.Validated), i.dispatchImmediately(E.Validated);
  })) : r();
}
function JN(t) {
  const { seriesConfig: e, chartSeries: i, axes: a, fieldList: n, chartData: o, options: s, commonStrings: r } = t, { tooltipFormatter: l, dataLabelFormatter: c } = s ?? {}, d = i.find((m) => te(m.uid, "isOverlay") === !0), u = r.notAvailable;
  if (d !== void 0) {
    const m = {
      trendLine: d,
      seriesConfig: e,
      valueFormat: Sr(),
      chartData: o,
      defaultR2Value: u
    };
    hn({
      // TODO: Remove the type assertion and correct the typings
      styleCallback: ZN,
      callbackProps: m,
      series: d,
      seriesConfig: e
    });
  }
  const f = i.find((m) => te(m.uid, "isOverlay") !== !0);
  f !== void 0 && (He(f) !== void 0 && (f.id = e.id, hn({
    // TODO: Remove the type assertion and correct the typings
    styleCallback: KN,
    callbackProps: t,
    series: f,
    seriesConfig: e
  }), qp({
    axes: a,
    currentSeries: f,
    tooltipValueFormat: e.dataTooltipValueFormat
  }), YN({
    axes: a,
    seriesConfig: e,
    series: f,
    fieldList: n,
    tooltipFormatter: l
  })), HN({
    series: f,
    seriesType: b.ScatterSeries,
    dataLabelsConfig: e.dataLabels,
    yAxisValueFormat: a[1].valueFormat,
    customDataLabelFormatter: c
  }));
}
function eM(t) {
  const e = t.isHover, i = t.dataItem instanceof ji ? t.dataItem?.label?.isHover : !1;
  return e || i;
}
async function tM(t) {
  t.series.getIndex(0)?.slices.values.some((i) => eM(i)) || await ps({ chart: t, listSelectedElements: [], selectionSource: Ue.SelectionByClick });
}
async function vf(t) {
  const { chart: e, hitSlice: i, multiSelect: a = !1 } = t, n = [], o = e.series.getIndex(0);
  if (o !== void 0) {
    if (!o.slices.values.every((r) => (r.isHover || r.isFocused) !== r.isActive)) {
      const r = _p(o), l = Za(o), c = {
        element: {},
        xAxisField: r,
        yAxisField: l,
        chartType: b.PieSeries,
        seriesIndex: 0
      };
      o.slices.each((d, u) => {
        d.isActive && (d === i || a || d.dataItem instanceof ji && d.dataItem.label.isHover) ? qi(d.dataItem?.dataContext) ? (ss({
          groupOfSlicesDataContext: d.dataItem?.dataContext
        }) ?? []).forEach((y) => {
          n.push({
            ...c,
            element: void 0,
            elementDataContext: y,
            elementIndex: u
          });
        }) : n.push({
          ...c,
          element: d,
          elementDataContext: d.dataItem?.dataContext,
          elementIndex: u
        }) : vi({
          element: d,
          selected: !1,
          useNativeState: !0
        });
      }), n.forEach((d) => {
        vi({
          element: d.element,
          selected: !0,
          useNativeState: !0
        });
      });
    }
    await ps({ chart: e, listSelectedElements: n, selectionSource: Ue.SelectionByClick });
  }
  e.feedLegend();
}
function iM(t) {
  const e = async (n) => {
    const { target: o } = n;
    if (Qp(t) && t.series.getIndex(0)?.slices.template.togglable) {
      const s = el(n, t);
      if (o instanceof dm)
        await vf({ chart: t, multiSelect: s, hitSlice: o });
      else if (o instanceof Vo) {
        const r = o.dataItem;
        if (r instanceof ji) {
          const { slice: l } = r;
          l.isActive = !l.isActive, await vf({ chart: t, multiSelect: s, hitSlice: l });
        }
      } else
        await tM(t);
    }
  }, i = t.series.getIndex(0)?.slices.template;
  i !== void 0 && (i.events.on(E.Hit, e), i.events.on(E.DoubleHit, e));
  const a = t.series.getIndex(0)?.labels.template;
  a !== void 0 && a.events.on(E.Hit, e), t.events.on(E.Hit, e), t.events.on(E.DoubleHit, e);
}
function Ff(t) {
  return t?.offsetParent !== null;
}
function aM(t, e) {
  t !== void 0 && e !== void 0 && window.IntersectionObserver !== void 0 && new IntersectionObserver(
    (a) => {
      a[0].intersectionRatio > 0 && (B(t.uid, "chartWasCreatedWhileHidden") === !0 ? (t.reinit(), t.events.once(E.Validated, () => {
        t.reinit();
      }), J(t.uid, {
        chartWasCreatedWhileHidden: !1
      })) : B(t.uid, "chartWasUpdatedWhileHidden") === !0 && (t.reinit(), J(t.uid, {
        chartWasUpdatedWhileHidden: !1
      })));
    },
    {
      root: null
    }
  ).observe(e);
}
function nM(t, e) {
  let i = T.pieChart.dataLabels.maxWidth ?? 100;
  if (t != null) {
    const {
      alignDataLabels: a,
      dataLabelsOffset: n = T.pieChart.dataLabelsOffset,
      optimizeDataLabelsOverlapping: o,
      dataLabels: s,
      dataLabelsInside: r
    } = t;
    if (s?.visible === !0 && a === !0 && r !== !0 && o === !0) {
      const l = typeof e.radius == "number" ? e.radius / 100 : e.radius.value, c = e.chartContainer.measuredWidth, d = e.chartContainer.measuredHeight, u = l * Math.min(c, d), f = 5, m = Math.floor((c - u) / 2) - f - n;
      i = Math.min(m, i - f);
      const g = 30;
      i < g && (i = g);
    }
  }
  return i;
}
function Oy(t) {
  if (gi(t)) {
    const e = typeof t.radius == "number" ? t.radius : t.radius.percent;
    J(t.uid, { pieChartRadius: e });
    const i = () => {
      const a = Ct(
        B(t.uid, "pieChartRadius") ?? T.pieChart.chartOptimizedRadius
      );
      let n = a;
      const o = B(t.uid, "config");
      if (o !== void 0) {
        const { series: s } = o, {
          innerRadius: r,
          optimizeDataLabelsOverlapping: l,
          alignDataLabels: c,
          dataLabelsOffset: d = T.pieChart.dataLabelsOffset,
          dataLabels: u,
          dataLabelsInside: f
        } = s[0];
        if (u?.visible === !0 && c === !0 && l === !0 && f !== !0) {
          const p = T.pieChart.chartOptimizedRadius / 100, S = 500, x = 150, C = 0.6, F = 0.5, v = 1, A = t.chartContainer.measuredWidth - d * 2, w = Math.max(A - x, 0) / (S - x), O = w < 1 ? (
            // case 1: the container width is less than the radiusContainerWidthBreakpoint - we want to scale the radius down.
            Math.max(w ** v * C, 0.4)
          ) : (
            // case 2: the container width is at or more than the radiusContainerWidthBreakpoint - ramp up radius to the max radius
            Math.min(w ** F * C, p)
          );
          n = Ct(O * 100);
        } else
          n = Ct(T.pieChart.chartRadius);
        a.value.toFixed(1) !== n.value.toFixed(1) && (J(t.uid, { pieChartRadius: n.percent }), t.radius = n, t.innerRadius = Ct((r ?? T.pieChart.innerRadius) * n.value));
        const g = t.series?.values?.[0];
        g instanceof xi && (g.labels.template.maxWidth = nM(
          o?.series[0],
          t
        ));
      }
      return n;
    };
    t.events.on(E.SizeChanged, at(i, T.debounceTime)), i(), t.validate();
  }
}
function By(t) {
  if (t instanceof Me)
    Oy(t);
  else if (!(t instanceof zt)) {
    const e = () => {
      const a = B(t.uid, "config"), {
        chartPaddingMinSize: n,
        chartPaddingRightWhenLegendNotOnRight: o,
        chartContainerPaddingTopWhenRotated: s,
        chartContainer: r
      } = T, l = a?.series, c = z(l), d = fi({ config: a }), u = l?.[0]?.dataLabels?.visible ?? !0;
      let f = T.chartDefaultPaddingRight;
      if (d && u && (c === b.LineSeries || c === b.ComboLineAndBarSeries || c === b.BarSeries && (a?.stackedType ?? Kf()) === Ie.Side)) {
        let g = 0;
        const y = (p) => dt(p.uid, "isDataLabel") ?? !1;
        t.series.each((p) => {
          const S = p.bullets.values.find(y);
          S !== void 0 && S.clones.each((x) => {
            let C = x.measuredWidth;
            switch (x.horizontalCenter) {
              case ce.Middle:
                C /= 2;
                break;
              case he.Right:
                C *= -1;
                break;
              case he.Left:
            }
            const F = x.pixelX + C;
            F > g && (g = F, f = C);
          });
        });
      }
      f >= 0 && (t.chartContainer.paddingRight = f), t.chartContainer.paddingTop = d ? s : r.paddingTop;
      const m = a?.legend?.visible !== !1 && a?.legend?.position === me.Right;
      t.paddingRight = m ? n : o;
    };
    let i = 0;
    t.series.each((a) => {
      a.events.once(E.Validated, () => {
        i += 1, i === t.series.length && e();
      });
    });
  }
}
function oM(t, e) {
  t.adapter.add("criticalError", (i) => (i.message = e.errors.simpleError, i));
}
function kl(t, e) {
  const i = t.svgContainer?.SVGContainer;
  i !== void 0 && (i.style.position = e ?? "relative");
}
function sM(t) {
  const e = t.svgContainer?.SVGContainer;
  e !== void 0 && (e.style.display = "flex");
}
function rM(t) {
  t.modal !== void 0 && (t.modal.classPrefix = "modal", kl(t, "static"), t.modal.events.on(E.Opened, () => {
    kl(t, "relative"), sM(t);
  }), t.modal.events.on(E.Closed, () => {
    kl(t, "static");
  }));
}
function wd(t) {
  rM(t);
}
function Lf(t) {
  let e = "";
  for (let i = 0; i < t.length; i += 1) {
    const a = t[i];
    e += `<li>${a.message}</li>`;
  }
  return `<ol>${e}</ol>`;
}
function ur(t) {
  t.modal !== void 0 && (t.modal.closable = !0, t.modal.content = "", t.closeModal());
}
async function Tn(t) {
  const { chart: e, chartConfig: i, queryObject: a, createMessage: n, allowUsingObjectIdStat: o, errorStrings: s } = t, r = await pc({
    input: i,
    queryObject: a,
    allowUsingObjectIdStat: o
  }), { schemaErrors: l, customErrors: c, warnings: d } = r;
  if (e.modal !== void 0) {
    if (e.modal.closable = !1, i === void 0) {
      const u = n === void 0 ? s.modalHeaders.newChart : void 0, f = n ?? s.errors.newChartRequest;
      e.modal.events.once(E.Opened, () => {
        if (n !== void 0) {
          const m = e.modal?.elements?.title?.parentElement ?? null;
          m !== null && (m.style.visibility = "hidden");
        }
      }), e.openModal(f, u);
    } else if (l.length > 0) {
      const u = s.errors.simpleError;
      e.openModal(u, s.modalHeaders.error);
    } else if (c.length > 0) {
      const u = Lf(c);
      e.openModal(u, s.modalHeaders.error);
    } else if (d.length > 0) {
      const u = Lf(d), f = `<p>${s.errors.warningRequest}</p>${u}`;
      e.openModal(f, s.modalHeaders.warning);
    }
  }
  return r;
}
async function yn(t) {
  const { chart: e, chartConfig: i, invalidType: a, elementCount: n, seriesCount: o, openModal: s, errorStrings: r } = t, l = B(e.uid, "queryObject"), c = B(e.uid, "options"), d = B(e.uid, "formatLocale"), u = i !== void 0 && ei({
    seriesConfig: i.series[0],
    xAxisValueFormatType: ii(i)
  }), f = await wm({
    invalidType: a,
    elementCount: n,
    seriesCount: o,
    chartLimits: c?.chartLimits,
    filterBySelection: c?.filterBySelection,
    queryObject: l,
    errorStrings: r,
    formatLocale: d,
    isTemporalLineChart: u
  });
  Cm(f, e.htmlContainer), e.modal !== void 0 && s !== !1 && gi(e) && (e.modal.closable = !1, e.openModal(f.message, f.header));
}
async function Af(t) {
  const { chart: e, chartConfig: i, errorStrings: a } = t, n = B(e.uid, "options");
  (e.modal?.content === void 0 || e.modal?.content === "") && Qf({
    chartConfig: i,
    nullAsValid: n?.messageOptions?.nullAsValid,
    dataSet: e.data
  }) && await yn({
    chart: e,
    invalidType: de.EmptyDataSet,
    openModal: n?.messageOptions?.displayMessageWhenNoData !== !1,
    chartConfig: i,
    errorStrings: a
  });
}
async function Tf(t, e) {
  if (t instanceof fe) {
    const i = B(t.uid, "isRotated"), a = B(t.uid, "options"), n = [];
    [
      { axis: t.xAxes.getIndex(0) },
      { axis: t.yAxes.getIndex(0) },
      { axis: t.xAxes.getIndex(1), isSecondValueAxis: !0 },
      { axis: t.yAxes.getIndex(1), isSecondValueAxis: !0 }
    ].forEach((o) => {
      const { axis: s, isSecondValueAxis: r } = o;
      if (s !== void 0) {
        const l = An(s.renderer, i);
        xy(s, r) || n.push(
          yn({
            chart: t,
            openModal: a?.messageOptions?.displayMessageWhenLogAxisNotPossible !== !1,
            invalidType: l ? de.NegativeValueInXAxisLogScale : de.NegativeValueInYAxisLogScale,
            errorStrings: e
          })
        );
      }
    }), await Promise.all(n);
  }
}
async function kd(t) {
  const {
    chart: e,
    data: i,
    chartConfig: a,
    pieSlicesSymbols: n,
    queryObject: o,
    options: s,
    currentValidationStatus: r,
    commonStrings: l,
    errorStrings: c
  } = t, { slices: d } = n ?? {}, { chartWillRender: u, createMessage: f } = s ?? {};
  let m = r, g = a, y = Ee(n);
  if (u !== void 0 && (e instanceof zt || e instanceof Me)) {
    g = Ee(a);
    const p = Fc({
      data: i,
      seriesConfig: a.series
    });
    if (g = await u({
      chartConfig: g,
      data: p,
      slices: d
    }), m = await Tn({
      chart: e,
      chartConfig: g,
      queryObject: o,
      createMessage: f,
      allowUsingObjectIdStat: s?.messageOptions?.allowUsingObjectIdStat,
      errorStrings: c
    }), e instanceof Me) {
      if (i && "dataItems" in i) {
        const { colorMatchApplied: S, rendererFieldNames: x } = await fo({
          data: i.dataItems,
          queryObject: o,
          chartConfig: g,
          allowColorMatch: ja({ chartConfig: g, queryObject: o })
        });
        J(e.uid, { colorMatchApplied: S, rendererFieldNames: x });
      }
      y = await Td({
        chart: e,
        chartConfig: g,
        queryObject: o,
        labelUpdateNeeded: !0,
        usePopupTemplateFieldsInfo: s?.usePopupTemplateFieldsInfo,
        commonStrings: l
      });
    }
  }
  return { alteredConfig: g, newValidationStatus: m, alteredPieSlicesSymbols: y };
}
function Dy(t) {
  const { chart: e, data: i, config: a, hideEmptySeries: n } = t, o = a.series.length, s = Ee(a);
  let r = !1;
  if (n && e instanceof fe && o > 1) {
    const l = z(a?.series), c = H(a?.series), d = /* @__PURE__ */ new Set();
    switch (l) {
      case b.ComboLineAndBarSeries:
      case b.BarSeries:
      case b.LineSeries: {
        s.series.forEach((f) => {
          let m = "";
          "y" in f && (m = Array.isArray(f.y) ? f.y[0] : f.y, c === L.BarAndLineSplitByNoAggregation && (m = `${m}_${Lt({
            where: f.query?.where
          })}`), (i ?? e.data)?.some(
            (y) => fc({
              dataItem: y,
              x: f.x,
              y: m
            })
          ) && d.add(f));
        });
        break;
      }
      case b.BoxPlotSeries: {
        const f = Mi(a);
        s.series.forEach((m) => {
          let g, y;
          m.type === b.BoxPlotSeries ? (g = (i ?? e.data).dataItems, y = g?.some(
            (p) => Sb({
              dataItem: p,
              splitBy: m.query?.where,
              showOutliers: f
            })
          )) : m.type === b.LineSeries && (g = (i ?? e.data).meanLines, y = g?.some((p) => gI(p, m.query?.where))), y && d.add(m);
        });
        break;
      }
    }
    const u = Array.from(d.values());
    r = u.length > 0 && u.length < o, r ? (J(e.uid, { unfilteredConfig: Ee(a) }), s.series = u, J(e.uid, { config: Ee(s) })) : J(e.uid, { unfilteredConfig: void 0 });
  }
  return J(e.uid, { seriesFilteredOut: r }), { seriesFilteredOut: r, updatedConfig: s };
}
Io.classNamePrefix = "arcgis-charts-";
async function Id(t, e) {
  const i = await Rk(e.locale);
  Io.defaultLocale = i, t.language.locale = i, J(t.uid, { formatLocale: e.formatLocale }), t.rtl = e.rtl;
}
function rl(t) {
  const { chart: e, actionMode: i, cursorRange: a } = t;
  if (gi(e)) {
    const n = i ?? B(e.uid, "actionMode") ?? T.actionMode;
    J(e.uid, { actionMode: n });
    const o = B(e.uid, "filterBySelection");
    switch (n) {
      case ne.MonoSelection:
      case ne.MultiSelection:
      case ne.MultiSelectionWithCtrlKey:
        o !== !0 ? AI(e) : Al(e);
        break;
      case ne.Zoom:
        Al(e);
        break;
      case ne.None:
        Co({
          chart: e,
          selectionSource: Ue.ClearSelection,
          clearOnlyVisibleSeries: !1,
          disposeStyleAndSelection: !1
        }), Al(e);
        break;
    }
    lB({ chart: e, actionMode: n, cursorRange: a });
  }
}
function lM(t, e) {
  e === !0 && (t.tapToActivate = !0, t.tapTimeout = 3e3, t.responsive.enabled = !0);
}
async function cM(t) {
  const { chart: e, axesConfig: i, chartType: a, isRotated: n, errorStrings: o } = t;
  switch (await Xa({ chartType: a, axesConfig: i, errorStrings: o }), a) {
    case b.ScatterSeries: {
      XD(e, i);
      break;
    }
    case b.HistogramSeries: {
      qD({ chart: e, axesConfig: i });
      break;
    }
    case b.GaugeSeries: {
      e instanceof zt && i?.[0]?.valueFormat !== void 0 && RD(e, i[0].valueFormat);
      break;
    }
    case b.BarSeries:
    case b.LineSeries:
    case b.ComboLineAndBarSeries:
    case b.BoxPlotSeries: {
      pD({ chart: e, chartType: a, isRotated: n, axesConfig: i });
      break;
    }
  }
}
async function Od(t) {
  const {
    chart: e,
    chartConfig: i,
    chartConfig: { axes: a },
    rotationChanged: n,
    axisLabelsBehaviorChanged: o,
    chartType: s,
    isRotated: r,
    dualAxisChanged: l,
    timeIntervalInfoWasReset: c,
    data: d,
    queryObject: u,
    guideTooltipFormatter: f,
    xAxisLabelFormatter: m,
    yAxisLabelFormatter: g,
    secondaryYAxisLabelFormatter: y,
    gaugeInnerLabelFormatter: p,
    commonStrings: S,
    errorStrings: x
  } = t;
  switch (await Xa({ chartType: s, axesConfig: a, errorStrings: x }), s) {
    case b.ScatterSeries: {
      e instanceof fe && await UD({
        chart: e,
        axesConfig: a,
        axisLabelsBehaviorChanged: o,
        guideTooltipFormatter: f,
        xAxisLabelFormatter: m,
        yAxisLabelFormatter: g,
        commonStrings: S,
        errorStrings: x
      });
      break;
    }
    case b.HistogramSeries: {
      e.data !== void 0 && e instanceof fe && await YD({
        chart: e,
        axesConfig: a,
        histogramBins: e.data,
        guideTooltipFormatter: f,
        xAxisLabelFormatter: m,
        yAxisLabelFormatter: g,
        commonStrings: S,
        errorStrings: x
      });
      break;
    }
    case b.BarSeries:
    case b.LineSeries:
    case b.ComboLineAndBarSeries:
    case b.BoxPlotSeries: {
      e instanceof fe && await yD({
        chart: e,
        chartConfig: i,
        rotationChanged: n,
        axisLabelsBehaviorChanged: o,
        isRotated: r,
        dualAxisChanged: l,
        timeIntervalInfoWasReset: c,
        timeIntervalInfo: d?.timeIntervalInfo ?? B(e.uid, "timeIntervalInfo"),
        guideTooltipFormatter: f,
        xAxisLabelFormatter: m,
        yAxisLabelFormatter: g,
        secondaryYAxisLabelFormatter: y,
        commonStrings: S,
        errorStrings: x
      });
      break;
    }
    case b.GaugeSeries: {
      e instanceof zt && await ED({
        chart: e,
        chartConfig: i,
        data: (d ?? e.data).dataItems,
        queryObject: u,
        axisValueFormatter: m,
        gaugeInnerLabelFormatter: p,
        commonStrings: S,
        errorStrings: x
      });
      break;
    }
  }
}
async function Ny(t) {
  const { chart: e, chartConfig: i, hideLoaderHandle: a, options: n, commonStrings: o, queryObject: s } = t, { selectionTheme: r, ignoreSmoothRenderingLimit: l } = n ?? {}, c = z(i.series);
  e.series.clear();
  let d, u;
  const f = [], m = [], g = e instanceof fe ? [e.xAxes.getIndex(0), e.yAxes.getIndex(0), e.xAxes.getIndex(1) ?? e.yAxes.getIndex(1)] : void 0, y = { hideLoaderHandle: a, selectionTheme: r, commonStrings: o }, p = { ...y, axisList: g };
  for (let x = 0; x < i.series.length; x += 1) {
    const C = i.series[x];
    if (u = z([C]), e instanceof fe && (u === b.BoxPlotSeries || u === b.LineSeries && c === b.BoxPlotSeries))
      d = PO({
        ...p,
        chart: e,
        axisList: g,
        chartConfig: i,
        seriesIndex: x
      }), m.push(...d.flat());
    else
      switch (u) {
        case b.BarSeries: {
          e instanceof fe && (d = rN({
            ...p,
            chart: e,
            chartConfig: i,
            seriesIndex: x
          }), m.push(d));
          break;
        }
        case b.LineSeries: {
          e instanceof fe && (d = TO({
            ...p,
            chart: e,
            chartConfig: i,
            seriesIndex: x,
            ignoreSmoothRenderingLimit: l
          }), m.push(d));
          break;
        }
        case b.ScatterSeries: {
          e instanceof fe && C.type === b.ScatterSeries && (f.push(
            QN({
              ...p,
              chart: e,
              seriesConfig: C,
              ignoreSmoothRenderingLimit: l
            })
          ), e.bulletsContainer.zIndex = 1, e.seriesContainer.zIndex = 2);
          break;
        }
        case b.HistogramSeries: {
          e instanceof fe && C.type === b.HistogramSeries && f.push(
            SN({ ...p, chart: e, seriesConfig: C })
          );
          break;
        }
        case b.PieSeries: {
          e instanceof Me && C.type === b.PieSeries && (d = DN({ ...y, seriesConfig: C }), m.push(d));
          break;
        }
      }
  }
  const S = PS({ chartConfig: i, queryObject: s, chartData: e.data });
  if (S.length > 0 && (e.colors.list = S.map((x) => {
    const [C, F, v, A] = x;
    return new Us({ r: C, g: F, b: v, a: A });
  })), f.length > 0) {
    const x = await Promise.all(f);
    e.series.pushAll(x.flat());
  } else m.length > 0 && e.series.pushAll(m);
  MI(e);
}
async function Bd(t) {
  const {
    chart: e,
    chartConfig: i,
    chartConfig: { series: a, axes: n, chartRenderer: o },
    seriesIndexMapper: s,
    rotationChanged: r,
    outliersVisibilityChanged: l,
    standardizeValuesVisibilityChanged: c,
    chartData: d,
    queryObject: u,
    options: f,
    dataWasUpdated: m,
    sortChanged: g,
    groupOfSlicesWasUpdated: y,
    pieSlicesSymbols: p,
    commonStrings: S,
    errorStrings: x
  } = t, C = e.series.values, F = /* @__PURE__ */ new Map(), v = i.series.length, A = z(a), w = Ri(i), O = ti(i), I = uc(u), N = await At(u, f?.usePopupTemplateFieldsInfo), M = we(u), P = os(o, M.renderer);
  for (const [R, $] of a.entries()) {
    const W = z([$]), U = C[R], q = {
      numberOfSeries: v,
      series: U,
      seriesConfig: $,
      seriesIndex: R,
      colorMatch: w,
      queryObject: u,
      rendererType: P,
      options: f,
      dataWasUpdated: m,
      fieldList: N,
      subtypeInfo: I,
      sortChanged: g,
      commonStrings: S
    }, Z = {
      ...q,
      axes: n,
      seriesIndexMapper: s
    };
    let ee = U;
    if (e instanceof fe && (W === b.BoxPlotSeries || W === b.LineSeries && A === b.BoxPlotSeries)) {
      if (ee = C.find((j) => j.id === $.id), U !== void 0 && (ee instanceof ut || ee instanceof ye)) {
        const j = qe(i);
        jO({
          ...q,
          chart: e,
          series: ee,
          seriesIndexMapper: s,
          seriesSymbolMapForEvent: F,
          chartData: d,
          showOutliers: i.showOutliers,
          showMean: j,
          outliersVisibilityChanged: l,
          standardizeValuesVisibilityChanged: c,
          rotationChanged: r,
          options: f
        });
      }
    } else
      switch (W) {
        case b.BarSeries:
          lN({
            ...Z,
            stackedType: O,
            seriesSymbolMapForEvent: F,
            rotationChanged: r
          });
          break;
        case b.LineSeries:
          DO({
            ...Z,
            stackedType: O,
            seriesSymbolMapForEvent: F,
            rotationChanged: r
          });
          break;
        case b.ScatterSeries:
          JN({
            ...Z,
            chartSeries: C,
            chartData: d
          });
          break;
        case b.HistogramSeries:
          await CN({
            ...Z,
            chartSeries: C,
            chartConfig: i,
            chartData: d && "bins" in d ? d : void 0,
            chartRenderer: o
          });
          break;
        case b.PieSeries:
          VN({
            ...q,
            chart: e,
            groupOfSlicesWasUpdated: y,
            pieSlicesSymbols: p,
            selectionTheme: f?.selectionTheme
          });
          break;
      }
  }
  await nB({
    chart: e,
    options: f,
    dataWasUpdated: m,
    chartData: d,
    chartConfig: i,
    queryObject: u,
    rotationChanged: r,
    sortChanged: g,
    groupOfSlicesWasUpdated: y,
    errorStrings: x
  });
}
async function Dd(t) {
  let { chartConfig: e } = t;
  const { chart: i, options: a, globalOptions: n, queryObject: o, commonStrings: s, errorStrings: r } = t, {
    hideLoaderAnimation: l,
    disableTogglingLegendItems: c,
    cursorRange: d,
    actionMode: u,
    pieChartLegendValueLabelFormatter: f,
    guideTooltipFormatter: m,
    xAxisLabelFormatter: g,
    yAxisLabelFormatter: y,
    secondaryYAxisLabelFormatter: p,
    gaugeInnerLabelFormatter: S,
    usePopupTemplateFieldsInfo: x
  } = a ?? {};
  let C, F, v, A;
  const { loaderElements: w, loaderHandle: O } = BI(i, a);
  O.showLoader(l !== !0);
  const I = z(e.series), N = await At(o, x);
  J(i.uid, { fieldList: N });
  const {
    valid: M,
    invalidType: P,
    data: R,
    count: $,
    binnedServerData: W,
    queryConfig: U
  } = await uo({
    chartConfig: e,
    queryObject: o,
    abortKey: us(i),
    options: a,
    errorStrings: r,
    fieldList: N
  });
  J(i.uid, {
    options: a,
    elementCount: $,
    initialized: M,
    binnedServerData: W,
    queryConfig: U,
    boxPlotMeanLinesData: R?.meanLines,
    timeIntervalInfo: R?.timeIntervalInfo,
    trendLineData: {
      r2: R?.r2,
      trendLinePoints: R?.trendLinePoints
    }
  });
  const q = /* @__PURE__ */ new Map();
  e.series.forEach((ge, yt) => {
    q.set(ge.id, yt);
  });
  const Z = Vi(R), ee = qe(e);
  e = Dy({
    chart: i,
    hideEmptySeries: a?.hideEmptySeries ?? T.options.hideEmptySeries,
    data: ee ? R : Z,
    config: e
  }).updatedConfig;
  const j = R && ee && "meanLines" in R ? R.meanLines : Z;
  if (j !== void 0 && I !== b.HistogramSeries) {
    const { colorMatchApplied: ge, rendererFieldNames: yt } = await fo({
      data: j,
      queryObject: o,
      chartConfig: e,
      allowColorMatch: ja({ chartConfig: e, queryObject: o })
    });
    J(i.uid, { colorMatchApplied: ge, rendererFieldNames: yt });
  }
  if (!M)
    await yn({
      chart: i,
      invalidType: P,
      elementCount: $,
      seriesCount: e.series.length,
      chartConfig: e,
      errorStrings: r
    }), O.hideLoader();
  else {
    Z !== void 0 && (i.data = Z);
    const ge = H(e.series);
    I === b.BoxPlotSeries && ge !== L.BoxPlotMonoField && ge !== L.BoxPlotMonoFieldAndSplitBy && (Hi({ arrayToSort: i.data, chartConfig: e }), dy({ chart: i, chartData: i.data, chartConfig: e }));
    let yt;
    i instanceof Me && (Iy({
      chart: i,
      seriesConfig: e.series,
      commonStrings: s
    }), yt = await Td({
      chart: i,
      chartConfig: e,
      queryObject: o,
      labelUpdateNeeded: !0,
      usePopupTemplateFieldsInfo: a?.usePopupTemplateFieldsInfo,
      commonStrings: s
    }));
    const Nt = {
      dataItems: i.data,
      timeIntervalInfo: B(i.uid, "timeIntervalInfo"),
      meanLines: B(i.uid, "boxPlotMeanLinesData"),
      outliers: R?.outliers
    };
    un({
      data: i instanceof Me ? { dataItems: i.data } : R,
      seriesConfig: e.series,
      htmlContainer: i.htmlContainer
    });
    const Mt = await kd({
      chart: i,
      data: R,
      chartConfig: e,
      pieSlicesSymbols: yt,
      queryObject: o,
      options: a,
      commonStrings: s,
      errorStrings: r
    });
    A = Mt.newValidationStatus;
    const { alteredConfig: Oe, alteredPieSlicesSymbols: Fi } = Mt;
    if (yt = Fi, i instanceof Me && (Wr({
      data: i.data,
      newChartConfig: Oe,
      pieSlicesSymbols: yt,
      fieldList: B(i.uid, "fieldList")
    }), zi({
      data: yt,
      htmlContainer: i.htmlContainer,
      chartId: i.id,
      colorMatchApplied: Fn(i, Oe)
    }), ym({ data: i.data, chartConfig: Oe, htmlContainer: i.htmlContainer })), A?.valid !== !1) {
      const { title: Be, subtitle: le, footer: bt, series: Qe, background: $t } = Oe;
      C = _D(i), ol(C, { title: Be, subtitle: le }), F = ZD(i), sl(F, bt), v = AO(i, Qe), KI(i);
      const Li = fi({ config: Oe }), vo = H(Qe);
      J(i.uid, {
        config: Oe,
        isRotated: Li,
        isNonAggregatedChart: !dn(vo)
      }), Oe.axes !== void 0 && (await cM({ chart: i, axesConfig: Oe.axes, chartType: I, isRotated: Li, errorStrings: r }), await Od({
        chart: i,
        chartConfig: Oe,
        chartType: I,
        isRotated: Li,
        data: R,
        queryObject: o,
        guideTooltipFormatter: m,
        xAxisLabelFormatter: g,
        yAxisLabelFormatter: y,
        secondaryYAxisLabelFormatter: p,
        gaugeInnerLabelFormatter: S,
        commonStrings: s,
        errorStrings: r
      })), await Ny({
        chart: i,
        chartConfig: Oe,
        hideLoaderHandle: O.hideLoader,
        commonStrings: s,
        options: a,
        queryObject: o
      }), await Bd({
        chart: i,
        chartConfig: Oe,
        seriesIndexMapper: q,
        rotationChanged: !1,
        queryObject: o,
        chartData: I === b.BoxPlotSeries ? Nt : R,
        groupOfSlicesWasUpdated: !0,
        pieSlicesSymbols: yt,
        dataWasUpdated: !0,
        options: a,
        commonStrings: s,
        errorStrings: r
      }), Sd({
        legendElements: v,
        seriesConfig: Qe,
        webChartLegend: Oe.legend,
        pieChartLegendValueLabelFormatter: f
      }), Ty(i), jD(i), nl(i, $t), wy({
        chart: i,
        scrollbarXConfig: Oe.axes?.[0]?.scrollbar,
        scrollbarYConfig: Oe.axes?.[1]?.scrollbar
      }), fy(i), my(i, Oe?.cursorCrosshair), rl({ chart: i, actionMode: u, cursorRange: d });
      const ys = ia(i.htmlContainer);
      i.dateFormatter.intlLocales = ys.formatLocale, lM(i, n?.enableResponsiveFeatures), (i instanceof zt || ms(i.series)) && (O.hideLoader(), no(i.htmlContainer)), By(i);
    }
  }
  return { chartElements: C !== void 0 && F !== void 0 && v !== void 0 && w !== void 0 ? { headerElements: C, footerElements: F, legendElements: v, loaderHandle: O, loaderElements: w } : void 0, validationStatus: A };
}
function dM(t) {
  t.series.each((e) => {
    e.events.on(E.Ready, () => {
      ms(t.series) && Fd(t);
    });
  });
}
async function uM(t) {
  const { chartContainer: e, chartConfig: i, queryObject: a, t9nStrings: n, options: o, globalOptions: s } = t, { errorStrings: r, commonStrings: l } = n, { createMessage: c } = o ?? {};
  e == null && await Ga("divNode", n.errorStrings);
  const d = vc(e, fe);
  d.id = i?.id ?? d.uid, J(d.uid, { queryObject: a });
  const u = ia(d.htmlContainer);
  await Id(d, u), wd(d), d.events.on(E.Inited, () => d.zoomOutButton.deepInvalidate());
  const f = await Tn({
    chart: d,
    chartConfig: i,
    queryObject: a,
    createMessage: c,
    allowUsingObjectIdStat: o?.messageOptions?.allowUsingObjectIdStat,
    errorStrings: r
  }), m = Ir(i, d.htmlContainer), g = z(m?.series);
  let y;
  return f.valid && (d instanceof fe && g !== b.BoxPlotSeries && (d.maskBullets = !1), y = (await Dd({
    chartConfig: m,
    chart: d,
    queryObject: a,
    options: o,
    globalOptions: s,
    commonStrings: l,
    errorStrings: r
  })).chartElements, J(d.uid, { config: Ee(m) }), vI(d), FI(d)), Ua(f, d.htmlContainer), { chart: d, chartElements: y };
}
async function fM(t) {
  const { chartContainer: e, chartConfig: i, queryObject: a, errorStrings: n, commonStrings: o, options: s, globalOptions: r } = t;
  e == null && await Ga("divNode", n);
  const l = vc(e, Me);
  l.id = i?.id ?? l.uid;
  const c = ia(l.htmlContainer);
  await Id(l, c), l.radius = Ct(T.pieChart.chartRadius), wd(l);
  const d = await Tn({
    chart: l,
    chartConfig: i,
    queryObject: a,
    createMessage: s?.createMessage,
    allowUsingObjectIdStat: s?.messageOptions?.allowUsingObjectIdStat,
    errorStrings: n
  });
  let u;
  return d.valid && (u = (await Dd({
    chartConfig: i,
    chart: l,
    queryObject: a,
    options: s,
    globalOptions: r,
    commonStrings: o,
    errorStrings: n
  })).chartElements, J(l.uid, { config: Ee(i), filterBySelection: s?.filterBySelection }), iM(l)), Ua(d, e), { chart: l, chartElements: u };
}
async function mM(t) {
  const { chartContainer: e, chartConfig: i, queryObject: a, errorStrings: n, commonStrings: o, options: s, globalOptions: r } = t;
  e == null && await Ga("divNode", n);
  const l = vc(e, zt);
  l.id = i?.id ?? l.uid;
  const c = ia(l.htmlContainer);
  await Id(l, c), wd(l), l.maskBullets = !1;
  let d = await Tn({
    chart: l,
    chartConfig: i,
    queryObject: a,
    createMessage: s?.createMessage,
    allowUsingObjectIdStat: s?.messageOptions?.allowUsingObjectIdStat,
    errorStrings: n
  }), u;
  if (d.valid) {
    const f = T.gauge, m = Number.isFinite(i?.innerRadius) ? i?.innerRadius : f.innerRadius, g = Number.isFinite(i?.startAngle) ? i?.startAngle : f.startAngle, y = Number.isFinite(i?.endAngle) ? i?.endAngle : f.endAngle;
    l.radius = Ct(f.radius), typeof m == "number" && (l.innerRadius = Ct(m)), typeof g == "number" && (l.startAngle = g), typeof y == "number" && (l.endAngle = y);
    const p = await Dd({
      chartConfig: i,
      chart: l,
      queryObject: a,
      options: s,
      globalOptions: r,
      commonStrings: o,
      errorStrings: n
    });
    u = p.chartElements, d = p.validationStatus ?? d, J(l.uid, { config: Ee(i) });
  }
  return dM(l), Ua(d, l.htmlContainer), { chart: l, chartElements: u };
}
async function gM(t) {
  let { newConfig: e } = t;
  const { chart: i, chartElements: a, options: n, queryObject: o, forceDataUpdate: s, commonStrings: r, errorStrings: l } = t, { createMessage: c, chartLimits: d, guideTooltipFormatter: u } = n ?? {};
  ur(i);
  const f = await Tn({
    chart: i,
    chartConfig: e,
    queryObject: o,
    createMessage: c,
    allowUsingObjectIdStat: n?.messageOptions?.allowUsingObjectIdStat,
    errorStrings: l
  });
  if (f.valid && e !== void 0) {
    DI(a.loaderElements, n), a.loaderHandle.showLoader(n?.hideLoaderAnimation !== !0);
    const g = B(i.uid, "seriesFilteredOut"), y = B(i.uid, "unfilteredConfig"), p = B(i.uid, "config"), S = p?.series, x = e.series, C = z(x), F = fi({ config: e });
    J(i.uid, { config: Ee(e), isRotated: F });
    const { dataUpdateNeeded: v, updateNeededDetails: A } = wr({
      options: n,
      forceDataUpdate: s,
      oldConfig: g ? y : p,
      newConfig: e,
      formerFilterBySelection: B(i.uid, "filterBySelection"),
      timeIntervalInfo: B(i.uid, "timeIntervalInfo"),
      currentSelectionDataItems: B(i.uid, "currentSelectionDataItems"),
      currentSelectionOIDs: B(i.uid, "currentSelectionOIDs"),
      currentSelectionIndexes: B(i.uid, "computedSelectionIndexes")
    });
    J(i.uid, { filterBySelection: n?.filterBySelection }), rl({ chart: i, actionMode: n?.actionMode, cursorRange: n?.cursorRange });
    const { xOrYChanged: w } = A.common;
    let { numberOfSeriesChanged: O } = A.common;
    const I = vm(p, e), N = Fm(p, e), M = sx(p, e), P = rx(p, e), R = JSON.stringify(qd(S)) !== JSON.stringify(qd(x)), $ = dx(p, e), W = ux(p, e), U = wc(p, e), q = kc({
      oldConfig: g ? y : p,
      newConfig: e,
      dataUpdateNeeded: v
    }), Z = um({
      oldConfig: p,
      newConfig: e,
      rotationChanged: N
    }), ee = Fy({
      chart: i,
      dualAxisChanged: M,
      rotationChanged: N,
      timeIntervalInfoWasReset: I,
      axisLabelsBehaviorChanged: Z
    });
    let j, ie, ge = C !== b.BarSeries && C !== b.LineSeries && C !== b.ComboLineAndBarSeries && C !== b.HistogramSeries;
    const yt = H(x);
    if (J(i.uid, { isNonAggregatedChart: !dn(yt) }), v) {
      (s === !0 || ix(A)) && J(i.uid, { binnedServerData: void 0 });
      const {
        count: Be,
        valid: le,
        invalidType: bt,
        data: Qe,
        binnedServerData: $t,
        queryConfig: Li
      } = await uo({
        chartConfig: e,
        queryObject: o,
        abortKey: us(i),
        currentSelectionDataItems: B(i.uid, "currentSelectionDataItems"),
        binnedServerData: B(i.uid, "binnedServerData"),
        options: n,
        errorStrings: l
      });
      J(i.uid, {
        elementCount: Be,
        initialized: le,
        binnedServerData: $t,
        queryConfig: Li,
        boxPlotMeanLinesData: Qe?.meanLines,
        timeIntervalInfo: Qe?.timeIntervalInfo,
        trendLineData: {
          r2: Qe?.r2,
          trendLinePoints: Qe?.trendLinePoints
        }
      }), ge = le, ge ? (ur(i), j = Qe, ie = Vi(j)) : (await yn({
        chart: i,
        invalidType: bt,
        elementCount: Be,
        seriesCount: x.length,
        chartConfig: e,
        errorStrings: l
      }), a.loaderHandle.hideLoader());
    } else if (C === b.BarSeries || C === b.LineSeries || C === b.RadarSeries || C === b.ComboLineAndBarSeries || C === b.BoxPlotSeries) {
      const Be = B(i.uid, "elementCount");
      if (Be !== void 0 && (ge = Ba({
        count: Be,
        seriesCount: x.length,
        chartType: C,
        chartLimits: d
      })), ge) {
        const le = Am(S, x);
        if (le.length > 0 && (Zk(i.series, le), i.feedLegend()), ci(x[0])) {
          const { binTemporalData: bt } = x[0], { unit: Qe, size: $t } = x[0].temporalBinning ?? {};
          bt === !1 && Qe !== void 0 && $t !== void 0 && J(i.uid, { timeIntervalInfo: { unit: Qe, size: $t } });
        }
      } else {
        let le;
        switch (C) {
          case b.BarSeries:
          case b.ComboLineAndBarSeries:
            le = de.BarElementExceedsLimit;
            break;
          case b.LineSeries:
            le = de.LineChartExceedsLimit;
            break;
          case b.BoxPlotSeries:
            le = de.BoxPlotExceedsLimit;
            break;
        }
        await yn({
          chart: i,
          invalidType: le,
          elementCount: Be,
          seriesCount: x.length,
          chartConfig: e,
          errorStrings: l
        }), a.loaderHandle.hideLoader();
      }
    }
    q && (Hi({
      arrayToSort: v ? ie ?? i.data : i.data,
      chartConfig: e,
      fieldList: B(i.uid, "fieldList"),
      isTimeBinningSeries: ei({
        seriesConfig: ha(e),
        xAxisValueFormatType: ii(e),
        setTimeBinningInfoWhenNotProvided: n?.setTimeBinningInfoWhenNotProvided
      })
    }), C === b.BoxPlotSeries && dy({
      chart: i,
      chartData: v ? ie ?? i.data : i.data,
      chartConfig: e
    }), v || (i.validateData(), C === b.BoxPlotSeries && i.series.each((Be) => {
      Be instanceof ye && !(Be instanceof _t) && Be.id.includes(ve.Outliers) && Be.validateData();
    })));
    const Nt = v && j && "bins" in j ? j : void 0, Mt = j && "trendLinePoints" in j ? j : B(i.uid, "trendLineData");
    j = {
      dataItems: v ? ie ?? i.data : i.data,
      timeIntervalInfo: B(i.uid, "timeIntervalInfo"),
      meanLines: B(i.uid, "boxPlotMeanLinesData"),
      outliers: v ? j?.outliers : i.series.values.find((Be) => !(Be instanceof _t) && Be instanceof ye)?.data,
      trendLinePoints: Mt?.trendLinePoints,
      r2: Mt?.r2,
      ...Nt
    }, (v || q) && un({ data: j, seriesConfig: e.series, htmlContainer: i.htmlContainer });
    const Oe = /* @__PURE__ */ new Map();
    e.series.forEach((Be, le) => {
      Oe.set(Be.id, le);
    });
    const Fi = ja({ chartConfig: e, queryObject: o });
    if (!v || ge) {
      const Be = qe(e), le = Dy({
        chart: i,
        data: Be ? j : ie,
        config: e,
        hideEmptySeries: n?.hideEmptySeries ?? T.options.hideEmptySeries
      });
      if (e = le.updatedConfig, O = le.seriesFilteredOut, (v || U) && C !== b.HistogramSeries) {
        const Qe = qe(e), $t = j && Qe && "meanLines" in j ? j.meanLines : ie ?? i.data, { colorMatchApplied: Li, rendererFieldNames: vo } = await fo({
          data: $t,
          queryObject: o,
          chartConfig: e,
          allowColorMatch: Fi
        });
        J(i.uid, { colorMatchApplied: Li, rendererFieldNames: vo });
      }
      ie !== void 0 && (i.data = ie), e.axes !== void 0 && await Od({
        chart: i,
        chartConfig: e,
        rotationChanged: N,
        timeIntervalInfoWasReset: I,
        axisLabelsBehaviorChanged: Z,
        chartType: C,
        isRotated: F,
        dualAxisChanged: M,
        guideTooltipFormatter: u,
        xAxisLabelFormatter: n?.xAxisLabelFormatter,
        yAxisLabelFormatter: n?.yAxisLabelFormatter,
        secondaryYAxisLabelFormatter: n?.secondaryYAxisLabelFormatter,
        commonStrings: r,
        errorStrings: l
      });
      const bt = C === b.BoxPlotSeries && (JS(x, S) || KS(x, S));
      (i.series === void 0 || i.series.length === 0 || w || O || le.seriesFilteredOut || R || (C === b.BarSeries || C === b.LineSeries || C === b.RadarSeries || C === b.ComboLineAndBarSeries) && i.series.length !== e.series.length || C !== b.HistogramSeries && ee || P || // NOTE: This fix is here to resolve the issue: https://devtopia.esri.com/webgis/arcgis-charts/issues/6537
      // TODO: find a better way to order legends for box plot with split by field rather than re-initializing the series in the future.
      bt || A.boxPlot.showMeanChanged) && (!v && (N || bt || ee) && i.invalidateData(), await Ny({
        chart: i,
        chartConfig: e,
        hideLoaderHandle: a.loaderHandle.hideLoader,
        commonStrings: r,
        queryObject: o,
        options: n
      })), await Bd({
        chart: i,
        chartConfig: e,
        seriesIndexMapper: Oe,
        rotationChanged: N,
        outliersVisibilityChanged: $,
        standardizeValuesVisibilityChanged: W,
        queryObject: o,
        chartData: j,
        options: n,
        dataWasUpdated: v,
        sortChanged: q,
        commonStrings: r,
        errorStrings: l
      }), ol(a.headerElements, { title: e.title, subtitle: e.subtitle }), sl(a.footerElements, e.footer), Sd({
        legendElements: a.legendElements,
        seriesConfig: e.series,
        webChartLegend: e.legend,
        disableTogglingLegendItems: n?.disableTogglingLegendItems
      }), nl(i, e.background), wy({
        chart: i,
        scrollbarXConfig: e.axes?.[0]?.scrollbar,
        scrollbarYConfig: e.axes?.[1]?.scrollbar
      });
    }
    ms(i.series) && (a.loaderHandle.hideLoader(), no(i.htmlContainer));
  }
  Ua(f, i.htmlContainer), my(i, e?.cursorCrosshair);
  const m = sB(i);
  (m.behavior === Ce.SelectX || m.behavior === Ce.SelectXY || m.behavior === Ce.SelectY || m.behavior === Ce.None) && i.scrollbarX.start === 0 && i.scrollbarX.end === 1 && i.scrollbarY.start === 0 && i.scrollbarY.end === 1 && Fd(i), By(i), vy(i.series.values[0]);
}
async function hM(t) {
  const { chart: e, chartElements: i, newConfig: a, queryObject: n, forceDataUpdate: o, options: s, commonStrings: r, errorStrings: l } = t;
  ur(e);
  let c = await Tn({
    chart: e,
    chartConfig: a,
    queryObject: n,
    createMessage: s?.createMessage,
    allowUsingObjectIdStat: s?.messageOptions?.allowUsingObjectIdStat,
    errorStrings: l
  });
  if (c.valid && a !== void 0) {
    i.loaderHandle.showLoader(s?.hideLoaderAnimation !== !0);
    const d = B(e.uid, "config"), u = d?.series, f = a?.series, { dataUpdateNeeded: m } = wr({
      forceDataUpdate: o,
      oldConfig: d,
      newConfig: a,
      options: s,
      formerFilterBySelection: B(e.uid, "filterBySelection"),
      currentSelectionDataItems: B(e.uid, "currentSelectionDataItems"),
      currentSelectionOIDs: B(e.uid, "currentSelectionOIDs"),
      currentSelectionIndexes: B(e.uid, "currentSelectionIndexes")
    }), g = wc(d, a), y = kc({ oldConfig: d, newConfig: a, dataUpdateNeeded: m });
    J(e.uid, { filterBySelection: s?.filterBySelection, config: Ee(a) });
    let p = !0, S, x, C = !1;
    if (m) {
      const {
        count: F,
        valid: v,
        invalidType: A,
        data: w,
        queryConfig: O
      } = await uo({
        chartConfig: a,
        currentSelectionDataItems: B(e.uid, "currentSelectionDataItems"),
        options: s,
        queryObject: n,
        abortKey: us(e),
        errorStrings: l
      });
      S = w, J(e.uid, { elementCount: F, queryConfig: O, initialized: v }), p = v, x = Vi(S), p ? x !== void 0 && uF(e.data, x) && (e.data = x, C = !0) : (await yn({
        chart: e,
        invalidType: A,
        elementCount: F,
        seriesCount: f.length,
        errorStrings: l
      }), i.loaderHandle.hideLoader());
    }
    if (!C || p) {
      if (m || g) {
        const P = await fo({
          data: x ?? e.data,
          queryObject: n,
          chartConfig: a,
          allowColorMatch: ja({ chartConfig: a, queryObject: n })
        });
        e.data = P.dataItems, J(e.uid, {
          colorMatchApplied: P.colorMatchApplied,
          rendererFieldNames: P.rendererFieldNames
        });
      }
      const F = Qg(u, f);
      (C || F) && Iy({ chart: e, seriesConfig: f, commonStrings: r }), (y || F) && (Hi({
        arrayToSort: x ?? e.data,
        chartConfig: a,
        fieldList: B(e.uid, "fieldList")
      }), e.validateData());
      const v = Nl({ oldConfig: d, newConfig: a }), A = hm(d, a);
      let w = await Td({
        chart: e,
        chartConfig: a,
        queryObject: n,
        labelUpdateNeeded: C || v || g || A,
        usePopupTemplateFieldsInfo: s?.usePopupTemplateFieldsInfo,
        commonStrings: r
      });
      (C || y) && (un({
        data: { dataItems: e.data },
        seriesConfig: a.series,
        htmlContainer: e.htmlContainer
      }), ym({ data: e.data, chartConfig: a, htmlContainer: e.htmlContainer }));
      const O = await kd({
        chart: e,
        data: { dataItems: e.data },
        chartConfig: a,
        pieSlicesSymbols: w,
        queryObject: n,
        options: s,
        currentValidationStatus: c,
        commonStrings: r,
        errorStrings: l
      });
      c = O.newValidationStatus ?? c;
      const { alteredPieSlicesSymbols: I, alteredConfig: N } = O;
      w = I;
      const M = Nl({
        oldConfig: a,
        newConfig: N
      });
      (m || v || M || g || A) && Wr({
        data: e.data,
        newChartConfig: N,
        pieSlicesSymbols: w,
        fieldList: B(e.uid, "fieldList")
      }), zi({
        data: w,
        htmlContainer: e.htmlContainer,
        chartId: e.id,
        colorMatchApplied: Fn(e, N)
      }), await Bd({
        chart: e,
        queryObject: n,
        chartConfig: N,
        seriesIndexMapper: /* @__PURE__ */ new Map(),
        // pie chart won't use this
        options: s,
        dataWasUpdated: C,
        sortChanged: y,
        chartData: S,
        groupOfSlicesWasUpdated: F,
        pieSlicesSymbols: w,
        commonStrings: r,
        errorStrings: l
      }), ol(i.headerElements, {
        title: N.title,
        subtitle: N.subtitle
      }), sl(i.footerElements, N.footer), Sd({
        legendElements: i.legendElements,
        seriesConfig: N.series,
        webChartLegend: N.legend,
        disableTogglingLegendItems: s?.disableTogglingLegendItems,
        pieChartLegendValueLabelFormatter: s?.pieChartLegendValueLabelFormatter
      }), nl(e, N.background), rl({ chart: e, actionMode: s?.actionMode, cursorRange: s?.cursorRange }), Oy(e);
    }
    ms(e.series) && (i.loaderHandle.hideLoader(), no(e.htmlContainer));
  }
  Ua(c, e.htmlContainer);
}
async function pM(t) {
  const { chart: e, chartElements: i, newConfig: a, queryObject: n, forceDataUpdate: o, options: s, commonStrings: r, errorStrings: l } = t, { createMessage: c, hideLoaderAnimation: d, xAxisLabelFormatter: u, gaugeInnerLabelFormatter: f, guideTooltipFormatter: m } = s ?? {};
  ur(e);
  let g = await Tn({
    chart: e,
    chartConfig: a,
    queryObject: n,
    createMessage: c,
    allowUsingObjectIdStat: s?.messageOptions?.allowUsingObjectIdStat,
    errorStrings: l
  });
  if (g.valid && a !== void 0) {
    i.loaderHandle.showLoader(d !== !0);
    const y = B(e.uid, "config"), p = a.series, S = z(p), { dataUpdateNeeded: x } = wr({ forceDataUpdate: o, oldConfig: y, newConfig: a });
    let C;
    if (x) {
      const {
        count: A,
        valid: w,
        invalidType: O,
        data: I,
        queryConfig: N
      } = await uo({
        chartConfig: a,
        queryObject: n,
        options: s,
        abortKey: us(e),
        errorStrings: l
      });
      C = I, C?.dataItems !== void 0 && (e.data = C.dataItems), un({
        data: { dataItems: e.data },
        seriesConfig: a.series,
        htmlContainer: e.htmlContainer
      }), J(e.uid, { elementCount: A, queryConfig: N, initialized: w }), w || (await yn({ chart: e, invalidType: O, elementCount: A, seriesCount: 1, errorStrings: l }), i.loaderHandle.hideLoader());
    }
    const F = await kd({
      chart: e,
      data: { dataItems: e.data },
      chartConfig: a,
      queryObject: n,
      options: s,
      currentValidationStatus: g,
      commonStrings: r,
      errorStrings: l
    });
    g = F.newValidationStatus ?? g;
    const v = F.alteredConfig;
    if (g.valid) {
      v.axes !== void 0 && await Od({
        chart: e,
        chartConfig: v,
        chartType: S,
        data: C,
        queryObject: n,
        xAxisLabelFormatter: u,
        gaugeInnerLabelFormatter: f,
        guideTooltipFormatter: m,
        commonStrings: r,
        errorStrings: l
      });
      const A = T.gauge, w = Number.isFinite(v?.innerRadius) ? v.innerRadius : A.innerRadius, O = Number.isFinite(v?.startAngle) ? v.startAngle : A.startAngle, I = Number.isFinite(v?.endAngle) ? v.endAngle : A.endAngle;
      e.innerRadius = Ct(w), e.startAngle = O, e.endAngle = I, ol(i.headerElements, {
        title: v.title,
        subtitle: v.subtitle
      }), sl(i.footerElements, v.footer), nl(e, v.background), J(e.uid, { config: Ee(v) }), i.loaderHandle.hideLoader(), no(e.htmlContainer);
    }
  }
  Ua(g, e.htmlContainer);
}
async function yM(t) {
  const { chartContainer: e, chartConfig: i, queryObject: a, t9nStrings: n, options: o, globalOptions: s } = t, { errorStrings: r, commonStrings: l } = n;
  Io.commercialLicense = s?.hideLicenseWatermark !== !1, Io.queue = s?.queueChartCreation !== !1, Io.autoDispose = s?.autoDisposeChart === !0, s?.useAnimatedCharts === !0 ? hS(jd) : pS(jd);
  let c;
  switch (z(i?.series)) {
    case b.PieSeries:
      c = await fM({
        chartContainer: e,
        chartConfig: i,
        queryObject: a,
        options: o,
        globalOptions: s,
        commonStrings: l,
        errorStrings: r
      });
      break;
    case b.GaugeSeries:
      c = await mM({
        chartContainer: e,
        chartConfig: i,
        queryObject: a,
        options: o,
        globalOptions: s,
        commonStrings: l,
        errorStrings: r
      });
      break;
    default:
      c = await uM({
        chartContainer: e,
        chartConfig: i,
        queryObject: a,
        options: o,
        globalOptions: s,
        t9nStrings: n
      });
      break;
  }
  return c;
}
async function bM(t) {
  const { chartContainer: e, chartConfig: i, t9nStrings: a, options: n, globalOptions: o } = t, { errorStrings: s } = a, { layer: r, view: l } = n ?? {}, c = !Ff(e);
  let d;
  i !== void 0 && (Xi(i) ? d = i : d = Gs({ chartConfig: i, queryObject: r })), d = await $o(d, r);
  let u;
  d && (Xi(d) || r !== void 0) && (u = await qn({ chartConfig: d, layer: r, view: l }));
  const f = await yM({
    chartContainer: e,
    chartConfig: d,
    queryObject: u,
    t9nStrings: a,
    options: n,
    globalOptions: o
  }), { chart: m, chartElements: g } = f;
  oM(m, s), J(m.uid, {
    chartWasCreatedWhileHidden: c,
    queryObject: u,
    filterBySelection: n?.filterBySelection,
    options: n
  }), aM(m, e), await Af({ chart: m, chartConfig: d, errorStrings: s }), await Tf(m, s);
  function y() {
    xb.delete(us(m)), m.isDisposed() || (Jk(m), g !== void 0 && (g.loaderHandle.hideLoader(), f.chartElements = void 0), m.dispose());
  }
  async function p(A) {
    const { newConfig: w, forceDataUpdate: O, updateOptions: I } = A, { commonStrings: N } = A, M = B(m.uid, "initialized"), P = B(m.uid, "config"), R = w?.series, $ = R !== void 0 ? z(R) : void 0;
    if (m.isDisposed() || g === void 0 || M === !1 || !fm(P, w))
      throw new ln(nn.ChartDisposed);
    switch ($) {
      case b.BoxPlotSeries:
      case b.BarSeries:
      case b.LineSeries:
      case b.ComboLineAndBarSeries:
      case b.ScatterSeries:
      case b.HistogramSeries:
        await gM({
          chart: m,
          chartElements: g,
          queryObject: u,
          newConfig: w,
          forceDataUpdate: O,
          options: I,
          commonStrings: N,
          errorStrings: s
        });
        break;
      case b.PieSeries:
        await hM({
          chart: m,
          chartElements: g,
          queryObject: u,
          forceDataUpdate: O,
          newConfig: w,
          options: I,
          commonStrings: N,
          errorStrings: s
        });
        break;
      case b.GaugeSeries:
        await pM({
          chart: m,
          chartElements: g,
          newConfig: w,
          queryObject: u,
          forceDataUpdate: O,
          options: I,
          commonStrings: N,
          errorStrings: s
        });
        break;
    }
  }
  async function S(A) {
    const { layerUpdate: w, newConfig: O, viewUpdate: I } = A;
    O && (w !== void 0 || Xi(O)) && (u = await qn({ layer: w, view: I, chartConfig: O }), J(m.uid, { queryObject: u }));
  }
  async function x(A) {
    const { newChartConfig: w, updateOptions: O, updateGlobalOptions: I, t9nStrings: N } = A, { errorStrings: M, commonStrings: P } = N;
    e == null && await Ga("divNode", M);
    const { layer: R, view: $, dataUpdated: W } = O ?? {}, U = !Ff(e), q = await At(u, n?.usePopupTemplateFieldsInfo);
    J(m.uid, { chartWasUpdatedWhileHidden: U, options: O, fieldList: q });
    let Z;
    Xi(w) ? Z = w : w !== void 0 && (Z = Gs({ chartConfig: w, queryObject: R })), Z = await $o(Z, R);
    const ee = Po(u);
    await S({ layerUpdate: R, newConfig: Z, viewUpdate: $ });
    const j = B(m.uid, "config");
    j !== void 0 && Lm(j, Z) && (Z = Ir(Z, m.htmlContainer));
    const ie = Po(u);
    await p({
      newConfig: Z,
      updateOptions: O,
      forceDataUpdate: W === !0 || ee !== ie,
      commonStrings: P
    }), await Af({ chart: m, chartConfig: Z, errorStrings: M }), await Tf(m, M);
  }
  async function C() {
    if (gi(m) && (m instanceof fe || m instanceof Me)) {
      const A = B(m.uid, "actionMode");
      A !== ne.MonoSelection && A !== ne.None && await LI(m);
    }
  }
  function F(A, w, O) {
    m.modal !== void 0 && !m.isDisposed() && (m.modal.closable = O?.closable ?? !1, A !== void 0 ? (m.modal.events.once(E.Opened, () => {
      const I = m.modal?.elements?.title?.parentElement;
      I instanceof HTMLElement && m.modal?.elements?.title?.innerText.length === 0 && (I.style.visibility = "hidden");
    }), m.openModal(A, w)) : m.closeModal());
  }
  function v() {
    Fd(m);
  }
  return {
    update: x,
    dispose: y,
    notify: F,
    resetZoom: v,
    clearSelection: () => Co({ chart: m }),
    switchSelection: C,
    exportImage: async (A) => await eI({ chart: m, exportOptions: A }),
    setActionMode: (A, w) => rl({ chart: m, actionMode: A, cursorRange: w })
  };
}
function SM(t, e) {
  let i;
  return e !== void 0 && (i = { ...e }, i.legend !== void 0 && (i.legend.position = t)), i;
}
function xM(t, e) {
  let i;
  return e !== void 0 && (i = { ...e }, i.legend !== void 0 && (i.legend.visible = t)), i;
}
function CM(t) {
  let e;
  return t !== void 0 && (e = { ...t }, delete e.axes?.[0]?.minimum, delete e.axes?.[0]?.maximum, delete e.axes?.[1]?.minimum, delete e.axes?.[1]?.maximum), e;
}
function wf(t, e) {
  return e != null || Xi(t);
}
async function vM(t) {
  const { queryObject: e, chartConfig: i, options: a, splitByField: n } = t;
  let o = [];
  const s = i.series[0], r = await $o(i, e), l = Wf({
    queryObject: e,
    chartConfig: r,
    runtimeDataFilters: a?.runtimeDataFilters,
    ignoreViewExtent: a?.ignoreViewExtent
  });
  if (l.outStatistics?.[0]?.outStatisticFieldName && (l.outStatistics[0].outStatisticFieldName = ot.outStatistics.outStatisticFieldName), ci(s) && ei({
    xAxisValueFormatType: ii(r),
    setTimeBinningInfoWhenNotProvided: a?.setTimeBinningInfoWhenNotProvided,
    seriesConfig: s
  }) && s.temporalBinning?.type === wi.CalendarBased) {
    const { temporalBinning: c, x: d } = s, u = await zf({
      queryObject: e,
      dateField: d,
      splitByField: n,
      queryConfig: l,
      temporalBinning: c
    });
    o = Array.from(
      new Set(
        u.flatMap((f) => {
          const { stackedAttributes: m } = f;
          let g = [];
          return m && (g = m.map((y) => y[n]).filter((y) => y !== void 0)), g;
        })
      ).values()
    );
  } else {
    const { uniqueQuery: c } = await Pr({
      chartConfig: r,
      queryObject: e,
      queryConfig: l,
      options: a
    }), d = await aa({
      queryObject: e,
      queryConfig: c,
      featureCount: 1
    });
    o = Array.from(
      new Set(
        d.map((u) => u.attributes[n]).filter((u) => u !== void 0)
      ).values()
    );
  }
  return o;
}
function FM(t, e) {
  const i = /* @__PURE__ */ new Map();
  return t.series.forEach((a) => {
    let n = Lt({
      where: a.query?.where,
      // normalize the value so it matches what we get from getAllValues()
      // Refer to https://devtopia.esri.com/WebGIS/arcgis-charts/issues/8127
      normalize: !0,
      // we do not escape the characters so they match what we get from getAllValues()
      // Refer to https://devtopia.esri.com/WebGIS/arcgis-charts/issues/8078
      escape: !1
    });
    e && n !== null && (n = Number(n));
    const o = z([a]);
    o !== void 0 && i.set(o, [
      ...i.get(o) ?? [],
      n
    ]);
  }), i;
}
function LM(t) {
  const { allValues: e, configUniqueValuesPerSeriesType: i, initialConfigWasEmpty: a } = t, n = /* @__PURE__ */ new Map();
  return Array.from(i.keys()).forEach((o) => {
    const s = i.get(o) ?? [];
    let r = [];
    a ? r = e : e.forEach((l) => {
      s.includes(l) || r.push(l);
    }), n.set(o, r);
  }), n;
}
function AM(t) {
  const { chartConfig: e, missingValue: i, splitByField: a, seriesTemplate: n } = t, o = JSON.parse(
    JSON.stringify({
      ...e.series[0],
      ...n
    })
  );
  if (o.query) {
    if (o.id = `${i}-${e.series.length}-${Date.now()}`, o.name = `${i}`, o.query.outStatistics?.[0] !== void 0) {
      const r = o.id;
      o.query.outStatistics[0].outStatisticFieldName = r, "y" in o && (o.y = r);
    }
    const s = typeof i == "number" || i === null ? i : `'${i}'`;
    o.query.where = `${a}=${s}`;
  }
  return o;
}
async function kf(t, e) {
  const { updateSplitBySeries: i, config: a } = t, { seriesTemplate: n } = i ?? {};
  if (i !== void 0 && a !== void 0 && (a.series.length > 0 || n !== void 0) && i.addMissingSeries) {
    const o = a.series.length === 0;
    a.series.length === 0 && n !== void 0 && a.series.push(n);
    const s = H(a.series);
    if (s === L.BoxPlotMonoFieldAndSplitBy || s === L.BoxPlotMultiFieldsAndSplitBy || s === L.BoxPlotMonoFieldAndCategoryAndSplitBy || s === L.BarAndLineSplitBy || s === L.BarAndLineSplitByNoAggregation) {
      const r = await qn({
        chartConfig: a,
        layer: t.layer,
        view: t.view
      });
      if (r !== void 0) {
        const l = Ze(a.series[0]?.query?.where), c = we(r);
        await c.load();
        const d = c.getField(l)?.toJSON(), u = cc(d), f = await vM({
          queryObject: r,
          chartConfig: a,
          splitByField: l,
          options: e
        });
        if (f.length > 0) {
          const m = FM(a, u), g = LM({
            allValues: f,
            configUniqueValuesPerSeriesType: m,
            initialConfigWasEmpty: o
          });
          Array.from(g.keys()).forEach((y) => {
            (g.get(y) ?? []).forEach((S) => {
              a.series.push(
                AM({
                  chartConfig: a,
                  seriesTemplate: n,
                  missingValue: S,
                  splitByField: l
                })
              );
            }), o && a.series.shift();
          });
        }
      }
    }
  }
}
function TM(t, e) {
  let i;
  switch (t) {
    case b.PieSeries:
      i = e?.placeholders.pieChartCreateMsg;
      break;
    case b.BarSeries:
      i = e?.placeholders.barChartCreateMsg;
      break;
    case b.BoxPlotSeries:
      i = e?.placeholders.boxPlotCreateMsg;
      break;
    case b.LineSeries:
      i = e?.placeholders.lineChartCreateMsg;
      break;
    case b.HistogramSeries:
      i = e?.placeholders.histogramCreateMsg;
      break;
    case b.ScatterSeries:
      i = e?.placeholders.scatterplotCreateMsg;
      break;
  }
  return i;
}
function wM() {
  return !0;
}
async function If(t) {
  const { layer: e } = t;
  let i;
  if (e !== void 0 && t.layerFilterChangePolicy === Ds.Refresh) {
    const a = we(e), n = yr(a);
    i = sa.watch(
      () => n.definitionExpression,
      async () => {
        await t.refresh({ updateData: !0, resetAxesBounds: !0 });
      }
    );
  }
  return i;
}
async function Of(t) {
  const { layer: e, model: i } = t, a = i && "getConfig" in i ? i.getConfig() : i;
  let n;
  if (e !== void 0 && t.layerRendererChangePolicy === Ns.Refresh) {
    const o = we(e);
    n = sa.watch(
      () => o.renderer,
      async () => {
        if (Ri(a)) {
          const s = wM();
          await t.refresh({ updateData: s });
        }
      }
    );
  }
  return n;
}
async function kM(t) {
  const { view: e, layer: i, model: a } = t, n = a && "getConfig" in a ? a.getConfig() : a;
  let o;
  if (e !== void 0 && n !== void 0) {
    const s = await qn({ chartConfig: n, view: e, layer: i });
    await sa.whenOnce(() => !s.updating);
    const r = async () => {
      e.stationary && (s.updating && await sa.whenOnce(() => !s.updating), await t.refresh({ updateData: !0, resetAxesBounds: !0, updateExtent: !0 }));
    };
    o = [], o.push(sa.when(() => e.stationary, r)), o.push(sa.when(() => !s.updating, r)), await r();
  }
  return o;
}
async function IM(t) {
  const { view: e, model: i } = t, a = i && "getConfig" in i ? i.getConfig() : i, n = z(a?.series);
  let o;
  return e !== void 0 && t.viewTimeExtentChangePolicy === Ao.Refresh && n !== b.HistogramSeries && (o = sa.watch(
    () => e.timeExtent,
    async () => {
      await t.refresh({ updateData: !0 });
    }
  )), o;
}
async function Bf(t) {
  const { layer: e } = t;
  let i;
  if (e !== void 0 && t.layerFieldsChangePolicy === Ms.Refresh) {
    const a = we(e), n = yr(a);
    i = sa.watch(
      /**
       * array objects need to be passed in as an array to watch. it's a requirement from the watch function's design.
       *       https://developers.arcgis.com/javascript/latest/api-reference/esri-core-reactiveUtils.html#watch
       */
      () => [n.fields],
      async () => {
        await t.refresh({ updateData: !0 });
      }
    );
  }
  return i;
}
async function Df(t) {
  const { view: e } = t;
  let i;
  return e !== void 0 && "selectionManager" in e && "selections" in e.selectionManager && (i = sa.watch(
    // TODO: remove the as any ->  @arcgis/core issue - https://devtopia.esri.com/WebGIS/arcgis-js-api/issues/62859#issuecomment-5394936
    () => e.selectionManager.selections,
    (a) => {
      t.syncSelectionsBetweenChartAndLayerViewPolicy === $s.Enabled && t.applySelectionFromView();
    }
  )), i;
}
const OM = ({ message: t, heading: e, options: i }) => ml`<calcite-alert .icon=${i?.icon ?? "exclamationMarkTriangle"} .open=${i?.active === !0} .autoClose=${i?.autoClose ?? !1} .autoCloseDuration=${i?.duration ?? "medium"} scale=m .kind=${i?.kind ?? "danger"} .ariaHidden=${i?.active !== !0} dir=ltr role=alertdialog label="arcgis charts notify panel">${e !== void 0 ? ml`<div slot=title>${e}</div>` : null}${t !== void 0 ? ml`<div slot=message>${t}</div>` : null}</calcite-alert>`, BM = FS`.hide{display:none}.am5-modal{width:100%;height:100%;position:absolute;z-index:100000;top:0;left:0}.am5-modal-curtain{top:0;left:0;width:100%;height:100%;position:absolute;background:#fff!important;z-index:100}.am5-modal-wrapper{top:0;left:0;width:100%;height:100%;position:absolute;display:flex;align-items:center;justify-content:center;white-space:nowrap;background:#ffffff80;z-index:101}.am5-modal-content{display:inline-block;padding:1.2em;vertical-align:middle;text-align:start;white-space:normal;background:#fff;border-radius:4px;box-shadow:#00000073 0 0 36px;color:#000}.am5-layer-1000{z-index:1000!important}.arcgis-charts-modal{box-shadow:none!important}.arcgis-charts-modal-header{background-color:#0000000d;font-weight:700;padding:4px;align-content:center}.show{display:block}.notifyPanel{flex:0 1 auto}.disable-interactions{pointer-events:none}.dim-text{color:var(--arcgis-charts-dim-text)}.chart{flex-grow:1;overflow-y:hidden}.chart>div{justify-content:center;align-items:center}.chart .arcgis-charts-modal-inside{padding:1em 1em 1em 0}.chart .arcgis-charts-modal-inside ol{padding-left:2em}.chart .arcgis-charts-modal-curtain{width:100%;height:100%;position:absolute;top:0;left:0;z-index:2001;background-color:#fff;opacity:.5;opacity:1}.chart .arcgis-charts-modal-content{background:#fffc;color:#000;display:inline-block;top:0;left:0;overflow:visible;z-index:2002;position:absolute;max-width:90%;max-height:90%;width:auto!important;height:auto!important;margin:auto!important;inset:auto!important}.chart .arcgis-charts-modal-header{display:block;width:100%;min-height:1.8em;background:#0000000d}.chart .arcgis-charts-modal-close{display:block;position:absolute;top:.3em;right:.3em;background:url(data:image/svg+xml;charset=utf-8;base64,PHN2ZyBoZWlnaHQ9IjUxMiIgdmVyc2lvbj0iMSIgdmlld0JveD0iMCAwIDUxMiA1MTIiIHdpZHRoPSI1MTIiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHBhdGggZD0iTTQ0NS4yIDEwOS4ybC00Mi40LTQyLjRMMjU2IDIxMy42IDEwOS4yIDY2LjhsLTQyLjQgNDIuNEwyMTMuNiAyNTYgNjYuOCA0MDIuOGw0Mi40IDQyLjRMMjU2IDI5OC40bDE0Ni44IDE0Ni44IDQyLjQtNDIuNEwyOTguNCAyNTYiLz48L3N2Zz4=) center center/80% no-repeat #6464641a;width:1.2em;height:1.2em;cursor:pointer}.chart .arcgis-charts-modal-title{font-weight:700;font-size:110%;padding:.5em 1.2em .5em 1em}:host{width:var(--chart-width, var(--arcgis-charts-default-width));height:var(--chart-height, var(--arcgis-charts-default-height));display:flex;flex-direction:row}`;
class DM extends Vy {
  constructor() {
    super(), this.chartRef = Hy(), this.skipNextUpdate = !1, this.commonStrings = Zd({ name: "common", blocking: !0 }), this.errorStrings = Zd({ name: "errors", blocking: !0 }), this.noRenderProps = [
      "disableInteractions",
      "rotation",
      "legendPosition",
      "legendVisibility",
      "view",
      "featureIndex",
      "filterByExtent"
    ], this.dataUpdateNeededProps = [
      "forceDataUpdate",
      "runtimeDataFilters",
      "returnFeaturesExtent",
      "chartLimits"
    ], this.updatedProps = /* @__PURE__ */ new Set(), this.handleExternalSelection = (e) => {
      const i = e, { selectionData: a, model: n } = i.detail, o = this.layer && n?.getLayer()?.id === Gd(this.layer).id;
      this.syncSelection && o && e.target !== this.el && !Di(a.selectionOIDs, this.selectionData?.selectionOIDs) && (a.selectionOIDs ? (this.selectionData = {
        selectionOIDs: a.selectionOIDs,
        selectionSource: Ue.ProgrammaticSelection
      }, this.arcgisSelectionComplete.emit({ selectionData: this.selectionData, model: this._model })) : this.clearSelection());
    }, this.configPanelNumberChange = (e) => {
      const i = e, { panelNumber: a, modelList: n } = i.detail;
      this.actionBarElement && this.enableConfiguration && this.ourModelExistsIn(n) && (this.actionBarElement.editChartToggle = a === 1 ? Yd.Active : Yd.Inactive);
    }, this.configDataChangeError = (e) => {
      const i = e, { error: a, model: n } = i.detail;
      this.enableConfiguration && n?.isSameChartAs(this._model) && this.errorAlert(a.message);
    }, this.configPopoverOpenChange = (e) => {
      const i = e;
      this.componentVersion !== "beta" && (this.disableInteractions = i.detail.open);
    }, this.modelConfigChange = async (e) => {
      const i = e;
      this.lastModelFunctionCalled = i.detail.functionCalled;
      const a = this._model?.getConfig();
      this.enableConfiguration && Fo(a) && (await this.applyPlaceholderForPartialConfig(a), this.arcgisConfigChange.emit({
        newConfig: a,
        oldConfig: this.config,
        functionCalled: i.detail.functionCalled
      })), this.config = Ee(a);
    }, this.actionBarSlotRef = (e) => {
      this.actionBarElement = e && "assignedElements" in e ? e.assignedElements().find((i) => i.tagName.toLowerCase() === "arcgis-charts-action-bar") : void 0;
    }, this.showNotifyPanel = !1, this.componentVersion = "stable", this.enableConfiguration = !1, this.syncSelection = !1, this.errorPolicy = bs.Throw, this.layerFilterChangePolicy = Ds.Refresh, this.viewTimeExtentChangePolicy = Ao.Ignore, this.layerRendererChangePolicy = Ns.Refresh, this.layerFieldsChangePolicy = Ms.Refresh, this.syncSelectionsBetweenChartAndLayerViewPolicy = $s.Disabled, this.arcgisAxesMinMaxChange = ni(), this.arcgisBadDataWarningRaise = ni(), this.arcgisConfigChange = ni(), this.arcgisDataFetchComplete = ni(), this.arcgisDataProcessComplete = ni(), this.arcgisDataProcessError = ni(), this.arcgisLegendItemVisibilityChange = ni(), this.arcgisNoRenderPropChange = ni(), this.arcgisRuntimeError = ni(), this.arcgisSelectionComplete = ni(), this.arcgisSeriesColorChange = ni(), this.arcgisSeriesOrder = ni(), this.arcgisUpdateComplete = ni(), this.listen("arcgisChartsJSDataProcessComplete", this.handleDataProcessComplete), this.listen("arcgisChartsJSDataFetchComplete", this.handleDataFetchComplete), this.listen("arcgisChartsJSLegendItemVisibilityChange", this.handleLegendItemVisibilityChanged), this.listen("arcgisChartsJSUpdateComplete", this.handleUpdateCompleted), this.listen("arcgisChartsJSBadDataWarningRaise", this.handleBadDataWarningRaise), this.listen("arcgisChartsJSSeriesColorChange", this.handleSeriesColorsChange), this.listen("arcgisChartsJSSelectionComplete", this.handleSelection), this.listen("arcgisChartsJSTooManySelectedElements", this.handleTooManySelectedElements), this.listen("calciteAlertClose", this.handleAlertClosed), this.listen("arcgisChartsJSAxesMinMaxChange", this.handleAxesMinMaxChange), this.listen("arcgisChartsJSSeriesOrder", this.handleSeriesOrder);
  }
  static {
    this.properties = { showNotifyPanel: 16, config: 16, componentVersion: 1, model: 0, enableConfiguration: 7, syncSelection: 7, rotation: 7, actionMode: 3, cursorRange: 3, legendPosition: 3, legendVisibility: 7, hideEmptySeries: 7, replaceNoValueCategoryWithZero: 7, ignoreSmoothRenderingLimit: 7, chartWillRender: 0, legendValueLabelFormatter: 0, timeZone: 3, view: 0, layer: 0, selectionData: 0, returnSelectionOIDs: 7, returnSelectionIndexes: 7, returnFeaturesExtent: 7, filterBySelection: 7, filterByExtent: 7, disableInteractions: 7, queueChartCreation: 7, useAnimatedCharts: 7, hideLicenseWatermark: 7, enableResponsiveFeatures: 7, autoDisposeChart: 7, featureIndex: 11, placeholder: 3, selectionTheme: 0, setTimeBinningInfoWhenNotProvided: 7, chartLimits: 0, tooltipFormatter: 0, dataLabelFormatter: 0, guideTooltipFormatter: 0, xAxisLabelFormatter: 0, yAxisLabelFormatter: 0, secondaryYAxisLabelFormatter: 0, gaugeInnerLabelFormatter: 0, messageOptions: 0, errorPolicy: 3, disableTogglingLegendItems: 7, hideLoaderAnimation: 7, loaderColors: 0, runtimeDataFilters: 0, usePopupTemplateFieldsInfo: 7, layerFilterChangePolicy: 3, viewTimeExtentChangePolicy: 3, layerRendererChangePolicy: 3, layerFieldsChangePolicy: 3, syncSelectionsBetweenChartAndLayerViewPolicy: 3, ignoreViewExtent: 7, updateSplitBySeries: 0 };
  }
  static {
    this.styles = BM;
  }
  get rotation() {
    return this._rotation;
  }
  set rotation(e) {
    this._rotation = e, this.rotationChange(this.rotation);
  }
  get legendPosition() {
    return this._legendPosition;
  }
  set legendPosition(e) {
    this._legendPosition = e, this.legendPositionChange(this.legendPosition);
  }
  get legendVisibility() {
    return this._legendVisibility;
  }
  set legendVisibility(e) {
    this._legendVisibility = e, this.legendVisibilityChange(this.legendVisibility);
  }
  get view() {
    return this._view;
  }
  set view(e) {
    const i = this.view;
    this._view = e, this.viewChange(this.view, i);
  }
  get filterByExtent() {
    return this._filterByExtent;
  }
  set filterByExtent(e) {
    this._filterByExtent = e, this.filterByExtentChanged(this.filterByExtent);
  }
  get disableInteractions() {
    return this._disableInteractions ?? !1;
  }
  set disableInteractions(e) {
    this._disableInteractions = e, this.disableInteractionsChange(this.disableInteractions);
  }
  get featureIndex() {
    return this._featureIndex;
  }
  set featureIndex(e) {
    const i = this.featureIndex;
    this._featureIndex = e, this.featureIndexChange(this.featureIndex, i);
  }
  async clearSelection() {
    this.chart !== void 0 && (this.chart.clearSelection(), this.filterBySelection === !0 && await this.refresh());
  }
  async errorAlert(e) {
    this.errorPolicy === bs.Throw && (this.notifyHeading = this.errorStrings?.errorHeading, this.notifyMessage = e, this.notifyOptions = {
      kind: "danger",
      autoClose: !0,
      active: !0
    }, this.actionBarElement && (this.actionBarElement.forceDisableActions = !0), this.showNotifyPanel = !0);
  }
  async exportAsImage(e = Wb.PNG) {
    const i = this.chartRef.value;
    i ? (await Ey(i, {
      useCORS: !0,
      backgroundColor: null
    })).toBlob((n) => {
      if (n) {
        const o = URL.createObjectURL(n), s = document.createElement("a");
        s.style.display = "none", s.download = `${this.model.getTitleText() ?? "chart"}.${e}`, s.setAttribute("href", o), s.click(), s.remove();
      }
    }, e) : this.errorAlert(this.errorStrings?.errors?.exportImageChartNotReady);
  }
  async exportAsCSV(e) {
    let i, a;
    if (this.chartData) {
      const n = this.layer ?? (Xi(this.config) && this.config?.iLayer !== void 0 ? await Cb(this.config.iLayer) : void 0), o = await At(n, this.usePopupTemplateFieldsInfo), s = Qd(this.model) ? this.model.getTitleText() : "chart";
      if (Object.values(this.chartData).filter((l) => Array.isArray(l) && l.length > 0).length > 1) {
        const l = new Wy();
        Object.entries(this.chartData).forEach(([d, u]) => {
          if (Array.isArray(u) && u.length > 0) {
            const f = Xd({
              rawData: u,
              config: this._model?.getConfig() ?? this.config,
              layer: n,
              fieldList: o
            }), m = Ud(f, e), g = `${s}-${d}.csv`;
            l.file(g, m);
          }
        });
        const c = await l.generateAsync({ type: "blob" });
        i = URL.createObjectURL(c), a = `${s}.zip`;
      } else {
        let l;
        if ("bins" in this.chartData ? l = this.chartData.bins : "dataItems" in this.chartData && (l = this.chartData.dataItems), l) {
          const c = Xd({
            rawData: l,
            config: this._model?.getConfig() ?? this.config,
            layer: n,
            fieldList: o
          }), d = Ud(c, e);
          i = URL.createObjectURL(new Blob([d], { type: "text/csv" })), a = `${s}.csv`;
        }
      }
      if (i !== void 0 && a !== void 0) {
        const l = document.createElement("a");
        l.style.display = "none", l.download = a, l.setAttribute("href", i), l.click(), l.remove(), URL.revokeObjectURL(i);
      }
    }
  }
  async notify(e, i, a) {
    this.chart !== void 0 && this.chart.notify(e, i, a);
  }
  async refresh(e) {
    const { updateData: i = !0, resetAxesBounds: a = !1, updateExtent: n = !1 } = e ?? {};
    this.updatedProps.add(i ? "forceDataUpdate" : "forceSimpleUpdate"), this.viewExtentUpdated = n, a && (delete this.config?.axes?.[0]?.minimum, delete this.config?.axes?.[0]?.maximum, delete this.config?.axes?.[1]?.minimum, delete this.config?.axes?.[1]?.maximum), this.hasUpdated && await this.updated(), this.viewExtentUpdated = !1;
  }
  async resetZoom() {
    this.chart !== void 0 && this.chart.resetZoom();
  }
  async switchSelection() {
    this.chart !== void 0 && this.filterBySelection !== !0 && await this.chart.switchSelection();
  }
  connectedCallback() {
    super.connectedCallback(), this.addConfigListeners(), document.addEventListener("arcgisSelectionComplete", this.handleExternalSelection);
  }
  async load() {
    if (this.syncSelectionsBetweenChartAndLayerViewPolicy === $s.Enabled) {
      const e = this.getSelectionFromLayerView();
      e && (this.selectionData = {
        selectionOIDs: e,
        selectionSource: Ue.ProgrammaticSelection
      });
    }
    this.debouncedChartUpdate = TS.promise(async () => {
      if (this.chart !== void 0) {
        const e = Array.from(this.updatedProps);
        if (e.length > 0) {
          const i = e.some((n) => this.dataUpdateNeededProps.includes(n));
          this.updatedProps.clear();
          const a = this.gatherComponentOptions(i);
          this.updateSplitBySeries?.addMissingSeries === !0 && (i || e.includes("model") || e.includes("layer") || e.includes("filterByExtent")) && await kf(this, a), this.chart && await this.chart.update({
            newChartConfig: this.config,
            updateOptions: a,
            updateGlobalOptions: {
              queueChartCreation: this.queueChartCreation,
              useAnimatedCharts: this.useAnimatedCharts,
              hideLicenseWatermark: this.hideLicenseWatermark,
              enableResponsiveFeatures: this.enableResponsiveFeatures,
              autoDisposeChart: this.autoDisposeChart
            },
            t9nStrings: {
              errorStrings: this.errorStrings,
              commonStrings: this.commonStrings
            }
          });
        }
      }
    }, zb);
  }
  shouldUpdate(e) {
    let i = !1;
    return [...e.entries()].forEach(([a, n]) => {
      this._shouldUpdate(this[a], n, a) && (i = !0);
    }), i;
  }
  _shouldUpdate(...e) {
    const [i, , a] = e;
    this.updatedProps.add(a);
    const n = this.noRenderProps.includes(a);
    n && this.arcgisNoRenderPropChange.emit({ propName: a, value: i, model: this._model });
    const o = !this.skipNextUpdate && !n;
    return this.skipNextUpdate = !1, o;
  }
  willUpdate(e) {
    e.has("model") && this.modelChange(), e.has("selectionData") && this.selectionDataChange(), e.has("layer") && this.layerChange(), e.has("runtimeDataFilters") && this.runtimeDataFiltersChange(), e.has("returnFeaturesExtent") && this.returnFeaturesExtentChange(), e.has("timeZone") && this.timeZoneChange(), e.has("filterBySelection") && this.filterBySelectionChanged(), e.has("layerFilterChangePolicy") && (this.hasUpdated || this.layerFilterChangePolicy !== Ds.Refresh) && this.layerFilterChangePolicyCallBack(this.layerFilterChangePolicy), e.has("viewTimeExtentChangePolicy") && (this.hasUpdated || this.viewTimeExtentChangePolicy !== Ao.Ignore) && this.viewTimeExtentChangePolicyCallback(this.viewTimeExtentChangePolicy), e.has("layerRendererChangePolicy") && (this.hasUpdated || this.layerRendererChangePolicy !== Ns.Refresh) && this.layerRendererChangePolicyCallBack(this.layerRendererChangePolicy), e.has("config") && this.configChange(this.config, e.get("config")), e.has("layerFieldsChangePolicy") && (this.hasUpdated || this.layerFieldsChangePolicy !== Ms.Refresh) && this.layerFieldsChangePolicyCallBack(this.layerFieldsChangePolicy);
  }
  async updated() {
    if (this.chart === void 0 && this.chartCreationProcessing !== void 0 && (await this.chartCreationProcessing, this.chartCreationProcessing = void 0), this.config !== void 0 && this.chart !== void 0 && !this.showNotifyPanel)
      try {
        wf(this.config, this.layer) && !Fo(this.config) && await this.debouncedChartUpdate?.push();
      } catch (e) {
        this.chartRef.value !== void 0 && (e.name === nn.ChartDisposed ? (this.chart.dispose(), this.chart = void 0, this.chartRef.value.innerHTML = "", await this.createChartInstance(!1)) : (e.name === nn.QueryFeaturesError ? this.arcgisDataProcessError.emit(e.details) : this.arcgisRuntimeError.emit(e.details ?? e), this.errorAlert(e?.message)));
      }
    else this.chart === void 0 && this.chartCreationProcessing === void 0 && !this.showNotifyPanel && await this.createChartInstance();
    this.placeholder !== void 0 ? await this.notify(this.placeholder) : this.enableConfiguration && Fo(this.config) && this.applyPlaceholderForPartialConfig(this.config), this.actionBarElement !== void 0 && CS(this.actionBarElement, this.el, this.config);
  }
  disconnectedCallback() {
    super.disconnectedCallback(), this.removeConfigListeners(), this.removeLayerListeners(), this.removeModelListeners(), this.removeExtentChangeListeners(), this.removeViewTimeExtentChangeListener(), document.removeEventListener(wb.SelectionComplete, this.handleExternalSelection), this.chart !== void 0 && this.chart.dispose();
  }
  applySelectionFromView() {
    const e = this.getSelectionFromLayerView();
    e && (this.selectionData = {
      selectionOIDs: e,
      selectionSource: Ue.ProgrammaticSelection
    }, this.arcgisSelectionComplete.emit({ selectionData: this.selectionData, model: this._model }));
  }
  handleDataProcessComplete(e) {
    this.chartData = e.detail, this.arcgisDataProcessComplete.emit({ chartData: e.detail, model: this._model });
  }
  handleDataFetchComplete(e) {
    this.arcgisDataFetchComplete.emit(e.detail);
  }
  handleLegendItemVisibilityChanged(e) {
    vb(e, this.config), this.arcgisLegendItemVisibilityChange.emit({ legendItemVisibility: e.detail, model: this._model });
  }
  handleUpdateCompleted(e) {
    if (this.enableConfiguration) {
      const i = e.detail, a = this.errorStrings?.notifications;
      if (this.placeholder === void 0 && (i.schemaErrors.length > 0 ? this.notify(a?.invalidConfig, void 0, {
        closable: !1
      }) : i.warnings.length > 0 && i.warnings.some((o) => o.keyword === Fb.NonNumericAggregation) && this.notify(a?.validateAggregationTypeMsg, a?.missingNumericFields, {
        closable: !1
      })), (SS(this._model) || xS(this._model)) && this._model.getAggregationType() === X.NoAggregation && this._model.getNumericFields().length === 1 && this.layer) {
        const n = Gd(this.layer).objectIdField;
        this._model.getNumericFields().includes(n) && this.notify(a?.noAggregationRequiresNumericFields, a?.missingNumericFields, {
          closable: !1
        });
      }
    }
    this.arcgisUpdateComplete.emit(e.detail);
  }
  handleBadDataWarningRaise(e) {
    this.arcgisBadDataWarningRaise.emit(e.detail);
  }
  handleSeriesColorsChange(e) {
    this.arcgisSeriesColorChange.emit({
      data: e.detail.data,
      colorMatchApplied: e.detail.colorMatchApplied,
      model: this._model
    });
  }
  handleSelection(e) {
    this.selectionData = { ...e.detail }, this.arcgisSelectionComplete.emit({ selectionData: e.detail, model: this._model });
  }
  handleTooManySelectedElements() {
    this.errorPolicy === bs.Throw && (this.notifyHeading = this.errorStrings?.tooManySelectedElements?.title, this.notifyMessage = this.errorStrings?.tooManySelectedElements?.message, this.notifyOptions = {
      kind: "warning",
      autoClose: !0,
      duration: "fast",
      active: !0
    }, this.showNotifyPanel = !0);
  }
  handleAlertClosed(e) {
    e.target === this.el && (this.skipNextUpdate = !0, this.showNotifyPanel = !1);
  }
  handleAxesMinMaxChange(e) {
    this.arcgisAxesMinMaxChange.emit({ bounds: e.detail, model: this._model });
  }
  handleSeriesOrder(e) {
    this.arcgisSeriesOrder.emit(e.detail);
  }
  modelChange() {
    if (Qd(this.model)) {
      this._model = this.model, this.config = Ee(this._model?.getConfig());
      const e = this._model?.getLayer();
      e && (this.layer = e), this.addModelListeners();
    } else
      this.config = this.model;
  }
  async selectionDataChange() {
    this.layer !== void 0 && this.syncSelectionsBetweenChartAndLayerViewPolicy === $s.Enabled && this.view !== void 0 && this.setSelectionInLayerView();
  }
  async viewChange(e, i) {
    await this.setExtentChangeListener(), await this.setViewTimeExtentChangeListener(), i !== void 0 && e === void 0 && await this.refresh(), this.view ? this.setViewSelectionsChangeListener() : this.removeViewSelectionsChangeListener();
  }
  async layerChange() {
    await this.addLayerListeners();
  }
  runtimeDataFiltersChange() {
    this.updatedProps.add("runtimeDataFilters");
  }
  returnFeaturesExtentChange() {
    this.updatedProps.add("returnFeaturesExtent");
  }
  featureIndexChange(e, i) {
    i === void 0 && typeof e == "number" && this.updatedProps.add("forceDataUpdate");
  }
  async disableInteractionsChange(e) {
    navigator.userAgent.search("Firefox") !== -1 && (e ? this.chartRef.value?.classList.add(Fa.DisableInteractions) : this.chartRef.value?.classList.remove(Fa.DisableInteractions));
  }
  rotationChange(e) {
    e !== void 0 && (this.config = Lb(e, this.config));
  }
  legendPositionChange(e) {
    e !== void 0 && (this.config = SM(e, this.config));
  }
  legendVisibilityChange(e) {
    e !== void 0 && (this.config = xM(e, this.config));
  }
  timeZoneChange() {
    this.updateConfigTimeZone();
  }
  filterBySelectionChanged() {
    this.config = CM(this.config);
  }
  layerFilterChangePolicyCallBack(e) {
    e !== Ds.Ignore ? this.setLayerFilterListener() : this.removeLayerFilterListener();
  }
  viewTimeExtentChangePolicyCallback(e) {
    e !== Ao.Refresh ? this.removeViewTimeExtentChangeListener() : this.setViewTimeExtentChangeListener();
  }
  layerRendererChangePolicyCallBack(e) {
    e !== Ns.Ignore ? this.setLayerRendererListener() : this.removeLayerRendererListener();
  }
  async filterByExtentChanged(e) {
    e || await this.refresh({
      updateData: !0,
      resetAxesBounds: !0,
      updateExtent: !0
    }), this.filterByExtent ? this.setExtentChangeListener() : this.removeExtentChangeListeners();
  }
  async configChange(e, i) {
    this.arcgisConfigChange.emit({ newConfig: e, oldConfig: i, functionCalled: this.lastModelFunctionCalled }), this.lastModelFunctionCalled = void 0, this.actionBarElement && !Fo(e) && (this.actionBarElement.forceDisableActions = !1);
  }
  layerFieldsChangePolicyCallBack(e) {
    e !== Ms.Ignore ? this.setLayerFieldsListener() : this.removeLayerFieldsListener();
  }
  addConfigListeners() {
    document.addEventListener("arcgisChartsConfigPanelNumberChange", this.configPanelNumberChange), document.addEventListener("arcgisChartsConfigDataChangeError", this.configDataChangeError), document.addEventListener("arcgisChartsConfigPopoverOpenChange", this.configPopoverOpenChange);
  }
  removeConfigListeners() {
    document.removeEventListener("arcgisChartsConfigPanelNumberChange", this.configPanelNumberChange), document.removeEventListener("arcgisChartsConfigDataChangeError", this.configDataChangeError), document.removeEventListener("arcgisChartsConfigPopoverOpenChange", this.configPopoverOpenChange);
  }
  getSelectionFromLayerView() {
    let e;
    const i = this.view;
    return i !== void 0 && "selectionManager" in i && "getSelection" in i.selectionManager && (e = i?.selectionManager?.getSelection(this.layer)), e;
  }
  setSelectionInLayerView() {
    let e;
    const i = this.selectionData?.selectionOIDs?.length === 0 || this.selectionData?.selectionOIDs === void 0 || this.selectionData?.selectionSource === Ue.ClearSelection, a = (this.selectionData?.selectionOIDs?.length ?? 0) > 0;
    i ? e = [] : a && this.selectionData && (e = this.selectionData.selectionOIDs);
    const n = this.view;
    e && n !== void 0 && "selectionManager" in n && "setSelection" in n.selectionManager && n.selectionManager.setSelection(this.layer, e);
  }
  addModelListeners() {
    this._model?.addEventListener("arcgisChartsModelConfigChange", this.modelConfigChange);
  }
  removeModelListeners() {
    this._model?.removeEventListener("arcgisChartsModelConfigChange", this.modelConfigChange);
  }
  async addLayerListeners() {
    this.removeLayerListeners(), this.layerFilterListener = await If(this), this.layerRendererListener = await Of(this), this.layerFieldsListener = await Bf(this), this.viewSelectionsChangeListener = await Df(this);
  }
  async setLayerFilterListener() {
    this.removeLayerFilterListener(), this.layerFilterListener = await If(this);
  }
  async setLayerRendererListener() {
    this.removeLayerRendererListener(), this.layerRendererListener = await Of(this);
  }
  async setLayerFieldsListener() {
    this.removeLayerFieldsListener(), this.layerFieldsListener = await Bf(this);
  }
  async setExtentChangeListener() {
    this.filterByExtent && (this.removeExtentChangeListeners(), this.extentChangeListeners = await kM(this));
  }
  async setViewTimeExtentChangeListener() {
    this.removeViewTimeExtentChangeListener(), this.viewTimeExtentChangeListener = await IM(this);
  }
  async setViewSelectionsChangeListener() {
    this.removeViewSelectionsChangeListener(), this.viewSelectionsChangeListener = await Df(this);
  }
  removeLayerListeners() {
    this.removeLayerFilterListener(), this.removeLayerRendererListener(), this.removeLayerFieldsListener();
  }
  removeLayerFilterListener() {
    this.layerFilterListener?.remove();
  }
  removeLayerRendererListener() {
    this.layerRendererListener?.remove();
  }
  removeLayerFieldsListener() {
    this.layerFieldsListener?.remove();
  }
  removeExtentChangeListeners() {
    this.extentChangeListeners !== void 0 && (this.extentChangeListeners.forEach((e) => e.remove()), this.extentChangeListeners = []);
  }
  removeViewSelectionsChangeListener() {
    this.viewSelectionsChangeListener !== void 0 && this.viewSelectionsChangeListener.remove();
  }
  removeViewTimeExtentChangeListener() {
    this.viewTimeExtentChangeListener?.remove(), this.runtimeDataFilters?.timeExtent && delete this.runtimeDataFilters.timeExtent;
  }
  async applyPlaceholderForPartialConfig(e) {
    const i = z(e?.series), a = TM(i, this.errorStrings);
    await this.notify(a);
  }
  checkForIncompatibleChartVersion() {
    const e = this.config?.version;
    this.errorPolicy === bs.Throw && Ab(e).versionStatus === Ry.Newer && (this.notifyHeading = this.errorStrings.incompatibleChartVersion?.title, this.notifyMessage = this.errorStrings.incompatibleChartVersion?.message ? Gt(this.errorStrings.incompatibleChartVersion.message, {
      chartVersion: e ?? ""
    }) : "", this.notifyOptions = {
      kind: "warning",
      autoClose: !0,
      active: !0
    }, this.showNotifyPanel = !0);
  }
  ourModelExistsIn(e) {
    return e.some((i) => this._model?.isSameChartAs(i));
  }
  updateConfigTimeZone() {
    this.config?.axes?.[0]?.valueFormat.type === b.DateAxisFormat && (this.config.axes[0].valueFormat.intlOptions.timeZone = Tb(this.timeZone));
  }
  gatherComponentOptions(e) {
    let i = this.runtimeDataFilters;
    return this.view && this.viewTimeExtentChangePolicy === Ao.Refresh && this.view.timeExtent?.start != null && this.view.timeExtent?.end != null && (i = {
      ...i,
      timeExtent: [this.view.timeExtent.start.valueOf(), this.view.timeExtent.end.valueOf()]
    }), {
      dataUpdated: e,
      layer: this.layer,
      view: this.filterByExtent ? this.view : void 0,
      createMessage: this.placeholder,
      hideLoaderAnimation: this.hideLoaderAnimation,
      loaderColors: this.loaderColors,
      runtimeDataFilters: i,
      messageOptions: this.messageOptions,
      viewExtentUpdated: this.viewExtentUpdated,
      usePopupTemplateFieldsInfo: this.usePopupTemplateFieldsInfo,
      ignoreViewExtent: this.ignoreViewExtent,
      chartLimits: this.chartLimits,
      guideTooltipFormatter: this.guideTooltipFormatter,
      xAxisLabelFormatter: this.xAxisLabelFormatter,
      yAxisLabelFormatter: this.yAxisLabelFormatter,
      secondaryYAxisLabelFormatter: this.secondaryYAxisLabelFormatter,
      tooltipFormatter: this.tooltipFormatter,
      dataLabelFormatter: this.dataLabelFormatter,
      selectionData: this.selectionData,
      filterBySelection: this.filterBySelection,
      actionMode: this.actionMode,
      cursorRange: this.cursorRange,
      selectionTheme: this.selectionTheme,
      setTimeBinningInfoWhenNotProvided: this.setTimeBinningInfoWhenNotProvided,
      returnSelectionOIDs: this.returnSelectionOIDs,
      returnSelectionIndexes: this.returnSelectionIndexes,
      returnFeaturesExtent: this.returnFeaturesExtent,
      disableTogglingLegendItems: this.disableTogglingLegendItems,
      hideEmptySeries: this.hideEmptySeries,
      replaceNoValueCategoryWithZero: this.replaceNoValueCategoryWithZero,
      gaugeInnerLabelFormatter: this.gaugeInnerLabelFormatter,
      ignoreSmoothRenderingLimit: this.ignoreSmoothRenderingLimit,
      chartWillRender: this.chartWillRender,
      pieChartLegendValueLabelFormatter: this.legendValueLabelFormatter
    };
  }
  async createChartInstance(e = !0) {
    this.chartCreationProcessing !== void 0 && (await this.chartCreationProcessing, this.chartCreationProcessing = void 0), this.updateConfigTimeZone(), this.checkForIncompatibleChartVersion(), this.updatedProps.clear();
    try {
      if (wf(this.config, this.layer)) {
        const i = this.gatherComponentOptions();
        await kf(this, i);
        const a = this.componentVersion === "beta" ? Ok : bM;
        this.chartCreationProcessing = a({
          chartContainer: this.chartRef.value,
          chartConfig: Fo(this.config) ? void 0 : this.config,
          options: i,
          globalOptions: {
            queueChartCreation: this.queueChartCreation,
            useAnimatedCharts: this.useAnimatedCharts,
            hideLicenseWatermark: this.hideLicenseWatermark,
            enableResponsiveFeatures: this.enableResponsiveFeatures,
            autoDisposeChart: this.autoDisposeChart
          },
          t9nStrings: {
            errorStrings: this.errorStrings,
            commonStrings: this.commonStrings
          }
        }), this.chart = await this.chartCreationProcessing, this.chartCreationProcessing = void 0, e && (await this.addLayerListeners(), await this.setExtentChangeListener(), await this.setViewTimeExtentChangeListener());
      }
    } catch (i) {
      i.name === nn.QueryFeaturesError ? this.arcgisDataProcessError.emit(i.details) : this.arcgisRuntimeError.emit(i.details ?? i), this.errorAlert(i?.message), this.chart?.dispose(), this.chartCreationProcessing = void 0, this.chart = void 0;
    }
  }
  render() {
    const e = this.showNotifyPanel ? OM({ heading: this.notifyHeading, message: this.notifyMessage, options: this.notifyOptions }) : null, i = this.showNotifyPanel && this.notifyOptions?.kind === "danger" ? Fa.Hide : `${Fa.Chart} ${Fa.Show}`, a = this.showNotifyPanel ? `${Fa.Show} ${Fa.NotifyPanel}` : Fa.Hide;
    return zy`<slot name=${bS.actionBar} @slotchange=${(n) => {
      this.actionBarElement = vS(n, this.el, this.config);
    }} ${Ed(this.actionBarSlotRef)}></slot><div class=${Vd(i)} ${Ed(this.chartRef)}></div><div class=${Vd(a)}>${e}</div>`;
  }
}
Py("arcgis-chart", DM);
export {
  DM as ArcgisChart
};
