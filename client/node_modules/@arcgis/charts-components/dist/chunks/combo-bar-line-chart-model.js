import { WebChartTypes as a } from "@arcgis/charts-spec";
import "lodash-es";
import "d3-array";
import { ay as g, ar as l, ao as f } from "./interfaces.js";
import "@arcgis/core/geometry/support/jsonUtils.js";
import "@arcgis/core/rest/support/AttributeBinsQuery.js";
import "@arcgis/core/rest/support/Query.js";
import "@arcgis/core/rest/support/StatisticDefinition.js";
import "@arcgis/core/time/TimeExtent.js";
import "@arcgis/core/core/promiseUtils.js";
import "@arcgis/core/request.js";
import { n as S, j as r, l as n } from "./index4.js";
import { g as h, s as d, a as m, b } from "./bar-chart-series.js";
import { g as y, a as _, e as C, b as p, f as L, s as k, h as u, c as v, i as M, d as B, j as z, k as V, l as U, m as c, n as O, o as A, p as D, q as F, r as j } from "./baseline-stacking.js";
import { S as H, s as w } from "./serial-chart-model.js";
/*! All material copyright Esri, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.33/esri/copyright.txt for details.
v4.33.19 */
class x extends H {
  constructor() {
    super(...arguments), this._chartType = a.ComboLineAndBarSeries;
  }
  getConfig() {
    return this._config;
  }
  async setup(e) {
    await this.loadConfigFromLayer(e), e.config !== void 0 && (S(e.config?.series) && await this.initDefaultSeries(), await this.updateSeriesFromLayerFilter()), this.resolveSetup();
  }
  // ---------------------------------------------------------------------------------------------
  // Protected Methods
  // ---------------------------------------------------------------------------------------------
  async generateDefaultConfig() {
    const e = await g();
    return e.series = [
      await l({
        objectIDField: this.layerInfo?.objectIdField
      })
    ], e;
  }
  /**
   * Initializes the default series for the combo bar-line chart. Used in resetting the series styling.
   * @category Private
   */
  async initDefaultSeries() {
    this.defaultSeries = await f({
      objectIDField: this.layerInfo?.objectIdField
    });
  }
  // ---------------------------------------------------------------------------------------------
  // Series Methods
  // ---------------------------------------------------------------------------------------------
  // Then we need a function like setSeriesType(seriesIndex, seriesType) to change a series from bar to line and vice-versa
  async setSeriesType(e, i) {
    if (e < this._config.series.length && e >= 0) {
      const t = this._config.series[e];
      let o;
      if (i === a.BarSeries && r(t)) {
        const s = { ...t };
        delete s.lineSymbol, delete s.markerSymbol, delete s.lineSmoothed, delete s.markerVisible, delete s.areaColor, delete s.stackNegativeValuesToBaseline, o = {
          ...await l({
            objectIDField: this.layerInfo?.objectIdField
          }),
          ...s,
          type: a.BarSeries,
          y: [t.y].flat()[0]
        }, o.fillSymbol && (o.fillSymbol = {
          ...o.fillSymbol,
          color: t.lineSymbol?.color
        });
      } else if (i === a.LineSeries && n(t)) {
        const s = { ...t };
        delete s.fillSymbol, delete s.hideOversizedStackedLabels, delete s.hideOversizedSideBySideLabels, o = {
          ...await f({
            objectIDField: this.layerInfo?.objectIdField
          }),
          ...s,
          type: a.LineSeries
        }, o.lineSymbol && (o.lineSymbol = {
          ...o.lineSymbol,
          color: t.fillSymbol?.color
        });
      }
      o !== void 0 && (this._config.series[e] = o, this.emitConfigUpdate("setDataType"));
    }
  }
  /**
   * Gets the line style of the series based on the series index. If the index is out of bounds, it will return `undefined`.
   * @param {number} seriesIndex The index of the series.
   * @returns {RESTSimpleLineSymbolStyle | undefined}
   */
  getSeriesLineStyle(e) {
    return y(e, this._config);
  }
  /**
   * Sets the line style of the series based on the series index.
   * @param {RESTSimpleLineSymbolStyle | undefined} newStyle The new style for the series.
   * @param {number} seriesIndex The index of the series.
   *
   * **NOTE:** This method will only work if the series is a line chart series.
   */
  setSeriesLineStyle(e, i) {
    const t = this._config.series?.[i];
    r(t) && (_(e, i, this._config), this.emitConfigUpdate("setSeriesLineStyle"));
  }
  /**
   * Gets the line width of the series based on the series index. If the index is out of bounds, it will return `undefined`.
   * @param {number} seriesIndex The index of the series.
   * @returns {number | undefined}
   */
  getSeriesLineWidth(e) {
    return C(e, this._config);
  }
  /**
   * Sets the line width of the series based on the series index.
   * @param {number | undefined} newWidth The new width for the series.
   * @param {number} seriesIndex The index of the series.
   *
   * **NOTE:** This method will only work if the series is a line chart series.
   */
  setSeriesLineWidth(e, i) {
    const t = this._config.series?.[i];
    r(t) && (p(e, i, this._config), this.emitConfigUpdate("setSeriesLineWidth"));
  }
  /**
   * Gets the marker color of the series based on the series index. If the index is out of bounds, it will return `undefined`.
   * @param {number} seriesIndex The index of the series.
   * @returns {Color | undefined}
   */
  getSeriesMarkerColor(e) {
    return L(e, this._config);
  }
  /**
   * Sets the marker color of the series based on the series index.
   * @param {Color | undefined} newColor The new color for the series.
   * @param {number} seriesIndex The index of the series.
   *
   * **NOTE:** This method will only work if the series is a line chart series.
   */
  setSeriesMarkerColor(e, i) {
    const t = this._config.series?.[i];
    r(t) && (k(e, i, this._config), this.emitConfigUpdate("setSeriesMarkerColor"));
  }
  /**
   * Gets the marker style of the series based on the series index. If the index is out of bounds, it will return `undefined`.
   * @param {number} seriesIndex The index of the series.
   * @returns {RESTSimpleMarkerSymbolStyle | undefined}
   */
  getSeriesMarkerStyle(e) {
    return u(e, this._config);
  }
  /**
   * Sets the marker style of the series based on the series index.
   * @param {RESTSimpleMarkerSymbolStyle | undefined} newStyle The new style for the series.
   * @param {number} seriesIndex The index of the series.
   *
   * **NOTE:** This method will only work if the series is a line chart series.
   */
  setSeriesMarkerStyle(e, i) {
    const t = this._config.series?.[i];
    r(t) && (v(e, i, this._config), this.emitConfigUpdate("setSeriesMarkerStyle"));
  }
  /**
   * Gets the marker size of the series based on the series index. If the index is out of bounds, it will return `undefined`.
   * @param {number} seriesIndex The index of the series.
   * @returns {number | undefined}
   */
  getSeriesMarkerSize(e) {
    return M(e, this._config);
  }
  /**
   * Sets the marker size of the series based on the series index.
   * @param {number | undefined} newSize The new size for the series.
   * @param {number} seriesIndex The index of the series.
   *
   * **NOTE:** This method will only work if the series is a line chart series.
   */
  setSeriesMarkerSize(e, i) {
    const t = this._config.series?.[i];
    r(t) && (B(e, i, this._config), this.emitConfigUpdate("setSeriesMarkerSize"));
  }
  /**
   * Specify whether line segments of the series should be smoothed.
   * @param {number} seriesIndex - The index of the series.
   *
   * @default false
   * @returns {boolean}
   */
  isLineSmoothed(e) {
    return z(e, this._config);
  }
  /**
   * Specify whether line segments of the series should be smoothed.
   * @param {boolean} props.smoothed - `true` if line segment of the series should be smoothed, `false` otherwise.
   * @param {number} props.seriesIndex - The index of the series.
   *
   * **NOTE:** This method will only work if the series is a line chart series.
   * @default false
   */
  setLineSmoothed(e, i) {
    const t = this._config.series?.[i];
    r(t) && (V({
      smoothed: e,
      seriesIndex: i,
      config: this._config
    }), this.emitConfigUpdate("setLineSmoothed"));
  }
  /**
   * Specify whether the line series should show area.
   * @param {number} seriesIndex - The index of the series.
   *
   * @default false
   * @returns {boolean}
   */
  isAreaVisible(e) {
    return U(e, this._config);
  }
  /**
   * Specify whether the line series should show area.
   * @param {boolean} props.visible - `true` if the line series should show area, `false` otherwise.
   * @param {number} props.seriesIndex - The index of the series.
   *
   * **NOTE:** This method will only work if the series is a line chart series.
   */
  setAreaVisible(e, i) {
    const t = this._config.series?.[i];
    r(t) && (c({
      visible: e,
      seriesIndex: i,
      config: this._config
    }), this.emitConfigUpdate("setAreaVisible"));
  }
  /**
   * Indicate whether to show or hide the markers/bullets of the line series.
   * @param {number} seriesIndex - The index of the series.
   *
   * @default true
   * @returns {boolean}
   */
  isMarkerVisible(e) {
    return O(e, this._config);
  }
  /**
   * Indicate whether to show or hide the markers/bullets of the line series.
   * @param {boolean} props.visible - `true` if the markers/bullets of the line series should be shown, `false` otherwise.
   * @param {number} props.seriesIndex - The index of the series.
   *
   * **NOTE:** This method will only work if the series is a line chart series.
   */
  setMarkerVisible(e, i) {
    const t = this._config.series?.[i];
    r(t) && (A({
      visible: e,
      seriesIndex: i,
      config: this._config
    }), this.emitConfigUpdate("setMarkerVisible"));
  }
  /**
   * Specify the color of the filled area for line chart.
   * @param {number} seriesIndex - The index of the series.
   *
   * NOTE: areaColor will be applied only if `showArea` is true, and is defaulted to the line color if not provided.
   *
   * @returns {Color | undefined}
   */
  getAreaColor(e) {
    return D(e, this._config);
  }
  /**
   * Specify the color of the filled area for line chart.
   * @param {Color | undefined} props.color - The color of the filled area for line chart.
   * @param {number} props.seriesIndex - The index of the series.
   *
   * **NOTE:** This method will only work if the series is a line chart series.
   */
  setAreaColor(e, i) {
    const t = this._config.series?.[i];
    r(t) && (c({
      visible: !0,
      seriesIndex: i,
      config: this._config
    }), w(e, i, this._config), this.emitConfigUpdate("setAreaColor"));
  }
  /**
   * Specify how negative values are treated in stacked series.
   * @param {number} seriesIndex - The index of the series.
   *
   * NOTE: If true, negative values will be stacked on the base line.
   * If false, negative values will be stacked in relation to their previous values in the stack.
   *
   * @default true
   * @returns {boolean}
   */
  isNegativeValuesStackedToBaseline(e) {
    return F(e, this._config);
  }
  /**
   * Specify how negative values are treated in stacked series.
   * @param {boolean} props.stackedToBaseline - `true` if negative values should be stacked on the base line, `false` otherwise.
   * @param {number} props.seriesIndex - The index of the series.
   *
   * NOTE: If true, negative values will be stacked on the base line.
   * If false, negative values will be stacked in relation to their previous values in the stack.
   *
   * **NOTE:** This method will only work if the series is a line chart series.
   */
  setNegativeValuesStackedToBaseline(e, i) {
    const t = this._config.series?.[i];
    r(t) && (j({
      stackNegativeValuesToBaseline: e,
      seriesIndex: i,
      config: this._config
    }), this.emitConfigUpdate("setNegativeValuesStackedToBaseline"));
  }
  /**
   * Gets whether to hide oversized data labels of the side-by-side series based on the series index. If the index is out of bounds, it will return `undefined`.
   * @param {number} seriesIndex The index of the series.
   * @returns {boolean | undefined}
   */
  getSeriesHideOversizedSideBySideLabels(e) {
    return h(e, this._config);
  }
  /**
   * Sets whether to hide oversized data labels of the side-by-side series based on the series index.
   * @param {boolean} hide The value for hiding oversized labels.
   * @param {number} seriesIndex The index of the series.
   *
   * **NOTE:** This method will only work if the series is a bar chart series.
   */
  setSeriesHideOversizedSideBySideLabels(e, i) {
    const t = this._config.series?.[i];
    n(t) && (d(e, i, this._config), this.emitConfigUpdate("setSeriesHideOversizedSideBySideLabels"));
  }
  /**
   * Gets whether to hide oversized data labels of the stacked series based on the series index. If the index is out of bounds, it will return `undefined`.
   * @param {number} seriesIndex The index of the series.
   * @returns {boolean | undefined}
   */
  getSeriesHideOversizedStackedLabels(e) {
    return m(e, this._config);
  }
  /**
   * Sets whether to hide oversized data labels of the stacked series based on the series index.
   * @param {boolean} hide The value for hiding oversized stacked labels.
   * @param {number} seriesIndex The index of the series.
   *
   * **NOTE:** This method will only work if the series is a bar chart series.
   */
  setSeriesHideOversizedStackedLabels(e, i) {
    const t = this._config.series?.[i];
    n(t) && (b(e, i, this._config), this.emitConfigUpdate("setSeriesHideOversizedStackedLabels"));
  }
}
export {
  x as ComboBarLineChartModel
};
