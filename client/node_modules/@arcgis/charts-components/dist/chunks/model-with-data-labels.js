import { C as a } from "./model-with-y-guides.js";
import { WebChartLegendPositions as r } from "@arcgis/charts-spec";
import { cloneDeep as L } from "lodash-es";
import "d3-array";
import { aa as o, a2 as l, aV as s, a0 as n } from "./interfaces.js";
import "@arcgis/core/geometry/support/jsonUtils.js";
import "@arcgis/core/rest/support/AttributeBinsQuery.js";
import "@arcgis/core/rest/support/Query.js";
import "@arcgis/core/rest/support/StatisticDefinition.js";
import "@arcgis/core/time/TimeExtent.js";
import "@arcgis/core/core/promiseUtils.js";
import "@arcgis/core/request.js";
/*! All material copyright Esri, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.33/esri/copyright.txt for details.
v4.33.19 */
const b = (t) => t.colorMatch ?? !0, h = (t, e) => {
  e.colorMatch = t;
};
class X extends a {
  /**
   * Gets whether the chart should attempt to match the data source's colors.
   *
   * `true`: Attempt to match the data source's colors.
   *
   * `false`: Use the colors defined in the config.
   *
   * @returns {boolean}
   */
  getColorMatch() {
    return b(this._config);
  }
  /**
   * Sets whether the chart should attempt to match the data source's colors.
   *
   * `true`: Attempt to match the data source's colors.
   *
   * `false`: Use the colors defined in the config.
   *
   * @param {boolean} newColorMatch
   */
  setColorMatch(e) {
    h(e, this._config), this.emitConfigUpdate("setColorMatch");
  }
}
const f = (t) => {
  let e = !1;
  return t.legend !== void 0 && (e = t.legend.visible ?? !0), e;
}, p = (t, e) => {
  e.legend === void 0 && (e.legend = o()), e.legend.visible = t;
}, c = (t) => t.legend?.title?.content, T = (t, e) => {
  e.legend === void 0 && (e.legend = o()), (e.legend.title === void 0 || t === void 0) && (e.legend.title = l({
    text: "",
    visible: !0,
    font: n(s.LegendTitle),
    type: s.LegendTitle
  })), t !== void 0 && (e.legend.title.content = t);
}, m = (t) => t.legend?.body, v = (t, e) => {
  e.legend === void 0 && (e.legend = o()), e.legend.body = t ?? l({
    text: "",
    visible: !0,
    font: n(s.LegendText),
    type: s.LegendText
  }).content;
}, g = (t) => t.legend?.title?.content.text ?? "", y = (t, e) => {
  if (e.legend?.title !== void 0)
    e.legend.title.content.text = t;
  else if (e.legend === void 0 && t !== void 0) {
    const i = o();
    i.title !== void 0 && (i.title.content.text = t, i.title.visible = !0, e.legend = i);
  }
}, u = (t) => t.legend?.title?.visible ?? !1, x = (t, e) => {
  if (e.legend?.title !== void 0)
    e.legend.title.visible = t;
  else if (e.legend !== void 0 && e.legend?.title === void 0 && t)
    e.legend.title = l({
      text: g(e),
      visible: t,
      font: n(s.LegendTitle),
      type: s.LegendTitle
    });
  else if (e.legend === void 0) {
    const i = o();
    i.title = l({
      text: g(e),
      visible: t,
      font: n(s.LegendTitle),
      type: s.LegendTitle
    }), e.legend = i;
  }
}, C = (t) => t.legend?.position ?? r.Right, D = (t, e) => {
  if (e.legend !== void 0)
    e.legend.position = t;
  else if (e.legend === void 0) {
    const i = o();
    i.position = t, e.legend = i;
  }
}, M = (t) => t.legend?.roundMarkers ?? !1, _ = (t, e) => {
  e.legend === void 0 && (e.legend = o()), e.legend.roundMarkers = t;
}, V = (t) => t.legend?.maxHeight ?? void 0, R = (t, e) => {
  e.legend === void 0 && (e.legend = o()), e.legend.maxHeight = t;
};
class Y extends a {
  // ---------------------------------------------------------------------------------------------
  // Data Props
  // ---------------------------------------------------------------------------------------------
  /**
   * Gets whether the legend title is visible.
   *
   * `true`: Legend title is visible.
   *
   * `false`: Legend title is hidden.
   *
   * @returns {boolean}
   */
  getLegendVisibility() {
    return f(this._config);
  }
  /**
   * Sets whether the legend title is visible.
   *
   * `true`: Show legend title.
   *
   * `false`: Hide legend title.
   *
   * @param {boolean} legendVisibility
   */
  setLegendVisibility(e) {
    p(e, this._config), this.emitConfigUpdate("setLegendVisibility");
  }
  // ---------------------------------------------------------------------------------------------
  // General Props
  // ---------------------------------------------------------------------------------------------
  /**
   * Gets the legend title text.
   * @returns {string}
   */
  getLegendTitleText() {
    return g(this._config);
  }
  /**
   * Sets the legend title text.
   * @param {string} legendTitleText
   */
  setLegendTitleText(e) {
    y(e, this._config), this.emitConfigUpdate("setLegendTitleText");
  }
  /**
   * Gets whether the legend title is visible.
   *
   * `true`: Legend title is visible.
   *
   * `false`: Legend title is hidden.
   *
   * @returns {boolean}
   */
  getLegendTitleVisibility() {
    return u(this._config);
  }
  /**
   * Sets whether the legend title is visible.
   *
   * `true`: Show legend title.
   *
   * `false`: Hide legend title.
   *
   * @param {boolean} showLegendTitle
   */
  setLegendTitleVisibility(e) {
    x(e, this._config), this.emitConfigUpdate("setLegendTitleVisibility");
  }
  /**
   * Gets the legend position: top, bottom, left, or right.
   * @returns {WebChartLegendPositions}
   */
  getLegendPosition() {
    return C(this._config);
  }
  /**
   * Sets the legend position; where the chart legend should be displayed, top, bottom, left, or right.
   * @param {WebChartLegendPositions} legendPosition
   */
  setLegendPosition(e) {
    D(e, this._config), this.emitConfigUpdate("setLegendPosition");
  }
  // ---------------------------------------------------------------------------------------------
  // Format Props
  // ---------------------------------------------------------------------------------------------
  /**
   * Gets the legend title symbol. Contains styling information such as font, color, and symbol style.
   * @returns {WebChartTextSymbol | undefined}
   */
  getLegendTitleSymbol() {
    return c(this._config);
  }
  /**
   * Sets the legend title symbol. Contains styling information such as font, color, and symbol style.
   * @param {WebChartTextSymbol | undefined} legendTitle
   */
  setLegendTitleSymbol(e) {
    T(e, this._config), this.emitConfigUpdate("setLegendTitleSymbol");
  }
  /**
   * Gets the legend text symbol. Contains styling information such as font, color, and symbol style.
   * @returns {WebChartTextSymbol | undefined}
   */
  getLegendTextSymbol() {
    return m(this._config);
  }
  /**
   * Sets the legend text symbol. Contains styling information such as font, color, and symbol style.
   * @param {WebChartTextSymbol | undefined} legendText
   */
  setLegendTextSymbol(e) {
    v(e, this._config), this.emitConfigUpdate("setLegendTextSymbol");
  }
  /**
   * Gets the maximum height of the legend.
   * @returns {number | undefined}
   */
  getLegendMaxHeight() {
    return V(this._config);
  }
  /**
   * Sets the maximum height of the legend. If not set, the legend will occupy the same height as the series container or pie chart.
   * @param maxHeight - the maximum height for the legend
   */
  setLegendMaxHeight(e) {
    R(e, this._config), this.emitConfigUpdate("setLegendMaxHeight");
  }
  /**
   * Gets the indicator for whether the legend markers should be rounded.
   * @returns {boolean}
   */
  getLegendRoundMarker() {
    return M(this._config);
  }
  /**
   * Sets the indicator for whether the legend markers should be rounded.
   * @param roundMarker - the round marker indicator
   */
  setLegendRoundMarker(e) {
    _(e, this._config), this.emitConfigUpdate("setLegendRoundMarker");
  }
}
const U = (t, e) => t.series?.[e ?? 0]?.dataTooltipVisible ?? !0, S = (t, e, i) => {
  i && t.series?.[i] ? t.series[i].dataTooltipVisible = e : t.series && t.series.forEach((d) => {
    d.dataTooltipVisible = e;
  });
}, k = (t, e) => t.series?.[e ?? 0]?.dataTooltipReverseColor ?? !1, H = (t, e, i) => {
  i && t.series?.[i] ? t.series[i].dataTooltipReverseColor = e : t.series && t.series.forEach((d) => {
    d.dataTooltipReverseColor = e;
  });
};
class Z extends a {
  /**
   * Gets the visibility of the data tooltips.
   * @param seriesIndex The index of the series.
   * @returns {boolean}
   * @remarks
   * a. If the seriesIndex is provided, the visibility for that series will be returned. Otherwise, the visibility of the first series will be returned.
   * b. If the visibility is not set on the series, the default value of `true` will be returned.
   */
  getDataTooltipVisibility(e) {
    return U(this._config, e);
  }
  /**
   * Sets the visibility of the data tooltips.
   * @param visibility The visibility of the data tooltips.
   * @param seriesIndex The index of the series to set the visibility.
   * @remarks If the seriesIndex is provided, the visibility will be set for that series only. Otherwise, the visibility will be set for all series.
   */
  setDataTooltipVisibility(e, i) {
    S(this._config, e, i), this.emitConfigUpdate("setDataTooltipVisibility");
  }
  /**
   * Gets the setting of the `dataTooltipReverseColor` property.
   * @param seriesIndex The index of the series.
   * @returns {boolean}
   * @remarks
   * a. If the seriesIndex is provided, the dataTooltipReverseColor for that series will be returned. Otherwise, the same property of the first series will be returned.
   * b. If the dataTooltipReverseColor is not set on the series, the default value of `false` will be returned.
   */
  getDataTooltipReverseColor(e) {
    return k(this._config, e);
  }
  /**
   * Sets the setting of the `dataTooltipReverseColor` property.
   * @param reverseColor Indicator of whether to reverse the color.
   * @param seriesIndex The index of the series to set the reverse color.
   * @remarks If the seriesIndex is provided, the reverse color will be set for that series only. Otherwise, the reverse color will be set for all series.
   */
  setDataTooltipReverseColor(e, i) {
    H(this._config, e, i), this.emitConfigUpdate("setDataTooltipVisibility");
  }
}
const P = (t) => t.series[0]?.dataLabels?.visible ?? !1, W = (t, e) => {
  e.series.forEach((i) => {
    i.dataLabels !== void 0 ? i.dataLabels.visible = t : i.dataLabels = l({
      text: "",
      visible: t,
      font: n(s.DataLabels),
      type: s.DataLabels
    });
  });
}, E = (t) => {
  for (const e of t.series)
    if (e.dataLabels !== void 0)
      return e.dataLabels.content;
}, F = (t, e) => {
  for (const i of e.series)
    (i.dataLabels === void 0 || t === void 0) && (i.dataLabels = l({
      text: "",
      visible: !0,
      font: n(s.DataLabels),
      type: s.DataLabels
    })), t !== void 0 && (i.dataLabels.content = L(t));
};
class $ extends a {
  // ---------------------------------------------------------------------------------------------
  // Data Props
  // ---------------------------------------------------------------------------------------------
  /**
   * Gets whether the data labels are visible.
   *
   * `true`: Data labels are visible.
   *
   * `false`: Data labels are hidden.
   *
   * @returns {boolean}
   */
  getDataLabelsVisibility() {
    return P(this._config);
  }
  /**
   * Sets the visibility of the data labels.
   *
   * `true`: Show data labels.
   *
   * `false`: Hide data labels.
   *
   * @param {boolean} newDataLabelsVisibility
   */
  setDataLabelsVisibility(e) {
    W(e, this._config), this.emitConfigUpdate("setDataLabelsVisibility");
  }
  // ---------------------------------------------------------------------------------------------
  // Format Props
  // ---------------------------------------------------------------------------------------------
  /**
   * Gets the data labels text symbol. Contains styling information such as font, color, and symbol style.
   * @returns {WebChartTextSymbol | undefined}
   */
  getDataLabelsSymbol() {
    return E(this._config);
  }
  /**
   * Sets the data labels text symbol. Contains styling information such as font, color, and symbol style.
   * @param {WebChartTextSymbol | undefined} newDataLabelsSymbol
   */
  setDataLabelsSymbol(e) {
    F(e, this._config), this.emitConfigUpdate("setDataLabelsSymbol");
  }
}
export {
  Y as M,
  Z as a,
  X as b,
  $ as c
};
