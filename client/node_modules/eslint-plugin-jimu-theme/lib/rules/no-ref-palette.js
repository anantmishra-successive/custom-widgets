'use strict'
const { DocURL, getMatchNodeIdentifiers, DefaultThemeAliases, NewThemeColors, ThemeNeutralPaletteShades } = require('../utils')

const regex1 = /var\(--\bref-\bpalette-\b(primary|secondary|neutral|error|warning|info|success)-\b(100|200|300|400|500|600|700|800|900|1000|1100|1200|1300)\)/g
const regex2 = /var\(--\bref-\bpalette-\b(black|white)\)/g

function reportLiteral(context, node, match, isTemplateLiteral) {
  const colorName = match[1]
  const colorShade = match[2]
  if (!colorName && !colorShade) return

  const reports = {
    node: node,
    messageId: 'message'
  }
  if (isTemplateLiteral) {
    const start = node.range[0] + match.index + 1
    const end = start + match[0].length
    reports.loc = {
      start: context.sourceCode.getLocFromIndex(start),
      end: context.sourceCode.getLocFromIndex(end),
    }
  }
  context.report(reports)
}

/** @type {import('eslint').Rule.RuleModule} */
module.exports = {
  meta: {
    type: 'suggestion',
    docs: {
      description: 'This rule is used to check whether a theme ref palette variable is being used.',
      recommended: false,
      url: `${DocURL}no-ref-palette.md`,
    },
    fixable: 'code',
    messages: {
      message: 'Theme `ref.palette` variables should not be used, please use the `sys.color` variable instead.',
    },
    schema: [
      {
        type: 'object',
        properties: {
          themeAliases: {
            type: 'array',
            items: {
              type: 'string',
            },
            default: DefaultThemeAliases,
            description: 'The plug-in determines whether a variable is a theme variable based on the "theme" keyword. If you use another name, define it through this property.'
          },
          allowBlackAndWhite: {
            type: 'boolean',
            default: true,
            description: 'Whether to allow black and white of palette to be used. Default is true.',
          }
        },
        additionalProperties: false,
      },
    ],
  },
  create(context) {
    const option = context.options[0] || {}

    const themeAliases = option.themeAliases || DefaultThemeAliases
    const allowBlackAndWhite = option.allowBlackAndWhite ?? true
    return {
      MemberExpression(node) {
        const variables = context.sourceCode.getScope(node).variables
        if ((getMatchNodeIdentifiers(node, { value: [themeAliases, 'ref', 'palette', NewThemeColors, ThemeNeutralPaletteShades], stop: themeAliases }, { value: variables, level: 2 }, true))) {
          context.report({
            node: node,
            messageId: 'message',
          })
        } else if ((getMatchNodeIdentifiers(node, { value: [themeAliases, 'ref', 'palette', ['black', 'white']], stop: themeAliases }, { value: variables, level: 2 }, true))) {
          if (!allowBlackAndWhite) {
            context.report({
              node: node,
              messageId: 'message',
            })
          }
        }
      },
      Literal(node) {
        if (typeof node.value === 'string') {
          const text = node.value
          let match
          while ((match = regex1.exec(text)) !== null) {
            reportLiteral(context, node, match, false)
          }
          while ((match = regex2.exec(text)) !== null) {
            if (!allowBlackAndWhite) {
              reportLiteral(context, node, match, false)
            }
          }
        }
      },
      TemplateLiteral(node) {
        node.quasis.forEach((quasi) => {
          if (quasi.value && typeof quasi.value.raw === 'string') {
            const text = quasi.value.raw
            let match
            while ((match = regex1.exec(text)) !== null) {
              reportLiteral(context, node, match, true)
            }
            while ((match = regex2.exec(text)) !== null) {
              if (!allowBlackAndWhite) {
                reportLiteral(context, node, match, true)
              }
            }
          }
        })
      }
    }
  }
}
