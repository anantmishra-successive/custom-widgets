import { proxyExports as v, getControllersCount as w, trackPropKey as y } from "@arcgis/lumina/controllers";
import { AccessorController as b, getAccessorControllerBoundProperties as E, makeBinderProxy as x } from "@arcgis/lumina/controllers/accessor";
import { isEsriInternalEnv as M } from "@arcgis/components-utils";
import { V as g } from "./useView.js";
import { watch as m } from "@arcgis/core/core/reactiveUtils.js";
/*! All material copyright Esri, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.33/esri/copyright.txt for details.
v4.33.19 */
const I = (d, e) => (t) => P(t, d);
class f extends b {
  #o = /* @__PURE__ */ new Map();
  #e;
  #t;
  constructor(e, t) {
    super(e, t), new g(e);
    const s = this, o = s.instance;
    let n = o.viewModel, l = o.visibleElements;
    const r = new Proxy(this.exports, {
      get(i, a, h) {
        return a === "viewModel" ? n : a === "visibleElements" ? l : Reflect.get(i, a, h);
      }
    });
    if (s.#t = o, s.instance = r, s.exports = r, n) {
      const i = {
        component: e,
        get exports() {
          return s.instance.viewModel;
        }
      };
      E(s).set("viewModel", "viewModel"), e.addController(i), n = x(e, new WeakRef(i), w(e) - 1, n, s.#o);
    }
    s.instance.visibleElements && (l = s.#s(o));
  }
  hostConnected() {
    this.instance = this.#t, super.hostConnected();
  }
  hostLoad() {
    this.#e = m(() => this.component.el.view, (e) => {
      const t = this.instance;
      !("view" in t) && typeof t.viewModel == "object" ? t.viewModel.view = e : t.view = e, !("map" in t) && typeof t.viewModel == "object" ? t.viewModel.map = e?.map : t.map = e?.map;
    }, { sync: !0, initial: !0 });
  }
  hostUpdate(e) {
    e.has("closed") && (this.instance.visible = !this.component.closed);
  }
  hostLoaded() {
    const { el: e } = this.component;
    e.childElem ??= document.createElement("div"), this.instance.container = e.childElem, this.component.closed !== void 0 && this.onLifecycle(() => m(() => this.instance.visible, (t) => this.component.closed = !t, { initial: !0 }));
  }
  #s(e) {
    return new Proxy(e.visibleElements, {
      get: (t, s) => {
        if (typeof s == "symbol" || s in Promise.prototype)
          return t[s];
        const o = [s], n = this.#i(o);
        return y(this.component, (l) => {
          const r = l;
          this.component[r] = !1;
          let i = e.visibleElements ?? {}, a;
          for (const c of o.slice(0, -1))
            if (typeof i[c] == "object" && i[c] !== null)
              i = i[c];
            else {
              a = !!i[c];
              break;
            }
          a === void 0 && (a = !!(i[o.slice(-1)[0]] ?? !0));
          const p = r.startsWith("hide") || r.startsWith("show") ? r.startsWith("hide") : a;
          this.onUpdate((c) => {
            if (c.has(r)) {
              const u = this.component[r];
              this.#n(o, u, p);
            }
          });
        }, n);
      }
    });
  }
  #i(e) {
    const t = new Proxy({}, {
      get: (s, o) => {
        const n = Reflect.get(s, o);
        return typeof o == "symbol" || o in Promise.prototype ? n : (e.push(o), t);
      }
    });
    return t;
  }
  #n(e, t, s) {
    let o = this.instance.visibleElements ?? {};
    for (const l of e.slice(0, -1))
      (typeof o[l] != "object" || o[l] === null) && (o[l] = {}), o = o[l];
    const n = !!(s ? !t : t);
    o[e.at(-1)] = n;
  }
  hostDestroy() {
    this.#e?.remove(), super.hostDestroy();
  }
}
process.env.NODE_ENV !== "production" && M() && (f.devOnly$allowedPropNameMismatches = /* @__PURE__ */ new Set([
  "manager",
  "el",
  "position",
  "multipleSortEnabled",
  // Deprecated
  "focusTrapEnabled",
  "focusTrapDisabled",
  // Deprecated
  "hideLastEditInfo"
]));
const P = v(f);
export {
  I as m
};
