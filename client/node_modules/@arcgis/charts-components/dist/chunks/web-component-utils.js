import { WebChartTypes as L, RESTSymbolType as v, WebChartSortOrderKinds as Q, WebChartStackedKinds as U, WebChartLineSmoothedKinds as J, RESTSimpleMarkerSymbolStyle as ee, RESTVerticalAlignment as h, RESTHorizontalAlignment as p, RESTSimpleLineSymbolStyle as te, WebChartLegendPositions as ie } from "@arcgis/charts-spec";
import { isEqual as ae, capitalize as b, isNumber as B, zip as X } from "lodash-es";
import { d as $ } from "./interfaces2.js";
import { a as E } from "./common.js";
import { g as oe } from "./series-types.js";
import { V as re, aP as ne, P as le, k as w, bO as se, cs as u, z, aT as O, W as T, b4 as de, H as F, aQ as ce, aR as N } from "./interfaces.js";
import { g as ue } from "./histogram-data.js";
import { p as ge, q as me, r as pe, t as Y, v as ye, d as q } from "./data.js";
import { g as fe, a as he, b as be } from "./pie-chart-data.js";
import { r as xe, g as I, b as Z, d as W } from "./box-plot-data.js";
import "d3-array";
import "@arcgis/core/geometry/support/jsonUtils.js";
import "@arcgis/core/rest/support/AttributeBinsQuery.js";
import "@arcgis/core/rest/support/Query.js";
import "@arcgis/core/rest/support/StatisticDefinition.js";
import "@arcgis/core/time/TimeExtent.js";
import "@arcgis/core/core/promiseUtils.js";
import "@arcgis/core/request.js";
import { A as Se } from "./index2.js";
/*! All material copyright Esri, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.33/esri/copyright.txt for details.
v4.33.19 */
const Ye = [
  L.BarSeries,
  L.BoxPlotSeries,
  L.LineSeries,
  L.PieSeries,
  L.HistogramSeries,
  L.ScatterSeries
], qe = 1, Ze = { PNG: "png" }, _ = {
  aria: {
    defaultChartItemRole: "figure"
  },
  title: {
    marginBottom: 8,
    wrap: !0
  },
  subtitle: {
    marginBottom: 10,
    wrap: !0
  },
  rotated: !1,
  legendProperties: {
    legendLabels: {
      marginLeft: 5,
      marginRight: 5,
      truncate: !1,
      applyOnClones: !0,
      wrap: !0,
      maxWidth: 200
    },
    valueLabels: {
      wrap: !0,
      maxWidth: 200
    },
    legendTitle: {
      wrap: !0,
      maxWidth: 220,
      marginLeft: 10,
      marginRight: 10,
      marginTop: 10
    },
    legendMarkersSize: 14,
    legendLabelReducedOpacity: 0.5,
    // 50% of original opacity
    rectangleMarkerRadius: 3,
    // for rounded rectangles
    roundedMarkerRadius: 12,
    // for circles
    legendPaddingRightWithScrollbarVisible: 10,
    maxHeight: 100,
    marginTop: 2,
    marginBottom: 2,
    marginLeft: 0,
    marginRight: 0,
    paddingTop: 0,
    paddingBottom: 0,
    paddingLeft: 0,
    paddingRight: 0,
    position: ie.Right
  },
  footer: {
    wrap: !0,
    horizontalCenter: p.Center,
    verticalCenter: h.Middle,
    align: p.Center
  },
  axisLabel: {
    rotation: 0,
    align: p.Center,
    horizontalCenter: p.Center,
    verticalCenter: h.Top,
    dy: 5,
    paddingTop: 5,
    paddingRight: 5,
    paddingLeft: 5,
    maxWidth: Number.NaN
  },
  axisTickLength: 5,
  rotatedAxisLabel: {
    rotation: -45,
    horizontalCenter: p.Left,
    verticalCenter: h.Bottom,
    dy: 6,
    paddingTop: 5,
    paddingLeft: 0,
    paddingRight: 5
  },
  histogramAxisLabel: {
    rotation: 0,
    horizontalCenter: p.Center,
    verticalCenter: h.Middle,
    dy: 0,
    dx: 0,
    paddingLeft: 3,
    paddingRight: 3
  },
  xAxisTitleLabel: {
    align: p.Center,
    valign: h.Middle,
    rotation: 0,
    fontSize: 10,
    wrap: !0
  },
  yAxisTitleLabel: {
    align: p.Center,
    valign: h.Middle,
    rotation: 270,
    wrap: !0
  },
  titleLabel: {
    align: p.Center,
    wrap: !0
  },
  subtitleLabel: {
    align: p.Center,
    wrap: !0
  },
  horizontalSurfaceGuideLabels: {
    horizontalCenter: p.Right,
    align: p.Right,
    verticalCenter: h.Middle,
    wrap: !0
  },
  horizontalLineGuideLabels: {
    horizontalCenter: p.Right,
    align: p.Right,
    verticalCenter: h.Top,
    wrap: !0
  },
  verticalSurfaceGuideLabels: {
    horizontalCenter: p.Center,
    verticalCenter: h.Top,
    valign: h.Top
  },
  verticalLineGuideLabels: {
    horizontalCenter: p.Right,
    verticalCenter: h.Bottom,
    valign: h.Top,
    wrap: !0,
    rotation: 90
  },
  guideAbove: !1,
  cursorCrosshair: {
    style: {
      type: v.SLS,
      style: te.Dash,
      color: [0, 0, 0, 102],
      width: 1
    },
    horizontalLineVisible: !1,
    verticalLineVisible: !1
  },
  gauge: {
    innerRadius: 80,
    radius: 80,
    startAngle: -180,
    endAngle: 180,
    innerLabelToInnerChartRatio: 0.5,
    // 50% of the chart's size, considering the inner radius
    axisLabelToInnerChartRatio: 0.13,
    // ~= 40 / 300: font size 40 for a 300px gauge
    innerLabelAutoMinFontSize: 14,
    innerLabelAutoMaxFontSize: 100,
    axisLabelAutoMinFontSize: 14,
    axisLabelAutoMaxFontSize: 40,
    gaugeMinGridDistance: 1,
    axisMinimum: 0,
    axisMaximum: 100,
    numberOfLabelIntervals: 5,
    numberOfTicksBetweenTwoLabels: 4,
    maximumNumberOfLabelIntervals: 24,
    // result in 25 maximum number of axis labels
    paddingTop: 10,
    paddingBottom: 10,
    paddingRight: 5,
    paddingLeft: 5
  },
  gaugeTicksLength: 7,
  gaugeInnerLabel: {
    horizontalCenter: p.Center,
    verticalCenter: h.Middle
  },
  gaugeNeedle: {
    startWidth: 10,
    endWidth: 1,
    innerRadius: 25,
    displayPin: !1
  },
  gaugeFirstLabelId: "arcgis_charts_gauge_first_label",
  gaugeLastLabelId: "arcgis_charts_gauge_last_label",
  // containers
  headerContainer: {
    layout: "vertical",
    width: "100%",
    paddingBottom: 5
  },
  footerContainer: {
    layout: "vertical",
    width: "100%",
    paddingTop: 5,
    paddingBottom: 15
  },
  paddingMinSize: 0,
  marginMinSize: 0,
  chartPaddingMinSize: 7,
  chartPaddingRightWhenLegendNotOnRight: 15,
  chartAndLegendContainer: {
    paddingTop: 0
  },
  chartContainer: {
    paddingBottom: 0,
    paddingTop: 15
  },
  chartContainerPaddingTopWhenRotated: 5,
  dataLabelInitialize: {
    strokeWidth: 0,
    applyOnClones: !0
  },
  dataLabel: {
    align: p.Center,
    horizontalCenter: p.Center,
    valign: h.Bottom,
    verticalCenter: h.Top,
    dy: -3
  },
  dataLabelRotated: {
    align: p.Right,
    horizontalCenter: p.Right,
    valign: h.Middle,
    verticalCenter: h.Middle,
    dx: 2
  },
  dataLabelStackedRotated: {
    align: p.Center,
    horizontalCenter: p.Center,
    valign: h.Middle,
    verticalCenter: h.Middle
  },
  dataLabelStackedNonRotated: {
    align: p.Center,
    horizontalCenter: p.Center,
    valign: h.Middle,
    verticalCenter: h.Middle
  },
  dataLabelNegative: {
    paddingTop: 5,
    paddingRight: 5
  },
  rotatedChartPadding: {
    paddingTop: 2,
    paddingRight: 2
  },
  scatterplotSeries: {
    strokeOpacity: 0,
    r2: Number.NaN,
    trendLinePoints: [{}, {}]
  },
  histogramSeries: {
    normalDistribNumberOfPoints: 100
  },
  lineMarker: {
    markerSize: 7,
    markerStyle: ee.Circle
  },
  lineSeries: {
    strokeWidth: 2,
    lineSmoothed: !1,
    lineSmoothedKind: J.Bezier,
    showArea: !1,
    areaOpacity: 0.25,
    markerVisible: !0,
    rotated: !1,
    stackedType: U.Side,
    stackNegativeValuesToBaseline: !0,
    marker: {
      markerSize: 4,
      markerStrokeWidth: 2
    }
  },
  buffer: !1,
  elementLimitForSmoothRendering: 1e3,
  // for line and scatter-plot
  defaultStatParameterValue: 0.5,
  // outStatistics
  pieChart: {
    dataLabels: { maxWidth: 100, wrap: !1 },
    dataLabelsOffset: 10,
    dataLabelsInside: !1,
    chartRadius: 80,
    chartOptimizedRadius: 70,
    innerRadius: ne,
    min: -90,
    max: 270,
    displayCategoryOnLegend: !0,
    displayCategoryOnTooltip: !0,
    displayCategoryOnDataLabel: !0,
    displayNumericValueOnLegend: !1,
    displayNumericValueOnDataLabel: !0,
    displayNumericValueOnTooltip: !0,
    displayPercentageOnLegend: !1,
    displayPercentageOnDataLabel: !1,
    displayPercentageOnTooltip: !0,
    sliceGrouping: {
      sliceId: re.defaultGroupOfSlicesId,
      percentageThreshold: 0,
      // 0 means no grouping
      fillSymbol: {
        type: v.SFS,
        color: [210, 210, 210, 255 * le]
        // light grey, 70% opacity
      }
    },
    defaultPadding: 0,
    alignDataLabels: !1,
    ticksOpacity: 1,
    minimumSize: 20,
    technicalFieldSliceId: "arcgis_charts_slice_id",
    technicalFieldSlicePercent: "arcgis_charts_slice_percent",
    technicalFieldGroupedSlices: "arcgis_charts_grouped_slices"
  },
  pieSliceCustomLabelName: "customLabel",
  yAxisLabelMaxWidth: 100,
  xAxisLabelMaxWidth: 75,
  axisLabelPadding: 1.5,
  categoryAxisLabelPadding: 3,
  seriesSort: Q.Ascending,
  technicalSortingFieldBySum: "arcgis_charts_category_sum",
  technicalSortingFieldByPercent: "arcgis_charts_category_first_series_percent",
  color: [0, 0, 0, 255],
  chartEllipsis: "...",
  backgroundColor: [255, 255, 255, 255],
  xAxisMinGridDistance: 120,
  xCategoryAxisMinGridDistance: 40,
  yAxisMinGridDistance: 40,
  yCategoryAxisMinGridDistance: 20,
  secondRotatedValueAxisMinGridDistance: 80,
  staggerMinGridDistance: 40,
  shortestMinGridDistance: 20,
  maxNumberOfXAxisLabelsInWrapModeForDateAxis: 15,
  maxNumberOfXAxisLabelsInWrapMode: 20,
  lineWidth: 1,
  loaderRotationSpeed: 400,
  loaderIntervalTimeout: 400,
  loaderBackground: [255, 255, 255, 230],
  loaderSpinnerColor: [0, 122, 194, 255],
  loaderLabelFontSize: 20,
  selectionTheme: {
    selectedElementsTheme: {
      elementOutlineColor: [0, 255, 255, 255],
      elementOutlineWidth: 5
    }
  },
  columnTooltipPosition: "pointer",
  markerTooltipPosition: "fixed",
  patternLineProperties: {
    width: 5,
    height: 5,
    strokeWidth: 1
  },
  patternRectProperties: {
    rectWidth: 9,
    rectHeight: 9,
    width: 10,
    height: 10,
    strokeWidth: 0.3,
    fillOpacity: 0
  },
  originalCategoryValue: "arcgis_charts_original_category_value",
  originalDateValue: "arcgis_charts_original_date_value",
  typeOrDomainFieldName: "arcgis_charts_type_domain_field_name",
  typeOrDomainIdValue: "arcgis_charts_type_domain_id_value",
  dateBinningRange: "arcgis_charts_bin_range",
  originalServerBinningRange: "arcgis_charts_server_bin_range",
  dateBinModel: "arcgis_charts_bin_model",
  xAxisField: "arcgis_charts_axis_field",
  nullValue: "arcgis_charts_null",
  queryMaxFloatPrecision: 10,
  dateFormatUTC: {
    timeZone: "UTC",
    year: "numeric",
    month: "numeric",
    day: "numeric",
    hour: "numeric",
    minute: "numeric",
    second: "numeric",
    hour12: !0
  },
  dayDefaultFormat: {
    day: "numeric",
    month: "short"
  },
  weekDefaultFormat: {
    day: "numeric",
    month: "short"
  },
  rendererOtherValue: "arcgisChartsrendererOtherValue",
  rendererSymbolField: "arcgis_charts_renderer_symbol",
  scatterplotAggregationFields: {
    dataContextXMinField: "arcgis_charts_xmin",
    dataContextXMaxField: "arcgis_charts_xmax",
    dataContextYMinField: "arcgis_charts_ymin",
    dataContextYMaxField: "arcgis_charts_ymax",
    dataContextCountDistinctX: "distinctX",
    dataContextCountDistinctY: "distinctY",
    queryNumberOfFeatures: "numberOfFeatures",
    queryNumberOfAggregatedFeatures: "numberOfAggregatedFeatures",
    xStep: "xStep",
    yStep: "yStep",
    rowCount: "rowCount",
    columnCount: "columnCount",
    realGridSize: "realGridSize"
  },
  dataTooltipVisible: !0,
  dataTooltipStyle: {
    outline: {
      type: v.SLS,
      color: [255, 255, 255, 255],
      width: 1
    }
  },
  dataTooltipStyleReversed: {
    color: [255, 255, 255, 255],
    outline: {
      type: v.SLS,
      width: 3
    }
  },
  tooltipWidth: 300,
  axisLabelOveredOpacity: 0.5,
  // 50% of original opacity
  generalFontSize: 10,
  actionMode: Se.MultiSelectionWithCtrlKey,
  debounceTime: 100,
  // 100 ms
  chartDefaultPaddingRight: 0,
  // 0 px default chart's plotting area right padding
  htmlEmptyContent: "<p></p>",
  boxPlot: {
    boxPlotCategory: "arcgis_charts_box_plot_category",
    boxPlotOutliersSuffix: "_arcgis_charts_outliers",
    boxPlotOutliersVisibility: !1,
    boxPlotStandardizeValuesVisibility: !1,
    boxPlotOutliersSize: 4,
    boxPlotLineWidth: 2,
    boxPlotOutlierId: "is_arcgis_charts_outlier",
    boxPlotMeanLineMarkerId: "is_arcgis_charts_mean_marker",
    boxPlotWhiskersColor: [153, 153, 153, 178.5],
    boxPlotTooltipLabelWidth: 250
  },
  binTemporalData: !0,
  lastTemporalBin: "is_arcgis_charts_last_bin",
  options: {
    hideEmptySeries: !0,
    replaceNoValueCategoryWithZero: !0
  }
};
function Ce(d, e) {
  return !ae(d, e);
}
function Qe(d, e) {
  return Ce(d, e) || d !== e;
}
const j = (d, e) => {
  let t = d == null ? "" : String(d);
  return Number.isFinite(Number(t)) && (t = Number(t).toFixed(2)), (e || /[",\r\n]/u.test(t)) && (t = `"${t.replace(/"/gu, '""')}"`), t;
};
function Ue(d, e = {}) {
  const { columns: t, delimiter: l = ",", includeHeader: r = !0, quoteAll: i = !1 } = e, a = d.length === 0;
  let m = "";
  if (!a) {
    const s = t ?? Object.keys(d[0]), g = [];
    if (r) {
      const x = s.map((y) => j(y, i));
      g.push(x.join(l));
    }
    d.forEach((x) => {
      const y = s.map((f) => j(x[f], i));
      g.push(y.join(l));
    }), m = g.join(`\r
`);
  }
  return m;
}
function Je(d) {
  const { rawData: e, config: t, layer: l, fieldList: r } = d;
  let i = e;
  if (t !== void 0 && Array.isArray(e) && e.length > 0) {
    const a = oe(t?.series);
    a === L.HistogramSeries ? i = Fe(t, e) : a === L.BarSeries || a === L.LineSeries || a === L.ComboLineAndBarSeries ? i = Le({
      config: t,
      rows: e,
      layer: l,
      fieldList: r
    }) : a === L.PieSeries ? i = Me({
      config: t,
      rows: e,
      layer: l,
      fieldList: r
    }) : a === L.BoxPlotSeries && (i = _e({
      config: t,
      rows: e,
      fieldList: r
    }));
  }
  return i;
}
function Fe(d, e) {
  const t = ue(d), l = `${b($.Min)} of ${t}`, r = `${b($.Max)} of ${t}`, i = `${b($.Count)} of ${t}`;
  return e.map((a) => {
    const { minValue: m, maxValue: s, count: g } = a, x = B(m), y = B(s), f = B(g), o = {};
    return x && (o[l] = m.toFixed(2)), y && (o[r] = s.toFixed(2)), x && y && (o.Label = `${m.toFixed(2)} - ${s.toFixed(2)}`), f && (o[i] = g), o;
  });
}
function H(d, e, t) {
  const l = Object.keys(d);
  let r = [];
  return t ? r = t.map((i) => l.find((a) => a.toLowerCase().includes(i.toLowerCase())) || "") : r = l.filter((a) => a.toLowerCase().includes(e.toLowerCase())), r.filter((i) => i.trim() !== "");
}
function Le(d) {
  const { config: e, rows: t, layer: l, fieldList: r } = d, i = ge(e), a = me(e), m = b(a), s = pe(e), g = w(e.series), x = Y(e), y = ye(e), f = se(l)?.objectIdField ?? "FID", o = s.length === 1 && s[0] === f;
  let c;
  switch (g) {
    case u.BarAndLineNoAggregation:
      c = t.map((n) => {
        const S = M({
          field: i,
          value: n[i],
          fieldList: r
        }), C = { [i]: S };
        return Object.assign(C, ...s.map((P) => ({ [P]: n[P] }))), C;
      });
      break;
    case u.BarAndLineFromFields:
      c = X(s, t).map(([n, S]) => {
        const C = z(e.series)[0], P = {};
        return S !== void 0 && n !== void 0 && (P.Field = S[i], P.Value = S[C]), P;
      });
      break;
    case u.BarAndLineMonoField:
    case u.BarAndLineMultiFields:
      c = t.map((n) => {
        const S = M({
          field: i,
          value: n[i],
          fieldList: r
        }), C = { [i]: S };
        return s.forEach((P, R) => {
          const k = q({
            config: e,
            numericFields: s,
            aggregationType: a,
            layer: l,
            numericFieldIndex: R
          }), V = z(e.series)[R];
          let K = V, G = V;
          V.toLowerCase() === k.name.toLowerCase() && (K = k.description, G = k.name), C[K] = n[G];
        }), C;
      });
      break;
    case u.BarAndLineSplitBy:
      c = t.flatMap((n) => {
        const S = H(n, s[0]), C = M({
          field: i,
          value: n[i],
          fieldList: r
        });
        return x.map(
          (P, R) => ({
            [i]: C,
            [y]: P,
            [o ? m : `${m} of ${s[0]}`]: n[S[R]]
          })
        );
      });
      break;
    case u.BarAndLineSplitByNoAggregation:
      c = t.map((n) => {
        const S = M({
          field: i,
          value: n[i],
          fieldList: r
        }), C = H(n, s[0], x);
        return {
          [i]: S,
          [y]: n[y],
          [s[0]]: n[C[0]]
        };
      });
      break;
    default:
      c = t;
  }
  return c;
}
function Pe(d, e = 2) {
  if (d.length === 0)
    return [];
  const t = d.reduce((l, r) => {
    for (const [i, a] of Object.entries(r))
      typeof a == "number" && Number.isFinite(a) && (l[i] = (l[i] ?? 0) + a);
    return l;
  }, {});
  return d.map((l) => {
    const r = { ...l };
    for (const [i, a] of Object.entries(l))
      if (typeof a == "number" && t[i] > 0) {
        const m = a / t[i] * 100;
        r[`${i}${O}`] = `${m.toFixed(e)}%`;
      }
    return r;
  });
}
function Me(d) {
  const { config: e, rows: t, layer: l, fieldList: r } = d, i = fe(e), a = w(e.series);
  let m = Pe(t, 2);
  const s = he(e), g = a !== u.PieFromFields ? E.Category : E.Fields, x = be(e, g), y = q({
    config: e,
    numericFields: s,
    aggregationType: x,
    mode: g,
    layer: l
  }), f = z(e.series)[0];
  return a === u.PieFromCategory ? m = m.map((o) => {
    const c = M({
      field: i,
      value: o[i],
      fieldList: r
    }), n = { [i]: c };
    let S = f, C = f;
    return f.toLowerCase() === y.name.toLowerCase() && (S = y.description, C = y.name), n[S] = o[C], n[b(O.trim())] = o[`${C}${O}`], n;
  }) : a === u.PieFromFields && (m = X(s, m).map(([o, c]) => {
    const n = {};
    return c !== void 0 && o !== void 0 && (n.Field = c[i], n.Value = c[f], n[b(O.trim())] = c[`${f}${O}`]), n;
  })), m;
}
function D(d) {
  const { rawData: e, keyBase: t = "", outRow: l } = d;
  for (const [r, i] of Object.entries(F)) {
    const a = e[t + i];
    a !== void 0 && (l[r] = B(a) ? a.toFixed(2) : a);
    const m = e[t + i + ce];
    m !== void 0 && (l[`${r} Outlier`] = B(m) ? m.toFixed(2) : m);
    const s = e[t + i + N];
    s !== void 0 && (l[`${r} Z-Score`] = B(s) ? s.toFixed(2) : s);
  }
}
function A(d) {
  const { rawData: e, outRow: t, config: l, boxPlotSubType: r, fieldList: i } = d, a = I(l), m = Z(l), s = W(l);
  let g = F.Outlier;
  const x = T;
  switch (r) {
    case u.BoxPlotMonoFieldAndCategory: {
      const o = M({
        field: a,
        value: e[a],
        fieldList: i
      });
      t[a] = o, t[b(F.Outlier)] = e[g];
      break;
    }
    case u.BoxPlotMultiFieldsAndCategory: {
      t[b(a)] = e[a], g = `${m.find(
        (c) => Object.keys(e).some((n) => n.toLowerCase().includes(c.toLowerCase()))
      ) ?? ""}_${g}`, t[b(F.Outlier)] = e[g];
      break;
    }
    case u.BoxPlotMonoFieldAndSplitBy:
    case u.BoxPlotMultiFieldsAndSplitBy: {
      const o = e[s];
      g = `${o}_${g}`, t.Field = e[x], t[b(s)] = o, t[b(F.Outlier)] = e[g];
      break;
    }
    case u.BoxPlotMonoFieldAndCategoryAndSplitBy: {
      const o = e[s];
      g = `${o}_${g}`, t[b(a)] = e[a], t[b(s)] = o, t[b(F.Outlier)] = e[g];
      break;
    }
    case u.BoxPlotMonoField:
    case u.BoxPlotMultiFields:
    default: {
      t.Field = e[x], t[b(F.Outlier)] = e[g];
      break;
    }
  }
  const y = `${g}${N}`, f = e[y];
  f !== void 0 && (t[`${b(F.Outlier)} Z-Score`] = B(f) ? f.toFixed(2) : f);
}
function Be(d) {
  const { rawData: e, outRow: t, config: l, splitByValue: r } = d, i = w(l.series), a = e[`${r}_${F.Average}`], m = W(l), s = I(l);
  let g = "";
  switch (i) {
    case u.BoxPlotMonoFieldAndSplitBy: {
      g = `${r}_${m}`, t.Field = e[T], t[b(m)] = e[g];
      break;
    }
    case u.BoxPlotMultiFieldsAndSplitBy: {
      g = `${r}_${F.Average}`, t.Field = e[T], t[b(m)] = e[g];
      break;
    }
    case u.BoxPlotMonoFieldAndCategoryAndSplitBy: {
      g = `${r}_${F.Average}`, t[s] = e[s], t[b(m)] = r;
      break;
    }
  }
  t[b(F.Average)] = B(a) ? a.toFixed(2) : a;
  const x = `${a}${N}`, y = e[x];
  y !== void 0 && (t[`${b(F.Average)} Z-Score`] = B(y) ? y.toFixed(2) : y);
}
function _e(d) {
  const { config: e, rows: t, fieldList: l } = d, r = w(e.series);
  let i = r;
  const a = xe(e), m = Array.isArray(t) && t.length > 0 && t.every((o) => o[_.boxPlot.boxPlotMeanLineMarkerId] !== void 0);
  a && !m && (r === u.BoxPlotMonoFieldAndSplitBy ? i = u.BoxPlotMonoField : r === u.BoxPlotMultiFieldsAndSplitBy ? i = u.BoxPlotMultiFields : r === u.BoxPlotMonoFieldAndCategoryAndSplitBy && (i = u.BoxPlotMonoFieldAndCategory));
  const s = I(e), g = Z(e), x = Y(e), y = W(e);
  let f;
  switch (i) {
    case u.BoxPlotMonoField:
    case u.BoxPlotMonoFieldAndCategory: {
      f = t.map((o) => {
        const c = {};
        if (o[_.boxPlot.boxPlotOutlierId])
          A({ rawData: o, outRow: c, config: e, boxPlotSubType: i });
        else {
          if (i === u.BoxPlotMonoFieldAndCategory) {
            const n = M({
              field: s,
              value: o[s],
              fieldList: l
            });
            c[s] = n;
          } else i === u.BoxPlotMonoField && (c.Field = o[T]);
          D({ rawData: o, outRow: c });
        }
        return c;
      });
      break;
    }
    case u.BoxPlotMultiFields: {
      f = t.flatMap((o) => {
        const c = {};
        return o[_.boxPlot.boxPlotOutlierId] ? A({
          rawData: o,
          outRow: c,
          config: e,
          boxPlotSubType: i
        }) : (c.Field = o[T], D({ rawData: o, outRow: c })), [c];
      });
      break;
    }
    case u.BoxPlotMultiFieldsAndCategory: {
      f = t.flatMap(
        (o) => g.map((c) => {
          const n = {};
          let S = "";
          if (n.Field = c, o[_.boxPlot.boxPlotOutlierId])
            A({
              rawData: o,
              outRow: n,
              config: e,
              boxPlotSubType: i
            });
          else {
            if (i === u.BoxPlotMultiFieldsAndCategory) {
              const C = M({
                field: s,
                value: o[s],
                fieldList: l
              });
              n[s] = C, S = `${c}_`;
            }
            D({ rawData: o, outRow: n, keyBase: S });
          }
          return n;
        })
      );
      break;
    }
    case u.BoxPlotMonoFieldAndSplitBy:
    case u.BoxPlotMultiFieldsAndSplitBy:
    case u.BoxPlotMonoFieldAndCategoryAndSplitBy: {
      f = t.flatMap((o) => {
        if (o[_.boxPlot.boxPlotOutlierId]) {
          const c = {};
          return A({
            rawData: o,
            outRow: c,
            config: e,
            boxPlotSubType: i
          }), [c];
        } else return o[_.boxPlot.boxPlotMeanLineMarkerId] ? x?.map((c) => {
          const n = {};
          return Be({
            rawData: o,
            outRow: n,
            splitByValue: c,
            config: e
          }), n;
        }) : x.map((c) => {
          const n = {};
          if (i === u.BoxPlotMonoFieldAndCategoryAndSplitBy) {
            const S = M({
              field: s,
              value: o[s],
              fieldList: l
            });
            n[s] = S;
          }
          return o[_.boxPlot.boxPlotOutlierId] ? A({
            rawData: o,
            outRow: n,
            config: e,
            boxPlotSubType: i
          }) : (n[y] = c, D({ rawData: o, outRow: n, keyBase: `${c}_` })), n;
        });
      });
      break;
    }
    default:
      f = t;
  }
  return f;
}
const Ae = (d) => {
  let e = !1;
  return (typeof d == "string" || typeof d == "number") && (e = !Number.isNaN(new Date(d).getTime())), e;
}, M = (d) => {
  const { field: e, value: t, fieldList: l } = d;
  let r = !1;
  return l !== void 0 && l.length > 0 && (r = de(l).some((a) => a === e)), Ae(t) && r ? new Date(t).toISOString() : t;
};
export {
  _ as C,
  Ze as D,
  Ce as a,
  Ue as b,
  Qe as h,
  qe as m,
  Ye as s,
  Je as t
};
