import { c as E } from "../../chunks/runtime.js";
import { repeat as k } from "lit-html/directives/repeat.js";
import { keyed as L } from "lit-html/directives/keyed.js";
import { c as A } from "../../chunks/setup-utils.js";
import { b as x, p as T, k as F, j as b } from "../../chunks/type-guards.js";
import { WebChartTypes as o, WebChartTemporalBinningUnits as N } from "@arcgis/charts-spec";
import { isEqual as S } from "lodash-es";
import { o as I, cr as B, cc as w, G as V, bR as U } from "../../chunks/interfaces.js";
import "@arcgis/core/geometry/support/jsonUtils.js";
import "@arcgis/core/rest/support/AttributeBinsQuery.js";
import "@arcgis/core/rest/support/Query.js";
import "@arcgis/core/rest/support/StatisticDefinition.js";
import "@arcgis/core/time/TimeExtent.js";
import "@arcgis/core/core/promiseUtils.js";
import "@arcgis/core/request.js";
import { a as C } from "../../chunks/index2.js";
import { a as $ } from "../../chunks/chart-ui-utils.js";
import { c as H, P as R } from "../../chunks/popover-ui-utils.js";
import { C as n } from "../../chunks/interfaces2.js";
import { d as _, e as X } from "../../chunks/chart-ui-utils2.js";
import "d3-array";
import { LitElement as Y, createEvent as f, safeClassMap as h } from "@arcgis/lumina";
import { html as c } from "lit";
import { createRef as O, ref as W } from "lit-html/directives/ref.js";
import { u as z } from "../../chunks/useT9n.js";
import { s as M, g as G } from "../../chunks/store.js";
import { h as Z, a as y, s as j } from "../../chunks/web-component-utils.js";
import { A as K } from "../../chunks/axis-model-wrapper.js";
import { css as q } from "@lit/reactive-element/css-tag.js";
/*! All material copyright Esri, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.33/esri/copyright.txt for details.
v4.33.19 */
const d = {
  chartUIComponent: "chart-ui-component",
  tabBar: "tab-bar",
  tab: "tab"
};
function P(p, e) {
  const t = /* @__PURE__ */ new Set();
  let i = e;
  return p?.forEach((a, s) => {
    const r = a.getChartId();
    (t.has(r) || r === void 0 || r === "") && (a.setChartId(`Chart_${Date.now()}_${s}`), e === r && (i = a.getChartId())), t.add(r);
  }), i;
}
function Q(p, e, t) {
  return p?.filter(
    (i) => w(t, i.getConfig()) && i.getLayer()?.id === e
  ) ?? [];
}
function J(p) {
  const { modelList: e, layerList: t, activeLayerId: i, disableEditing: a } = p, s = /* @__PURE__ */ new Map();
  return e?.forEach((r) => {
    const l = r.getLayer();
    l && s.set(l.id, l);
  }), a || t.forEach((r) => s.set(r.id, r)), Array.from(s.values()).filter((r) => !i || r.id === i);
}
function ee(p, e) {
  p.forEach((t) => {
    e.forEach((i) => {
      t?.id === i.getLayer()?.id && D(t, i);
    });
  });
}
function D(p, e) {
  const t = p;
  if (t) {
    const i = [...t?.charts ?? []], a = i?.findIndex((r) => r.id === e.getChartId());
    let s = !1;
    a !== void 0 && a > -1 ? (s = !S(i[a], e.getConfig()), i[a] = e.getConfig()) : t && !I(e.getConfig()) && (s = !0, i.push(e.getConfig())), s && (t.charts = i);
  }
}
function te(p, e) {
  const t = p;
  if (t) {
    const i = [...t.charts ?? []], a = i.findIndex((s) => s.id === e);
    a > -1 && (i.splice(a, 1), t.charts = i);
  }
}
function ae(p, e) {
  const t = p;
  if (t) {
    let i = [...t.charts ?? []];
    i = B({
      arrayA: i,
      arrayB: e.map((a) => a.getConfig()),
      getKey: (a) => a.id ?? a.title?.content.text ?? ""
    }), t.charts = i;
  }
}
const ie = q`:host{display:flex;flex-direction:column;flex:1 1 auto;overflow:hidden;height:inherit;max-height:100%}.chart-ui-component{overflow-y:auto;overflow-x:hidden}.label{display:flex;margin-left:1rem;margin-bottom:.5rem;justify-content:space-between}.text{display:flex;margin-left:1rem;width:calc(100% - 1.5rem);height:2rem;margin-bottom:.5rem;justify-content:space-between}.field-list{max-height:50vh;overflow-y:scroll}.row{padding:.5rem}.bin-count-container{display:flex;width:calc(100% - 1rem);padding:.5rem}.bin-count-slider{margin-left:1rem;width:calc(90% - 1rem)}.bin-count-input{margin-left:1rem;height:2rem;width:2rem}.bin-row{padding:.5rem 0 .5rem .5rem}.tab-bar{display:flex}.tab{flex:1;height:2.5rem}`;
class se extends Y {
  constructor() {
    super(), this.chartsListFlowItem = O(), this.supportedChartTypes = [
      o.BarSeries,
      o.BoxPlotSeries,
      o.LineSeries,
      o.PieSeries,
      o.HistogramSeries,
      o.ScatterSeries
    ], this._messages = z(), this.chartDataProcessComplete = (e) => {
      const t = e, { chartData: i, model: a } = t.detail, s = this.getModel(this.selectedChartId);
      if (a?.isSameChartAs(s))
        switch (s?.getChartType()) {
          case o.HistogramSeries:
            this.chartData = i, a && (a.dataStore.chartData = i);
            break;
          case o.PieSeries: {
            this.chartData = i, a && (a.dataStore.chartData = i);
            break;
          }
          case o.ScatterSeries: {
            const l = i, { dataItems: m, r2: u } = l;
            let g = u;
            Number.isFinite(u) || (g = void 0), this.r2 = g, a && (a.dataStore.r2 = g), this.calculatedDataMinMaxBounds = this.getDataExtent(m), a && (a.dataStore.calculatedDataMinMaxBounds = this.calculatedDataMinMaxBounds);
            break;
          }
          case o.LineSeries: {
            const { dataItems: l, timeIntervalInfo: m } = i;
            x(s) && (m?.size !== void 0 && s.getTemporalBinningSize() !== m?.size && s.setTemporalBinningSize(m?.size), m?.unit !== void 0 && s.getTemporalBinningUnit() !== m?.unit && m?.unit !== N.Quarter && s.setTemporalBinningUnit(m?.unit)), this.calculatedDataMinMaxBounds = this.getDataExtent(l), a && (a.dataStore.calculatedDataMinMaxBounds = this.calculatedDataMinMaxBounds);
            break;
          }
        }
    }, this.chartAxesMinMaxChange = (e) => {
      const t = e, { bounds: i, model: a } = t.detail, s = this.getModel(this.selectedChartId), r = a?.isSameChartAs(s), l = s?.getChartType();
      if (r)
        switch (l) {
          case o.BarSeries:
          case o.BoxPlotSeries:
          case o.LineSeries:
          case o.HistogramSeries:
          case o.ScatterSeries:
            this.calculatedMinMaxBounds = i, a && (a.dataStore.calculatedMinMaxBounds = i), this.updateAxesBoundsInAppState(i);
            break;
        }
    }, this.chartSeriesColorChange = (e) => {
      const t = e, { data: i, model: a } = t.detail, s = this.getModel(this.selectedChartId);
      if (a?.isSameChartAs(s))
        switch (s?.getChartType()) {
          case o.BarSeries:
          case o.BoxPlotSeries:
          case o.LineSeries:
          case o.HistogramSeries:
            this.seriesColor = i, a && (a.dataStore.seriesColor = i);
            break;
          case o.PieSeries: {
            const l = /* @__PURE__ */ new Map([[0, i]]);
            this.seriesColor = l, a && (a.dataStore.seriesColor = l);
            break;
          }
          case o.ScatterSeries:
        }
    }, this.chartNoRenderPropChange = (e) => {
      const t = e, { propName: i, value: a, model: s } = t.detail, r = this.modelList.find((l) => s?.isSameChartAs(l));
      if (r)
        switch (i) {
          case "rotation":
            typeof a == "boolean" && F(r) && r.setRotatedState(a);
            break;
          case "legendPosition":
            typeof a == "string" && T(r) && r.setLegendPosition(a);
            break;
          case "legendVisibility":
            typeof a == "boolean" && T(r) && r.setLegendVisibility(a);
            break;
        }
    }, this.chartLegendItemVisibilityChange = async (e) => {
      const t = e, { legendItemVisibility: i, model: a } = t.detail, s = this.modelList.find((r) => a?.isSameChartAs(r));
      s?.setSeriesVisibility(i), b(s) && ((s.getMinYBound() === null || Number.isNaN(s.getMinYBound())) && await s.setMinYBound(null), (s.getMaxYBound() === null || Number.isNaN(s.getMaxYBound())) && await s.setMaxYBound(null), x(s) && ((s.getMinXBound() === null || Number.isNaN(s.getMinXBound())) && await s.setMinXBound(null), (s.getMaxXBound() === null || Number.isNaN(s.getMaxXBound())) && await s.setMaxXBound(null)));
    }, this.onSelectChartTypeChange = (e) => {
      this.currentChartTypeText = "", this.calculatedDataMinMaxBounds = void 0, this.calculatedMinMaxBounds = void 0, this.removeSelectChartTypePopover();
      const { selectedModelType: t, layerId: i } = e.target;
      t !== void 0 && this.arcgisChartsConfigNewChart.emit({
        key: "key",
        chartType: t,
        layerId: i
      });
    }, this.onAddChartClose = () => {
      this.removeSelectChartTypePopover();
    }, this.onModelConfigChange = (e) => {
      if (this.syncChartsToLayers) {
        const t = e.target;
        D(t?.getLayer(), t);
      }
      this.requestUpdate();
    }, this.currentChartTypeText = "", this.modelList = [], this.layerList = [], this.disableEditing = !1, this.syncChartsToLayers = !1, this.panelNumber = 0, this.arcgisChartsConfigChartViewChartClose = f(), this.arcgisChartsConfigModelListChange = f(), this.arcgisChartsConfigNewChart = f(), this.arcgisChartsConfigPanelNumberChange = f(), this.arcgisChartsConfigPopoverOpenChange = f(), this.arcgisChartsConfigSelectedChartChange = f(), this.listen("arcgisChartsConfigModelListReorder", this.modelListReorderChangeListener);
  }
  static {
    this.properties = { selectedPanel: 16, currentChartTypeText: 16, messageOverrides: 0, modelList: [0, { hasChanged: y }], layerList: [0, { hasChanged: y }], selectedChartId: 3, activeLayerId: 3, disableEditing: 7, syncChartsToLayers: 7, timeZone: 3, headerTitle: 3, open: 7, chartData: [0, { hasChanged: y }], r2: 9, calculatedDataMinMaxBounds: [0, { hasChanged: y }], calculatedMinMaxBounds: [2, { hasChanged: y }], seriesColor: [2, { hasChanged: Z }], popoverPlacement: 3, usePopupTemplateFieldsInfo: 5, panelNumber: 11, filterBySelection: 5 };
  }
  static {
    this.styles = ie;
  }
  async setFocus() {
    this.chartsListFlowItem.value?.setFocus();
  }
  connectedCallback() {
    super.connectedCallback(), this.addChartEventListeners();
  }
  async load() {
    await this.layerListChange();
    const e = this.getModel(this.selectedChartId);
    this.setEventBasedPropsFromModelData(e);
  }
  async willUpdate(e) {
    e.has("layerList") && (this.hasUpdated || this.layerList?.length > 0) && await this.layerListChange(), e.has("modelList") && (this.hasUpdated || this.modelList?.length > 0) && await this.modelListChange(this.modelList, e.get("modelList")), e.has("selectedChartId") && await this.selectedChartIdChange(this.selectedChartId), e.has("panelNumber") && (this.hasUpdated || this.panelNumber !== 0) && this.panelNumberChange(this.panelNumber);
  }
  disconnectedCallback() {
    super.disconnectedCallback(), this.clearPartialModels(), this.removeSelectChartTypePopover(), this.removeChartEventListeners(), this.selectChartTypePopover = void 0;
  }
  modelListReorderChangeListener(e) {
    const { modelList: t } = e.detail;
    if (this.modelList = B({
      arrayA: this.modelList,
      arrayB: t,
      getKey: (i) => i.getChartId() ?? i.getTitleText() ?? ""
    }), this.syncChartsToLayers) {
      const i = t.find((a) => a.getLayer()?.id !== void 0)?.getLayer()?.id;
      if (i) {
        const a = this.layerList.find((s) => s.id.toString() === i);
        a && ae(a, t);
      }
    }
  }
  async layerListChange() {
    const e = [], t = this.layerList.map((a) => a.id.toString()), i = [...this.modelList.filter((a) => t.includes(a.getLayer()?.id ?? ""))];
    for (let a of this.layerList ?? []) {
      if (a.type === "sublayer") {
        const r = await a.createFeatureLayer();
        if (!r)
          continue;
        a = r;
      }
      const s = a;
      for (const r of s.charts ?? []) {
        const l = await A({
          layer: a,
          config: r
        });
        l !== void 0 && e.push(l);
      }
    }
    P(e), e.forEach((a) => {
      i.find((r) => r.isSameChartAs(a)) === void 0 && i.push(a);
    }), this.modelList = i;
  }
  async modelListChange(e, t) {
    this.selectedChartId = P(e, this.selectedChartId), t?.forEach((a) => {
      a.removeEventListener("arcgisChartsModelConfigChange", this.onModelConfigChange);
    }), e.forEach((a) => {
      a.addEventListener("arcgisChartsModelConfigChange", this.onModelConfigChange);
    });
    const i = this.getModel(this.selectedChartId);
    this.currentChartTypeText = i?.getChartType() !== void 0 ? await $(i.getChartType()) : "", this.syncChartsToLayers && ee(this.layerList, e), this.arcgisChartsConfigModelListChange.emit({ modelList: e });
  }
  async selectedChartIdChange(e) {
    this.selectedChartId === void 0 && (this.panelNumber = 0), this.selectedPanel = n.Data;
    const t = this.getModel(e);
    this.setEventBasedPropsFromModelData(t), this.currentChartTypeText = t?.getChartType() !== void 0 ? await $(t.getChartType()) : "", e !== void 0 && e !== M.selectedChartId && (M.selectedChartId = e), this.arcgisChartsConfigSelectedChartChange.emit({
      key: "key",
      model: t
    });
  }
  panelNumberChange(e) {
    e === 0 ? this.clearPartialModels() : e === 1 && (this.arcgisChartsConfigPopoverOpenChange.emit({ open: !1 }), this.removeSelectChartTypePopover(), this.selectChartTypePopover = void 0), this.arcgisChartsConfigPanelNumberChange.emit({ panelNumber: e, modelList: this.modelList });
  }
  addChartEventListeners() {
    document.addEventListener(C.DataProcessComplete, this.chartDataProcessComplete), document.addEventListener(C.AxesMinMaxChange, this.chartAxesMinMaxChange), document.addEventListener(C.SeriesColorChange, this.chartSeriesColorChange), document.addEventListener(C.NoRenderPropChange, this.chartNoRenderPropChange), document.addEventListener(C.LegendItemVisibilityChange, this.chartLegendItemVisibilityChange);
  }
  removeChartEventListeners() {
    document.removeEventListener(C.DataProcessComplete, this.chartDataProcessComplete), document.removeEventListener(C.AxesMinMaxChange, this.chartAxesMinMaxChange), document.removeEventListener(C.SeriesColorChange, this.chartSeriesColorChange), document.removeEventListener(C.NoRenderPropChange, this.chartNoRenderPropChange), document.removeEventListener(C.LegendItemVisibilityChange, this.chartLegendItemVisibilityChange);
  }
  getDataExtent(e) {
    const t = this.getModel(this.selectedChartId)?.getConfig();
    let i = [];
    if (t !== void 0 && e !== void 0) {
      const a = V({
        chartConfig: t,
        chartData: e
      }), { minY: s, maxY: r, minX: l, maxX: m } = a;
      i = [
        { isXAxis: !0, minimum: l, maximum: m },
        { isXAxis: !1, minimum: s, maximum: r }
      ];
    }
    return i;
  }
  updateAxesBoundsInAppState(e) {
    e?.forEach((t) => {
      const { isXAxis: i, maximum: a, minimum: s } = t, r = this.getModel(this.selectedChartId);
      if (r !== void 0 && b(r) && this.selectedChartId !== void 0) {
        const l = new K(r, i), m = G({
          chartId: this.selectedChartId,
          isXAxis: i,
          isLogarithmic: l.getLogarithmic()
        }), u = M.chartAxesBoundDataMap;
        u[this.selectedChartId] === void 0 && (u[this.selectedChartId] = {});
        const g = u[this.selectedChartId]?.[m], v = {
          defaultMinBound: g?.defaultMinBound === g?.currMinBound ? s : g?.defaultMinBound,
          currMinBound: s,
          defaultMaxBound: g?.defaultMaxBound === g?.currMaxBound ? a : g?.defaultMaxBound,
          currMaxBound: a
        };
        !S(g, v) && this.selectedChartId !== void 0 && u?.[this.selectedChartId] !== void 0 && (u[this.selectedChartId][m] = v);
      }
    });
  }
  getPlacement() {
    let e;
    if (this.popoverPlacement !== void 0)
      e = this.popoverPlacement;
    else {
      const t = this.modelList?.filter((a) => w(j, a.getConfig())).length;
      e = Number(t) <= 2 ? "bottom" : "top";
    }
    return e;
  }
  onBackFlow() {
    this.panelNumber -= 1;
  }
  onAddChartClick(e) {
    const { referenceElement: t, layerId: i } = e.detail;
    this.setupSelectChartTypePopover(t, i), this.addSelectChartTypePopover();
  }
  setupSelectChartTypePopover(e, t) {
    if (this.selectChartTypePopover === void 0) {
      const i = {
        onSelectChartTypeChange: this.onSelectChartTypeChange,
        popoverClose: this.onAddChartClose
      };
      this.selectChartTypePopover = H(R.SelectChartTypePopover, i);
    }
    this.selectChartTypePopover !== void 0 && (this.selectChartTypePopover.layerId = t, this.selectChartTypePopover.popoverReferenceElement = e, this.selectChartTypePopover.popoverPlacement = this.getPlacement());
  }
  addSelectChartTypePopover() {
    this.selectChartTypePopover !== void 0 && (document.body.contains(this.selectChartTypePopover) || (this.selectChartTypePopover.open = !0, document.body.appendChild(this.selectChartTypePopover), this.arcgisChartsConfigPopoverOpenChange.emit({ open: !0 })));
  }
  getModel(e) {
    return this.modelList?.find((t) => t.getChartId() === e);
  }
  removeSelectChartTypePopover() {
    this.selectChartTypePopover?.remove(), this.selectChartTypePopover = void 0, this.arcgisChartsConfigPopoverOpenChange.emit({ open: !1 });
  }
  clearPartialModels() {
    this.modelList = this.modelList.filter((e) => !I(e.getConfig()));
  }
  onViewChartDelete(e) {
    const { chartId: t } = e.detail;
    if (t !== void 0) {
      const i = this.modelList.find((s) => s.getChartId() === t), a = this.layerList.find((s) => s.id === i?.getLayer()?.id);
      this.modelList = [...this.modelList.filter((s) => s.getChartId() !== t)], a && this.syncChartsToLayers && te(a, t);
    }
  }
  onViewChartsSelect(e) {
    this.selectedChartId === e.detail.chartId && this.arcgisChartsConfigSelectedChartChange.emit({
      key: "key",
      model: this.getModel(this.selectedChartId)
    }), this.selectedChartId = e.detail.chartId;
  }
  onViewChartsEdit(e) {
    this.onViewChartsSelect(e), this.panelNumber = 1;
  }
  onViewChartClose() {
    this.open = !1, this.removeSelectChartTypePopover(), this.selectChartTypePopover = void 0, this.arcgisChartsConfigChartViewChartClose.emit();
  }
  setEventBasedPropsFromModelData(e) {
    this.chartData = e?.dataStore.chartData, this.r2 = e?.dataStore.r2, this.seriesColor = e?.dataStore.seriesColor, this.calculatedMinMaxBounds = e?.dataStore.calculatedMinMaxBounds, this.calculatedDataMinMaxBounds = e?.dataStore.calculatedDataMinMaxBounds;
  }
  createTooltip(e) {
    const t = e.target;
    switch (this.tooltip = _(t), t.icon) {
      case "configure":
        this.tooltip.innerHTML = this._messages.data ?? "";
        break;
      case "graph-bar-stacked":
      case "graph-line-series":
      case "box-chart-series":
        this.tooltip.innerHTML = this._messages.series ?? "";
        break;
      case "graph-pie-slice":
        this.tooltip.innerHTML = this._messages.slices ?? "";
        break;
      case "graph-axis":
        this.tooltip.innerHTML = this._messages.axes ?? "";
        break;
      case "graph-guides":
        this.tooltip.innerHTML = this._messages.guides ?? "";
        break;
      case "palette":
        this.tooltip.innerHTML = this._messages.format ?? "";
        break;
      case "text":
        this.tooltip.innerHTML = this._messages.general ?? "";
        break;
      default:
        this.tooltip.innerHTML = "";
        break;
    }
    document.body.appendChild(this.tooltip);
  }
  destroyTooltip() {
    X(this.tooltip);
  }
  renderViewCharts() {
    const e = J({
      modelList: this.modelList,
      layerList: this.layerList,
      activeLayerId: this.activeLayerId,
      disableEditing: this.disableEditing
    });
    return k(e, (t) => t.id, (t) => c`<arcgis-charts-config-view-charts .noGroup=${this.activeLayerId !== void 0} .modelList=${Q(this.modelList, t.id.toString(), this.supportedChartTypes)} .selectedChartId=${this.selectedChartId ?? ""} .layer=${t} .disableEditing=${this.disableEditing} @arcgisChartsConfigViewChartSelect=${this.onViewChartsSelect} @arcgisChartsConfigViewChartEdit=${this.onViewChartsEdit} @arcgisChartsConfigViewChartDelete=${this.onViewChartDelete} @arcgisChartsConfigViewChartAddChart=${this.onAddChartClick}></arcgis-charts-config-view-charts>`);
  }
  render() {
    return this.open !== !1 ? c`<calcite-flow>${L("charts-list", c`<calcite-flow-item .selected=${this.panelNumber === 0 || this.disableEditing} .heading=${this.headerTitle ?? this._messages.defaultHeaderTitle} closable @calciteFlowItemClose=${this.onViewChartClose} ${W(this.chartsListFlowItem)}>${this.renderViewCharts()}</calcite-flow-item>`)}${this.renderTabs()}</calcite-flow>` : null;
  }
  renderTabs() {
    const e = this.getModel(this.selectedChartId);
    return L("chart-edit", c`<calcite-flow-item .selected=${this.panelNumber >= 1 && !this.disableEditing} @calciteFlowItemBack=${this.onBackFlow} .heading=${this._messages[this.selectedPanel ?? n.Data]} .description=${this.currentChartTypeText !== "" && this._messages.pageFlowTitle !== void 0 ? U(this._messages.pageFlowTitle, {
      chartName: e?.getTitleText() ?? this.currentChartTypeText,
      layerName: e?.getLayer()?.title ?? ""
    }) : ""}>${e?.getChartType() !== void 0 ? c`<calcite-action-bar class=${h(d.tabBar)} layout=horizontal expand-disabled><calcite-action class=${h(d.tab)} icon=configure scale=s alignment=center .active=${this.selectedPanel === n.Data || this.selectedPanel === void 0} @click=${() => {
      this.selectedPanel = n.Data;
    }} @mouseover=${this.createTooltip} @mouseout=${this.destroyTooltip} text></calcite-action>${e?.getChartType() === o.BarSeries ? c`<calcite-action class=${h(d.tab)} icon=graph-bar-stacked scale=s alignment=center .active=${this.selectedPanel === n.Series} @click=${() => {
      this.selectedPanel = n.Series;
    }} @mouseover=${this.createTooltip} @mouseout=${this.destroyTooltip} text></calcite-action>` : null}${e?.getChartType() === o.LineSeries ? c`<calcite-action class=${h(d.tab)} icon=graph-line-series scale=s alignment=center .active=${this.selectedPanel === n.Series} @click=${() => {
      this.selectedPanel = n.Series;
    }} @mouseover=${this.createTooltip} @mouseout=${this.destroyTooltip} text></calcite-action>` : null}${e?.getChartType() === o.BoxPlotSeries ? c`<calcite-action class=${h(d.tab)} icon=box-chart-series scale=s alignment=center .active=${this.selectedPanel === n.Series} @click=${() => {
      this.selectedPanel = n.Series;
    }} @mouseover=${this.createTooltip} @mouseout=${this.destroyTooltip} text></calcite-action>` : null}${e?.getChartType() === o.PieSeries ? c`<calcite-action class=${h(d.tab)} icon=graph-pie-slice scale=s alignment=center .active=${this.selectedPanel === n.Slices} @click=${() => {
      this.selectedPanel = n.Slices;
    }} @mouseover=${this.createTooltip} @mouseout=${this.destroyTooltip} text></calcite-action>` : null}${e?.getChartType() !== o.PieSeries ? c`<calcite-action class=${h(d.tab)} icon=graph-axis scale=s alignment=center .active=${this.selectedPanel === n.Axes} @click=${() => {
      this.selectedPanel = n.Axes;
    }} @mouseover=${this.createTooltip} @mouseout=${this.destroyTooltip} text></calcite-action>` : null}${e?.getChartType() !== o.PieSeries ? c`<calcite-action class=${h(d.tab)} icon=graph-guides scale=s alignment=center .active=${this.selectedPanel === n.Guides} @click=${() => {
      this.selectedPanel = n.Guides;
    }} @mouseover=${this.createTooltip} @mouseout=${this.destroyTooltip} text></calcite-action>` : null}<calcite-action class=${h(d.tab)} icon=palette scale=s alignment=center .active=${this.selectedPanel === n.Format} @click=${() => {
      this.selectedPanel = n.Format;
    }} @mouseover=${this.createTooltip} @mouseout=${this.destroyTooltip} text></calcite-action><calcite-action class=${h(d.tab)} icon=text scale=s alignment=center .active=${this.selectedPanel === n.General} @click=${() => {
      this.selectedPanel = n.General;
    }} @mouseover=${this.createTooltip} @mouseout=${this.destroyTooltip} text></calcite-action></calcite-action-bar>` : null}${this.renderChartUIComponent()}</calcite-flow-item>`);
  }
  renderChartUIComponent() {
    const e = this.getModel(this.selectedChartId), t = e?.getLayer();
    let i = null;
    if (e !== void 0 && !this.disableEditing)
      switch (e?.getChartType()) {
        case "barSeries":
          i = c`<arcgis-charts-config-bar-chart class=${h(d.chartUIComponent)} .model=${e} .timeZone=${this.timeZone} .usePopupTemplateFieldsInfo=${this.usePopupTemplateFieldsInfo} .layer=${t} .page=${this.selectedPanel ?? n.Data} .calculatedMinMaxBounds=${this.calculatedMinMaxBounds} .seriesColor=${this.seriesColor}></arcgis-charts-config-bar-chart>`;
          break;
        case "lineSeries":
          i = c`<arcgis-charts-config-line-chart class=${h(d.chartUIComponent)} .model=${e} .timeZone=${this.timeZone} .usePopupTemplateFieldsInfo=${this.usePopupTemplateFieldsInfo} .layer=${t} .page=${this.selectedPanel ?? n.Data} .calculatedDataMinMaxBounds=${this.calculatedDataMinMaxBounds} .calculatedMinMaxBounds=${this.calculatedMinMaxBounds} .seriesColor=${this.seriesColor}></arcgis-charts-config-line-chart>`;
          break;
        case "pieSeries":
          i = c`<arcgis-charts-config-pie-chart class=${h(d.chartUIComponent)} .model=${e} .usePopupTemplateFieldsInfo=${this.usePopupTemplateFieldsInfo} .layer=${t} .chartData=${this.chartData} .page=${this.selectedPanel ?? n.Data} .calculatedMinMaxBounds=${this.calculatedMinMaxBounds} .seriesColor=${this.seriesColor} .filterBySelection=${this.filterBySelection}></arcgis-charts-config-pie-chart>`;
          break;
        case "histogramSeries":
          i = c`<arcgis-charts-config-histogram class=${h(d.chartUIComponent)} .model=${e} .usePopupTemplateFieldsInfo=${this.usePopupTemplateFieldsInfo} .layer=${t} .page=${this.selectedPanel ?? n.Data} .chartData=${this.chartData} .calculatedMinMaxBounds=${this.calculatedMinMaxBounds} .seriesColor=${this.seriesColor}></arcgis-charts-config-histogram>`;
          break;
        case "scatterSeries":
          i = c`<arcgis-charts-config-scatter-plot class=${h(d.chartUIComponent)} .model=${e} .usePopupTemplateFieldsInfo=${this.usePopupTemplateFieldsInfo} .layer=${t} .page=${this.selectedPanel ?? n.Data} .r2=${this.r2} .calculatedDataMinMaxBounds=${this.calculatedDataMinMaxBounds} .calculatedMinMaxBounds=${this.calculatedMinMaxBounds}></arcgis-charts-config-scatter-plot>`;
          break;
        case "boxPlotSeries":
          i = c`<arcgis-charts-config-box-plot class=${h(d.chartUIComponent)} .model=${e} .usePopupTemplateFieldsInfo=${this.usePopupTemplateFieldsInfo} .layer=${t} .page=${this.selectedPanel ?? n.Data} .calculatedMinMaxBounds=${this.calculatedMinMaxBounds} .seriesColor=${this.seriesColor}></arcgis-charts-config-box-plot>`;
          break;
      }
    return i;
  }
}
E("arcgis-charts-config-create-flow", se);
export {
  se as ArcgisChartsConfigCreateFlow
};
