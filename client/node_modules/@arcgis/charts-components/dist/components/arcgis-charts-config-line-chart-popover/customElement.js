import { c as k } from "../../chunks/runtime.js";
import { repeat as b } from "lit-html/directives/repeat.js";
import { keyed as v } from "lit-html/directives/keyed.js";
import { WebChartTimeAggregationTypes as d, RESTFieldType as h, WebChartTemporalBinningUnits as c } from "@arcgis/charts-spec";
import { isEqual as f } from "lodash-es";
import "d3-array";
import { aL as I, aM as F, c9 as P, b3 as x, b1 as C, cg as T } from "../../chunks/interfaces.js";
import "@arcgis/core/geometry/support/jsonUtils.js";
import "@arcgis/core/rest/support/AttributeBinsQuery.js";
import "@arcgis/core/rest/support/Query.js";
import "@arcgis/core/rest/support/StatisticDefinition.js";
import "@arcgis/core/time/TimeExtent.js";
import "@arcgis/core/core/promiseUtils.js";
import "@arcgis/core/request.js";
import { e as A } from "../../chunks/popover-ui-utils.js";
import { LitElement as w, createEvent as y, safeClassMap as o } from "@arcgis/lumina";
import { html as n } from "lit";
import { createRef as g, ref as p } from "lit-html/directives/ref.js";
import { u as D } from "../../chunks/useT9n.js";
import { L as a } from "../../chunks/interfaces2.js";
import { j as L, U as $, i as u, h as E, s as z } from "../../chunks/chart-ui-utils2.js";
import { css as S } from "@lit/reactive-element/css-tag.js";
/*! All material copyright Esri, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.33/esri/copyright.txt for details.
v4.33.19 */
const N = S`.hide{display:none}.am5-modal{width:100%;height:100%;position:absolute;z-index:100000;top:0;left:0}.am5-modal-curtain{top:0;left:0;width:100%;height:100%;position:absolute;background:#fff!important;z-index:100}.am5-modal-wrapper{top:0;left:0;width:100%;height:100%;position:absolute;display:flex;align-items:center;justify-content:center;white-space:nowrap;background:#ffffff80;z-index:101}.am5-modal-content{display:inline-block;padding:1.2em;vertical-align:middle;text-align:start;white-space:normal;background:#fff;border-radius:4px;box-shadow:#00000073 0 0 36px;color:#000}.am5-layer-1000{z-index:1000!important}.arcgis-charts-modal{box-shadow:none!important}.arcgis-charts-modal-header{background-color:#0000000d;font-weight:700;padding:4px;align-content:center}.show{display:block}.notifyPanel{flex:0 1 auto}.disable-interactions{pointer-events:none}.dim-text{color:var(--arcgis-charts-dim-text)}.name{display:flex;flex-direction:column;margin:.5rem;padding:.5rem;background:#fff;min-width:250px}.header{margin:0;font-weight:bolder}.fab{display:flex;justify-content:stretch}.pick-list-item-label{font-size:small}.sort-icon-color{color:#000}.sort-y-axis{transform:rotate(90deg)}calcite-panel{max-height:60vh}calcite-panel .size-section{width:19rem;margin:1rem 0;display:flex;flex-wrap:wrap;justify-content:space-evenly}calcite-panel .size-section calcite-label{width:8rem;margin-bottom:.25rem}calcite-panel .apply-button{width:17rem}`, r = {
  jsAppFlyout: "js-app-flyout",
  name: "line-chart-data-popover",
  numericFieldPickList: "line-chart-data-numeric-fields-pick-list",
  header: "header",
  fab: "fab",
  pickListItemLabel: "pick-list-item-label",
  sizeSection: "size-section",
  applyButton: "apply-button"
};
class K extends w {
  constructor() {
    super(...arguments), this._messages = D(), this.picklist = g(), this.intervalSizeElement = g(), this.intervalTypeElement = g(), this.popoverElement = g(), this.placement = "leading", this.offsetDistance = -200, this.pickListHasChanged = !1, this.layerFieldsInfo = [], this.arcgisChartsConfigLineChartDataPopoverChange = y(), this.arcgisChartsConfigLineChartPopoverClose = y();
  }
  static {
    this.properties = { aggregationLabels: 16, timeAggregationLabels: 16, messageOverrides: 0, headingTitle: 3, referenceElement: 2, open: 7, contentKind: 1, layerFieldsInfo: 0, selectedContent: 1 };
  }
  static {
    this.styles = N;
  }
  async reposition() {
    await this.popoverElement.value?.reposition();
  }
  async willUpdate(e) {
    e.has("selectedContent") && this.selectedContentChange(this.selectedContent, e.get("selectedContent"));
    const t = await Promise.all(L.map(async (i) => await I(i)));
    f(this.aggregationLabels, t) || (this.aggregationLabels = t);
    const s = [d.Start, d.End], l = await Promise.all(s.map(async (i) => await F(i)));
    f(this.timeAggregationLabels, l) || (this.timeAggregationLabels = l);
  }
  async updated() {
    setTimeout(async () => {
      typeof this.picklist.value?.setFocus == "function" && await this.picklist.value?.setFocus();
    }, $.PopoverTimer), A(this.popoverElement.value, this.open), this.hasUpdated || setTimeout(() => {
      this.popoverElement.value?.reposition();
    }, $.PopoverTimer);
  }
  selectedContentChange(e, t) {
    this.pickListHasChanged = !f(e, t);
  }
  buildAggregationPickListItems() {
    return b(L, (e) => e, (e, t) => n`<calcite-list-item .label=${this.aggregationLabels?.[t]} .value=${e} .selected=${u(e, this.selectedContent)}></calcite-list-item>`);
  }
  buildIntervalAlignmentPickListItems() {
    const e = [d.Start, d.End];
    return b(e, (t) => t, (t, s) => n`<calcite-list-item .label=${this.timeAggregationLabels?.[s]} .value=${t} .selected=${u(t, this.selectedContent)}></calcite-list-item>`);
  }
  buildPickListItem(e) {
    return v(e.name, n`<calcite-list-item .label=${P(this.layerFieldsInfo, e.name)} .value=${e.name} .selected=${u(e.name, this.selectedContent)}></calcite-list-item>`);
  }
  buildPickListItems(e) {
    const t = this.layerFieldsInfo?.length ?? 0, s = [];
    switch (e) {
      case a.numericFields: {
        for (let l = 0; l < t; l += 1) {
          const i = this.layerFieldsInfo?.[l];
          i && C(i) && s.push(this.buildPickListItem(i));
        }
        break;
      }
      case a.xAxisField: {
        for (let l = 0; l < t; l += 1) {
          const i = this.layerFieldsInfo?.[l];
          i && (C(i) || i.type === h.Date || i.type === h.DateOnly || i.type === h.TimestampOffset) && s.push(this.buildPickListItem(i));
        }
        break;
      }
      case a.splitByField: {
        const l = v(" ", n`<calcite-list-item label=" " value=" " .selected=${u("", this.selectedContent)}></calcite-list-item>`);
        s.push(l);
        for (let i = 0; i < t; i += 1) {
          const m = this.layerFieldsInfo?.[i];
          m && (x(m) || m.type === h.String) && s.push(this.buildPickListItem(m));
        }
        break;
      }
    }
    return s;
  }
  closePopover() {
    if (this.contentKind === a.numericFields) {
      const e = {
        pickListElement: this.picklist.value,
        eventEmitter: this.arcgisChartsConfigLineChartDataPopoverChange,
        contentKind: this.contentKind
      };
      E(e);
    }
    this.open = !1, this.arcgisChartsConfigLineChartPopoverClose.emit();
  }
  onDataContentTypeChange(e) {
    this.pickListHasChanged = !0;
    const t = e.target.selectedItems;
    this.arcgisChartsConfigLineChartDataPopoverChange.emit({
      contentKind: this.contentKind,
      value: t.map((s) => s.value)
    }), this.open = !1;
  }
  intervalChange() {
    const e = Number.parseInt(this.intervalSizeElement.value?.value ?? ""), t = this.intervalTypeElement.value?.selectedOption?.value;
    !Number.isNaN(e) && e > 0 && this.arcgisChartsConfigLineChartDataPopoverChange.emit({
      contentKind: this.contentKind,
      value: [{ intervalSize: e, intervalUnits: t }]
    }), this.open = !1;
  }
  onNumericFieldsChange(e) {
    e.target !== null && (this.selectedContent = e.target.selectedItems.map((t) => t.value));
  }
  onNumericFieldSelectionDone() {
    this.pickListHasChanged && this.closePopover();
  }
  renderAggregationType() {
    const e = this.buildAggregationPickListItems();
    return n`<calcite-list label class=${o(r.pickListItemLabel)} selection-mode=single selection-appearance=border @calciteListChange=${this.onDataContentTypeChange}>${e}</calcite-list>`;
  }
  renderXAxisField() {
    const e = this.buildPickListItems(a.xAxisField);
    return n`<calcite-list label class=${o(r.pickListItemLabel)} selection-mode=single selection-appearance=border filter-enabled @calciteListChange=${this.onDataContentTypeChange} ${p(this.picklist)}>${e}</calcite-list>`;
  }
  renderNumericFields() {
    const e = this.buildPickListItems(a.numericFields);
    return n`<calcite-list label class=${o(r.numericFieldPickList)} selection-mode=multiple filter-enabled @calciteListChange=${this.onNumericFieldsChange} ${p(this.picklist)}>${e}</calcite-list>`;
  }
  renderSplitByField() {
    const e = this.buildPickListItems(a.splitByField);
    return n`<calcite-list label class=${o(r.pickListItemLabel)} selection-mode=single selection-appearance=border filter-enabled @calciteListChange=${this.onDataContentTypeChange} ${p(this.picklist)}>${e}</calcite-list>`;
  }
  renderIntervalAlignment() {
    const e = this.buildIntervalAlignmentPickListItems();
    return n`<calcite-list label class=${o(r.pickListItemLabel)} selection-mode=single selection-appearance=border @calciteListChange=${this.onDataContentTypeChange}>${e}</calcite-list>`;
  }
  renderInterval() {
    const e = this.selectedContent, t = [
      c.Second,
      c.Minute,
      c.Hour,
      c.Day,
      c.Week,
      c.Month,
      c.Year
    ];
    return n`<div><div class=${o(r.sizeSection)}><calcite-label scale=m>${this._messages.intervalSize}<calcite-input type=number scale=m min=1 step=any .value=${z(e?.size, 1)} ${p(this.intervalSizeElement)}></calcite-input></calcite-label><calcite-label scale=m>${this._messages.intervalType}<calcite-select .label=${this._messages.intervalType ?? ""} ${p(this.intervalTypeElement)}>${t.map((s) => n`<calcite-option .value=${s} .label=${T(s, this._messages)} .selected=${e?.unit === s}></calcite-option>`)}</calcite-select></calcite-label><calcite-button class=${o(r.applyButton)} appearance=outline @click=${this.intervalChange}>${this._messages.apply}</calcite-button></div></div>`;
  }
  renderPopoverInfo() {
    let e;
    switch (this.contentKind) {
      case a.aggregation:
        e = this.renderAggregationType();
        break;
      case a.xAxisField:
        e = this.renderXAxisField();
        break;
      case a.numericFields:
        e = this.renderNumericFields();
        break;
      case a.splitByField:
        e = this.renderSplitByField();
        break;
      case a.intervalAlignment:
        e = this.renderIntervalAlignment();
        break;
      case a.interval:
        e = this.renderInterval();
        break;
    }
    return e;
  }
  render() {
    let e;
    return this.contentKind === a.numericFields && (e = n`<div slot=footer><calcite-fab class=${o(r.fab)} appearance=outline-fill kind=neutral icon .label=${this._messages.selectionDone} scale=s text-enabled .text=${this._messages.selectionDone} @click=${this.onNumericFieldSelectionDone}></calcite-fab></div>`), n`<div class=${o(r.jsAppFlyout)}><calcite-popover class=${o(r.name)} .referenceElement=${this.referenceElement ?? document.body} .placement=${this.placement} .offsetDistance=${this.offsetDistance} @calcitePopoverClose=${this.closePopover} .open=${this.open} label ${p(this.popoverElement)}><calcite-panel closable .closed=${!this.open} @calcitePanelClose=${this.closePopover}><div slot=header-content class=${o(r.header)}>${this.headingTitle ?? ""}</div>${this.renderPopoverInfo()}${e}</calcite-panel></calcite-popover></div>`;
  }
}
k("arcgis-charts-config-line-chart-popover", K);
export {
  K as ArcgisChartsConfigLineChartPopover
};
