import { c as A } from "../../chunks/runtime.js";
import { ref as B } from "lit-html/directives/ref.js";
import { C as M, F as i, L as m } from "../../chunks/common.js";
import { d as y, j as d, h as c, l as S, p as h, m as T, f as V } from "../../chunks/type-guards.js";
import { RESTSimpleLineSymbolStyle as $, RESTSymbolType as f, RESTFontWeight as D, RESTFontStyle as w, RESTFontDecoration as N } from "@arcgis/charts-spec";
import { isEmpty as u, cloneDeep as r, isArray as L, isObject as E, mergeWith as G } from "lodash-es";
import "d3-array";
import "../../chunks/interfaces.js";
import "@arcgis/core/geometry/support/jsonUtils.js";
import "@arcgis/core/rest/support/AttributeBinsQuery.js";
import "@arcgis/core/rest/support/Query.js";
import "@arcgis/core/rest/support/StatisticDefinition.js";
import "@arcgis/core/time/TimeExtent.js";
import "@arcgis/core/core/promiseUtils.js";
import "@arcgis/core/request.js";
import { c as b, e as l } from "../../chunks/index4.js";
import { r as k, c as W, P as O } from "../../chunks/popover-ui-utils.js";
import { n as X } from "../../chunks/chart-ui-utils2.js";
import { u as R } from "../../chunks/useT9n.js";
import { html as P } from "lit";
import { LitElement as Y, createEvent as F, safeClassMap as p } from "@arcgis/lumina";
import { css as j } from "@lit/reactive-element/css-tag.js";
/*! All material copyright Esri, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.33/esri/copyright.txt for details.
v4.33.19 */
const v = {
  type: f.TS,
  color: [1, 1, 1, 255],
  font: {
    family: "Tahoma",
    size: 12,
    decoration: N.None,
    style: w.Normal,
    weight: D.Normal
  }
}, C = {
  type: f.SLS,
  color: [1, 1, 1, 255],
  style: $.Solid,
  width: 2
}, g = {
  element: "chart-element",
  elementList: "element-list",
  sectionLabel: "section-label"
}, _ = j`:host{width:var(--arcgis-charts-config-calcite-block-default-width);margin:var(--arcgis-charts-config-calcite-block-default-margin)}.section-label{display:flex;margin:var(--arcgis-charts-config-margin-major) var(--arcgis-charts-config-margin-minor);justify-content:space-between;align-items:center;font-weight:var(--calcite-font-weight-medium);font-size:var(--calcite-font-size-0)}.element-list{margin:var(--arcgis-charts-config-margin-minor)}.element{user-select:none}`;
class z extends Y {
  constructor() {
    super(...arguments), this._messages = R(), this.formatPopover = null, this.selectableElements = [], this.textProperties = [], this.symbolProperties = [], this.symbolPropertyChange = (t) => {
      const e = t;
      let s;
      if (e.target?.localName === "calcite-list-item" ? s = e.target?.value : s = e.target?.parentNode?.value, this.selectedTexts = [], this.selectedBackground = [], this.selectedSymbols.includes(s))
        this.selectedSymbols = [], this.updateSelectedElement(this.selectedSymbols);
      else {
        const o = this.getFormatValue(s);
        this.selectedSymbols = [s], this.initSelectedSymbols(b(o) ? o : C);
      }
      this.setupFormatPopover();
    }, this.textPropertyChange = (t) => {
      const e = t;
      let s;
      if (e.target?.localName === "calcite-list-item" ? s = e.target?.value : s = e.target?.parentNode?.value, this.selectedSymbols = [], this.selectedBackground = [], e.shiftKey) {
        this.selectedTexts = [];
        const o = this.textProperties.indexOf(this.lastSelectedText ?? s), a = this.textProperties.indexOf(s);
        this.textProperties.forEach((n, x) => {
          x >= Math.min(o, a) && x <= Math.max(o, a) && this.selectedTexts.push(n);
        }), this.updateSelectedElement(this.selectedTexts), this.setupFormatPopover();
      } else if (e.ctrlKey)
        this.selectedTexts.includes(s) ? (this.selectedTexts = this.selectedTexts.filter((o) => o !== s), this.updateSelectedElement(this.selectedTexts)) : (this.selectedTexts = [...this.selectedTexts, s], this.updateSelectedElement(this.selectedTexts)), this.setupFormatPopover();
      else if (this.selectedTexts.includes(s))
        this.selectedTexts = [], this.updateSelectedElement(this.selectedTexts), this.setupFormatPopover();
      else {
        const o = this.getFormatValue(s);
        this.selectedTexts = [s], this.initSelectedTexts(l(o) ? o : v), this.setupFormatPopover();
      }
      this.lastSelectedText = s;
    }, this.backgroundChange = (t) => {
      const e = t;
      let s;
      e.target?.localName === "calcite-list-item" ? s = e.target?.value : s = e.target?.parentNode?.value, this.selectedSymbols = [], this.selectedTexts = [], this.selectedBackground.includes(s) ? (this.selectedBackground = [], this.selectedElement = {}) : (this.selectedBackground = [s], this.selectedElement = u(this.getFormatValue(s)) ? void 0 : this.getFormatValue(s)), this.setupFormatPopover();
    }, this.updateSymbolProps = (t) => {
      const e = t.detail;
      this.selectedSymbols.forEach((s) => {
        this.setFormatValue(s, e);
      }), this.selectedElement = r(t.target.selectedElement);
    }, this.updateBackground = (t) => {
      this.setFormatValue(M.Background, t.detail), this.selectedElement = t.detail;
    }, this.updateTextProps = (t) => {
      const { font: e, color: s } = t.detail;
      this.selectedTexts.forEach((o) => {
        const a = this.getFormatValue(o), n = l(a) ? a : void 0;
        this.setFormatValue(o, {
          ...n,
          type: f.TS,
          font: { ...n?.font, ...e },
          color: s ?? n?.color
        });
      }), this.selectedElement = r(t.target.selectedElement);
    }, this.onModelConfigChange = () => {
      this.requestUpdate();
    }, this.formatPopoverClose = (t) => {
      this.formatPopover === t?.target && (this.selectedTexts = [], this.selectedSymbols = [], this.selectedBackground = [], this.selectedElement = {}, this.removeFormatPopover());
    }, this.mergeFormatValues = (t, e) => {
      let s = !1;
      L(t) && L(e) || E(t) && E(e) ? s = !0 : s = t === e;
      const o = typeof t == "number" || typeof e == "number" ? Number.NaN : "";
      return s ? void 0 : o;
    }, this.openChange = (t) => {
      this.arcgisChartsConfigPopoverOpenChange.emit(t.detail);
    }, this.updateSelectableElements = (t) => {
      t && !this.selectableElements.includes(t) && this.selectableElements.push(t);
    }, this.selectedSymbols = [], this.selectedTexts = [], this.selectedBackground = [], this.arcgisChartsConfigFormatPopoverChange = F(), this.arcgisChartsConfigPopoverOpenChange = F();
  }
  static {
    this.properties = { selectedSymbols: 16, selectedTexts: 16, selectedBackground: 16, selectedElement: 16, messageOverrides: 0, model: 0 };
  }
  static {
    this.styles = _;
  }
  load() {
    this.modelChange(this.model);
  }
  willUpdate(t) {
    t.has("model") && this.modelChange(this.model, t.get("model"));
  }
  disconnectedCallback() {
    super.disconnectedCallback(), this.removeFormatPopover(), this.model.removeEventListener("arcgisChartsModelConfigChange", this.onModelConfigChange);
  }
  modelChange(t, e) {
    e?.removeEventListener("arcgisChartsModelConfigChange", this.onModelConfigChange), t?.addEventListener("arcgisChartsModelConfigChange", this.onModelConfigChange);
  }
  correctTextElementSelection() {
    for (const t of this.selectableElements) {
      const e = this.selectedTexts.includes(t.value) || this.selectedSymbols.includes(t.value) || this.selectedBackground.includes(t.value);
      t.selected = e;
    }
  }
  formatPopoverChange(t) {
    this.arcgisChartsConfigFormatPopoverChange.emit({
      open: t,
      element: this.formatPopover
    }), this.arcgisChartsConfigPopoverOpenChange.emit({
      open: t
    });
  }
  updateSelectedElement(t, e) {
    if (this.selectedElement = void 0, e === void 0) {
      const s = r(this.getFormatValue(t[0]));
      this.selectedElement = t?.reduce((o, a) => {
        const n = this.getFormatValue(a);
        return G(o, n, this.mergeFormatValues);
      }, s);
    } else {
      let s = r(e);
      u(e) && (this.selectedSymbols?.length > 0 && (s = r(C)), this.selectedTexts?.length > 0 && (s = r(v))), this.selectedElement = s;
    }
  }
  initSelectedTexts(t) {
    let e = r(t);
    u(t) && (e = r(v)), this.selectedElement = e;
  }
  initSelectedSymbols(t) {
    let e = r(t);
    u(t) && (e = r(C)), this.selectedElement = e;
  }
  setupFormatPopover() {
    this.formatPopover = k(this.formatPopover);
    const t = this.selectedElement, e = {
      selectedElement: this.selectedElement,
      referenceElement: this.el,
      updateSymbolProps: this.updateSymbolProps,
      updateTextProps: this.updateTextProps,
      updateBackground: this.updateBackground,
      openChange: this.openChange,
      hostElement: this.el,
      placement: "auto",
      popoverClose: this.formatPopoverClose
    };
    this.formatPopover = W(O.FormatPopover, e), t?.type === f.TS || t?.type === f.SLS || // To check if the selected element is background.
    Array.isArray(this.selectedElement) ? (this.formatPopover.open = !0, this.addFormatPopover()) : (this.formatPopover.open = !1, this.removeFormatPopover());
  }
  removeFormatPopover() {
    this.formatPopover !== null && (this.formatPopover.open = !1, this.formatPopover = k(this.formatPopover)), this.formatPopoverChange(!1);
  }
  addFormatPopover() {
    this.formatPopover !== null && !document.body.contains(this.formatPopover) && document.body.appendChild(this.formatPopover), this.formatPopoverChange(!0);
  }
  getFormatValue(t) {
    switch (t) {
      case i.Title:
        return this.model.getTitleSymbol();
      case i.Description:
        return this.model.getDescriptionSymbol();
      case i.XAxisTitle:
        return c(this.model) ? this.model.getXAxisTitleSymbol() : void 0;
      case i.YAxisTitle:
        return d(this.model) ? this.model.getYAxisTitleSymbol() : void 0;
      case i.AxisLabels:
        return c(this.model) ? this.model.getAxisLabelsSymbol() : void 0;
      case i.GuideLabels:
        return T(this.model) ? this.model.getGuideLabelsSymbol() : void 0;
      case i.LegendText:
        return h(this.model) ? this.model.getLegendTextSymbol() : void 0;
      case i.LegendTitle:
        return h(this.model) ? this.model.getLegendTitleSymbol() : void 0;
      case i.DataLabels:
        return S(this.model) ? this.model.getDataLabelsSymbol() : void 0;
      case m.AxisLines:
        return c(this.model) ? this.model.getAxisLinesSymbol() : void 0;
      case m.GridLines:
        return d(this.model) ? this.model.getGridLinesSymbol() : void 0;
      case m.LeaderLines:
        return y(this.model) ? this.model.getTicksSymbol() : void 0;
      case i.Background:
        return this.model.getBackgroundColor();
      default:
        return;
    }
  }
  setFormatValue(t, e) {
    switch (t) {
      case i.Title:
        l(e) && this.model.setTitleSymbol(e);
        break;
      case i.Description:
        l(e) && this.model.setDescriptionSymbol(e);
        break;
      case i.XAxisTitle:
        c(this.model) && l(e) && this.model.setXAxisTitleSymbol(e);
        break;
      case i.YAxisTitle:
        d(this.model) && l(e) && this.model.setYAxisTitleSymbol(e);
        break;
      case i.AxisLabels:
        c(this.model) && l(e) && this.model.setAxisLabelsSymbol(e);
        break;
      case i.GuideLabels:
        T(this.model) && l(e) && this.model.setGuideLabelsSymbol(e);
        break;
      case i.LegendText:
        h(this.model) && l(e) && this.model.setLegendTextSymbol(e);
        break;
      case i.LegendTitle:
        h(this.model) && l(e) && this.model.setLegendTitleSymbol(e);
        break;
      case i.DataLabels:
        S(this.model) && l(e) && this.model.setDataLabelsSymbol(e);
        break;
      case m.AxisLines:
        c(this.model) && b(e) && this.model.setAxisLinesSymbol(e);
        break;
      case m.GridLines:
        d(this.model) && b(e) && this.model.setGridLinesSymbol(e);
        break;
      case m.LeaderLines:
        y(this.model) && b(e) && this.model.setTicksSymbol(e);
        break;
      case i.Background:
        Array.isArray(e) && this.model.setBackgroundColor(e);
        break;
    }
  }
  renderFormatElements() {
    this.textProperties = [
      i.Title,
      ...c(this.model) ? [i.XAxisTitle] : [],
      ...d(this.model) ? [i.YAxisTitle] : [],
      ...h(this.model) ? [i.LegendTitle] : [],
      i.Description,
      ...h(this.model) ? [i.LegendText] : [],
      ...c(this.model) ? [i.AxisLabels] : [],
      ...T(this.model) ? [i.GuideLabels] : [],
      ...S(this.model) ? [i.DataLabels] : []
    ], V(this.model) && (this.textProperties = this.textProperties.filter((s) => s !== i.DataLabels)), this.symbolProperties = [
      i.Background,
      ...c(this.model) ? [m.AxisLines] : [],
      ...d(this.model) ? [m.GridLines] : [],
      ...y(this.model) ? [m.LeaderLines] : []
    ];
    const t = this.textProperties.map((s) => this.renderTextElement(s, this.textPropertyChange)), e = this.symbolProperties.map((s) => s === i.Background ? this.renderTextElement(s, this.backgroundChange) : this.renderTextElement(s, this.symbolPropertyChange));
    return { textElements: t, symbolElements: e };
  }
  renderTextElement(t, e) {
    const s = X(t), o = this.getFormatValue(t), a = typeof o == "string" ? o : "", n = this.selectedTexts.includes(t) || this.selectedSymbols.includes(t) || this.selectedBackground.includes(t);
    return P`<calcite-list-item class=${p(g.element)} .label=${this._messages[t]} .description=${a} .value=${t} .selected=${n} @click=${e} ${B(this.updateSelectableElements)}>${s !== void 0 ? P`<calcite-icon slot=content-start scale=s .icon=${s}></calcite-icon>` : null}</calcite-list-item>`;
  }
  render() {
    const { textElements: t, symbolElements: e } = this.renderFormatElements();
    return P`<div class=${p(g.sectionLabel)}>${this._messages.textElements}</div><calcite-list label class=${p(g.elementList)} selection-mode=multiple selection-appearance=border @calciteListChange=${this.correctTextElementSelection}>${t}</calcite-list><div class=${p(g.sectionLabel)}>${this._messages.symbolElements}</div><calcite-list label class=${p(g.elementList)} selection-mode=single selection-appearance=border>${e}</calcite-list>`;
  }
}
A("arcgis-charts-config-format", z);
export {
  z as ArcgisChartsConfigFormat
};
