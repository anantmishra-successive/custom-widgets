/*! All material copyright Esri, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.33/esri/copyright.txt for details.
v4.33.19 */
function N(e) {
  e.el.childElem && (e.el.childElem.ownedBy = e.el);
  const i = v(e);
  if (!i) {
    const t = y(e);
    if (!t) {
      g(e);
      return;
    }
    return f(t, e, !0), t;
  }
  return w(i, e.el.parent) || (e.el.parent = i, i.localName === "arcgis-expand" ? E(i, e) : i.localName === "arcgis-placement" ? P(i, e) : f(i, e, !1)), i;
}
function v({ el: e }) {
  for (let i = e.parentElement; i; i = i?.parentElement ?? null) {
    if (c.has(i.localName))
      return i;
    if ("ownedBy" in i && i.ownedBy instanceof HTMLElement && c.has(i.ownedBy.localName))
      return i.ownedBy;
  }
}
const c = /* @__PURE__ */ new Set([
  "arcgis-map",
  "arcgis-scene",
  "arcgis-link-chart",
  "arcgis-expand",
  "arcgis-placement"
]);
function w(e, i) {
  if (e !== i)
    return !1;
  const t = e.localName;
  return t === "arcgis-expand" || t === "arcgis-placement";
}
function a(e, i, t = "arcgisReady") {
  const s = e;
  if (s.view)
    i(s.view);
  else {
    let r = function(l) {
      l.target === e && (a(e, i, t), e.removeEventListener(t, r));
    };
    e.addEventListener(t, r);
  }
}
const E = (e, i) => a(e, (t) => {
  i.el.childElem && e.content != null && e.content.append(i.el.childElem), e.expandIcon = i.icon || i.widget?.icon || e.expandIcon, i.position = e.position, i.el.view = t;
}), P = (e, i) => a(e, (t) => {
  i.el.childElem && i.el.append(i.el.childElem), i.position = e.position, i.el.view = t;
}), f = (e, i, t) => a(
  e,
  (s) => {
    t ? g(i) : i.el.childElem && b(e, i), i.el.view = s;
  },
  "arcgisViewReadyChange"
);
function b(e, i) {
  const t = i.el.childElem ?? i.el, s = e?.childElem, r = [...e.children], l = {};
  for (const n of r) {
    if (n === s)
      continue;
    const o = n.position ?? "manual";
    l[o] ??= [], l[o].push({ child: n, position: o, index: r.indexOf(n) });
  }
  const h = l[i.position ?? "manual"]?.findIndex(({ child: n }) => n === i.el), d = e.view.ui;
  d.remove(t), d.add(t, { position: i.position, index: h });
}
function T(e) {
  let i = !1, t = e.el.view;
  const s = Object.getOwnPropertyDescriptor(Object.getPrototypeOf(e.el), "view") ?? {
    get: () => t,
    set: (r) => t = r
  };
  Object.defineProperty(e.el, "view", {
    get: s.get.bind(e.el),
    set: (r) => {
      s.set.call(e.el, r), r && !i && (i = !0, e.arcgisReady.emit());
    },
    configurable: !0,
    enumerable: !0
  }), t && (e.el.view = t);
}
function p(e) {
  return e == null || e === "";
}
function x(e, i) {
  return i != null && e?.position === i.position && e?.heading === i.heading && e?.tilt === i.tilt && e?.fov === i.fov;
}
function S(e, i) {
  return i === void 0 || e?.targetGeometry !== i?.targetGeometry || e?.rotation !== i?.rotation || e?.scale !== i?.scale;
}
function B(e, i) {
  return u(i?.center, e);
}
function u(e, i) {
  if (typeof i == "string")
    return u(e, i.split(",").map(Number));
  if (!e)
    return i;
  if (Array.isArray(i)) {
    const t = i[0], s = i[1], r = i.length > 2 ? i[2] : void 0;
    if (t !== e.longitude || s !== e.latitude || r !== e.z)
      return i;
  } else if (i && !e?.equals(i))
    return i;
}
async function F(e, i) {
  i != null && (typeof i == "string" ? e.el.view = await C(e, i) : e.widget && (e.el.view = i.view));
}
async function C(e, i) {
  const t = y(e, i);
  return await new Promise((s) => {
    typeof t?.view?.ready == "boolean" ? s(t.view) : t && t.addEventListener("arcgisViewReadyChange", () => s(t.view), { once: !0 });
  });
}
function g(e) {
  e.el.childElem && (e.el.shadowRoot ?? e.el).append(e.el.childElem);
}
function y(e, i) {
  const t = i ?? e.referenceElement;
  if (typeof t != "string")
    return t ?? void 0;
  const s = t.includes("#") || t.includes(".") || t.includes("["), r = e.el.getRootNode();
  return (s ? void 0 : r.querySelector(`#${t}`)) ?? r.querySelector(t) ?? void 0;
}
const L = (e) => e.el.childElem;
async function O(e) {
  const i = typeof e == "function" ? e() : e;
  i && ("setFocus" in i && typeof i.setFocus == "function" ? await i.setFocus() : i instanceof HTMLElement && i.focus());
}
export {
  N as a,
  x as b,
  B as c,
  T as d,
  p as e,
  L as g,
  S as i,
  u as p,
  F as r,
  O as s
};
