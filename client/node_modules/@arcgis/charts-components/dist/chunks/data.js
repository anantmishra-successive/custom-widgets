import { WebChartStackedKinds as Te, WebChartStatisticType as b, WebChartTypes as C, defaultBarLineFromFieldsName as P, WebChartOrderDataByTypes as L, WebChartSortOrderKinds as N, defaultBarLineFromFieldsValue as Be, defaultPieFromFieldsValue as we, WebChartTemporalBinningTypes as W, RESTFieldType as ye, WebChartNullPolicyTypes as ne, RESTSymbolType as Ce, WebChartCalendarBinningUnits as Le, WebChartFixedDateBinningUnits as ke } from "@arcgis/charts-spec";
import { capitalize as E, memoize as ue, isEmpty as Ne, cloneDeep as ve } from "lodash-es";
import "d3-array";
import { bS as Ie, c0 as y, a4 as Z, al as Oe, a2 as De, a0 as Ve, aV as qe, c5 as $e, aL as me, c9 as j, bR as D, k as R, bO as je, cs as M, m as I, b5 as Me, bt as pe, b6 as ee, b7 as te, cd as Ue, h as ie, cr as Ee, i as Pe, b4 as Ke, a5 as We, a6 as Re, ao as ze, ap as Xe, ar as Ye, b3 as ce } from "./interfaces.js";
import "@arcgis/core/geometry/support/jsonUtils.js";
import "@arcgis/core/rest/support/AttributeBinsQuery.js";
import "@arcgis/core/rest/support/Query.js";
import "@arcgis/core/rest/support/StatisticDefinition.js";
import "@arcgis/core/time/TimeExtent.js";
import "@arcgis/core/core/promiseUtils.js";
import "@arcgis/core/request.js";
import { q as _e, l as k, n as He, o as Ge, j as B, k as w } from "./index4.js";
import { a as Qe, S } from "./common.js";
import { g as se } from "./series-types.js";
import { u as ge } from "./index3.js";
/*! All material copyright Esri, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.33/esri/copyright.txt for details.
v4.33.19 */
async function ae(t = Ie().locale) {
  let e = await import("./messages.en3.js");
  switch (t) {
    case y.Arabic:
      e = await import("./messages.ar3.js");
      break;
    case y.Bosnian:
      e = await import("./messages.bs3.js");
      break;
    case y.Bulgarian:
      e = await import("./messages.bg3.js");
      break;
    case y.Catalan:
      e = await import("./messages.ca3.js");
      break;
    case y.Czech:
      e = await import("./messages.cs3.js");
      break;
    case y.Danish:
      e = await import("./messages.da3.js");
      break;
    case y.German:
      e = await import("./messages.de3.js");
      break;
    case y.Greek:
      e = await import("./messages.el3.js");
      break;
    case y.EnglishUSA:
      e = await import("./messages.en-US3.js");
      break;
    case y.Spanish:
      e = await import("./messages.es3.js");
      break;
    case y.Estonian:
      e = await import("./messages.et3.js");
      break;
    case y.French:
      e = await import("./messages.fr3.js");
      break;
    case y.Finnish:
      e = await import("./messages.fi3.js");
      break;
    case y.Hebrew:
      e = await import("./messages.he3.js");
      break;
    case y.Croatian:
      e = await import("./messages.hr3.js");
      break;
    case y.Hungarian:
      e = await import("./messages.hu3.js");
      break;
    case y.Indonesian:
      e = await import("./messages.id3.js");
      break;
    case y.Italian:
      e = await import("./messages.it3.js");
      break;
    case y.Japanese:
      e = await import("./messages.ja3.js");
      break;
    case y.Korean:
      e = await import("./messages.ko3.js");
      break;
    case y.Lithuanian:
      e = await import("./messages.lt3.js");
      break;
    case y.Latvian:
      e = await import("./messages.lv3.js");
      break;
    case y.NorwegianBokml:
      e = await import("./messages.no3.js");
      break;
    case y.Dutch:
      e = await import("./messages.nl3.js");
      break;
    case y.Polish:
      e = await import("./messages.pl3.js");
      break;
    case y.PortugueseBrazil:
      e = await import("./messages.pt-BR3.js");
      break;
    case y.PortuguesePortugal:
      e = await import("./messages.pt-PT3.js");
      break;
    case y.Romanian:
      e = await import("./messages.ro3.js");
      break;
    case y.Russian:
      e = await import("./messages.ru3.js");
      break;
    case y.Serbian:
      e = await import("./messages.sr3.js");
      break;
    case y.Slovak:
      e = await import("./messages.sk3.js");
      break;
    case y.Slovenian:
      e = await import("./messages.sl3.js");
      break;
    case y.Swedish:
      e = await import("./messages.sv3.js");
      break;
    case y.Thai:
      e = await import("./messages.th3.js");
      break;
    case y.Turkish:
      e = await import("./messages.tr3.js");
      break;
    case y.Ukrainian:
      e = await import("./messages.uk3.js");
      break;
    case y.Vietnamese:
      e = await import("./messages.vi3.js");
      break;
    case y.ChineseChina:
      e = await import("./messages.zh-CN3.js");
      break;
    case y.ChineseHongKong:
      e = await import("./messages.zh-HK3.js");
      break;
    case y.ChineseTaiwan:
      e = await import("./messages.zh-TW3.js");
      break;
    case y.English:
  }
  return e;
}
function X(t, e, i) {
  const s = t?.axes?.[e];
  s?.title !== void 0 ? s.title.content.text = i : s !== void 0 && (s.title = De({
    text: i,
    visible: !0,
    font: Ve(qe.AxisTitle)
  }));
}
async function _(t) {
  const { config: e, layerInfo: i, numericFields: s, aggregationType: a } = t;
  let r = "";
  if (e) {
    const c = $e(e) === Te.Stacked100, o = await ae();
    if (c)
      r = o.axisLabels.percent;
    else {
      const m = await me(a);
      if (s.length === 1) {
        const l = j(i.layerFieldsInfo, s[0]);
        a === b.NoAggregation ? r = l : a === b.Count && s[0] === i.objectIdField ? r = o.axisLabels.count : r = D(o.axisLabels.aggregationOfFieldName, {
          aggregation: m,
          fieldName: l
        });
      } else s.length > 1 && (a === b.NoAggregation ? r = o.axisLabels.values : r = D(o.axisLabels.aggregationOfValues, {
        aggregation: m
      }));
    }
  }
  return r;
}
const Fe = async (t, e) => t.axes?.[e] ?? (await Oe(t.type))[e], fe = (t, e, i) => {
  t.axes !== void 0 && (t.axes[i] = e);
}, H = (t, e, i) => {
  let s = Number.NaN;
  return i ? s = t.axes?.[e]?.maximum : s = t.axes?.[e]?.minimum, s ?? Number.NaN;
}, G = async (t, e, i, s) => {
  const a = t?.axes?.[i];
  s && a !== void 0 ? a.maximum = e : !s && a !== void 0 && (a.minimum = e);
}, Ot = (t) => H(t, 1, !0), q = async (t, e) => {
  await G(t, e, 1, !0);
}, Dt = (t) => H(t, 1, !1), $ = async (t, e) => {
  await G(t, e, 1, !1);
}, Vt = (t) => H(t, 0, !0), Je = async (t, e) => {
  await G(t, e, 0, !0);
}, qt = (t) => H(t, 0, !1), Ze = async (t, e) => {
  await G(t, e, 0, !1);
}, et = (t) => t.axes?.[0]?.valueFormat ?? Z(), tt = async (t, e) => {
  const i = await Fe(t, 0);
  if (i !== void 0 && e !== void 0) {
    const s = {
      ...i,
      valueFormat: e
    };
    fe(t, s, 0);
  }
}, $t = (t) => {
  let e;
  return _e(t.axes?.[1]?.valueFormat) && (e = t.axes?.[1]?.valueFormat), e;
}, jt = async (t, e) => {
  const i = await Fe(t, 1);
  if (i !== void 0 && e !== void 0) {
    const s = {
      ...i,
      valueFormat: e
    };
    fe(t, s, 1);
  }
}, de = (t, e, i) => {
  const s = t.axes?.[e];
  s !== void 0 && (s.integerOnlyValues = i);
}, it = (t) => {
  let e = S.xAxisAsc;
  const i = t.orderOptions?.data?.orderType ?? L.Category, s = t.orderOptions?.data?.orderBy ?? N.Ascending;
  return i === L.Category && Array.isArray(s) ? e = S.customSort : i === L.Category ? s === N.Ascending ? e = S.xAxisAsc : e = S.xAxisDesc : s === N.Ascending ? e = S.yAxisAsc : e = S.yAxisDesc, e;
}, st = (t) => {
  const e = se(t.series);
  let i = !1;
  return (e === C.BarSeries || e === C.LineSeries) && (i = it(t) === S.customSort), i;
}, Mt = (t) => {
  let e = [];
  const i = t.orderOptions?.data?.orderType;
  return st(t) && i === L.Category && (e = t.orderOptions?.data?.orderBy), e;
}, Ut = (t, e, i) => {
  let s = L.Category, a = N.Ascending;
  const r = se(e.series);
  e.orderOptions ??= {}, t === S.customSort && i !== void 0 ? (a = [...i], e.orderOptions.data = {
    orderType: s,
    orderBy: a
  }) : (r === C.BarSeries || r === C.LineSeries) && (s = t === S.xAxisAsc || t === S.xAxisDesc ? L.Category : L.YValue, a = t === S.xAxisAsc || t === S.yAxisAsc ? N.Ascending : N.Descending, e.orderOptions.data = {
    orderType: s,
    orderBy: a
  });
}, U = (t) => t?.series?.[0]?.x ?? "", re = (t) => {
  const {
    config: e,
    numericFields: i,
    aggregationType: s,
    mode: a,
    layer: r,
    numericFieldIndex: c,
    seriesIndex: o,
    splitByField: m = ""
  } = t, l = se(e.series), f = R(e.series), n = r ? je(r).objectIdField : "FID", g = U(e), d = i.length === 1 && i[0] === n;
  let u = "y", p = "y";
  switch (l) {
    case C.PieSeries: {
      s !== b.NoAggregation ? a === Qe.Category ? (u = `${s}_${i[0]}_0`.toUpperCase(), p = d ? E(b.Count) : E(`${s} of ${i[0]}`)) : u = we : u = i[0];
      break;
    }
    case C.BarSeries:
    case C.LineSeries:
    case C.ComboLineAndBarSeries:
    case C.RadarSeries: {
      if (m === "" || i.length > 1)
        g === P || g === void 0 || g.trim() === "" || f === M.BarAndLineFromFields ? u = Be : (u = `${s}_${i[c ?? 0]}_${c ?? 0}`.toUpperCase(), p = d ? E(b.Count) : E(`${s} of ${i[c ?? 0]}`));
      else {
        const F = i[0];
        u = `${s}_${F}_${o ?? 0}`.toUpperCase(), p = d ? E(b.Count) : E(`${s} of ${F}`);
      }
      break;
    }
  }
  return {
    name: u,
    description: p
  };
}, at = (t) => {
  let e;
  const i = t.series[0];
  return I(i) && (e = i.temporalBinning?.size), e;
}, rt = (t) => {
  let e;
  const i = t.series[0];
  return I(i) && (e = i.temporalBinning?.unit), e;
}, lt = (t) => {
  let e;
  const i = t.series[0];
  return I(i) && (e = i.temporalBinning?.timeAggregationType), e;
}, ot = (t) => {
  let e;
  const i = t.series[0];
  return I(i) && (e = i.temporalBinning?.trimIncompleteTimeInterval), e;
}, nt = (t) => {
  let e;
  const i = t.series[0];
  return I(i) && (e = i.temporalBinning?.nullPolicy), e;
}, Se = (t, e) => {
  e?.series?.forEach((i) => {
    I(i) && (i.temporalBinning ??= { type: W.FixedDateBased }, i.temporalBinning.size = t);
  }), $(e, null), q(e, null);
}, ct = (t, e) => {
  e?.series?.forEach((i) => {
    I(i) && (i.temporalBinning ??= { type: W.FixedDateBased }, i.temporalBinning.nullPolicy = t);
  }), $(e, null), q(e, null);
}, Et = (t, e) => {
  e.series?.forEach((i) => {
    I(i) && (i.temporalBinning ??= { type: W.FixedDateBased }, i.temporalBinning.unit = t);
  }), $(e, null), q(e, null);
}, Pt = (t, e) => {
  e.series?.forEach((i) => {
    I(i) && (i.temporalBinning ??= { type: W.FixedDateBased }, i.temporalBinning.timeAggregationType = t);
  }), $(e, null), q(e, null);
}, Kt = (t, e) => {
  e.series?.forEach((i) => {
    I(i) && (i.temporalBinning ??= { type: W.FixedDateBased }, i.temporalBinning.trimIncompleteTimeInterval = t);
  }), $(e, null), q(e, null);
}, Wt = (t) => {
  Se(0, t);
};
async function dt(t) {
  const { config: e, layer: i, xAxisField: s, splitByField: a, layerFieldsInfo: r, aggregationFields: c, fetchNullValues: o } = t, l = r.filter((x) => x.name === a)[0]?.type, f = o !== !0 ? `${a} IS NOT NULL` : "", n = s && o !== !0 ? `${s} IS NOT NULL` : "", { where: g } = e?.dataFilters ?? {}, d = {
    where: pe([g, f, n]),
    // excluding the null values from the list
    orderByFields: Ue(a) ? [] : [`${a} ${N.Ascending}`],
    // default sorting ascending for split-by field
    geometry: e?.dataFilters?.geometry
  }, u = i;
  let p = "";
  c.length === 0 ? p = u?.objectIdField ?? "" : [p] = c;
  let F = await ge({
    queryObject: u,
    category: e?.series[0].x ?? "",
    splitByField: a,
    queryConfig: d
  });
  if (e) {
    const x = e?.series.map((A) => ie({ where: A.query?.where })?.toString() ?? "").filter((A) => A !== void 0 && A !== "");
    F = Ee({
      arrayA: F,
      arrayB: x,
      getKey: (A) => A.toString()
    });
  }
  return { categoriesArray: F, splitByFieldType: l, numericalField: p };
}
function Rt(t, e) {
  let i = e === "";
  for (const s of t)
    if (e === s.name) {
      i = !0;
      break;
    }
  return i;
}
function zt(t, e) {
  const i = Me(t);
  let s = e.length === 0, a = 0;
  for (const r of e) {
    for (const c of i)
      if (r === c && (a += 1), a === e.length) {
        s = !0;
        break;
      }
    if (s)
      break;
  }
  return s;
}
function Xt(t, e) {
  e.forEach((i) => {
    Object.getOwnPropertyNames(i.prototype).forEach((s) => {
      Object.defineProperty(
        t.prototype,
        s,
        Object.getOwnPropertyDescriptor(i.prototype, s) || /* @__PURE__ */ Object.create(null)
      );
    });
  });
}
async function yt(t) {
  const { layerInfo: e, config: i, category: s } = t, { layer: a } = e, { where: r } = i?.dataFilters ?? {}, { fetchNullValues: c } = i?.series?.[0]?.query ?? {}, o = c !== !0 ? `${s} IS NOT NULL` : "", m = {
    where: pe([r, o]),
    // excluding the null values from the list
    orderByFields: [],
    geometry: i?.dataFilters?.geometry
  }, l = ee(a);
  return (
    // fetch unique category values asynchronously
    (await ge({ queryObject: a, category: s, queryConfig: m })).map((n) => {
      const g = String(n);
      return te({
        fieldName: s,
        fieldValueToMatch: g,
        subtypeInfo: l,
        // use the retrieved subtype information
        fieldList: e.layerFieldsInfo
        // list of field information from the layer
      }) ?? g;
    })
  );
}
async function Y(t) {
  const { seriesIndex: e, config: i, layerInfo: s } = t, { objectIdField: a } = s ?? {};
  let r;
  const c = i.series[e ?? 0];
  let o = !1, m = !1;
  if (c === void 0) {
    const d = i.series;
    o = d.slice(0, e).every((u) => B(u)), m = d.slice(0, e).every((u) => w(u));
  } else
    o = B(c), m = w(c);
  o ? r = await ze({
    seriesIndex: e,
    objectIDField: a
  }) : m ? r = await Xe({
    seriesIndex: e,
    objectIDField: a
  }) : r = await Ye({
    seriesIndex: e,
    objectIDField: a
  });
  const l = U(i), f = i.series[0]?.dataLabels?.visible ?? !1, n = {
    ...r,
    x: l,
    y: "",
    dataLabels: {
      ...r.dataLabels,
      type: r.dataLabels?.type ?? C.Text,
      content: r.dataLabels?.content ?? { type: Ce.TS },
      visible: f
    }
  }, g = V(i);
  if (n.query = {
    groupByFieldsForStatistics: [l]
  }, g !== b.NoAggregation && a !== void 0) {
    const d = `${g}_${a}_0`.toUpperCase();
    n.y = d, n.query.outStatistics = [
      {
        statisticType: g,
        onStatisticField: a,
        outStatisticFieldName: d
      }
    ];
  }
  if (B(n) || w(n)) {
    let d;
    if (i?.series?.[0] !== void 0 && (d = R(i.series)), d !== M.BarAndLineNoAggregation && d !== M.BarAndLineSplitByNoAggregation) {
      let u = rt(i);
      u === Le.Quarter && (u = ke.Month), n.temporalBinning = {
        type: W.FixedDateBased,
        size: at(i),
        unit: u,
        timeAggregationType: lt(i),
        trimIncompleteTimeInterval: ot(i),
        nullPolicy: nt(i)
      };
    }
  }
  return ve(n);
}
async function Q(t, e) {
  const { layerFieldsInfo: i, objectIdField: s } = e, a = U(t), r = R(t.series), c = v(t), o = V(t), m = K(t), l = c.length === 0 || c.includes(s), f = await me(o), n = l ? "" : c.map((h) => j(i ?? [], h)).join(", "), g = j(i ?? [], a), d = j(i ?? [], m), u = t.series.some((h) => k(h)), p = u ? "category" : "xAxisField", F = g;
  let x = "";
  const A = await ae();
  if (r === M.BarAndLineFromFields)
    x = D(A.titleLabels.aggrTypeOfAggrFields, {
      aggregationType: f,
      aggregationFields: n
    });
  else if (o === b.NoAggregation) {
    const h = l ? s : n;
    if (m === "") {
      const z = u ? "aggrTypeCategory" : "aggrTypeXAxisField";
      x = D(A.titleLabels[z], {
        aggregationType: h,
        [p]: F
      });
    } else {
      const z = u ? "aggrTypeCategoryBySplitBy" : "aggrTypeXAxisFieldBySplitBy";
      x = D(A.titleLabels[z], {
        aggregationType: h,
        [p]: F,
        splitByField: d
      });
    }
  } else if (o === b.Count)
    if (m === "") {
      const h = u ? "aggrTypeCategory" : "aggrTypeXAxisField";
      x = D(A.titleLabels[h], {
        aggregationType: f,
        [p]: F
      });
    } else {
      const h = u ? "aggrTypeCategoryBySplitBy" : "aggrTypeXAxisFieldBySplitBy";
      x = D(A.titleLabels[h], {
        aggregationType: f,
        [p]: F,
        splitByField: d
      });
    }
  else if (m !== "") {
    const h = u ? "aggrTypeOfAggrFieldByCategoryBySplitByField" : "aggrTypeOfAggrFieldByXAxisFieldBySplitByField";
    x = D(A.titleLabels[h], {
      aggregationType: f,
      aggregationField: n,
      [p]: F,
      splitByField: d
    });
  } else if (c.length > 0) {
    const h = u ? "aggrTypeOfAggrFieldsByCategory" : "aggrTypeOfAggrFieldsByXAxisField";
    x = D(A.titleLabels[h], {
      aggregationType: f,
      aggregationFields: n,
      [p]: F
    });
  }
  return x;
}
const be = (t) => ie({
  where: t.query?.where,
  normalize: !1,
  escape: !1
}) ?? "", V = (t) => t?.series?.[0]?.query?.outStatistics?.[0]?.statisticType ?? b.NoAggregation, Yt = async (t, e, i) => {
  const s = v(e), a = K(e);
  await oe({
    splitByField: a,
    numericFields: s,
    aggregationType: t,
    config: e,
    layerInfo: i
  });
  const r = await _({
    config: e,
    layerInfo: i,
    numericFields: v(e),
    aggregationType: V(e)
  });
  X(e, 1, r), e.title && (e.title.content.text = await Q(e, i)), await $(e, null), await q(e, null), le(e, i);
}, K = ue(
  (t) => {
    const e = t?.series?.[0]?.query?.where?.split("=")[0].trim() ?? "";
    return Pe(t?.series?.[0]?.query?.where) ? "" : e;
  },
  (t) => t?.series?.[0]?.query?.where
), _t = async (t, e, i) => {
  const s = v(e), a = V(e);
  await oe({
    splitByField: t,
    numericFields: s,
    aggregationType: a,
    config: e,
    layerInfo: i
  });
  const r = await _({
    config: e,
    layerInfo: i,
    numericFields: v(e),
    aggregationType: V(e)
  });
  X(e, 1, r), e.title && (e.title.content.text = await Q(e, i)), await $(e, null), await q(e, null);
}, v = ue(
  // without memoizing, the worst case efficiency is O(series.length), best case is O(1)
  // with memoizing, the worst case efficiency for repeated calls becomes O(1)
  (t) => {
    let e = [];
    if (K(t) === "")
      e = t?.series.map((i) => {
        const s = i.query?.outStatistics?.map((a) => a.onStatisticField) ?? [];
        return s?.length > 0 ? s : i.y;
      }).flat() ?? [];
    else {
      const i = t?.series?.[0], s = i?.query?.outStatistics?.[0]?.onStatisticField ?? [i?.y].flat()[0];
      e = s !== void 0 ? [s] : [];
    }
    return [...new Set(e.filter((i) => i !== ""))];
  },
  // using series array address as key, since a change to the numeric fields will always rebuild a fresh series array
  (t) => t?.series
), ut = async (t, e, i) => {
  const { objectIdField: s } = i;
  let a = V(e);
  t.length === 0 ? (t.push(s), a = b.Count) : a === b.Count && t.length >= 1 && !t.includes(s) && (a = b.Sum);
  const r = K(e);
  await oe({
    splitByField: r,
    numericFields: t,
    aggregationType: a,
    config: e,
    layerInfo: i
  });
  const c = await _({
    config: e,
    layerInfo: i,
    numericFields: v(e),
    aggregationType: V(e)
  });
  X(e, 1, c), e.title && (e.title.content.text = await Q(e, i)), await $(e, null), await q(e, null), le(e, i);
}, Ht = async (t, e, i) => {
  const { layerFieldsInfo: s } = i ?? {}, a = e?.series?.length ?? 0, r = U(e);
  let c;
  const o = e.series.some((n) => k(n)), m = He(e.series), l = Ge(e.series);
  if (s !== void 0) {
    const n = Ke(s);
    !n.includes(r) && n.includes(t) ? c = We() : n.includes(r) && !n.includes(t) && (o ? c = Z() : c = Re()), s.find((d) => d.name === t)?.type === ye.String && (c = Z()), c !== void 0 && await tt(e, c);
  }
  a === 0 && (e.series = [await Y({ config: e, layerInfo: i })]), e.series.forEach((n) => {
    n.x = t, n.query !== void 0 && (n.query.groupByFieldsForStatistics = [t]);
  });
  const f = j(s, t);
  if (X(e, 0, f), i !== void 0) {
    const n = await _({
      config: e,
      layerInfo: i,
      numericFields: v(e),
      aggregationType: V(e)
    });
    X(e, 1, n), e.title && (e.title.content.text = await Q(e, i)), le(e, i);
    const g = v(e);
    await ut(g, e, i);
  }
  if (await $(e, null), await q(e, null), m || l) {
    await Ze(e, null), await Je(e, null), Se(0, e);
    const n = c?.type === C.DateAxisFormat ? ne.Null : ne.Interpolate;
    ct(n, e);
  }
};
function le(t, e) {
  let i = !1;
  const s = V(t), a = v(t);
  s === b.Count ? i = !0 : s === b.NoAggregation && (i = a.every((o) => {
    const m = e.layerFieldsInfo.find((l) => l.name === o);
    return m !== void 0 ? ce(m) : !1;
  })), de(t, 1, i);
  const r = t.series.some((o) => B(o)), c = t.series.some((o) => w(o));
  if (r || c) {
    const o = U(t), m = e.layerFieldsInfo.find((f) => f.name === o), l = m !== void 0 && ce(m);
    de(t, 0, l);
  }
}
const mt = (t) => {
  let e = S.xAxisAsc;
  const i = t.orderOptions?.data?.orderType ?? L.Category, s = t.orderOptions?.data?.orderBy ?? N.Ascending;
  return i === L.Category && Array.isArray(s) ? e = S.customSort : i === L.Category ? s === N.Ascending ? e = S.xAxisAsc : e = S.xAxisDesc : s === N.Ascending ? e = S.yAxisAsc : e = S.yAxisDesc, e;
};
async function pt(t) {
  const { numericFields: e, aggregationType: i, config: s, layerInfo: a } = t;
  let r = !1;
  const c = await Y({
    config: s,
    layerInfo: a,
    seriesIndex: 0
  }), o = await ae(), m = re({
    config: s,
    numericFields: e,
    aggregationType: i,
    layer: a.layer
  }).name, l = {
    ...c,
    id: `series_${Date.now()}`,
    name: o.axisLabels.values,
    x: P,
    y: m
  }, f = [];
  for (const g of e)
    f.push({
      onStatisticField: g,
      outStatisticFieldName: `${g}_0`.toUpperCase(),
      statisticType: i
    });
  l.query = { outStatistics: f };
  const n = s.series[0];
  return n !== void 0 && (l.id = n.id, s.colorMatch || (k(n) && k(l) ? l.fillSymbol = n.fillSymbol : (B(l) && B(n) || w(l) && w(n)) && (l.lineSymbol = n.lineSymbol, l.markerSymbol = n.markerSymbol), r = !0), l.id = n.id, n.name !== c.name && (l.name = n.name)), s.series.length === 1 && !s.colorMatch && (k(l) ? l.fillSymbol = s.series[0].fillSymbol : (B(l) || w(l)) && (l.lineSymbol = s.series[0].lineSymbol, l.markerSymbol = s.series[0].markerSymbol), r = !0), s.colorMatch = !r, [l];
}
async function xe(t) {
  const { numericFields: e, aggregationType: i, config: s, layerInfo: a } = t, { layerFieldsInfo: r, objectIdField: c } = a, o = [];
  let m = !1;
  for (let l = 0; l < e.length; l += 1) {
    const f = await Y({
      config: s,
      layerInfo: a,
      seriesIndex: l
    }), n = re({
      config: s,
      numericFields: e,
      aggregationType: i,
      layer: a.layer,
      numericFieldIndex: l
    }).name, g = e[l];
    let d = {
      ...f,
      query: {
        ...f.query
      }
    };
    g !== c && (d = {
      ...d,
      id: g,
      name: j(r, g)
    });
    let u = g;
    d.query !== void 0 && (i !== b.NoAggregation ? (u = n, d.query.outStatistics = [
      {
        ...f.query?.outStatistics?.[0] ?? {},
        onStatisticField: g,
        outStatisticFieldName: n,
        statisticType: i
      }
    ]) : delete d.query.outStatistics), d.y = u;
    const p = s.series.find(
      (F) => F.query?.outStatistics?.[0]?.onStatisticField === g && F.query.where === void 0
    );
    if (p !== void 0 && typeof p.y == "string" && p.y.trim() !== "") {
      s.colorMatch || (k(d) && k(p) ? d.fillSymbol = p.fillSymbol : (B(d) && B(p) || w(d) && w(p)) && (d.lineSymbol = p.lineSymbol, d.markerSymbol = p.markerSymbol), m = !0);
      const F = await Y({
        config: s,
        layerInfo: a,
        seriesIndex: l
      });
      d.id = p.id, p.id !== F.id && p.name !== F.name && (d.id = p.id, d.name = p.name);
    }
    o.push(d);
  }
  return s.series.length === 1 && o.length === 1 && !s.colorMatch && (k(s.series[0]) && k(o[0]) ? o[0].fillSymbol = s.series[0].fillSymbol : (B(s.series[0]) && B(o[0]) || w(s.series[0]) && w(o[0])) && (o[0].lineSymbol = s.series[0].lineSymbol, o[0].markerSymbol = s.series[0].markerSymbol), m = !0), s.colorMatch = !m, o;
}
async function gt(t) {
  const { splitByField: e, numericFields: i, aggregationType: s, config: a, layerInfo: r } = t, { layer: c, layerFieldsInfo: o } = r, { fetchNullValues: m } = a?.series?.[0]?.query ?? {}, l = U(a), f = l !== P ? l : void 0, { categoriesArray: n, splitByFieldType: g, numericalField: d } = await dt({
    config: a,
    layer: c,
    layerFieldsInfo: o,
    xAxisField: f,
    aggregationFields: i,
    splitByField: e,
    fetchNullValues: m
  });
  let u = [], p = !1;
  if (n.length === 0) {
    u = await xe({
      numericFields: i,
      aggregationType: s,
      config: a,
      layerInfo: r
    });
    for (const F of u)
      F.query && (F.query.where = `${e}=''`);
  } else
    for (let F = 0; F < n.length; F += 1) {
      const x = n[F], A = re({
        config: a,
        numericFields: i,
        aggregationType: s,
        layer: r.layer,
        seriesIndex: F,
        splitByField: e
      }).name, h = await Y({
        config: a,
        layerInfo: r,
        seriesIndex: F
      }), z = {
        fieldName: e,
        fieldValueToMatch: x ?? "",
        subtypeInfo: ee(r.layer),
        fieldList: r.layerFieldsInfo
      }, he = te(z), J = `${x}`, T = {
        ...h,
        id: J,
        name: he ?? J,
        y: A,
        query: {
          ...h.query,
          where: `${e}=${g === ye.String && x !== null ? `'${x}'` : x}`,
          outStatistics: s !== b.NoAggregation ? [
            {
              ...h.query?.outStatistics?.[0] ?? {},
              onStatisticField: d,
              outStatisticFieldName: A,
              statisticType: s
            }
          ] : void 0
        }
      };
      s === b.NoAggregation && (T.query !== void 0 && (delete T.query.outStatistics, delete T.query.groupByFieldsForStatistics), T.y = d);
      const O = a.series.find(
        (Ae) => String(be(Ae)).trim().replace(/'/gu, "") === J
      );
      O !== void 0 && (a.colorMatch || (k(T) && k(O) ? T.fillSymbol = O.fillSymbol : (B(T) && B(O) || w(T) && w(O)) && (T.lineSymbol = O.lineSymbol, T.markerSymbol = O.markerSymbol), p = !0), T.id = O.id, T.name = O.name), u.push(T);
    }
  return a.colorMatch = !p, u;
}
const oe = async (t) => {
  const { splitByField: e, numericFields: i, aggregationType: s, config: a, layerInfo: r } = t, { x: c } = a.series[0], o = R(a.series);
  e === "" || i.length > 1 ? c === P || c === void 0 || c.trim() === "" || o === M.BarAndLineFromFields ? a.series = await pt({
    config: a,
    layerInfo: r,
    numericFields: i,
    aggregationType: s
  }) : a.series = await xe({
    config: a,
    layerInfo: r,
    numericFields: i,
    aggregationType: s
  }) : a.series = await gt({
    config: a,
    layerInfo: r,
    splitByField: e,
    numericFields: i,
    aggregationType: s
  });
}, Gt = (t) => {
  const { config: e, seriesIndex: i, layerInfo: s, commonStrings: a } = t, r = e.series?.[i], c = K(e);
  let o;
  if (R(e.series) === M.BarAndLineFromFields)
    o = a.axisLabels.values;
  else if (Ne(c)) {
    const l = r.query?.outStatistics?.[0]?.onStatisticField;
    l !== void 0 && l !== s.objectIdField && (o = j(s.layerFieldsInfo, l));
  } else {
    const l = String(be(r)).trim().replace(/'/gu, ""), f = {
      fieldName: K(e),
      fieldValueToMatch: l ?? "",
      subtypeInfo: ee(s.layer),
      fieldList: s.layerFieldsInfo
    };
    o = te(f) ?? l;
  }
  return o ?? r.id;
}, Qt = (t, e) => {
  e.orderOptions ??= {};
  const i = e.orderOptions?.data?.orderType;
  mt(e) === S.customSort && i === L.Category && (e.orderOptions.data = {
    orderType: L.Category,
    orderBy: [...t]
  });
}, Jt = (t) => t.dataFilters, Zt = (t, e) => {
  t !== void 0 ? e.dataFilters = t : delete e.dataFilters;
}, ei = async (t, e) => {
  const i = U(t), s = et(t)?.type, a = v(t), r = R(t.series);
  let c = [];
  return s === C.CategoryAxisFormat && (r === M.BarAndLineFromFields || i === P ? c = a.map((o) => j(e?.layerFieldsInfo, o)) : i.trim() !== "" && i !== P && e !== void 0 && (c = await yt({
    layerInfo: e,
    config: t,
    category: i
  }))), c;
}, ti = (t, e) => {
  e.series.forEach((i) => {
    i.query && (i.query.fetchNullValues = t);
  });
}, ii = (t) => t.series.some((e) => e.query?.fetchNullValues), si = (t) => (
  // TODO: Look into split-by values gotchas cases once done
  t.series.map((e) => String(ie({ where: e.query?.where }))).filter((e) => e !== void 0 && e.trim() !== "")
);
export {
  lt as A,
  Pt as B,
  ot as C,
  Kt as D,
  nt as E,
  ct as F,
  Wt as G,
  Ht as H,
  ut as I,
  Yt as J,
  _t as K,
  Jt as L,
  Zt as M,
  mt as N,
  ei as O,
  Ut as P,
  Mt as Q,
  Qt as R,
  oe as S,
  ti as T,
  ii as U,
  Vt as V,
  qt as W,
  Ot as X,
  Dt as Y,
  $t as Z,
  jt as _,
  Je as a,
  $ as b,
  q as c,
  re as d,
  Gt as e,
  ae as f,
  _ as g,
  Xt as h,
  zt as i,
  Rt as j,
  tt as k,
  et as l,
  yt as m,
  dt as n,
  de as o,
  U as p,
  V as q,
  v as r,
  Ze as s,
  si as t,
  X as u,
  K as v,
  at as w,
  Se as x,
  rt as y,
  Et as z
};
