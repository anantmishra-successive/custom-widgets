/// <reference types="@arcgis/core/interfaces.d.ts" />
import { AccessorController } from '@arcgis/lumina/controllers/accessor';
import { Nil } from '@arcgis/components-utils';
import { default as ArcgisMap } from '@arcgis/core/Map';
import { ArcgisReferenceElement } from '../utils/component-utils';
import { LitElement, EventEmitter } from '@arcgis/lumina';
import { PropertyValues } from 'lit';
type Requires<Props, Widget extends WidgetInstance> = LitElement & Pick<Widget, keyof Props & keyof Widget> & Uses<Widget>;
type WidgetInstance = __esri.Widget & {
    state?: string;
    viewModel?: __esri.Accessor & {
        state?: string;
        view?: __esri.LinkChartView | __esri.MapView | __esri.SceneView | Nil;
        map?: ArcgisMap | Nil;
    };
    view?: __esri.LinkChartView | __esri.MapView | __esri.SceneView | Nil;
    map?: ArcgisMap | Nil;
    visibleElements?: Record<never, unknown>;
};
type Uses<Widget extends WidgetInstance> = {
    state?: Exclude<Widget["viewModel"], Nil>["state"] | Widget["state"];
    viewModel?: Widget["viewModel"];
    closed?: boolean;
    icon: Nil | string;
    label: Nil | string;
    referenceElement?: ArcgisReferenceElement | string;
    position: __esri.UIPosition;
    arcgisReady: EventEmitter;
    arcgisPropertyChange: EventEmitter<{
        name: string;
    }> | undefined;
    el: HTMLElement & {
        childElem?: HTMLElement & {
            ownedBy?: HTMLElement;
        };
        view?: __esri.LinkChartView | __esri.MapView | __esri.SceneView;
    };
    autoDestroyDisabled: boolean;
    destroy: () => Promise<void>;
};
/**
 * A controller for a wrapped JS API Widget
 * - loads the widget
 * - initializes the widget with the component's properties
 * - does two-way binding between widget and component properties
 * - re-emits the widgets's events on the component
 * - type-checks everything âœ¨
 *
 * Documentation:
 * https://qawebgis.esri.com/components/lumina/transition-from-widgets#usewidget-controller
 */
export declare const makeWidgetController: <Props, Widget extends WidgetInstance, OmitProps extends string = never>(createWidget: ((props?: Props) => Widget) | (new (props?: Props) => Widget), _options?: {
    /**
     * Don't expose the following Widget's properties on the component.
     * You can also bind the property to \@State rather than \@Prop if you
     * wish to use it internally only:
     *
     * @example
     * \@state() timeZone = this.widget.timeZone;
     */
    omitProps: OmitProps[];
}) => (component: Requires<Omit<Props, OmitProps | "container" | "id" | "view" | "visible" | "visibleElements">, Widget>) => Widget;
export declare class WidgetController<Props, Widget extends WidgetInstance> extends AccessorController<Props, Widget, Uses<Widget>> {
    #private;
    constructor(component: Requires<Props, Widget> & Uses<Widget>, createWidget: ((props?: Props) => Widget) | (new (props?: Props) => Widget));
    hostConnected(): void;
    hostLoad(): void;
    hostUpdate(changes: PropertyValues<Uses<Widget>>): void;
    hostLoaded(): void;
    hostDestroy(): void;
}
export {};
