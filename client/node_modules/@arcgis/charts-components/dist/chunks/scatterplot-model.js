import { WebChartTypes as f } from "@arcgis/charts-spec";
import { isEmpty as l, isEqual as v } from "lodash-es";
import "d3-array";
import { ai as b, aj as r, c9 as c, bR as M, b3 as C, aE as F } from "./interfaces.js";
import "@arcgis/core/geometry/support/jsonUtils.js";
import "@arcgis/core/rest/support/AttributeBinsQuery.js";
import "@arcgis/core/rest/support/Query.js";
import "@arcgis/core/rest/support/StatisticDefinition.js";
import "@arcgis/core/time/TimeExtent.js";
import "@arcgis/core/core/promiseUtils.js";
import "@arcgis/core/request.js";
import { s as T, a as A, b as _, c as w, u as m, f as I, o as Y, h as X } from "./data.js";
import { C as k, M as z, b as O, a as P } from "./model-with-y-guides.js";
import { M as W, a as D, b as E, c as U } from "./model-with-data-labels.js";
/*! All material copyright Esri, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.33/esri/copyright.txt for details.
v4.33.19 */
const S = (s) => {
  T(s, null), A(s, null), _(s, null), w(s, null);
}, p = (s) => {
  const { name: e, axisIndex: t, config: i, layerInfo: d } = s, { layerFieldsInfo: a } = d, n = a.find((y) => y.name === e), o = n !== void 0 && C(n);
  Y(i, t, o);
}, u = async (s) => {
  const { x: e, y: t, config: i, layerInfo: d } = s, { layerFieldsInfo: a } = d, n = c(a, e), o = c(a, t);
  if (l(e) || m(i, 0, n), l(t) || m(i, 1, o), !l(e) && !l(t)) {
    const y = await I(), L = M(y.titleLabels.xAndY, { x: n, y: o });
    i.title?.content && (i.title.content.text = L);
  }
}, x = (s) => s.series[0]?.x ?? "", g = (s) => s.series[0]?.y ?? "", B = async (s, e, t) => {
  S(e), e.series[0] && (e.series[0].x = s), await u({
    x: s,
    y: g(e),
    config: e,
    layerInfo: t
  }), p({
    name: s,
    axisIndex: 0,
    config: e,
    layerInfo: t
  });
}, V = async (s, e, t) => {
  S(e), e.series[0] && (e.series[0].y = s), await u({
    x: x(e),
    y: s,
    config: e,
    layerInfo: t
  }), p({
    name: s,
    axisIndex: 1,
    config: e,
    layerInfo: t
  });
}, G = (s) => {
  const e = {};
  return s.series[0]?.markerSymbol ?? e;
}, j = (s, e) => {
  e.series[0] && (e.series[0].markerSymbol = s);
}, q = (s) => (s.series[0]?.overlays?.trendLine?.visible ?? !0) && (s.series[0]?.overlays?.trendLine?.created ?? !1), R = (s) => {
  const e = {};
  return s.series[0]?.overlays?.trendLine?.symbol ?? e;
}, H = (s, e) => {
  e.series[0].overlays ??= r(), e.series[0].overlays.trendLine ??= r().trendLine, e.series[0].overlays.trendLine.symbol = s;
}, J = (s, e) => {
  e.series[0].overlays ??= r(), e.series[0].overlays.trendLine ??= r().trendLine, e.series[0].overlays.trendLine.visible = s;
}, K = (s, e) => {
  !(e.series[0]?.overlays?.trendLine?.created ?? !1) && s && (e.series[0].overlays ??= r(), e.series[0].overlays.trendLine ??= r().trendLine, e.series[0].overlays.trendLine.created = s), J(s, e);
}, h = (s) => s.series[0]?.sizePolicy ?? b(), Q = (s, e) => {
  e.series[0] && (s !== void 0 && s.field?.trim() !== "" ? e.series[0].sizePolicy = { ...e.series[0].sizePolicy, ...s } : e.series[0].sizePolicy = void 0);
}, Z = (s) => s?.series?.[0]?.overlays, $ = (s, e) => {
  e?.series[0] !== void 0 && (e.series[0].overlays = s);
};
class N extends k {
  constructor() {
    super(...arguments), this._chartType = f.ScatterSeries;
  }
  async setup(e) {
    await this.loadConfigFromLayer(e), this.resolveSetup();
  }
  // ---------------------------------------------------------------------------------------------
  // Data Props
  // ---------------------------------------------------------------------------------------------
  /**
   * Gets the x-axis field.
   * @returns {string}
   */
  getXAxisField() {
    return x(this._config);
  }
  /**
   * Sets the x-axis field.
   * @param {string} fieldName
   * @async **This method is `async` and must be awaited for the changes to take effect.**
   */
  async setXAxisField(e) {
    await B(e, this._config, this.layerInfo), this.dispatchEvent(new CustomEvent("arcgisChartsModelDataChange")), this.emitConfigUpdate("setXAxisField");
  }
  /**
   * Gets the y-axis field.
   * @returns {string}
   */
  getYAxisField() {
    return g(this._config);
  }
  /**
   * Sets the y-axis field.
   * @param {string} fieldName
   * @async **This method is `async` and must be awaited for the changes to take effect.**
   */
  async setYAxisField(e) {
    await V(e, this._config, this.layerInfo), this.dispatchEvent(new CustomEvent("arcgisChartsModelDataChange")), this.emitConfigUpdate("setYAxisField");
  }
  /**
   * Gets whether the linear trend line is shown.
   * @returns {boolean}
   */
  getShowLinearTrend() {
    return q(this._config);
  }
  /**
   * Sets whether to show the linear trend line.
   * @param {boolean} show
   */
  setShowLinearTrend(e) {
    K(e, this._config), this.emitConfigUpdate("setShowLinearTrend");
  }
  /**
   * Gets the line symbol for the linear trend line.
   * @returns {ISimpleLineSymbol}
   */
  getLinearTrendSymbol() {
    return R(this._config);
  }
  /**
   * Sets the line symbol for the linear trend line.
   * @param {ISimpleLineSymbol} symbol
   */
  setLinearTrendSymbol(e) {
    H(e, this._config), this.emitConfigUpdate("setLinearTrendSymbol");
  }
  /**
   * Gets the marker symbol used for the scatter plot points when using a fixed symbol (i.e. no size policy is set).
   * @returns {ISimpleMarkerSymbol}
   */
  getFixedMarkerSymbol() {
    return G(this._config);
  }
  /**
   * Sets the marker symbol used for the scatter plot points when using a fixed symbol (i.e. no size policy is set).
   * @param {ISimpleMarkerSymbol} symbol
   */
  setFixedMarkerSymbol(e) {
    j(e, this._config), this.emitConfigUpdate("setFixedMarkerSymbol");
  }
  /**
   * Gets the size policy for the scatter plot points. This is used to scale the size of the marker symbol based on a given field.
   * @returns {SizePolicy | undefined}
   */
  getSizePolicy() {
    return h(this._config);
  }
  /**
   * Sets the size policy for the scatter plot points. This is used to scale the size of the marker symbol based on a given field.
   * @param {SizePolicy | undefined} sizePolicy
   */
  setSizePolicy(e) {
    const t = h(this._config);
    v(t, e) || (Q(e, this._config), this.emitConfigUpdate("setSizePolicy"));
  }
  /**
   * Gets the chart overlays. The scatter plot implements only 1 overlay, **trendLine**.
   */
  getSeriesOverlays() {
    return Z(this._config);
  }
  /**
   * Sets the chart overlays. The scatter plot implements only 1 overlay, **trendLine**.
   * @param {ScatterplotOverlays} overlays The overlays
   */
  setSeriesOverlays(e) {
    $(e, this._config), this.emitConfigUpdate("setSeriesOverlays");
  }
  // ---------------------------------------------------------------------------------------------
  // Protected methods
  // ---------------------------------------------------------------------------------------------
  async generateDefaultConfig() {
    return await F();
  }
}
X(N, [
  z,
  W,
  D,
  E,
  U,
  O,
  P
]);
export {
  N as ScatterplotModel
};
