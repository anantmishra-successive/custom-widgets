import { WebChartStackedKinds as y } from "@arcgis/charts-spec";
import "lodash-es";
import "d3-array";
import { aq as F, ag as I, a8 as B, a6 as v, k as g, cs as l, o as A } from "./interfaces.js";
import "@arcgis/core/geometry/support/jsonUtils.js";
import "@arcgis/core/rest/support/AttributeBinsQuery.js";
import "@arcgis/core/rest/support/Query.js";
import "@arcgis/core/rest/support/StatisticDefinition.js";
import "@arcgis/core/time/TimeExtent.js";
import "@arcgis/core/core/promiseUtils.js";
import "@arcgis/core/request.js";
import { C as u, M as O, b as M, a as b } from "./model-with-y-guides.js";
import { l as S, j as C } from "./index4.js";
import { w as U, x, y as L, z as D, A as w, B as N, C as E, D as V, E as k, F as W, G as P, g as X, q as T, r as o, u as j, b as z, c as K, p as Y, H as G, I as c, J as q, v as R, j as H, K as J, i as Q, L as Z, M as $, N as f, O as d, P as h, Q as m, R as p, S as ee, h as ie } from "./data.js";
import { S as te } from "./common.js";
import { M as se, a as ae, b as oe, c as ne } from "./model-with-data-labels.js";
import { M as re } from "./model-with-rotation.js";
/*! All material copyright Esri, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.33/esri/copyright.txt for details.
v4.33.19 */
class ge extends u {
  /**
   * Sets the time interval size for a temporal bar/line chart.
   * @returns {number | undefined}
   */
  getTemporalBinningSize() {
    return U(this._config);
  }
  /**
   * Sets the time interval size for a temporal bar/line chart.
   * @param {number | undefined} newSize The new time interval size.
   */
  setTemporalBinningSize(e) {
    x(e, this._config), this.emitConfigUpdate("setTemporalBinningSize");
  }
  /**
   * Gets the time interval units for a temporal bar/line chart.
   * @returns {WebChartFixedDateBinningUnits | undefined}
   */
  getTemporalBinningUnit() {
    return L(this._config);
  }
  /**
   * Sets the time interval units for a temporal bar/line chart.
   * @param {WebChartFixedDateBinningUnits | undefined} newUnit The new time interval units.
   */
  setTemporalBinningUnit(e) {
    D(e, this._config), this.emitConfigUpdate("setTemporalBinningUnit");
  }
  /**
   * Gets the time aggregation type for a temporal bar/line chart.
   * @returns {WebChartTimeAggregationTypes | undefined}
   */
  getTimeAggregationType() {
    return w(this._config);
  }
  /**
   * Sets the time aggregation type for a temporal bar/line chart.
   * @param {WebChartTimeAggregationTypes | undefined} newTimeAggregationType The new time aggregation type.
   */
  setTimeAggregationType(e) {
    N(e, this._config), this.emitConfigUpdate("setTimeAggregationType");
  }
  /**
   * Gets whether to trim incomplete time intervals for a temporal bar/line chart.
   * @returns {boolean | undefined}
   */
  getTrimIncompleteTimeInterval() {
    return E(this._config);
  }
  /**
   * Sets whether to trim incomplete time intervals for a temporal bar/line chart.
   * @param {boolean | undefined} newTrimIncompleteTimeInterval The new state.
   */
  setTrimIncompleteTimeInterval(e) {
    V(e, this._config), this.emitConfigUpdate("setTrimIncompleteTimeInterval");
  }
  /**
   * Gets the policy which tells the chart how to handle null values.
   *
   * `null`: Break the bar where null values are present.
   *
   * `zero`: Treats null values as zero.
   *
   * `interpolate`: Bar series: same effect as `null` - Line series: connects the lines across null values.
   *
   * @return {WebChartNullPolicyTypes | undefined}
   */
  getNullPolicy() {
    return k(this._config);
  }
  /**
   * Sets the policy which tells the chart how to handle null values.
   *
   * `null`: Break the bar where null values are present.
   *
   * `zero`: Treats null values as zero.
   *
   * `interpolate`: Bar series: same effect as `null` - Line series: connects the lines across null values.
   *
   * @param {WebChartNullPolicyTypes | undefined} newNullPolicy The new null policy.
   */
  setNullPolicy(e) {
    W(e, this._config), this.emitConfigUpdate("setNullPolicy");
  }
  /**
   * Resets the time interval to default for a temporal line chart.
   */
  resetTimeInterval() {
    P(this._config), this.emitConfigUpdate("resetTimeInterval");
  }
}
const le = (s, e) => e.series?.[s].assignToSecondValueAxis ?? !1, ce = (s, e, i) => {
  i.series?.[e] && (i.series[e].assignToSecondValueAxis = s);
}, fe = (s, e) => e.series?.[s]?.name, de = (s, e, i) => {
  i.series?.[e] && (i.series[e].name = s);
}, he = (s, e) => {
  const i = e.series?.[s];
  let t;
  return S(i) ? t = i.fillSymbol?.color : C(i) && (t = i.lineSymbol?.color), t;
}, me = (s, e, i) => {
  const t = i.series?.[e];
  t && (S(t) ? t.fillSymbol = {
    ...F(e),
    ...t.fillSymbol,
    color: s
  } : C(t) && (t.lineSymbol = {
    ...I(e),
    ...t.lineSymbol,
    color: s
  }));
}, pe = (s) => s.series.map((e) => e.id), ye = (s, e) => {
  e.series?.sort(
    (i, t) => s.findIndex((a) => i.id === a) - s.findIndex((a) => t.id === a)
  );
}, ue = (s) => s.stackedType ?? y.Side, Se = async (s) => {
  const { newStackedType: e, config: i, layerInfo: t } = s;
  if (i.stackedType = e, t !== void 0) {
    const a = await X({
      config: i,
      layerInfo: t,
      numericFields: o(i),
      aggregationType: T(i)
    });
    j(i, 1, a);
  }
  i.axes?.[1] && (e === y.Stacked100 ? i.axes[1].valueFormat = B() : i.axes[1].valueFormat = v()), await z(i, null), await K(i, null);
};
class Ce extends u {
  // ---------------------------------------------------------------------------------------------
  // Data Props
  // ---------------------------------------------------------------------------------------------
  /**
   * Gets the x-axis field for the chart.
   * @returns {string}
   */
  getXAxisField() {
    return Y(this._config);
  }
  /**
   * Sets the x-axis field for the chart.
   * @param {string} newXAxisField The new x-axis field.
   */
  async setXAxisField(e) {
    const i = e.trim() === "";
    i || await G(e, this._config, this.layerInfo);
    const t = o(this._config), r = g(this._config.series) === l.BarAndLineFromFields, n = t.includes(this.layerInfo?.objectIdField ?? "");
    if (i || r && n) {
      await this.resetConfig();
      const _ = t.length === 1 && t[0] === this.layerInfo?.objectIdField;
      this.layerInfo && t.length > 0 && !_ && await c(t, this._config, this.layerInfo);
    }
    this.dispatchEvent(new CustomEvent("arcgisChartsModelDataChange")), this.emitConfigUpdate("setXAxisField");
  }
  /**
   * Gets the aggregation type for the bar chart.
   * @returns {WebChartStatisticType}
   */
  getAggregationType() {
    return T(this._config);
  }
  /**
   * Sets the aggregation type for the chart.
   * @param {WebChartStatisticType} newAggregationType The new aggregation type. Must be one of the values allowed by `WebChartStatisticType`.
   * @async **This method is `async` and must be awaited for the changes to take effect.**
   */
  async setAggregationType(e) {
    this.layerInfo && (await q(e, this._config, this.layerInfo), this.dispatchEvent(new CustomEvent("arcgisChartsModelDataChange")), this.emitConfigUpdate("setAggregationType"));
  }
  /**
   * Gets whether the series should be assigned to the second value axis.
   * @param seriesIndex - The index of the series.
   * @returns {boolean}
   */
  getAssignToSecondValueAxis(e) {
    return le(e, this._config);
  }
  /**
   * Sets whether the series should be assigned to the second value axis.
   * @param assign - The value for the setting.
   * @param seriesIndex - The index of the series.
   */
  setAssignToSecondValueAxis(e, i) {
    ce(e, i, this._config), this.emitConfigUpdate("setAssignToSecondValueAxis");
  }
  /**
   * Gets the split-by field for the chart.
   * @returns {string}
   */
  getSplitByField() {
    return R(this._config);
  }
  /**
   * Sets the split-by field for the chart.
   * @param {string} newSplitByField The new split-by field.
   * @async **This method is `async` and must be awaited for the changes to take effect.**
   */
  async setSplitByField(e) {
    this.layerInfo?.layerFieldsInfo && H(this.layerInfo?.layerFieldsInfo, e) && (await J(e, this._config, this.layerInfo), this.dispatchEvent(new CustomEvent("arcgisChartsModelDataChange")), this.emitConfigUpdate("setSplitByField"));
  }
  /**
   * Gets the numeric fields array for the chart.
   * @returns {string[]}
   */
  getNumericFields() {
    return o(this._config);
  }
  /**
   * Sets the numeric field or numeric fields array for the chart.
   * @param {string | string[]} newNumericFields The new numeric field string or numeric fields array.
   * @async **This method is `async` and must be awaited for the changes to take effect.**
   */
  async setNumericFields(e) {
    if (typeof e == "string" && (e = [e]), Q(this.layerInfo?.layerFieldsInfo ?? [], e) && this.layerInfo) {
      await c(e, this._config, this.layerInfo);
      const t = o(this._config);
      g(this._config.series) === l.BarAndLineFromFields && t.some((n) => n === this.layerInfo?.objectIdField) && await this.resetConfig(), this.dispatchEvent(new CustomEvent("arcgisChartsModelDataChange")), this.emitConfigUpdate("setNumericFields");
    }
  }
  /**
   * Gets the data filter for the bar chart.
   * @returns {WebChartDataFilters | undefined}
   */
  getDataFilter() {
    return Z(this._config);
  }
  /**
   * Sets the data filter for the bar chart.
   * @param {WebChartDataFilters | undefined} newDataFilter The new data filter.
   */
  async setDataFilter(e) {
    $(e, this._config);
    const i = f(this._config);
    if (i === te.customSort) {
      const t = await d(this._config, this.layerInfo);
      h(i, this._config, t);
    }
    this.dispatchEvent(new CustomEvent("arcgisChartsModelDataChange")), this.emitConfigUpdate("setDataFilter");
  }
  /**
   * Gets the list of the category values for the chart.
   * @returns {string[]}
   */
  async getCustomSortValues() {
    return await d(this._config, this.layerInfo);
  }
  /**
   * Gets the sort order for the bar chart.
   * @returns {"xAxisAsc" | "xAxisDesc" | "yAxisAsc" | "yAxisDesc" | "customSort"}
   */
  getSortOrder() {
    return f(this._config);
  }
  /**
   * Sets the sort order for the bar chart.
   * @param {"xAxisAsc" | "xAxisDesc" | "yAxisAsc" | "yAxisDesc"}  newSortOrder The new sort order.
   * @param {string[]} orderByList The list of category's values to order by.
   */
  setSortOrder(e, i) {
    h(e, this._config, i), this.emitConfigUpdate("setSortOrder");
  }
  /**
   * Gets the list of custom sort values for custom sort
   * @returns {string[]}
   */
  getOrderByList() {
    return m(this._config);
  }
  /**
   * Sets the list of custom sort values for custom sort
   * @param {string[]} newOrderByList The new list of custom sort values
   */
  setOrderByList(e) {
    !A(this._config) && (p(e, this._config), this.emitConfigUpdate("setOrderByList"));
  }
  /**
   * Updates the series based on the layer filter.
   * @async **This method is `async` and must be awaited for the changes to take effect.**
   */
  async updateSeriesFromLayerFilter() {
    this.layerInfo !== void 0 && (await ee({
      splitByField: this.getSplitByField(),
      numericFields: this.getNumericFields(),
      aggregationType: this.getAggregationType(),
      config: this._config,
      layerInfo: this.layerInfo
    }), this.dispatchEvent(new CustomEvent("arcgisChartsModelDataChange")), this.emitConfigUpdate("updateSeriesFromLayerFilter"));
  }
  // ---------------------------------------------------------------------------------------------
  // Series Props
  // ---------------------------------------------------------------------------------------------
  /**
   * Gets the name of the series based on the series index.
   * If the index is out of bounds, it will return `undefined`.
   * @param {number} seriesIndex The index of the series.
   * @returns {string | undefined}
   */
  getSeriesName(e) {
    return fe(e, this._config);
  }
  /**
   * Sets name of the series based on the series index.
   * @param {string} name The name for the series.
   * @param {number} seriesIndex The index of the series.
   */
  setSeriesName(e, i) {
    de(e, i, this._config), this.emitConfigUpdate("setSeriesName");
  }
  /**
   * Gets the color of the series based on the series index. If the index is out of bounds, it will return `undefined`.
   * @param {number} seriesIndex The index of the series.
   * @returns {Color | undefined}
   */
  getSeriesColor(e) {
    return he(e, this._config);
  }
  /**
   * Sets the color of the series based on the series index.
   * @param {Color | undefined} newColor The new color for the series.
   * @param {number} seriesIndex The index of the series.
   */
  setSeriesColor(e, i) {
    me(e, i, this._config), this.emitConfigUpdate("setSeriesColor");
  }
  /**
   * Gets the order of the series array by returning an array of series ids.
   * @returns {string[]}
   */
  getOrderOfSeries() {
    return pe(this._config);
  }
  /**
   * Sets the order of the series array by providing an array of series ids.
   * @param {string[]} newOrder The new order of the series array.
   */
  setOrderOfSeries(e) {
    ye(e, this._config), this.emitConfigUpdate("setOrderOfSeries");
  }
  /**
   * Gets how the bars/lines should be placed when multiple series are rendered in the same chart, say when "split by" operation is executed on any field or
   * when multiple attributes/fields corresponding to the same set of classes are to be visualized.
   *
   * Currently this property is only used for bar and line series.
   *
   * @default sideBySide
   *
   * @returns {WebChartStackedKinds | undefined}
   */
  getStackedType() {
    return ue(this._config);
  }
  /**
   * Sets how the bars/lines should be placed when multiple series are rendered in the same chart, say when "split by" operation is executed on any field or
   * when multiple attributes/fields corresponding to the same set of classes are to be visualized.
   *
   * Currently this property is only used for bar and line series.
   *
   * @param {WebChartStackedKinds | undefined} newStackedType The new stacked type.
   *
   * @default sideBySide
   */
  async setStackedType(e) {
    await Se({
      newStackedType: e,
      config: this._config,
      layerInfo: this.layerInfo
    }), this.emitConfigUpdate("setStackedType");
  }
  /**
   * Moves a series from one index in the series array to another.
   * @param {number} fromIndex Index to move the series from.
   * @param {number} toIndex Index to move the series to.
   */
  moveSeries(e, i) {
    const t = this.getOrderOfSeries(), [a] = t.splice(e, 1);
    t.splice(i, 0, a), this.setOrderOfSeries(t), this.emitConfigUpdate("moveSeries");
  }
  /**
   * Moves the custom sort values in-place for the order by list in the config.
   *
   * NOTE: This method should be only used when the sort order is set to `SerialChartDataSortingKinds.customSort`.
   * @param {number} fromIndex The index to move the custom sort value from.
   * @param {number} toIndex The index to move the custom sort value to.
   */
  moveCustomSortValuesInOrderByList(e, i) {
    const t = m(this._config), [a] = t.splice(e, 1);
    t.splice(i, 0, a), p(t, this._config), this.emitConfigUpdate("moveCustomSortValuesInOrderByList");
  }
  /**
   * Resets the config to the default config
   */
  async resetConfig() {
    const e = this._config.id;
    this._config = await this.generateDefaultConfig(), this._config.id = e, this.dispatchEvent(new CustomEvent("arcgisChartsModelDataChange")), this.emitConfigUpdate("resetConfig");
  }
}
ie(Ce, [
  O,
  se,
  ae,
  oe,
  re,
  ne,
  M,
  b,
  ge
]);
export {
  Ce as S,
  de as a,
  me as s
};
