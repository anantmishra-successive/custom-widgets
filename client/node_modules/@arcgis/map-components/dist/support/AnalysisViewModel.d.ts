/// <reference types="@arcgis/core/interfaces.d.ts" />
import { default as Accessor } from '@arcgis/core/core/Accessor.js';
import { AnalysisUnion, AnalysisViewUnion } from '@arcgis/core/unionTypes.js';
import { default as SceneView } from '@arcgis/core/views/SceneView';
export type AnalysisMap = {
    [Key in AnalysisUnion["type"]]: Extract<AnalysisUnion, {
        type: Key;
    }>;
};
export type AnalysisViewMap = {
    [Key in keyof AnalysisMap]: Extract<AnalysisViewUnion, {
        analysis: {
            type: Key;
        };
    }>;
};
export type AnalysisViewFor<Analysis extends AnalysisUnion> = AnalysisViewMap[Analysis["type"]];
type OperationState = "active" | "inactive";
export declare abstract class AnalysisViewModel<IViewType extends SceneView, AnalysisType extends __esri.AnalysisUnion> extends Accessor {
    constructor();
    protected initialize(): void;
    destroy(): void;
    get supported(): boolean;
    view?: IViewType;
    set visible(v: boolean);
    get active(): boolean;
    get disabled(): boolean;
    /**
     * Analysis data object.
     */
    set analysis(v: AnalysisType);
    protected _analysisView?: AnalysisViewFor<AnalysisType>;
    get analysisView(): AnalysisViewFor<AnalysisType> | undefined;
    get ready(): boolean;
    get connectingToView(): boolean;
    /**
     * Whether the viewmodel owns the analysis. In that case, it will remove and destroy the analysis when it is is
     * destroyed. An analysis is initially created by the view model if none is provided and the view model owns it until
     * it is moved to a layer or removed from the view.
     */
    private _ownsAnalysis;
    private get _viewHasAnalysis();
    private _reconnectViewTask?;
    private _forceInteractiveHandle?;
    private _operationState;
    get operationState(): OperationState;
    protected abstract readonly supportedViewType: "2d" | "3d";
    protected abstract readonly unsupportedErrorMessage: string;
    private _loggedUnsupportedErrorMessage;
    /**
     * Breaks the loop of:
     *   Analysis move event
     *   -> reconnect
     *   -> remove analysis from view.analyses in disconnect
     *   -> Analysis move event
     */
    private _changeFromReconnect;
    private _startUserOperation;
    protected abstract constructAnalysis(): AnalysisType;
    /**
     * Removes the tool and clears the analysis by resetting its inputs.
     */
    clear(): void;
    abstract place(options?: {
        signal?: AbortSignal;
    }): Promise<void>;
    /**
     * If analysis has unset inputs, start() will kick off the user operation to specify those inputs.
     */
    start(operation?: (options?: {
        signal?: AbortSignal;
    }) => Promise<void>): Promise<void>;
    startNewAnalysis(): Promise<void>;
    continue(): Promise<void>;
    stop(): void;
    protected abstract clearAnalysis(): void;
    /**
     * A callback used by view models that manage an analysis belonging to an Layer.
     *
     * The function will be called each time the view becomes ready, the internal Layer of
     * the view model has been added to the map and the analysis view of the analysis has been created.
     */
    protected onConnectToAnalysisView(_analysisView: AnalysisViewFor<AnalysisType>): void;
    /**
     * A callback used by view models that manage an analysis.
     *
     * The function will be called each time the view becomes unready and the internal analysis
     * has been removed the map or analyses.
     */
    protected onDisconnectFromAnalysisView(): void;
    private _scheduleViewReconnect;
    private _reconnectView;
    private _disconnectFromView;
    private _setExternalAnalysis;
}
export {};
