import { WebChartVersionStatus as A, WebChartCurrentVersion as re, WebChartTypes as l, WebChartStatisticType as g, defaultPieFromFieldsName as P, WebChartOrderDataByTypes as S, WebChartSortOrderKinds as m, WebChartColoringPatterns as ie, WebChartLabelBehavior as k, WebChartTemporalBinningTypes as oe, WebChartFixedDateBinningUnits as b } from "@arcgis/charts-spec";
import { cloneDeep as s, isEmpty as v } from "lodash-es";
import { bO as se, f as Z, a as ne, u as ae, V as de, g as le, k as T, r as ce, cs as c, ba as F, bb as D, e as ue, h as ye, W as fe, cm as C, cd as U, ax as pe, bt as me, aN as Se, m as ve } from "./interfaces.js";
import { h as he, i as Be, a as be } from "./index4.js";
import { g as h } from "./series-types.js";
/*! All material copyright Esri, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.33/esri/copyright.txt for details.
v4.33.19 */
var w = /* @__PURE__ */ ((r) => (r.NONE = "none", r.ROTATE = "rotate", r.STAGGER = "stagger", r.WRAP = "wrap", r))(w || {});
function Fe(r) {
  const e = s(r);
  return v(r.axes) || (e.axes = r.axes?.map((i) => {
    const t = i;
    return delete t.calculateAutomaticMaximum, delete t.calculateAutomaticMinimum, t.title?.content.font?.style !== void 0 && (t.title.content.font.style = t.title.content.font.style.toLowerCase()), t;
  })), e;
}
function ge(r) {
  const e = s(r);
  return v(r.series) || (e.series = r.series.map((i, t) => {
    const o = i;
    i.id === void 0 && (o.id = `Series ${Date.now()}-${t}`);
    const n = h(r.series, t);
    return (n === l.BarSeries || n === l.LineSeries || n === l.RadarSeries) && o.query?.outStatistics?.[0]?.statisticType === "median" && (o.query.outStatistics[0].statisticType = g.ContinuousPercentile), n === l.BarSeries && o.multipleBarType !== void 0 && (o.stackedType = o.multipleBarType, delete o.multipleBarType), n === l.PieSeries && o.sliceGrouping !== void 0 && (o.sliceGrouping.sliceId = de.defaultGroupOfSlicesId, o.sliceGrouping.groupName !== void 0 && (o.sliceGrouping = {
      ...o.sliceGrouping,
      label: o.sliceGrouping.groupName
    }, delete o.sliceGrouping.groupName), o.sliceGrouping.groupSliceSymbol !== void 0 && (o.sliceGrouping = {
      ...o.sliceGrouping,
      fillSymbol: o.sliceGrouping.groupSliceSymbol
    }, delete o.sliceGrouping.groupSliceSymbol)), o;
  })), e;
}
async function M(r, e) {
  const i = [];
  return await Promise.all(
    r.map(async (t) => {
      if (!U(t)) {
        const o = C(t, !1);
        if (o.fieldToSort !== void 0) {
          const n = await F({
            queryObject: e,
            fieldToMatch: o.fieldToSort
          });
          n !== void 0 && i.push(
            o.orderBy === void 0 ? n : `${n} ${o.orderBy}`
          );
        }
      }
    })
  ), i;
}
async function Oe(r, e) {
  const i = { ...r };
  let t = e;
  if (!t) {
    const o = he(r) ? r.iLayer : r.dataSource?.layer;
    o && (t = await le(o));
  }
  if (t) {
    const o = T(i.series), n = h(i.series), p = i.series && i.series.length > 0 && i.series[0].x.trim() === "" || n === l.GaugeSeries && !ce(r) || o === c.PieFromFields || o === c.BarAndLineFromFields || o === c.BoxPlotMonoField || o === c.BoxPlotMonoFieldAndSplitBy || o === c.BoxPlotMultiFields || o === c.BoxPlotMultiFieldsAndSplitBy, B = n === l.ScatterSeries || o === c.BarAndLineNoAggregation || o === c.BarAndLineSplitByNoAggregation || o === c.BoxPlotMonoField || o === c.BoxPlotMonoFieldAndSplitBy || o === c.BoxPlotMonoFieldAndCategory || o === c.BoxPlotMonoFieldAndCategoryAndSplitBy || o === c.PieNoAggregation;
    if (i.series = await Promise.all(
      r.series.map(async (a) => {
        const d = { ...a };
        if (p || (d.x = await F({ queryObject: t, fieldToMatch: a.x })), "y" in d && B) {
          const u = d.y;
          if (Array.isArray(u)) {
            const y = await D({
              fieldsList: u,
              queryObject: t
            });
            y !== void 0 && "y" in d && (d.y = y);
          } else "y" in d && typeof u == "string" && (d.y = await F({ queryObject: t, fieldToMatch: u }));
        }
        if (a.query !== void 0) {
          let { where: u, groupByFieldsForStatistics: y, outStatistics: f } = a.query;
          if (y = await D({ fieldsList: y, queryObject: t }), f !== void 0 && (f = await Promise.all(
            f.map(async (O) => {
              const x = { ...O };
              return x.onStatisticField = await F({
                queryObject: t,
                fieldToMatch: O.onStatisticField
              }), x;
            })
          )), u !== void 0 && o === c.BarAndLineSplitBy) {
            const O = ue(a.query?.where), x = ye({
              where: a.query?.where,
              normalize: !1,
              escape: !1
            });
            u = `${await F({ queryObject: t, fieldToMatch: O })}=${x}`;
          }
          d.query !== void 0 && (u !== void 0 && (d.query.where = u), y !== void 0 && (d.query.groupByFieldsForStatistics = y), f !== void 0 && (d.query.outStatistics = f));
        }
        return d;
      })
    ), i.series[0]?.query !== void 0) {
      const a = i.series[0].query;
      let { orderByFields: d } = a;
      d !== void 0 && d.length > 0 && (d = await M(d, t), d.length > 0 && a.orderByFields !== void 0 && (i.series[0].query.orderByFields = d));
    }
    if (i.orderOptions?.orderByFields !== void 0) {
      let { orderByFields: a } = i.orderOptions;
      a !== void 0 && a.length > 0 && (a = await M(a, t), a.length > 0 && (i.orderOptions.orderByFields = a));
    }
    if (n === l.GaugeSeries && r.axes?.[0] !== void 0) {
      const { minimumFromField: a, maximumFromField: d } = r.axes[0];
      if (a !== void 0) {
        const u = typeof a == "string" ? a : a.onStatisticField, y = await F({ queryObject: t, fieldToMatch: u });
        let f = a;
        typeof r.axes[0].minimumFromField == "string" ? f = y : typeof a == "object" && (f = {
          ...a,
          onStatisticField: y
        }), r.axes[0].minimumFromField = f;
      }
      if (d !== void 0) {
        const u = typeof d == "string" ? d : d.onStatisticField, y = await F({ queryObject: t, fieldToMatch: u });
        let f = d;
        typeof r.axes[0].maximumFromField == "string" ? f = y : typeof d == "object" && (f = {
          ...d,
          onStatisticField: y
        }), r.axes[0].maximumFromField = f;
      }
    }
  }
  return i;
}
function xe(r) {
  const e = s(r);
  if (!v(r.series) && h(r.series) === l.BoxPlotSeries) {
    const t = e.series[0];
    t && (t.showOutliers !== void 0 && (r.showOutliers === void 0 && (e.showOutliers = t.showOutliers), delete t.showOutliers), t.standardizeValues !== void 0 && (r.standardizeValues === void 0 && (e.standardizeValues = t.standardizeValues), delete t.standardizeValues), t.showMean !== void 0 && (r.showMean === void 0 && (e.showMean = t.showMean), delete t.showMean));
  }
  return e;
}
function Te(r) {
  const e = {
    orderType: S.Category,
    orderBy: m.Ascending
  }, i = r.query?.orderByFields?.[0];
  if (i !== void 0) {
    const { outStatisticFieldName: t, statisticType: o } = r.query?.outStatistics?.[0] ?? {}, n = C(i);
    t !== void 0 && n.fieldToSort === t && o !== void 0 && (o === g.Average || o === "mean" ? e.orderType = S.Mean : o === g.ContinuousPercentile && (e.orderType = S.Median)), e.orderBy = n.orderBy ?? m.Ascending;
  }
  return e;
}
function Ce(r) {
  let e = !1;
  const i = Array.from(new Set(r.series.map((t) => t.type)));
  return i.length === 2 && i.includes(l.BoxPlotSeries) && i.includes(l.LineSeries) && (e = r.series.find((o) => o.type === l.LineSeries)?.query?.outStatistics?.[0] !== void 0), e;
}
function we(r) {
  const e = s(r);
  if (!v(e.series) && h(r.series) === l.BoxPlotSeries) {
    if (e.orderOptions?.data === void 0) {
      const t = Te(r.series[0]);
      t.orderType !== void 0 && (e.orderOptions ??= {}, e.orderOptions.data = {
        orderType: t.orderType,
        orderBy: t.orderBy
      });
    }
    if (e.series = r.series.map((t) => {
      const o = t;
      return v(o.x?.trim()) && (o.x = fe), delete o.query?.orderByFields, o;
    }), Ce(e)) {
      e.showMean = !0;
      const t = e.series.find(
        (o) => o.type === l.BoxPlotSeries
      );
      e.series.forEach((o) => {
        o.type === l.LineSeries && (delete o.query?.groupByFieldsForStatistics, delete o.query?.outStatistics, delete o.query?.orderByFields, t && (o.y = t.y));
      });
    }
    e.series = r.series.map((t) => {
      const o = t;
      return delete o.query?.outStatistics, o;
    });
  }
  return e;
}
function Pe(r) {
  const e = s(r);
  return e.legend !== void 0 && !Number.isFinite(e.legend.maxHeight) && (e.legend.maxHeight = Number.NaN), e;
}
function Le(r) {
  const e = s(r);
  return "dataSource" in e && e.dataSource.layer && (e.iLayer = e.dataSource.layer, delete e.dataSource), e;
}
function Ae(r) {
  const e = s(r), i = /* @__PURE__ */ new Set(), t = e.id ?? "";
  return i.add(t), e.series.forEach((o) => {
    let n = o.id;
    i.has(n) && (n = `${n}_${Date.now()}`, o.id = n), i.add(n);
  }), e;
}
function ke(r) {
  const e = s(r);
  return e?.orderOptions?.orderByFields !== void 0 && T(r.series) === c.PieFromFields && (e.orderOptions.orderByFields = r?.orderOptions?.orderByFields?.map(
    (i) => {
      let t = s(i);
      return i !== void 0 && i.includes("arcgis_charts_pie_category_from_fields_name") && (t = i.replace(
        "arcgis_charts_pie_category_from_fields_name",
        P
      )), t;
    }
  )), e;
}
function De(r) {
  const e = s(r);
  if (!v(r.series) && e.axes?.[0] !== void 0 && h(r.series) === l.GaugeSeries && r.axes?.[0] !== void 0) {
    const t = r.axes[0];
    t.ticks !== void 0 && Object.hasOwn(t.ticks, "spacing") && delete t.ticks.spacing, e.axes[0] = t;
  }
  return e;
}
function Me(r) {
  const e = s(r), { extent: i } = e.series[0]?.query ?? {};
  return i !== void 0 && (e.dataFilters = {
    ...e.dataFilters,
    geometry: i
  }, e.series.forEach((t) => {
    "query" in t && "extent" in t.query && delete t.query.extent;
  })), e;
}
function ee(r) {
  const e = s(r);
  return v(r.series) || (Be(r) && r.rotated === void 0 && (e.rotated = r.series[0].rotated ?? pe()), e.series.forEach((i) => {
    i.rotated !== void 0 && delete i.rotated;
  })), e;
}
function qe(r) {
  const e = s(r), i = r.dataSource;
  return "dataSource" in e && !v(i) && (i.type === "featureLayer" && e.dataSource !== void 0 && (e.dataSource.type = "layer"), "featureLayer" in i && (e.dataSource.layer = i.featureLayer, delete e.dataSource.featureLayer)), e;
}
function Ne(r) {
  const e = s(r);
  if ("dataSource" in r) {
    const i = r.dataSource;
    if (i.filter !== void 0 && i.filter.trim() !== "") {
      const t = me([i.filter, e.dataFilters?.where]);
      e.dataFilters = {
        ...e.dataFilters,
        where: t
      }, delete e.dataSource.filter;
    }
  }
  return e;
}
function Ie(r) {
  return r !== "originalValue";
}
function te(r) {
  let e;
  switch (r) {
    case "mean":
      e = S.Mean;
      break;
    case "median":
      e = S.Median;
      break;
    case "category":
      e = S.Category;
      break;
  }
  return e;
}
function We(r) {
  const e = s(r);
  if (!v(r.series) && h(r.series) === l.PieSeries) {
    const t = e.series[0];
    if (t) {
      if (t.sortLabelsBy === "originalValue")
        e.sortLabelsBy = t.sortLabelsBy;
      else if (t.sortLabelsBy !== void 0 && e.orderOptions?.data === void 0) {
        const o = L(e);
        o !== void 0 && (e.orderOptions ??= {}, e.orderOptions.data = o);
      }
      t.sortLabelsBy && delete t.sortLabelsBy;
    }
  }
  return e;
}
function Ve(r) {
  const e = s(r);
  return v(r.series) || (be(r) && r.stackedType === void 0 && (e.stackedType = r.series[0].stackedType ?? Se()), e.series.forEach((i) => {
    "stackedType" in i && delete i.stackedType;
  })), e;
}
function Ee(r) {
  const e = s(r), i = r.sortOptions?.sortSeriesBy;
  return e.orderOptions === void 0 && typeof i == "string" && (e.orderOptions ??= {}, e.orderOptions.series = {
    orderBy: i === "DESC" ? m.Descending : m.Ascending
  }), e;
}
function Ge(r) {
  const e = s(r);
  return e.colorMatch === void 0 && e.series[0]?.colorType !== void 0 && (e.colorMatch = e.series[0]?.colorType === ie.Match), e.series.forEach((i) => {
    i.colorType !== void 0 && delete i.colorType;
  }), e;
}
function ze(r) {
  const e = s(r);
  if (e.sortDataBy !== void 0) {
    if (e.orderOptions?.data === void 0) {
      const i = r.sortDataBy, t = te(i?.sortType);
      t !== void 0 && (e.orderOptions ??= {}, e.orderOptions.data = {
        orderType: t,
        orderBy: i?.sortOrder ?? m.Ascending
      });
    }
    delete e.sortDataBy;
  }
  return e;
}
function _e(r) {
  const e = s(r);
  return e.axes?.forEach((i) => {
    i !== void 0 && i.scrollbarVisible !== void 0 && i.scrollbar?.visible === void 0 && (i.scrollbar = {
      ...i.scrollbar,
      visible: i.scrollbarVisible
    }, delete i.scrollbarVisible);
  }), e;
}
function je(r) {
  const e = s(r), i = e.series[0]?.query?.orderByFields;
  if (i !== void 0 && i.length > 0 && e.orderOptions?.orderByFields === void 0) {
    e.orderOptions ??= {};
    let t = !0;
    if (i.length === 1) {
      const { fieldToSort: o, orderBy: n } = C(i[0]);
      let p;
      o === r.series[0].x || o === P ? p = S.Category : "y" in r.series[0] && o === r.series[0].y && (p = S.YValue), p !== void 0 && (t = !1, e.orderOptions.data === void 0 && (e.orderOptions.data = {
        orderType: p,
        orderBy: n?.toUpperCase() === "DESC" ? m.Descending : m.Ascending
      }));
    }
    t && (e.orderOptions.orderByFields = i);
  }
  return e.series.forEach((t) => {
    delete t.query?.orderByFields;
  }), e;
}
function L(r) {
  let e, i = r.orderOptions?.orderByFields?.[0];
  if (r.series?.length > 0) {
    const t = h(r.series), o = T(r.series);
    if (t !== l.PieSeries && o !== c.BarAndLineFromFields && (i = i ?? r.series[0].x), i && !U(i)) {
      const { fieldToSort: n, orderBy: p } = C(i);
      let B;
      n === r.series[0].x || n === P ? B = S.Category : "y" in r.series[0] && n === r.series[0].y && (B = S.YValue), B !== void 0 && (e = {
        orderType: B,
        orderBy: p?.toUpperCase() === "DESC" ? m.Descending : m.Ascending
      });
    }
  }
  return e;
}
function He(r) {
  const e = s(r), i = r, t = r, o = r, n = r, p = r;
  if (e) {
    if (e.orderOptions?.series === void 0 && i.sortOptions?.sortSeriesBy !== void 0 && (e.orderOptions ??= {}, e.orderOptions.series = {
      preferLabel: Ie(
        t.sortLabelsBy ?? i.sortOptions.sortSeriesBy.sortType
      ),
      orderBy: i.sortOptions.sortSeriesBy.sortOrder ?? m.Ascending
    }), t.sortLabelsBy === "originalValue" || n.orderOptions?.data?.preferDataLabel === !1 || p.orderOptions?.data?.preferLabel === !1)
      e.orderOptions?.data && delete e.orderOptions.data;
    else if (e.orderOptions?.data === void 0)
      if (h(e.series) === l.BoxPlotSeries) {
        if (t.sortLabelsBy || o.sortOptions?.sortDataBy !== void 0) {
          const a = te(o.sortOptions?.sortDataBy?.sortType);
          a !== void 0 && (e.orderOptions ??= {}, e.orderOptions.data = {
            orderType: a,
            orderBy: o.sortOptions?.sortDataBy?.sortOrder ?? m.Ascending
          });
        }
      } else {
        const a = L(e);
        a !== void 0 && (e.orderOptions ??= {}, e.orderOptions.data = a);
      }
    "sortLabelsBy" in e && delete e.sortLabelsBy, "sortOptions" in e && delete e.sortOptions;
  }
  return e;
}
function Re(r) {
  const e = s(r);
  if (e) {
    const i = T(e.series);
    if ((i === c.BarAndLineFromFields || i === c.PieFromFields) && e.orderOptions?.data === void 0 && e.orderOptions?.orderByFields !== void 0) {
      const t = L(e);
      t !== void 0 && (e.orderOptions ??= {}, e.orderOptions.data = t, delete e.orderOptions.orderByFields);
    }
  }
  return e;
}
function $e(r) {
  const e = s(r);
  return e.horizontalAxisLabelsBehavior === w.NONE && (e.horizontalAxisLabelsBehavior = k.Hide), e.verticalAxisLabelsBehavior === w.NONE && (e.verticalAxisLabelsBehavior = k.Hide), e;
}
function Qe(r) {
  const e = s(r), i = e.series[0];
  if (i && !i.temporalBinning && ve(e.series[0]) && ("timeIntervalSize" in i || "timeIntervalUnits" in i || "timeAggregationType" in i || "trimIncompleteTimeInterval" in i || "nullPolicy" in i)) {
    if (i.temporalBinning = {
      type: oe.FixedDateBased
    }, i.timeIntervalSize !== void 0 && (i.temporalBinning.size = i.timeIntervalSize, delete i.timeIntervalSize), i.timeIntervalUnits) {
      let t;
      switch (i.timeIntervalUnits) {
        case "esriTimeUnitsSeconds":
          t = b.Second;
          break;
        case "esriTimeUnitsMinutes":
          t = b.Minute;
          break;
        case "esriTimeUnitsHours":
          t = b.Hour;
          break;
        case "esriTimeUnitsDays":
          t = b.Day;
          break;
        case "esriTimeUnitsWeeks":
          t = b.Week;
          break;
        case "esriTimeUnitsMonths":
          t = b.Month;
          break;
        case "esriTimeUnitsYears":
          t = b.Year;
          break;
      }
      t !== void 0 && (i.temporalBinning.unit = t), delete i.timeIntervalUnits;
    }
    i.timeAggregationType && (i.temporalBinning.timeAggregationType = i.timeAggregationType, delete i.timeAggregationType), i.trimIncompleteTimeInterval !== void 0 && (i.temporalBinning.trimIncompleteTimeInterval = i.trimIncompleteTimeInterval, delete i.trimIncompleteTimeInterval), i.nullPolicy && (i.temporalBinning.nullPolicy = i.nullPolicy, delete i.nullPolicy);
  }
  return e;
}
function Ye(r) {
  const e = s(r);
  return e.series.forEach((i) => {
    i.query?.outStatistics?.forEach((t) => {
      t.statisticType === "percentile_cont" ? t.statisticType = g.ContinuousPercentile : t.statisticType === "percentile_disc" && (t.statisticType = g.DiscretePercentile);
    });
  }), e;
}
function Ke(r) {
  const e = s(r);
  return e.subtitle === void 0 && e.subTitle && (e.subtitle = e.subTitle), delete e.subTitle, e;
}
async function Xe(r, e) {
  let i = s(r);
  return i = Fe(i), i = ge(i), i = await Oe(i, e), i = xe(i), i = we(i), i = Pe(i), i = Ae(i), i;
}
function Je(r) {
  let e = s(r);
  return e = ke(e), e;
}
function q(r) {
  let e = s(r);
  return e = De(e), e;
}
function N(r) {
  let e = s(r);
  return e = Me(e), e;
}
function I(r) {
  let e = s(r);
  return e = ee(e), e;
}
function W(r) {
  let e = s(r);
  return e = qe(e), e;
}
function V(r) {
  let e = s(r);
  return e = Ne(e), e;
}
function E(r) {
  let e = s(r);
  return e = We(e), e;
}
function G(r) {
  let e = s(r);
  return e = Ee(e), e;
}
function z(r) {
  let e = s(r);
  return e = Ge(e), e;
}
function _(r) {
  return _e(r);
}
function j(r) {
  let e = s(r);
  return r.series[0]?.type === l.BoxPlotSeries && (e = ze(e)), e;
}
function H(r) {
  return Ve(r);
}
function R(r) {
  return He(r);
}
function $(r) {
  return Le(r);
}
function Q(r) {
  return Re(r);
}
function Y(r) {
  return $e(r);
}
function K(r) {
  return Qe(r);
}
function X(r) {
  return Ye(r);
}
function J(r) {
  let e = s(r);
  return e = ee(e), Ke(e);
}
function Ze(r) {
  const { versionsToConvert: e = [], configToUpdate: i } = r;
  let t = s(i);
  return e.length > 0 && t !== void 0 && (t = je(t), e.includes(Z) || e.includes(ae) ? (t = Je(t), t = q(t), t = N(t), t = I(t), t = W(t), t = V(t), t = E(t), t = G(t), t = z(t), t = _(t), t = j(t), t = H(t), t = R(t), t = $(t), t = Q(t), t = Y(t), t = K(t), t = X(t), t = J(t)) : e.forEach((o) => {
    if (t !== void 0)
      switch (o) {
        case "1.0.1":
          t = q(t);
          break;
        case "3.4.0":
          t = N(t);
          break;
        case "4.0.0":
          t = I(t);
          break;
        case "4.0.1":
          t = W(t);
          break;
        case "6.4.0":
          t = V(t);
          break;
        case "7.5.1":
          t = E(t);
          break;
        case "8.0.0":
          t = G(t);
          break;
        case "9.2.0":
          t = z(t);
          break;
        case "9.7.0":
          t = _(t);
          break;
        case "10.0.0":
          t = j(t);
          break;
        case "11.0.0":
          t = H(t);
          break;
        case "14.0.1":
          t = R(t);
          break;
        case "16.0.0":
          t = $(t);
          break;
        case "16.1.0":
          t = Q(t);
          break;
        case "18.1.3":
          t = Y(t);
          break;
        case "20.1.0":
          t = K(t);
          break;
        case "21.0.0":
          t = X(t);
          break;
        case "23.1.0":
          t = J(t);
          break;
      }
  }), t.version = re), t;
}
async function st(r, e) {
  let i = r;
  if (r) {
    const t = se(e);
    i = await Xe(r, t);
    const o = r.version ?? Z, { versionStatus: n, versions: p } = ne(o);
    (n === A.Older || n === A.Unrecognized) && (i = Ze({
      versionsToConvert: p,
      configToUpdate: i
    }));
  }
  return i;
}
export {
  st as c
};
