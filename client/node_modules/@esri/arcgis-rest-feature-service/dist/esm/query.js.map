{"version":3,"file":"query.js","sourceRoot":"","sources":["../../src/query.ts"],"names":[],"mappings":"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","sourcesContent":["/* Copyright (c) 2017-2018 Environmental Systems Research Institute, Inc.\n * Apache-2.0 */\n\nimport {\n  request,\n  cleanUrl,\n  appendCustomParams,\n  ISpatialReference,\n  IFeatureSet,\n  IFeature,\n  Units,\n  IExtent\n} from \"@esri/arcgis-rest-request\";\n\nimport {\n  IGetLayerOptions,\n  ISharedQueryOptions,\n  IStatisticDefinition\n} from \"./helpers.js\";\n\n/**\n * Request options to fetch a feature by id.\n */\nexport interface IGetFeatureOptions extends IGetLayerOptions {\n  /**\n   * Unique identifier of the feature.\n   */\n  id: number;\n}\n\n/**\n * feature query request options. See [REST Documentation](https://developers.arcgis.com/rest/services-reference/query-feature-service-layer-.htm) for more information.\n */\nexport interface IQueryFeaturesOptions extends ISharedQueryOptions {\n  objectIds?: number[];\n  relationParam?: string;\n  // NOTE: either time=1199145600000 or time=1199145600000, 1230768000000\n  time?: number | number[];\n  distance?: number;\n  units?: Units;\n  /**\n   * Attribute fields to include in the response. Defaults to \"*\"\n   */\n  outFields?: \"*\" | string[];\n  returnGeometry?: boolean;\n  maxAllowableOffset?: number;\n  geometryPrecision?: number;\n  // NOTE: either WKID or ISpatialReference\n  inSR?: string | ISpatialReference;\n  outSR?: string | ISpatialReference;\n  gdbVersion?: string;\n  returnDistinctValues?: boolean;\n  returnIdsOnly?: boolean;\n  returnCountOnly?: boolean;\n  returnExtentOnly?: boolean;\n  orderByFields?: string;\n  groupByFieldsForStatistics?: string;\n  outStatistics?: IStatisticDefinition[];\n  returnZ?: boolean;\n  returnM?: boolean;\n  multipatchOption?: \"xyFootprint\";\n  resultOffset?: number;\n  resultRecordCount?: number;\n  // TODO: IQuantizationParameters?\n  quantizationParameters?: any;\n  returnCentroid?: boolean;\n  resultType?: \"none\" | \"standard\" | \"tile\";\n  // to do: convert from Date() to epoch time internally\n  historicMoment?: number;\n  returnTrueCurves?: false;\n  sqlFormat?: \"none\" | \"standard\" | \"native\";\n  returnExceededLimitFeatures?: boolean;\n  /**\n   * Response format. Defaults to \"json\"\n   * NOTE: for \"pbf\" you must also supply `rawResponse: true`\n   * and parse the response yourself using `response.arrayBuffer()`\n   */\n  f?: \"json\" | \"geojson\" | \"pbf\";\n  /**\n   * someday...\n   *\n   * If 'true' the query will be preceded by a metadata check to gather info about coded value domains and result values will be decoded. If a fieldset is provided it will be used to decode values and no internal metadata request will be issued.\n   */\n  // decodeValues?: boolean | IField[];\n}\n\nexport interface IQueryFeaturesResponse extends IFeatureSet {\n  exceededTransferLimit?: boolean;\n}\n\n/**\n * query all features request options. See [REST Documentation](https://developers.arcgis.com/rest/services-reference/query-feature-service-layer-.htm) for more information.\n */\nexport interface IQueryAllFeaturesOptions extends ISharedQueryOptions {\n  objectIds?: number[];\n  relationParam?: string;\n  // NOTE: either time=1199145600000 or time=1199145600000, 1230768000000\n  time?: number | number[];\n  distance?: number;\n  units?: Units;\n  /**\n   * Attribute fields to include in the response. Defaults to \"*\"\n   */\n  outFields?: \"*\" | string[];\n  returnGeometry?: boolean;\n  maxAllowableOffset?: number;\n  geometryPrecision?: number;\n  // NOTE: either WKID or ISpatialReference\n  inSR?: string | ISpatialReference;\n  outSR?: string | ISpatialReference;\n  gdbVersion?: string;\n  orderByFields?: string;\n  groupByFieldsForStatistics?: string;\n  outStatistics?: IStatisticDefinition[];\n  returnZ?: boolean;\n  returnM?: boolean;\n  multipatchOption?: \"xyFootprint\";\n  resultOffset?: number;\n  resultRecordCount?: number;\n  // TODO: IQuantizationParameters?\n  quantizationParameters?: any;\n  resultType?: \"none\" | \"standard\" | \"tile\";\n  // to do: convert from Date() to epoch time internally\n  historicMoment?: number;\n  returnTrueCurves?: false;\n  sqlFormat?: \"none\" | \"standard\" | \"native\";\n  returnExceededLimitFeatures?: true;\n  /**\n   * Response format. Defaults to \"json\"\n   * NOTE: for \"pbf\" you must also supply `rawResponse: true`\n   * and parse the response yourself using `response.arrayBuffer()`\n   */\n  f?: \"json\" | \"geojson\";\n  /**\n   * someday...\n   *\n   * If 'true' the query will be preceded by a metadata check to gather info about coded value domains and result values will be decoded. If a fieldset is provided it will be used to decode values and no internal metadata request will be issued.\n   */\n  // decodeValues?: boolean | IField[];\n}\n\nexport interface IQueryAllFeaturesResponse extends IFeatureSet {\n  exceededTransferLimit?: true;\n}\n\nexport interface IQueryResponse {\n  count?: number;\n  extent?: IExtent;\n  objectIdFieldName?: string;\n  objectIds?: number[];\n}\n\n/**\n * Get a feature by id.\n *\n * ```js\n * import { getFeature } from '@esri/arcgis-rest-feature-service';\n *\n * const url = \"https://services.arcgis.com/V6ZHFr6zdgNZuVG0/arcgis/rest/services/Landscape_Trees/FeatureServer/0\";\n *\n * getFeature({\n *   url,\n *   id: 42\n * }).then(feature => {\n *  console.log(feature.attributes.FID); // 42\n * });\n * ```\n *\n * @param requestOptions - Options for the request\n * @returns A Promise that will resolve with the feature or the [response](https://developer.mozilla.org/en-US/docs/Web/API/Response) itself if `rawResponse: true` was passed in.\n */\nexport function getFeature(\n  requestOptions: IGetFeatureOptions\n): Promise<IFeature> {\n  const url = `${cleanUrl(requestOptions.url)}/${requestOptions.id}`;\n\n  // default to a GET request\n  const options: IGetFeatureOptions = {\n    ...{ httpMethod: \"GET\" },\n    ...requestOptions\n  };\n  return request(url, options).then((response: any) => {\n    if (options.rawResponse) {\n      return response;\n    }\n    return response.feature;\n  });\n}\n\n/**\n * Query a feature service. See [REST Documentation](https://developers.arcgis.com/rest/services-reference/query-feature-service-layer-.htm) for more information.\n *\n * ```js\n * import { queryFeatures } from '@esri/arcgis-rest-feature-service';\n *\n * queryFeatures({\n *   url: \"http://sampleserver6.arcgisonline.com/arcgis/rest/services/Census/MapServer/3\",\n *   where: \"STATE_NAME = 'Alaska'\"\n * })\n *   .then(result)\n * ```\n *\n * @param requestOptions - Options for the request\n * @returns A Promise that will resolve with the query response.\n */\nexport function queryFeatures(\n  requestOptions: IQueryFeaturesOptions\n): Promise<IQueryFeaturesResponse | IQueryResponse> {\n  const queryOptions = appendCustomParams<IQueryFeaturesOptions>(\n    requestOptions,\n    [\n      \"where\",\n      \"objectIds\",\n      \"relationParam\",\n      \"time\",\n      \"distance\",\n      \"units\",\n      \"outFields\",\n      \"geometry\",\n      \"geometryType\",\n      \"spatialRel\",\n      \"returnGeometry\",\n      \"maxAllowableOffset\",\n      \"geometryPrecision\",\n      \"inSR\",\n      \"outSR\",\n      \"gdbVersion\",\n      \"returnDistinctValues\",\n      \"returnIdsOnly\",\n      \"returnCountOnly\",\n      \"returnExtentOnly\",\n      \"orderByFields\",\n      \"groupByFieldsForStatistics\",\n      \"outStatistics\",\n      \"returnZ\",\n      \"returnM\",\n      \"multipatchOption\",\n      \"resultOffset\",\n      \"resultRecordCount\",\n      \"quantizationParameters\",\n      \"returnCentroid\",\n      \"resultType\",\n      \"historicMoment\",\n      \"returnTrueCurves\",\n      \"sqlFormat\",\n      \"returnExceededLimitFeatures\",\n      \"f\"\n    ],\n    {\n      httpMethod: \"GET\",\n      params: {\n        // set default query parameters\n        where: \"1=1\",\n        outFields: \"*\",\n        ...requestOptions.params\n      }\n    }\n  );\n\n  return request(`${cleanUrl(requestOptions.url)}/query`, queryOptions);\n}\n\n/**\n * Query a feature service to retrieve all features. See [REST Documentation](https://developers.arcgis.com/rest/services-reference/query-feature-service-layer-.htm) for more information.\n *\n * ```js\n * import { queryAllFeatures } from '@esri/arcgis-rest-feature-service';\n *\n * queryAllFeatures({\n *   url: \"http://sampleserver6.arcgisonline.com/arcgis/rest/services/Census/MapServer/3\",\n *   where: \"STATE_NAME = 'Alaska'\"\n * })\n *   .then(result)\n * ```\n *\n * @param requestOptions - Options for the request\n * @returns A Promise that will resolve with the query response.\n */\nexport async function queryAllFeatures(\n  requestOptions: IQueryAllFeaturesOptions\n): Promise<IQueryAllFeaturesResponse> {\n  let offset = 0;\n  let hasMore = true;\n  let allFeaturesResponse: IQueryAllFeaturesResponse | null = null;\n\n  // retrieve the maxRecordCount for the service\n  const pageSizeResponse = await request(requestOptions.url, {\n    httpMethod: \"GET\"\n  });\n  // default the pageSize to 2000 if it is not provided\n  const pageSize = pageSizeResponse.maxRecordCount || 2000;\n  const userRecordCount = requestOptions.params?.resultRecordCount;\n  // use the user defined count only if it's less than or equal to the page size, otherwise use pageSize\n  const recordCountToUse =\n    userRecordCount && userRecordCount <= pageSize ? userRecordCount : pageSize;\n\n  while (hasMore) {\n    const pagedOptions = {\n      ...requestOptions,\n      params: {\n        where: \"1=1\",\n        outFields: \"*\",\n        ...(requestOptions.params || {}),\n        resultOffset: offset,\n        resultRecordCount: recordCountToUse\n      }\n    };\n\n    const queryOptions = appendCustomParams<IQueryAllFeaturesOptions>(\n      pagedOptions,\n      [\n        \"where\",\n        \"objectIds\",\n        \"relationParam\",\n        \"time\",\n        \"distance\",\n        \"units\",\n        \"outFields\",\n        \"geometry\",\n        \"geometryType\",\n        \"spatialRel\",\n        \"returnGeometry\",\n        \"maxAllowableOffset\",\n        \"geometryPrecision\",\n        \"inSR\",\n        \"outSR\",\n        \"gdbVersion\",\n        \"orderByFields\",\n        \"groupByFieldsForStatistics\",\n        \"outStatistics\",\n        \"returnZ\",\n        \"returnM\",\n        \"multipatchOption\",\n        \"resultOffset\",\n        \"resultRecordCount\",\n        \"quantizationParameters\",\n        \"resultType\",\n        \"historicMoment\",\n        \"returnTrueCurves\",\n        \"sqlFormat\",\n        \"f\"\n      ],\n      {\n        httpMethod: \"GET\",\n        params: {\n          where: \"1=1\",\n          outFields: \"*\",\n          returnExceededLimitFeatures: true,\n          ...pagedOptions.params\n        }\n      }\n    );\n    const response: IQueryAllFeaturesResponse = await request(\n      `${cleanUrl(requestOptions.url)}/query`,\n      queryOptions\n    );\n\n    // save the first response structure\n    if (!allFeaturesResponse) {\n      allFeaturesResponse = { ...response };\n    } else {\n      // append features of subsequent requests\n      allFeaturesResponse.features = allFeaturesResponse.features.concat(\n        response.features\n      );\n    }\n\n    const returnedCount = response.features.length;\n\n\n    // check if the response has exceededTransferLimit handles both the standard json and geojson responses\n    const exceededTransferLimit =\n      response.exceededTransferLimit ||\n      (response as any).properties?.exceededTransferLimit;\n\n    // check if there are more features\n    if (returnedCount < pageSize || !exceededTransferLimit) {\n      hasMore = false;\n    } else {\n      offset += pageSize;\n    }\n  }\n\n  return allFeaturesResponse;\n}\n"]}