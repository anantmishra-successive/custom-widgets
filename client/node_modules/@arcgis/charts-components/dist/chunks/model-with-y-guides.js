import { WebChartTypes as g, WebChartLabelBehavior as p, RESTSymbolType as f } from "@arcgis/charts-spec";
import { cloneDeep as u } from "lodash-es";
import "d3-array";
import { a2 as c, a0 as l, aV as o, ci as k, k as z, g as I, a_ as E, aa as H, a3 as S, _ as b, a1 as N, d as O } from "./interfaces.js";
import "@arcgis/core/geometry/support/jsonUtils.js";
import "@arcgis/core/rest/support/AttributeBinsQuery.js";
import "@arcgis/core/rest/support/Query.js";
import "@arcgis/core/rest/support/StatisticDefinition.js";
import "@arcgis/core/time/TimeExtent.js";
import "@arcgis/core/core/promiseUtils.js";
import "@arcgis/core/request.js";
import { T as W, U as Z, t as P, a as v, s as _, c as T, b as L, V as j, W as q, h as C, X as J, Y as K, l as Q, k as $, Z as tt, _ as et } from "./data.js";
import { c as it } from "./index.js";
import { g as st } from "./series-types.js";
import { c as ot, b as rt } from "./index4.js";
import { G as d } from "./common.js";
/*! All material copyright Esri, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.33/esri/copyright.txt for details.
v4.33.19 */
const y = (e) => e.title?.content.text ?? "", nt = (e, t) => {
  t.title !== void 0 ? t.title.content.text = e : t.title === void 0 && e !== void 0 && (t.title = c({
    text: e,
    visible: !0,
    font: l(o.ChartTitle)
  }));
}, at = (e) => e.subtitle?.content.text ?? "", lt = (e, t) => {
  t.subtitle !== void 0 ? t.subtitle.content.text = e : t.subtitle === void 0 && e !== void 0 && (t.subtitle = c({
    text: e,
    visible: !0,
    font: l(o.ChartSubtitle)
  }));
}, A = (e) => e.footer?.content.text ?? "", ct = (e, t) => {
  t.footer !== void 0 ? t.footer.content.text = e : t.footer === void 0 && e !== void 0 && (t.footer = c({
    text: e,
    visible: !0,
    font: l(o.DescriptionText)
  }));
}, gt = (e) => e.title ? e.title.visible ?? !0 : !1, dt = (e, t) => {
  t.title !== void 0 ? t.title.visible = e : t.title === void 0 && (t.title = c({
    text: "",
    visible: e,
    font: l(o.ChartTitle)
  }));
}, ut = (e) => e.subtitle ? e.subtitle.visible ?? !0 : !1, ht = (e, t) => {
  t.subtitle !== void 0 ? t.subtitle.visible = e : t.subtitle === void 0 && (t.subtitle = c({
    text: "",
    visible: e,
    font: l(o.ChartSubtitle)
  }));
}, V = (e) => e.footer?.visible ?? !1, ft = (e, t) => {
  t.footer !== void 0 ? t.footer.visible = e : t.footer === void 0 && e !== V(t) && (t.footer = c({
    text: "",
    visible: !0,
    font: l(o.DescriptionText)
  }));
}, xt = (e) => e.chartRenderer, bt = (e, t) => {
  t.chartRenderer = e;
}, Ct = (e) => e.title?.content, yt = (e, t) => {
  if (e) {
    const i = y(t);
    t.title === void 0 && (t.title = c({
      text: "",
      visible: !0,
      font: l(o.ChartTitle),
      type: o.ChartTitle
    })), t.title.content = e, t.title.content.text = i;
  }
}, mt = (e) => e.subtitle?.content, pt = (e, t) => {
  if (e) {
    const i = y(t);
    t.subtitle === void 0 && (t.subtitle = c({
      text: "",
      visible: !0,
      font: l(o.ChartSubtitle),
      type: o.ChartSubtitle
    })), t.subtitle.content = e, t.subtitle.content.text = i;
  }
}, St = (e) => e.footer?.content, vt = (e, t) => {
  if (e) {
    const i = A(t);
    t.footer === void 0 && (t.footer = c({
      text: "",
      visible: !0,
      font: l(o.DescriptionText),
      type: o.DescriptionText
    })), t.footer.content = e, t.footer.content.text = i;
  }
}, _t = (e) => e.background, Tt = (e, t) => {
  t.background = e;
}, Lt = (e, t) => t.series[e]?.id, At = (e, t) => t.series.findIndex((i) => i.id === e), Vt = (e) => e.series.length ?? 0, Gt = (e, t) => t.series[e].visible ?? !0;
class G extends EventTarget {
  constructor() {
    super(...arguments), this.dataStore = {}, this.setupFinished = new Promise((t) => {
      this.resolveSetup = t;
    });
  }
  /**
   * Checks if the current chart model is for the same chart as another chart model.
   * @param {ChartModel | undefined} otherModel The other chart model to compare to.
   * @returns {boolean}
   */
  isSameChartAs(t) {
    const i = t?.getLayer();
    return i !== void 0 && this._config.id === t?.getChartId() && this.layerInfo?.layer.id === i.id;
  }
  /**
   * Gets the current chart configuration object.
   * @returns {ChartConfig}
   */
  getConfig() {
    return this._config;
  }
  /**
   * Sets the chart configuration object.
   * @param {ChartConfig} config The configuration object.
   */
  setConfig(t) {
    this._config = t, this.emitConfigUpdate("setConfig");
  }
  /**
   * Gets the chart type.
   * @returns {ChartTypes}
   */
  getChartType() {
    return this._chartType;
  }
  /**
   * Gets the associated layer.
   * @returns {SupportedLayer | undefined}
   */
  getLayer() {
    return this.layerInfo?.layer;
  }
  /**
   * Gets the chart id.
   * @returns {string | undefined}
   */
  getChartId() {
    return this._config.id;
  }
  /**
   * Sets the chart id.
   * @param {string} id
   */
  setChartId(t) {
    this._config.id = t;
  }
  // ---------------------------------------------------------------------------------------------
  // General Methods
  // ---------------------------------------------------------------------------------------------
  /**
   * Gets the version of the chart configuration.
   * @returns {string}
   */
  getVersion() {
    return this.getVersion();
  }
  /**
   * Gets the chart title text.
   * @returns {string}
   */
  getTitleText() {
    return y(this._config);
  }
  /**
   * Sets the chart title text.
   * @param {string} title The title text.
   */
  setTitleText(t) {
    nt(t, this._config), this.emitConfigUpdate("setTitleText");
  }
  /**
   * Gets the chart subtitle text.
   * @returns {string}
   */
  getSubtitleText() {
    return at(this._config);
  }
  /**
   * Sets the chart subtitle text.
   * @param {string} subtitle The subtitle text.
   */
  setSubtitleText(t) {
    lt(t, this._config), this.emitConfigUpdate("setSubtitleText");
  }
  /**
   * Gets the chart description text.
   * @returns {string}
   */
  getDescriptionText() {
    return A(this._config);
  }
  /**
   * Sets the chart description text.
   * @param {string} description The description text.
   */
  setDescriptionText(t) {
    ct(t, this._config), this.emitConfigUpdate("setDescriptionText");
  }
  /**
   * Gets whether or not the chart title is visible.
   *
   * `true`: Chart title is visible.
   *
   * `false`: Chart title is hidden.
   *
   * @returns {boolean}
   *
   * **Note: Even if the title is visible, it may not be displayed if the title text is empty.**
   */
  getChartTitleVisibility() {
    return gt(this._config);
  }
  /**
   * Sets whether or not the chart title is visible.
   *
   * `true`: Show chart title.
   *
   * `false`: Hide chart title.
   *
   * @param {boolean} visibility The visibility state of the chart title.
   *
   * **Note: Even if the title is visible, it may not be displayed if the title text is empty.**
   */
  setChartTitleVisibility(t) {
    dt(t, this._config), this.emitConfigUpdate("setChartTitleVisibility");
  }
  /**
   * Gets whether or not the chart subtitle is visible.
   *
   * `true`: Chart subtitle is visible.
   *
   * `false`: Chart subtitle is hidden.
   *
   * @returns {boolean}
   *
   * **Note: Even if the subtitle is visible, it may not be displayed if the subtitle text is empty.**
   */
  getChartSubtitleVisibility() {
    return ut(this._config);
  }
  /**
   * Sets whether or not the chart subtitle is visible.
   *
   * `true`: Show chart subtitle.
   *
   * `false`: Hide chart subtitle.
   *
   * @param {boolean} visibility The visibility state of the chart subtitle.
   *
   * **Note: Even if the subtitle is visible, it may not be displayed if the subtitle text is empty.**
   */
  setChartSubtitleVisibility(t) {
    ht(t, this._config), this.emitConfigUpdate("setChartSubtitleVisibility");
  }
  /**
   * Gets whether or not the chart description is visible.
   *
   * `true`: Description is visible.
   *
   * `false`: Description is hidden.
   *
   * @returns {boolean}
   *
   * **Note: Even if the description is visible, it may not be displayed if the description text is empty.**
   */
  getDescriptionVisibility() {
    return V(this._config);
  }
  /**
   * Sets whether or not the chart description is visible.
   *
   * `true`: Show description.
   *
   * `false`: Hide description.
   *
   * @param {boolean} visibility The visibility state of the description.
   *
   * **Note: Even if the description is visible, it may not be displayed if the description text is empty.**
   */
  setDescriptionVisibility(t) {
    ft(t, this._config), this.emitConfigUpdate("setDescriptionVisibility");
  }
  /**
   * Gets the chart renderer.
   * @returns {IDrawingInfo["renderer"] | undefined} The chart renderer if defined, otherwise undefined.
   */
  getChartRenderer() {
    return xt(this._config);
  }
  /**
   * Sets the chart renderer.
   * @param renderer The chart renderer to set.
   */
  setChartRenderer(t) {
    bt(t, this._config), this.emitConfigUpdate("setChartRenderer");
  }
  // ---------------------------------------------------------------------------------------------
  // Format Methods
  // ---------------------------------------------------------------------------------------------
  /**
   * Gets the title text symbol. Contains styling information such as font, color, and symbol style.
   * @returns {WebChartTextSymbol | undefined}
   */
  getTitleSymbol() {
    return Ct(this._config);
  }
  /**
   * Sets the title text symbol. Contains styling information such as font, color, and symbol style.
   * @param {WebChartTextSymbol | undefined} titleSymbol The title symbol.
   */
  setTitleSymbol(t) {
    yt(t, this._config), this.emitConfigUpdate("setTitleSymbol");
  }
  /**
   * Gets the subtitle text symbol. Contains styling information such as font, color, and symbol style.
   * @returns {WebChartTextSymbol | undefined}
   */
  getSubtitleSymbol() {
    return mt(this._config);
  }
  /**
   * Sets the subtitle text symbol. Contains styling information such as font, color, and symbol style.
   * @param {WebChartTextSymbol | undefined} subtitleSymbol The title symbol.
   */
  setSubtitleSymbol(t) {
    pt(t, this._config), this.emitConfigUpdate("setSubtitleSymbol");
  }
  /**
   * Gets the description text symbol. Contains styling information such as font, color, and symbol style.
   * @returns {WebChartTextSymbol | undefined}
   */
  getDescriptionSymbol() {
    return St(this._config);
  }
  /**
   * Sets the description text symbol. Contains styling information such as font, color, and symbol style.
   * @param {WebChartTextSymbol | undefined} descriptionSymbol The description symbol.
   */
  setDescriptionSymbol(t) {
    vt(t, this._config), this.emitConfigUpdate("setDescriptionSymbol");
  }
  /**
   * Gets the background color of the chart.
   * @returns {Color | undefined}
   */
  getBackgroundColor() {
    return _t(this._config);
  }
  /**
   * Sets the background color of the chart.
   * @param {Color | undefined} backgroundColor The background color.
   */
  setBackgroundColor(t) {
    Tt(t, this._config), this.emitConfigUpdate("setBackgroundColor");
  }
  // ---------------------------------------------------------------------------------------------
  // Series Methods
  // ---------------------------------------------------------------------------------------------
  /**
   * Gets the visibility of a series.
   * @param seriesIndex The series index
   * @returns {boolean}
   */
  getSeriesVisibility(t) {
    return Gt(t, this._config);
  }
  /**
   * Sets the visibility of a series.
   * @param {boolean} props.visible
   * @param {string} props.seriesId
   * @param {OverlayTerms} props.overlayType
   * @param {string} props.sliceId
   * @param {WebChartDataItem} props.sliceData
   */
  setSeriesVisibility(t) {
    k({ detail: t }, this._config), this.emitConfigUpdate("setSeriesVisibility");
  }
  /**
   * Gets the series ID for a given series index.
   *
   * If the series index is out of bounds, this function will return `undefined`.
   *
   * @param {number} seriesIndex The index of the series.
   * @returns {string | undefined}
   */
  getSeriesId(t) {
    return Lt(t, this._config);
  }
  /**
   * Gets the series index for a given series ID.
   *
   * If the series ID is not found, this function will return `undefined`.
   *
   * @param {string} seriesId
   * @returns {number | undefined}
   */
  getSeriesIndex(t) {
    return At(t, this._config);
  }
  /**
   * Gets the length of the series array.
   * @returns {number}
   */
  getSeriesLength() {
    return Vt(this._config);
  }
  /**
   * Gets the chart sub type of the series.
   * @returns {ChartSubType}
   */
  getChartSubType() {
    return z(this._config.series);
  }
  // ---------------------------------------------------------------------------------------------
  // Data Methods
  // ---------------------------------------------------------------------------------------------
  /**
   * Sets whether to fetch `null` values for them to be counted or displayed as categories on the chart.
   *
   * @param fetchNULLValues Whether to fetch `null` values.
   */
  setFetchNULLValues(t) {
    W(t, this._config), this.emitConfigUpdate("setFetchNULLValues");
  }
  /**
   * Gets whether to fetch `null` values for them to be counted or displayed as categories on the chart.
   *
   * @returns {boolean} Boolean value indicates whether NULL values will be fetched.
   */
  getFetchNULLValues() {
    return Z(this._config);
  }
  /**
   * Gets the split-by values for the chart.
   * @returns {string[]}
   */
  getSplitByValues() {
    return P(this._config);
  }
  // ---------------------------------------------------------------------------------------------
  // Protected Methods
  // ---------------------------------------------------------------------------------------------
  /**
   * Emits a config update event.
   * @category Protected
   */
  emitConfigUpdate(t) {
    this.dispatchEvent(
      new CustomEvent("arcgisChartsModelConfigChange", {
        detail: { config: this._config, functionCalled: t }
      })
    );
  }
  /**
   * A function that loads the config based on the provided props.
   * @category Protected
   * @param params.layer The layer to be used as the data source for the chart.
   * @param params.iLayer The layer description to use if the layer is not provided
   * @param params.config The config object to be loaded.
   */
  async loadConfigFromLayer(t) {
    const { layer: i, iLayer: s, config: r } = t;
    let a = i;
    if (!a && s && (a = await I(s)), a) {
      const h = await E(a, !0), { objectIdField: R } = a;
      this.layerInfo = {
        layer: a,
        layerFieldsInfo: h,
        objectIdField: R
      };
    }
    this._config = r !== void 0 ? await it(r) : await this.generateDefaultConfig(), this._config.legend !== void 0 && this._config.legend?.title === void 0 && (this._config.legend.title = H().title), s && (this._config.iLayer = s);
  }
}
const U = (e, t) => {
  const i = t.title?.content.text;
  (t.title === void 0 || e === void 0) && (t.title = c({
    text: "",
    visible: !0,
    font: l(o.AxisTitle),
    type: o.AxisTitle
  })), e !== void 0 && (t.title.content = e), t.title.content.text = i;
}, Ut = (e) => e.axes?.[0]?.title?.content, Bt = (e, t) => {
  t.axes?.[0] !== void 0 && U(e, t.axes[0]);
}, Xt = (e) => e.axes?.[1]?.title?.content, Yt = (e, t) => {
  t.axes?.[1] !== void 0 && U(e, t.axes[1]);
}, Dt = (e) => {
  for (const t of e.axes ?? [])
    if (t?.labels !== void 0)
      return t.labels.content;
}, Mt = (e, t) => {
  for (const i of t.axes ?? [])
    if (i !== void 0) {
      const s = i.labels?.content.text;
      e === void 0 ? i.labels = c({
        text: "",
        visible: !0,
        font: l(o.AxisLabels),
        type: o.AxisLabels
      }) : i.labels.content = u(e), i.labels.content.text = s;
    }
}, Ft = (e) => {
  for (const t of e.axes ?? [])
    if (t?.lineSymbol !== void 0)
      return t.lineSymbol;
}, wt = (e, t) => {
  for (const i of t.axes ?? [])
    i !== void 0 && (i.lineSymbol = u(e) ?? S());
}, Rt = (e) => {
  for (const t of e.axes ?? [])
    if (t?.grid !== void 0)
      return t.grid;
}, kt = (e, t) => {
  const i = t.axes;
  switch (st(t.series)) {
    // set y-axis grid line for charts -Bar chart/Line chart, Histogram and Box plot
    case g.BarSeries:
    case g.LineSeries:
    case g.ComboLineAndBarSeries:
    case g.HistogramSeries:
    case g.BoxPlotSeries:
    case g.RadarSeries: {
      i?.[1] !== void 0 && (i[1].grid = u(e));
      break;
    }
    // set both x and y-axis grid lines for charts - Scatter chart
    case g.ScatterSeries: {
      t.axes?.forEach((r) => {
        r !== void 0 && (r.grid = u(e));
      });
      break;
    }
    case g.PieSeries:
  }
}, m = (e, t) => t.axes?.[e]?.title?.content.text ?? "", B = (e, t, i) => {
  const s = i.axes?.[t];
  s?.title !== void 0 ? s.title.content.text = e : s !== void 0 && s?.title === void 0 && (s.title = c({
    text: e,
    visible: !0,
    font: l(o.AxisTitle)
  }));
}, X = (e, t) => t.axes?.[e]?.title?.visible ?? !1, Y = (e, t, i) => {
  const s = i.axes?.[t];
  s?.title !== void 0 ? s.title.visible = e : s !== void 0 && s?.title === void 0 && (s.title = c({
    text: m(t, i),
    visible: e,
    font: l(o.AxisTitle)
  }));
}, zt = (e) => e.axes?.[0].isLogarithmic ?? !1, It = async (e, t) => {
  e.axes?.[0] !== void 0 && (e.axes[0].isLogarithmic = t, await v(e, null), await _(e, null));
}, Et = (e) => e.axes?.[1]?.isLogarithmic ?? !1, Ht = async (e, t) => {
  e.axes?.[1] !== void 0 && (e.axes[1].isLogarithmic = t, await T(e, null), await L(e, null));
}, Nt = (e) => e.axes?.[0]?.scrollbar, Ot = (e, t) => {
  e.axes?.[0] !== void 0 && (e.axes[0].scrollbar = t);
}, Wt = (e) => e.axes?.[1]?.scrollbar, Zt = (e, t) => {
  e.axes?.[1] !== void 0 && (e.axes[1].scrollbar = t);
}, Pt = (e, t) => e.axes?.[t]?.displayZeroLine ?? !1, jt = (e, t, i) => {
  e.axes?.[i] !== void 0 && (e.axes[i].displayZeroLine = t);
}, qt = (e, t) => e.axes?.[t]?.displayCursorTooltip ?? !1, Jt = (e, t, i) => {
  e.axes?.[i] !== void 0 && (e.axes[i].displayCursorTooltip = t);
}, Kt = (e, t) => e.axes?.[t]?.buffer ?? !1, Qt = (e, t, i) => {
  const s = e.axes?.[i];
  s !== void 0 && (s.buffer = t);
}, $t = (e, t) => e.axes?.[t]?.tickSpacing, te = (e, t, i) => {
  e.axes?.[i] !== void 0 && (e.axes[i].tickSpacing = t);
}, ee = (e, t) => e.axes?.[t]?.integerOnlyValues ?? !1, ie = (e, t, i) => {
  e.axes?.[i] !== void 0 && (e.axes[i].integerOnlyValues = t);
};
class D extends G {
  /**
   * Gets the x-axis title text.
   * @returns {string}
   */
  getXAxisTitleText() {
    return m(0, this._config);
  }
  /**
   * Sets the x-axis title text.
   * @param {string} newXAxisTitleText - The new x-axis title text.
   */
  setXAxisTitleText(t) {
    B(t, 0, this._config), this.emitConfigUpdate("setXAxisTitleText");
  }
  /**
   * Gets whether the x-axis title is visible or not.
   *
   * `true`: X-axis title is visible.
   *
   * `false`: X-axis title is hidden.
   *
   * @returns {boolean}
   */
  getXAxisTitleVisibility() {
    return X(0, this._config);
  }
  /**
   * Sets the visibility of the x-axis title.
   *
   * `true`: X-axis title is visible.
   *
   * `false`: X-axis title is hidden.
   *
   * @param {boolean} newXAxisTitleVisibility - Whether the x-axis title is visible or not.
   */
  setXAxisTitleVisibility(t) {
    Y(t, 0, this._config), this.emitConfigUpdate("setXAxisTitleVisibility");
  }
  /**
   * Gets the maximum bound that is currently set for the x-axis.
   * @returns {number | null}
   */
  getMaxXBound() {
    return j(this._config);
  }
  /**
   * Sets the maximum bound for the x-axis.
   * @param {number | null} newMaxXBound - The new maximum bound for the x-axis.
   * @async **This method is `async` and must be awaited for the changes to take effect.**
   */
  async setMaxXBound(t) {
    await v(this._config, t), this.emitConfigUpdate("setMaxXBound");
  }
  /**
   * Gets the minimum bound that is currently set for the x-axis.
   * @returns {number | null}
   */
  getMinXBound() {
    return q(this._config);
  }
  /**
   * Sets the minimum bound for the x-axis.
   * @param {number | null} newMinXBound - The new minimum bound for the x-axis.
   * @async **This method is `async` and must be awaited for the changes to take effect.**
   */
  async setMinXBound(t) {
    await _(this._config, t), this.emitConfigUpdate("setMinXBound");
  }
  /**
   * Gets the x-axis title text symbol. Contains styling information such as font, color, and symbol style.
   * @returns {WebChartTextSymbol | undefined}
   */
  getXAxisTitleSymbol() {
    return Ut(this._config);
  }
  /**
   * Sets the x-axis title text symbol. Contains styling information such as font, color, and symbol style.
   * @param {WebChartTextSymbol | undefined} newXAxisTitle - The new x-axis title text symbol.
   */
  setXAxisTitleSymbol(t) {
    Bt(t, this._config), this.emitConfigUpdate("setXAxisTitleSymbol");
  }
  /**
   * Gets the axis labels text symbol. Contains styling information such as font, color, and symbol style.
   * @returns {WebChartTextSymbol | undefined}
   */
  getAxisLabelsSymbol() {
    return Dt(this._config);
  }
  /**
   * Sets the axis labels text symbol. Contains styling information such as font, color, and symbol style.
   * @param {WebChartTextSymbol | undefined} newAxisLabelsSymbol - The new axis labels text symbol.
   */
  setAxisLabelsSymbol(t) {
    Mt(t, this._config), this.emitConfigUpdate("setAxisLabelsSymbol");
  }
  /**
   * Gets the axis lines symbol. Contains styling information such as line width, line style, and line color.
   * @returns {ISimpleLineSymbol | undefined}
   */
  getAxisLinesSymbol() {
    return Ft(this._config);
  }
  /**
   * Sets the axis lines symbol. Contains styling information such as line width, line style, and line color.
   * @param {ISimpleLineSymbol | undefined} newAxisLinesSymbol - The new axis lines symbol.
   */
  setAxisLinesSymbol(t) {
    wt(t, this._config), this.emitConfigUpdate("setAxisLinesSymbol");
  }
}
const se = (e) => e.horizontalAxisLabelsBehavior ?? p.Rotate, oe = (e, t) => {
  t.horizontalAxisLabelsBehavior = e;
}, re = (e) => e.verticalAxisLabelsBehavior ?? p.Wrap, ne = (e, t) => {
  t.verticalAxisLabelsBehavior = e;
}, ae = (e) => e.cursorCrosshair?.horizontalLineVisible ?? !1, le = (e, t) => {
  t.cursorCrosshair === void 0 && (t.cursorCrosshair = b()), t.cursorCrosshair.horizontalLineVisible = e;
}, ce = (e) => e.cursorCrosshair?.verticalLineVisible ?? !1, ge = (e, t) => {
  t.cursorCrosshair === void 0 && (t.cursorCrosshair = b()), t.cursorCrosshair.verticalLineVisible = e;
}, de = (e) => e.cursorCrosshair?.style, ue = (e, t) => {
  t.cursorCrosshair === void 0 && (t.cursorCrosshair = b()), t.cursorCrosshair.style = e;
}, he = (e) => e.cursorCrosshair, fe = (e, t) => {
  t.cursorCrosshair = e;
};
class xe extends D {
  /**
   * Gets the Y-axis title text.
   * @returns {string}
   */
  getYAxisTitleText() {
    return m(1, this._config);
  }
  /**
   * Sets the Y-axis title text.
   * @param {string} titleText The Y-axis title text.
   */
  setYAxisTitleText(t) {
    B(t, 1, this._config), this.emitConfigUpdate("setYAxisTitleText");
  }
  /**
   * Gets the visibility of the Y-axis title.
   *
   * `true`: The Y-axis title is visible.
   *
   * `false`: The Y-axis title is hidden.
   *
   * @returns {boolean}
   */
  getYAxisTitleVisibility() {
    return X(1, this._config);
  }
  /**
   * Sets the visibility of the Y-axis title.
   *
   * `true`: Show the Y-axis title.
   *
   * `false`: Hide the Y-axis title.
   *
   * @param {boolean} visibility The visibility state of the Y-axis title.
   */
  setYAxisTitleVisibility(t) {
    Y(t, 1, this._config), this.emitConfigUpdate("setYAxisTitleVisibility");
  }
  /**
   * Gets the maximum bound for the y-axis.
   * @returns {number | null}
   */
  getMaxYBound() {
    return J(this._config);
  }
  /**
   * Sets the maximum bound for the y-axis.
   * @param {number | null} maxBound The maximum bound for the y-axis. If `null`, the maximum bound is automatically calculated.
   * @async **This method is `async` and must be awaited for the changes to take effect.**
   */
  async setMaxYBound(t) {
    await T(this._config, t), this.emitConfigUpdate("setMaxYBound");
  }
  /**
   * Gets the minimum bound for the y-axis.
   * @returns {number | null}
   */
  getMinYBound() {
    return K(this._config);
  }
  /**
   * Sets the minimum bound for the y-axis.
   * @param {number | null} minBound The minimum bound for the y-axis. If `null`, the minimum bound is automatically calculated.
   * @async **This method is `async` and must be awaited for the changes to take effect.**
   */
  async setMinYBound(t) {
    await L(this._config, t), this.emitConfigUpdate("setMinYBound");
  }
  /**
   * Gets the value format options for the x-axis.
   * @returns {CategoryFormatOptions | DateTimeFormatOptions | NumberFormatOptions | undefined}
   */
  getXAxisValueFormat() {
    return Q(this._config);
  }
  /**
   * Sets the value format options for the x-axis.
   * @param {CategoryFormatOptions | DateTimeFormatOptions | NumberFormatOptions | undefined} valueFormat The value format options for the x-axis.
   * @async **This method is `async` and must be awaited for the changes to take effect.**
   */
  async setXAxisValueFormat(t) {
    await $(this._config, t), this.emitConfigUpdate("setXAxisValueFormat");
  }
  /**
   * Gets the value format options for the y-axis.
   * @returns {NumberFormatOptions | undefined}
   */
  getYAxisValueFormat() {
    return tt(this._config);
  }
  /**
   * Sets the value format options for the y-axis.
   * @param {NumberFormatOptions | undefined} valueFormat The value format options for the y-axis.
   * @async **This method is `async` and must be awaited for the changes to take effect.**
   */
  async setYAxisValueFormat(t) {
    await et(this._config, t), this.emitConfigUpdate("setYAxisValueFormat");
  }
  /**
   * Gets whether logarithmic scale is enabled for the x-axis.
   *
   * `true`: Logarithmic scale is enabled for the x-axis.
   *
   * `false`: Logarithmic scale is disabled for the x-axis.
   *
   * @returns {boolean}
   */
  getXLogarithmic() {
    return zt(this._config);
  }
  /**
   * Sets whether logarithmic scale is enabled for the x-axis.
   *
   * `true`: Enable logarithmic scale for the x-axis.
   *
   * `false`: Disable logarithmic scale for the x-axis.
   *
   * @param {boolean} logarithmicState The state of the logarithmic scale for the x-axis.
   * @async **This method is `async` and must be awaited for the changes to take effect.**
   */
  async setXLogarithmic(t) {
    await It(this._config, t), this.emitConfigUpdate("setXLogarithmic");
  }
  /**
   * Gets whether logarithmic scale is enabled for the y-axis.
   *
   * `true`: Logarithmic scale is enabled for the y-axis.
   *
   * `false`: Logarithmic scale is disabled for the y-axis.
   *
   * @returns {boolean}
   */
  getYLogarithmic() {
    return Et(this._config);
  }
  /**
   * Sets whether logarithmic scale is enabled for the y-axis.
   *
   * `true`: Enable logarithmic scale for the y-axis.
   *
   * `false`: Disable logarithmic scale for the y-axis.
   *
   * @param {boolean} logarithmicState The state of the logarithmic scale for the y-axis.
   * @async **This method is `async` and must be awaited for the changes to take effect.**
   */
  async setYLogarithmic(t) {
    await Ht(this._config, t), this.emitConfigUpdate("setYLogarithmic");
  }
  /**
   * Gets the x-axis scrollbar configuration.
   * @returns {WebChartAxisScrollBar | undefined}
   */
  getXAxisScrollbar() {
    return Nt(this._config);
  }
  /**
   * Sets the x-axis scrollbar configuration.
   * @param {WebChartAxisScrollBar} scrollbar The x-axis scrollbar configuration.
   */
  setXAxisScrollbar(t) {
    Ot(this._config, t), this.emitConfigUpdate("setXAxisScrollbar");
  }
  /**
   * Gets the y-axis scrollbar configuration.
   * @returns {WebChartAxisScrollBar | undefined}
   */
  getYAxisScrollbar() {
    return Wt(this._config);
  }
  /**
   * Sets the y-axis scrollbar configuration.
   * @param {WebChartAxisScrollBar} scrollbar The y-axis scrollbar configuration.
   */
  setYAxisScrollbar(t) {
    Zt(this._config, t), this.emitConfigUpdate("setYAxisScrollbar");
  }
  /**
   * Gets the y-axis title text symbol. Contains styling information such as font, color, and symbol style.
   * @returns {WebChartTextSymbol | undefined}
   */
  getYAxisTitleSymbol() {
    return Xt(this._config);
  }
  /**
   * Sets the y-axis title text symbol. Contains styling information such as font, color, and symbol style.
   * @param {WebChartTextSymbol | undefined} titleSymbol The y-axis title text symbol.
   */
  setYAxisTitleSymbol(t) {
    Yt(t, this._config), this.emitConfigUpdate("setYAxisTitleSymbol");
  }
  /**
   * Gets the horizontal axis labels behavior for the chart.
   * @returns {WebChartLabelBehavior}
   */
  getHorizontalAxisLabelsBehavior() {
    return se(this._config);
  }
  /**
   * Sets the horizontal axis labels behavior for the chart.
   * @param horizontalBehavior The behavior for the horizontal axis labels.
   */
  setHorizontalAxisLabelsBehavior(t) {
    oe(t, this._config), this.emitConfigUpdate("setHorizontalAxisLabelsBehavior");
  }
  /**
   * Gets the vertical axis labels behavior for the chart.
   * @returns {WebChartLabelBehavior}
   */
  getVerticalAxisLabelsBehavior() {
    return re(this._config);
  }
  /**
   * Sets the vertical axis labels behavior for the chart.
   * @param verticalBehavior The behavior for the vertical axis labels.
   */
  setVerticalAxisLabelsBehavior(t) {
    ne(t, this._config), this.emitConfigUpdate("setVerticalAxisLabelsBehavior");
  }
  /**
   * Gets the grid lines symbol. Contains styling information such as line width, line style, and line color.
   * @returns {ISimpleLineSymbol | undefined}
   */
  getGridLinesSymbol() {
    return Rt(this._config);
  }
  /**
   * Sets the grid lines symbol. Contains styling information such as line width, line style, and line color.
   * @param {ISimpleLineSymbol | undefined} linesSymbol The grid lines symbol.
   */
  setGridLinesSymbol(t) {
    kt(t, this._config), this.emitConfigUpdate("setGridLinesSymbol");
  }
  /**
   * Gets the display zero line setting for the specified axis.
   * @param axisIndex The index of the axis to get the display zero line for.
   * @returns {boolean}
   * @remarks
   * a. This setting is only applicable to the axis of type ValueAxis.
   * b. To get the setting for the x-axis, the axisIndex should be `0`. For the y-axis, the axisIndex should be `1`.
   * c. If the displayZeroLine is not set on the axis, the default value of `false` will be returned.
   */
  getDisplayZeroLine(t) {
    return Pt(this._config, t);
  }
  /**
   * Sets the display zero line setting for the specified axis.
   * @param displayZeroLine The display zero line setting for the axis.
   * @param axisIndex The index of the axis to set the display zero line for.
   * @remarks
   * a. This setting is only applicable to the axis of type ValueAxis.
   * b. To set the setting for the x-axis, the axisIndex should be `0`. For the y-axis, the axisIndex should be `1`.
   */
  setDisplayZeroLine(t, i) {
    jt(this._config, t, i), this.emitConfigUpdate("setDisplayZeroLine");
  }
  /**
   * Gets the display cursor tooltip setting for the specified axis.
   * @param axisIndex The index of the axis to get the display cursor tooltip for.
   * @returns {boolean}
   * @remarks
   * a. To get the setting for the x-axis, the axisIndex should be `0`. For the y-axis, the axisIndex should be `1`.
   * b. If the displayCursorTooltip is not set on the axis, the default value of `false` will be returned.
   */
  getDisplayCursorTooltip(t) {
    return qt(this._config, t);
  }
  /**
   * Sets the display cursor tooltip setting for the specified axis.
   * @param displayCursorTooltip The display cursor tooltip setting for the axis.
   * @param axisIndex The index of the axis to set the display cursor tooltip for.
   * @remarks
   * a. To set the setting for the x-axis, the axisIndex should be `0`. For the y-axis, the axisIndex should be `1`.
   */
  setDisplayCursorTooltip(t, i) {
    Jt(this._config, t, i), this.emitConfigUpdate("setDisplayCursorTooltip");
  }
  /**
   * Gets the buffer setting for the specified axis.
   * @param axisIndex The index of the axis
   * @returns {boolean}
   * @remarks
   * a. This setting is only applicable to the axis of type ValueAxis.
   * b. To get the setting for the x-axis, the axisIndex should be `0`. For the y-axis, the axisIndex should be `1`.
   * c. If the `buffer` is not set on the axis, the default value of `false` will be returned.
   */
  getBuffer(t) {
    return Kt(this._config, t);
  }
  /**
   * Sets the buffer for the specified axis.
   * @param buffer The setting for the buffer
   * @param axisIndex The index of the axis
   * @remarks
   * a. This setting is only applicable to the axis of type ValueAxis.
   * b. To set the setting for the x-axis, the axisIndex should be `0`. For the y-axis, the axisIndex should be `1`.
   */
  setBuffer(t, i) {
    Qt(this._config, t, i), this.emitConfigUpdate("setBuffer");
  }
  /**
   * Gets the tick spacing setting for the specified axis.
   * @param axisIndex The index of the axis
   * @returns {number}
   * @remarks
   * a. To get the setting for the x-axis, the axisIndex should be `0`. For the y-axis, the axisIndex should be `1`.
   */
  getTickSpacing(t) {
    return $t(this._config, t);
  }
  /**
   * Sets the tick spacing for the specified axis.
   * @param tickSpacing The value to set for the tick spacing
   * @param axisIndex The index of the axis
   * @remarks
   * a. To set the setting for the x-axis, the axisIndex should be `0`. For the y-axis, the axisIndex should be `1`.
   */
  setTickSpacing(t, i) {
    te(this._config, t, i), this.emitConfigUpdate("setTickSpacing");
  }
  /**
   * Gets the integer only values setting for the specified axis.
   * @param axisIndex The index of the axis
   * @returns {boolean}
   * @remarks
   * a. This setting is only applicable to the axis of type ValueAxis.
   * b. To get the setting for the x-axis, the axisIndex should be `0`. For the y-axis, the axisIndex should be `1`.
   * c. If the `integerOnlyValues` is not set on the axis, the default value of `false` will be returned.
   */
  getIntegerOnlyValues(t) {
    return ee(this._config, t);
  }
  /**
   * Sets the integer only values setting for the specified axis.
   * @param integerOnlyValues The boolean value to set for the integer only values setting
   * @param axisIndex The index of the axis
   * @remarks
   * a. This setting is only applicable to the axis of type ValueAxis.
   * b. To set the setting for the x-axis, the axisIndex should be `0`. For the y-axis, the axisIndex should be `1`.
   */
  setIntegerOnlyValues(t, i) {
    ie(this._config, t, i), this.emitConfigUpdate("setIntegerOnlyValues");
  }
  /**
   * Gets the visibility of the horizontal line of the cursor's crosshair.
   * @returns {boolean}
   * @remarks if the cursor crosshair or its horizontal line visibility is not set, the default value of `false` will be returned.
   */
  getCursorCrosshairHorizontalLineVisibility() {
    return ae(this._config);
  }
  /**
   * Sets the visibility of the horizontal line of the cursor's crosshair.
   * @param visibility The visibility to set for the cursor's crosshair horizontal line
   * @remarks if the cursor crosshair is not set, it will be created with the default values.
   */
  setCursorCrosshairHorizontalLineVisibility(t) {
    le(t, this._config), this.emitConfigUpdate("setCursorCrosshairHorizontalLineVisibility");
  }
  /**
   * Gets the visibility of the vertical line of the cursor's crosshair.
   * @returns {boolean}
   * @remarks if the cursor crosshair or its vertical line visibility is not set, the default value of `false` will be returned.
   */
  getCursorCrosshairVerticalLineVisibility() {
    return ce(this._config);
  }
  /**
   * Sets the visibility of the vertical line of the cursor's crosshair.
   * @param visibility The visibility to set for the cursor's crosshair vertical line
   * @remarks if the cursor crosshair is not set, it will be created with the default values.
   */
  setCursorCrosshairVerticalLineVisibility(t) {
    ge(t, this._config), this.emitConfigUpdate("setCursorCrosshairVerticalLineVisibility");
  }
  /**
   * Gets the style of the cursor's crosshair from the chart config.
   * @param config The chart configuration
   * @returns {boolean}
   */
  getCursorCrosshairStyle() {
    return de(this._config);
  }
  /**
   * Sets the style of the cursor's crosshair in the chart config.
   * @param style The style to set for the cursor's crosshair
   * @param config The chart configuration
   */
  setCursorCrosshairStyle(t) {
    ue(t, this._config), this.emitConfigUpdate("setCursorCrosshairStyle");
  }
  /**
   * Gets the cursor crosshair from the chart config.
   * @param config The chart configuration object
   * @returns {WebChartCursorCrosshair | undefined}
   */
  getCursorCrosshair() {
    return he(this._config);
  }
  /**
   * Sets the cursor crosshair in the chart config.
   * @param cursorCrosshair The cursor crosshair to set
   * @param config The chart configuration object
   */
  setCursorCrosshair(t) {
    fe(t, this._config), this.emitConfigUpdate("setCursorCrosshair");
  }
}
C(xe, [D]);
const be = (e) => {
  for (const t of e.axes ?? [])
    for (const i of t?.guides ?? [])
      if (i.label !== void 0)
        return i.label;
}, Ce = (e, t) => {
  for (const i of t.axes ?? [])
    for (const s of i?.guides ?? []) {
      const r = s.label?.text ?? "";
      s.label = u(e), s.label !== void 0 && (s.label.text = r);
    }
};
function n(e) {
  return {
    ...e,
    axis: e.orientation === d.X ? e.config.axes?.[0] : e.config.axes?.[1],
    index: e.index ?? 0,
    orientation: e.orientation ?? d.Y
  };
}
const ye = (e) => {
  const { axis: t, index: i } = n(e);
  return t?.guides?.[i]?.visible ?? !0;
}, me = (e) => {
  const { visible: t, axis: i, index: s } = n(e);
  i?.guides?.[s] !== void 0 && (i.guides[s].visible = t);
}, M = (e) => {
  const t = O(e.start, e.end);
  ot(e.style) && t === f.SFS ? e.style = { type: f.SFS, color: e.style.color } : rt(e.style) && t === f.SLS && (e.style = { type: f.SLS, color: e.style.color });
}, pe = (e) => {
  const { axis: t, index: i } = n(e);
  return t?.guides?.[i]?.start ?? null;
}, Se = (e) => {
  const { start: t, axis: i, index: s } = n(e);
  i?.guides?.[s] !== void 0 && (i.guides[s].start = t, M(i.guides[s]));
}, ve = (e) => {
  const { axis: t, index: i } = n(e);
  return t?.guides?.[i]?.end;
}, _e = (e) => {
  const { end: t, axis: i, index: s } = n(e);
  i?.guides?.[s] !== void 0 && (i.guides[s].end = t, M(i.guides[s]));
}, Te = (e) => {
  const { axis: t, index: i } = n(e);
  return t?.guides?.[i]?.name;
}, Le = (e) => {
  const { name: t, axis: i, index: s } = n(e);
  i?.guides?.[s] !== void 0 && (i.guides[s].name = t);
}, Ae = (e) => {
  const { axis: t, index: i } = n(e);
  return t?.guides?.[i]?.label?.text;
}, Ve = (e) => {
  const { labelText: t, axis: i, index: s } = n(e), r = i?.guides?.[s]?.label ?? N(t, l(o.GuideLabel), o.GuideLabel);
  i?.guides?.[s] !== void 0 && (i.guides[s].label = { ...r, text: t });
}, Ge = (e) => {
  const { axis: t, index: i } = n(e);
  return t?.guides?.[i]?.above ?? !1;
}, Ue = (e) => {
  const { above: t, axis: i, index: s } = n(e);
  i?.guides?.[s] !== void 0 && (i.guides[s].above = t);
}, Be = (e) => {
  const { axis: t, index: i } = n(e);
  return t?.guides?.[i]?.style;
}, Xe = (e) => {
  const { style: t, axis: i, index: s } = n(e);
  i?.guides?.[s] !== void 0 && (i.guides[s].style = t);
}, F = (e) => {
  const { config: t, name: i, index: s, orientation: r } = e, a = r === d.X ? t.axes?.[0] : t.axes?.[1];
  if (a !== void 0) {
    a.guides = a.guides ?? [];
    const h = {
      type: g.Guide,
      name: i,
      start: a.valueFormat.type === g.DateAxisFormat ? "" : 0,
      style: S()
    };
    s !== void 0 && s < a.guides.length ? a.guides.splice(s, 0, h) : a.guides.push(h);
  }
}, w = (e) => {
  const { config: t, index: i, orientation: s } = e, r = s === d.X ? t.axes?.[0] : t.axes?.[1];
  r?.guides !== void 0 && (i !== void 0 && i < r.guides.length ? r.guides.splice(i, 1) : r.guides.pop());
}, Ye = (e) => {
  const { axis: t, index: i } = n(e);
  return t?.guides?.[i]?.tooltipReverseColor ?? !1;
}, De = (e) => {
  const { reverseColor: t, axis: i, index: s } = n(e);
  i?.guides?.[s] !== void 0 && (i.guides[s].tooltipReverseColor = t);
};
class x extends G {
  /**
   * Gets the guide labels text symbol. Contains styling information such as font, color, and symbol style.
   * @returns {WebChartTextSymbol | undefined}
   */
  getGuideLabelsSymbol() {
    return be(this._config);
  }
  /**
   * Sets the guide labels text symbol. Contains styling information such as font, color, and symbol style.
   * @param {WebChartTextSymbol | undefined} newGuideLabelsSymbol
   */
  setGuideLabelsSymbol(t) {
    Ce(t, this._config), this.emitConfigUpdate("setGuideLabels");
  }
  /**
   * Gets whether a guide is visible.
   * @param {number} [index] Default `0`. The index of the guide in the list of guides for the given axis orientation.
   * @param {GuideOrientation} [orientation] Default `y`. The axis orientation of the guide.
   * @returns {boolean}
   */
  getGuideVisibility(t, i) {
    return ye({ config: this._config, index: t, orientation: i });
  }
  /**
   * Sets whether a guide is visible
   * @param {boolean} visible New visibility to set.
   * @param {number} [index] Default `0`. The index of the guide in the list of guides for the given axis orientation.
   * @param {GuideOrientation} [orientation] Default `y`. The axis orientation of the guide.
   */
  setGuideVisibility(t, i, s) {
    me({ visible: t, config: this._config, index: i, orientation: s }), this.emitConfigUpdate("setGuideVisibility");
  }
  /**
   * Gets the start value of a guide.
   * @param {number} [index] Default `0`. The index of the guide in the list of guides for the given axis orientation.
   * @param {GuideOrientation} [orientation] Default `y`. The axis orientation of the guide.
   * @returns {Date | number | string | null}
   */
  getGuideStart(t, i) {
    return pe({ config: this._config, index: t, orientation: i });
  }
  /**
   * Sets the start value of a guide.
   * @param {Date | number | string | null} start New start value to set.
   * @param {number} [index] Default `0`. The index of the guide in the list of guides for the given axis orientation.
   * @param {GuideOrientation} [orientation] Default `y`. The axis orientation of the guide.
   */
  setGuideStart(t, i, s) {
    Se({ start: t, config: this._config, index: i, orientation: s }), this.emitConfigUpdate("setGuideStart");
  }
  /**
   * Gets the end value of a guide.
   * @param {number} [index] Default `0`. The index of the guide in the list of guides for the given axis orientation.
   * @param {GuideOrientation} [orientation] Default `y`. The axis orientation of the guide.
   * @returns {Date | number | string | null}
   */
  getGuideEnd(t, i) {
    return ve({ config: this._config, index: t, orientation: i });
  }
  /**
   * Sets the end value of a guide.
   * @param {Date | number | string | null | undefined} end New end value to set.
   * @param {number} [index] Default `0`. The index of the guide in the list of guides for the given axis orientation.
   * @param {GuideOrientation} [orientation] Default `y`. The axis orientation of the guide.
   */
  setGuideEnd(t, i, s) {
    _e({ end: t, config: this._config, index: i, orientation: s }), this.emitConfigUpdate("setGuideEnd");
  }
  /**
   * Gets the name of a guide.
   * @param {number} [index] Default `0`. The index of the guide in the list of guides for the given axis orientation.
   * @param {GuideOrientation} [orientation] Default `y`. The axis orientation of the guide.
   * @returns {string | undefined}
   */
  getGuideName(t, i) {
    return Te({ config: this._config, index: t, orientation: i });
  }
  /**
   * Sets the name of a guide.
   * @param {string} name New name to set.
   * @param {number} [index] Default `0`. The index of the guide in the list of guides for the given axis orientation.
   * @param {GuideOrientation} [orientation] Default `y`. The axis orientation of the guide.
   */
  setGuideName(t, i, s) {
    Le({ name: t, config: this._config, index: i, orientation: s }), this.emitConfigUpdate("setGuideName");
  }
  /**
   * Gets the guide label text.
   * @param {number} [index] Default `0`. The index of the guide in the list of guides for the given axis orientation.
   * @param {GuideOrientation} [orientation] Default `y`. The axis orientation of the guide.
   * @returns {string | undefined}
   */
  getGuideLabelText(t, i) {
    return Ae({ config: this._config, index: t, orientation: i });
  }
  /**
   * Sets the guide label text.
   * @param {string} labelText New label text to set.
   * @param {number} [index] Default `0`. The index of the guide in the list of guides for the given axis orientation.
   * @param {GuideOrientation} [orientation] Default `y`. The axis orientation of the guide.
   */
  setGuideLabelText(t, i, s) {
    Ve({ labelText: t, config: this._config, index: i, orientation: s }), this.emitConfigUpdate("setGuideLabelText");
  }
  /**
   * Gets whether the guide should be rendered above the other chart elements.
   * @param {number} [index] Default `0`. The index of the guide in the list of guides for the given axis orientation.
   * @param {GuideOrientation} [orientation] Default `y`. The axis orientation of the guide.
   * @returns {boolean}
   */
  getGuideAbove(t, i) {
    return Ge({ config: this._config, index: t, orientation: i });
  }
  /**
   * Sets whether the guide should be rendered above the other chart elements.
   * @param {boolean} above New above boolean to set.
   * @param {number} [index] Default `0`. The index of the guide in the list of guides for the given axis orientation.
   * @param {GuideOrientation} [orientation] Default `y`. The axis orientation of the guide.
   */
  setGuideAbove(t, i, s) {
    Ue({ above: t, config: this._config, index: i, orientation: s }), this.emitConfigUpdate("setGuideAbove");
  }
  /**
   * Gets the guide style.
   * @param {number} [index] Default `0`. The index of the guide in the list of guides for the given axis orientation.
   * @param {GuideOrientation} [orientation] Default `y`. The axis orientation of the guide.
   * @returns {ISimpleFillSymbol | ISimpleLineSymbol | undefined}
   */
  getGuideStyle(t, i) {
    return Be({ config: this._config, index: t, orientation: i });
  }
  /**
   * Sets the guide style.
   * @param {ISimpleFillSymbol | ISimpleLineSymbol} style New style to set.
   * @param {number} [index] Default `0`. The index of the guide in the list of guides for the given axis orientation.
   * @param {GuideOrientation} [orientation] Default `y`. The axis orientation of the guide.
   */
  setGuideStyle(t, i, s) {
    Xe({ style: t, config: this._config, index: i, orientation: s }), this.emitConfigUpdate("setGuideStyle");
  }
  /**
   * Gets whether the tooltip text color should be reversed for a guide.
   * @param index - The index of the guide in the list of guides for the given axis orientation.
   * @param orientation - The axis orientation of the guide.
   * @returns {boolean}
   */
  getTooltipReverseColor(t, i) {
    return Ye({ config: this._config, index: t, orientation: i });
  }
  /**
   * Sets whether the tooltip text color should be reversed for a guide.
   * @param reverseColor - New reverseColor boolean to set.
   * @param index - The index of the guide in the list of guides for the given axis orientation.
   * @param orientation - The axis orientation of the guide.
   */
  setTooltipReverseColor(t, i, s) {
    De({ reverseColor: t, config: this._config, index: i, orientation: s }), this.emitConfigUpdate("setTooltipReverseColor");
  }
}
class Me extends x {
  // ---------------------------------------------------------------------------------------------
  // Guides Methods
  // ---------------------------------------------------------------------------------------------
  /**
   * Gets the number guides in the X-axis guides list.
   * @returns {number | undefined} The number of X-axis guides.
   */
  getXGuidesLength() {
    return this._config.axes?.[0]?.guides?.length;
  }
  /**
   * Adds an X-axis guide.
   * @param {string} name The name of the guide.
   * @param {number} [index] The index to insert the new guide in the list of X-axis guides. If left `undefined`, the guide is appended to the end of the list.
   */
  addXAxisGuide(t, i) {
    F({
      config: this._config,
      name: t,
      index: i,
      orientation: d.X
    }), this.emitConfigUpdate("addXAxisGuide");
  }
  /**
   * Deletes an X-axis guide.
   * @param {number} [index] The index of the guide to delete in the list of X-axis guides. If left `undefined`, the last guide in the list is deleted.
   */
  deleteXAxisGuide(t) {
    w({
      config: this._config,
      index: t,
      orientation: d.X
    }), this.emitConfigUpdate("deleteXAxisGuide");
  }
}
C(Me, [x]);
class Fe extends x {
  /**
   * Gets the number guides in the Y-axis guides list.
   * @returns {number | undefined} The number of Y-axis guides.
   */
  getYGuidesLength() {
    return this._config.axes?.[1]?.guides?.length;
  }
  /**
   * Adds a Y-axis guide.
   * @param {string} name The name of the guide.
   * @param {number} [index] The index to insert the new guide in the list of Y-axis guides. If left `undefined`, the guide is appended to the end of the list.
   */
  addYAxisGuide(t, i) {
    F({
      config: this._config,
      name: t,
      index: i,
      orientation: d.Y
    }), this.emitConfigUpdate("addYAxisGuide");
  }
  /**
   * Deletes a Y-axis guide.
   * @param {number} [index] The index of the guide to delete in the list of Y-axis guides. If left `undefined`, the last guide in the list is deleted.
   */
  deleteYAxisGuide(t) {
    w({
      config: this._config,
      index: t,
      orientation: d.Y
    }), this.emitConfigUpdate("deleteYAxisGuide");
  }
}
C(Fe, [x]);
export {
  G as C,
  xe as M,
  Fe as a,
  Me as b,
  D as c
};
