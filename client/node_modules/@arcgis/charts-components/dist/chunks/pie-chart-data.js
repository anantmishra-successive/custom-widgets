import { defaultPieFromFieldsName as O, WebChartStatisticType as u, WebChartSortOrderKinds as S, WebChartOrderDataByTypes as p, defaultPieFromFieldsValue as N } from "@arcgis/charts-spec";
import { memoize as I, cloneDeep as P, isEmpty as K, isNull as j } from "lodash-es";
import "d3-array";
import { aa as $, av as E, aL as R, c9 as D, bR as T } from "./interfaces.js";
import "@arcgis/core/geometry/support/jsonUtils.js";
import "@arcgis/core/rest/support/AttributeBinsQuery.js";
import "@arcgis/core/rest/support/Query.js";
import "@arcgis/core/rest/support/StatisticDefinition.js";
import "@arcgis/core/time/TimeExtent.js";
import "@arcgis/core/core/promiseUtils.js";
import "@arcgis/core/request.js";
import { a as y, P as c } from "./common.js";
import { g as L, u as A, f as W, d as Y } from "./data.js";
/*! All material copyright Esri, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.33/esri/copyright.txt for details.
v4.33.19 */
const q = (a) => a.series?.[0]?.x ?? "";
function z(a, t) {
  const e = a.series?.[0];
  return [`${t === y.Category ? e.y : N} ${S.Descending}`];
}
const v = (a, t) => {
  let e = c.valueDesc;
  const i = a.orderOptions?.data?.orderType ?? z(a, t), s = a.orderOptions?.data?.orderBy ?? S.Descending;
  return i === p.Category && Array.isArray(s) ? e = c.customSort : i === p.Category ? s === S.Ascending ? e = c.labelAsc : e = c.labelDesc : s === S.Ascending ? e = c.valueAsc : e = c.valueDesc, e;
}, m = I(
  // without memoizing, the worst case efficiency is O(series.length), best case is O(1)
  // with memoizing, the worst case efficiency for repeated calls becomes O(1)
  (a) => {
    let t = [];
    return t = a.series?.[0]?.query?.outStatistics?.map(
      (e) => e.onStatisticField
    ) ?? [a.series?.[0]?.y ?? ""], [...new Set(t.filter((e) => e !== ""))];
  },
  // using series array address as key, since a change to the numeric fields will always rebuild a fresh series array
  (a) => a.series
), b = (a, t) => {
  const e = m(a);
  let i;
  return t === y.Fields && e.length === 0 ? i = u.Sum : i = a.series?.[0]?.query?.outStatistics?.[0]?.statisticType ?? u.NoAggregation, i;
};
async function B(a) {
  const { config: t, layerInfo: e, mode: i } = a, { objectIdField: s } = e ?? {}, o = await E(s), r = q(t), l = t.series[0]?.dataLabels?.visible ?? !1, n = {
    ...o,
    x: i === y.Category ? r : O,
    slices: t.series?.[0]?.slices,
    dataLabels: { ...o.dataLabels, visible: l },
    innerRadiusSize: t.series?.[0]?.innerRadius,
    sliceGrouping: t.series?.[0]?.sliceGrouping,
    dataLabelsCharacterLimit: t.series?.[0]?.dataLabelsCharacterLimit,
    numericValueFormat: t.series?.[0]?.numericValueFormat,
    percentValueFormat: t.series?.[0]?.percentValueFormat,
    displayCategoryOnDataLabel: t.series?.[0]?.displayCategoryOnDataLabel,
    displayNumericValueOnDataLabel: t.series?.[0]?.displayNumericValueOnDataLabel,
    displayPercentageOnDataLabel: t.series?.[0]?.displayPercentageOnDataLabel
  }, d = b(t, i);
  if (d !== u.NoAggregation && s !== void 0) {
    const g = `${d}_${s}_0`.toUpperCase();
    n.y = i === y.Category ? g : N, n.query = {
      outStatistics: i === y.Category ? [
        {
          statisticType: d,
          onStatisticField: s,
          outStatisticFieldName: g
        }
      ] : []
    };
  }
  return i === y.Category && n.query !== void 0 ? n.query.groupByFieldsForStatistics = [r] : delete n.query?.groupByFieldsForStatistics, P(n);
}
async function w(a, t, e) {
  const { layerFieldsInfo: i, objectIdField: s } = t, o = q(a), r = m(a), l = b(a, e), n = r.length === 0 || r.includes(s), d = await R(l), g = n ? "" : r.map((x) => D(i ?? [], x)).join(", "), f = D(i ?? [], o);
  let F = "";
  const C = await W();
  let h;
  return e === y.Fields ? h = r.length === 0 : h = o === "", h ? F = C.chartType.pieChart : l === u.NoAggregation ? F = T(C.titleLabels.aggrFieldsByCategory, {
    aggregationFields: n ? s : g,
    category: f
  }) : l === u.Count ? F = T(C.titleLabels.aggrTypeCategory, {
    aggregationType: d,
    category: f
  }) : r.length > 0 && (f === O || K(f) || j(f) ? F = T(C.titleLabels.aggrTypeOfAggrFields, {
    aggregationType: d,
    aggregationFields: g
  }) : F = T(C.titleLabels.aggrTypeOfAggrFieldsByCategory, {
    aggregationType: d,
    aggregationFields: g,
    category: f
  })), F;
}
const se = (a) => {
  const { newSortOrderKind: t, config: e, orderByList: i } = a;
  e.orderOptions ??= {}, t === c.customSort && i !== void 0 ? e.orderOptions.data = {
    orderType: p.Category,
    orderBy: [...i]
  } : e.orderOptions.data = {
    orderType: t === c.labelAsc || t === c.labelDesc ? p.Category : p.YValue,
    orderBy: t === c.labelAsc || t === c.valueAsc ? S.Ascending : S.Descending
  };
}, re = async (a) => {
  const { newCategory: t, config: e, layerInfo: i, mode: s } = a, o = e.series?.length ?? 0;
  if (e.series.forEach((r) => {
    r.x = s === y.Category ? t : O, r.query !== void 0 && t !== O ? r.query.groupByFieldsForStatistics = [t] : delete r.query?.groupByFieldsForStatistics;
  }), o === 0) {
    const r = [await B({ config: e, layerInfo: i, mode: s })];
    e.series = r;
  }
  if (i !== void 0) {
    const r = await L({
      config: e,
      layerInfo: i,
      numericFields: m(e),
      aggregationType: b(e, s)
    });
    A(e, 1, r), e.title && (e.title.content.text = await w(e, i, s));
    const l = s === y.Fields ? m(e).filter((n) => n !== i.objectIdField) : m(e);
    await G({ newNumericFields: l, config: e, layerInfo: i, mode: s });
  }
};
async function V(a) {
  const { numericFields: t, aggregationType: e, config: i, layerInfo: s, mode: o } = a, r = [], l = await B({
    config: i,
    layerInfo: s,
    mode: o
  }), n = {
    ...l,
    query: {
      ...l.query
    }
  };
  t.length <= 1 ? n.query.where = l.query?.where : delete n.query.where;
  const d = Y({
    config: i,
    numericFields: t,
    aggregationType: e,
    mode: o,
    layer: s.layer
  }).name;
  if (e !== u.NoAggregation)
    if (o === y.Category) {
      if (t.length > 0) {
        const g = t[0];
        n.query.outStatistics = [
          {
            ...l.query?.outStatistics?.[0] ?? {},
            onStatisticField: g,
            outStatisticFieldName: d,
            statisticType: e
          }
        ];
      }
    } else
      for (const g of t)
        n.query.outStatistics?.push({
          onStatisticField: g,
          outStatisticFieldName: g,
          statisticType: e
        });
  else
    n.query = {};
  n.y = d, r.push(n), i.series = r;
}
const oe = async (a) => {
  const { newAggregationType: t, config: e, layerInfo: i, mode: s } = a, o = m(e);
  await V({
    config: e,
    layerInfo: i,
    numericFields: o,
    aggregationType: t,
    mode: s
  });
  const r = await L({
    config: e,
    layerInfo: i,
    numericFields: m(e),
    aggregationType: b(e, s)
  });
  A(e, 1, r), e.title && (e.title.content.text = await w(e, i, s));
  const l = e.series?.[0]?.displayCategoryOnDataLabel, n = e.series?.[0]?.displayNumericValueOnDataLabel, d = e.series?.[0]?.displayPercentageOnDataLabel;
  e.legend = {
    ...e.legend ?? $(),
    displayNumericValue: n,
    displayPercentage: d,
    displayCategory: l
  };
}, G = async (a) => {
  let { newNumericFields: t } = a;
  const { config: e, layerInfo: i, mode: s } = a, { objectIdField: o } = i ?? {};
  let r = b(e, s);
  if (t = t === "" ? [] : t, t = typeof t == "string" ? [t] : t, o !== void 0 && (t.length === 0 && s === y.Category ? (t.push(o), r = u.Count) : r === u.Count && t.length >= 1 && !t.includes(o) && (r = u.Sum)), i !== void 0) {
    await V({
      config: e,
      layerInfo: i,
      numericFields: t,
      aggregationType: r,
      mode: s
    });
    const l = await L({
      config: e,
      layerInfo: i,
      numericFields: m(e),
      aggregationType: b(e, s)
    });
    A(e, 1, l), e.title && (e.title.content.text = await w(e, i, s));
  } else
    e.series.forEach((l) => {
      delete l.query, l.y = t[0];
    });
}, ne = (a, t) => {
  let e = [];
  const i = a.orderOptions?.data?.orderType, s = v(a, t), o = a.orderOptions?.data?.orderBy;
  return s === c.customSort && i === p.Category && Array.isArray(o) && (e = o), e;
}, le = (a) => {
  const { values: t, config: e, mode: i } = a;
  e.orderOptions ??= {};
  const s = e.orderOptions?.data?.orderType;
  v(e, i) === c.customSort && s === p.Category && (e.orderOptions.data = {
    orderType: p.Category,
    orderBy: [...t]
  });
};
export {
  m as a,
  b,
  G as c,
  oe as d,
  v as e,
  se as f,
  q as g,
  ne as h,
  le as i,
  re as s
};
