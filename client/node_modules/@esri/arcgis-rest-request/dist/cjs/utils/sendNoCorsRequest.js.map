{"version":3,"file":"sendNoCorsRequest.js","sourceRoot":"","sources":["../../../src/utils/sendNoCorsRequest.ts"],"names":[],"mappings":"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","sourcesContent":["import { requestConfig } from \"../requestConfig.js\";\n\n/**\n * Send a no-cors request to the passed uri. This is used to pick up\n * a cookie from a 3rd party server to meet a requirement of some authentication\n * flows.\n * @param url\n * @returns\n */\nexport function sendNoCorsRequest(url: string): Promise<void> {\n  // drop any query params, other than f=json\n  const urlObj = new URL(url);\n  url = urlObj.origin + urlObj.pathname;\n\n  if (urlObj.search.includes(\"f=json\")) {\n    url += \"?f=json\";\n  }\n\n  const origin = urlObj.origin;\n\n  // If we have already sent a no-cors request to this url, return the promise\n  // so we don't send multiple requests\n  if (requestConfig.pendingNoCorsRequests[origin]) {\n    return requestConfig.pendingNoCorsRequests[origin];\n  }\n\n  // Make the request and add to the cache\n  requestConfig.pendingNoCorsRequests[origin] = fetch(url, {\n    mode: \"no-cors\",\n    credentials: \"include\",\n    cache: \"no-store\"\n  })\n    .then((response) => {\n      // Add to the list of cross-origin no-cors domains\n      // if the domain is not already in the list\n      if (requestConfig.noCorsDomains.indexOf(origin) === -1) {\n        requestConfig.noCorsDomains.push(origin);\n      }\n\n      // Hold the timestamp of this request so we can decide when to\n      // send another request to this domain\n      requestConfig.crossOriginNoCorsDomains[origin.toLowerCase()] = Date.now();\n\n      // Remove the pending request from the cache\n      delete requestConfig.pendingNoCorsRequests[origin];\n\n      // Due to limitations of fetchMock at the version of the tooling\n      // in this project, we can't mock the response type of a no-cors request\n      // and thus we can't test this. So we are going to comment this out\n      // and leave it in place for now. If we need to test this, we can\n      // update the tooling to a version that supports this. Also\n      // JS SDK does not do this check, so we are going to leave it out for now.\n\n      // ================================================================\n      // no-cors requests are opaque to javascript\n      // and thus will always return a response with a type of \"opaque\"\n      // if (response.type === \"opaque\") {\n      //   return Promise.resolve();\n      // } else {\n      //   // Not sure if this is possible, but since we have a check above\n      //   // lets handle the else case\n      //   return Promise.reject(\n      //     new Error(`no-cors request to ${origin} not opaque`)\n      //   );\n      // }\n      // ================================================================\n    })\n    .catch((e) => {\n      // Not sure this is necessary, but if the request fails\n      // we should remove it from the pending requests\n      // and return a rejected promise with some information\n      delete requestConfig.pendingNoCorsRequests[origin];\n      return Promise.reject(new Error(`no-cors request to ${origin} failed`));\n    });\n  // return the promise\n  return requestConfig.pendingNoCorsRequests[origin];\n}\n\n/**\n * Allow us to get the no-cors domains that are registered\n * so we can pass them into the identity manager\n * @returns\n */\nexport function getRegisteredNoCorsDomains(): string[] {\n  // return the no-cors domains\n  return requestConfig.noCorsDomains;\n}\n\n/**\n * Register the domains that are allowed to be used in no-cors requests\n * This is called by `request` when the portal/self response is intercepted\n * and the `.authorizedCrossOriginNoCorsDomains` property is set.\n * @param authorizedCrossOriginNoCorsDomains\n */\nexport function registerNoCorsDomains(\n  authorizedCrossOriginNoCorsDomains: string[]\n): void {\n  // register the domains\n  authorizedCrossOriginNoCorsDomains.forEach((domain: string) => {\n    // ensure domain is lower case and ensure protocol is included\n    domain = domain.toLowerCase();\n    if (/^https?:\\/\\//.test(domain)) {\n      addNoCorsDomain(domain);\n    } else {\n      // no protocol present, so add http and https\n      addNoCorsDomain(\"http://\" + domain);\n      addNoCorsDomain(\"https://\" + domain);\n    }\n  });\n}\n\n/**\n * Ensure we don't get duplicate domains in the no-cors domains list\n * @param domain\n */\nfunction addNoCorsDomain(url: string): void {\n  // Since the caller of this always ensures a protocol is present\n  // we can safely use the URL constructor to get the origin\n  // and add it to the no-cors domains list\n  const uri = new URL(url);\n  const domain = uri.origin;\n  if (requestConfig.noCorsDomains.indexOf(domain) === -1) {\n    requestConfig.noCorsDomains.push(domain);\n  }\n}\n\n/**\n *  Is the origin of the passed url in the no-cors domains list?\n * @param url\n * @returns\n */\nexport function isNoCorsDomain(url: string): boolean {\n  let result = false;\n\n  if (requestConfig.noCorsDomains.length) {\n    // is the current url in the no-cors domains?\n    const origin = new URL(url).origin.toLowerCase();\n    result = requestConfig.noCorsDomains.some((domain) => {\n      return origin.includes(domain);\n    });\n  }\n\n  return result;\n}\n\n/**\n * Is the origin of the passed url in the no-cors domains list\n * and do we need to send a no-cors request?\n *\n * @param url\n * @returns\n */\nexport function isNoCorsRequestRequired(url: string): boolean {\n  let result = false;\n  // is the current origin in the no-cors domains?\n  if (isNoCorsDomain(url)) {\n    const origin = new URL(url).origin.toLowerCase();\n\n    // check if we have sent a no-cors request to this domain in the last hour\n    const lastRequest = requestConfig.crossOriginNoCorsDomains[origin] || 0;\n    if (Date.now() - 60 * 60000 > lastRequest) {\n      result = true;\n    }\n  }\n\n  return result;\n}\n"]}