{"version":3,"file":"request.esm.min.js","sources":["../../src/utils/process-params.ts","../../src/utils/encode-query-string.ts","../../../arcgis-rest-form-data/browser-ponyfill.mjs","../../src/utils/encode-form-data.ts","../../src/utils/ArcGISRequestError.ts","../../src/requestConfig.ts","../../src/utils/sendNoCorsRequest.ts","../../src/utils/warn.ts","../../../arcgis-rest-fetch/browser-ponyfill.mjs","../../src/request.ts","../../src/utils/isSameOrigin.ts","../../src/utils/append-custom-params.ts","../../src/utils/ArcGISTokenRequestError.ts","../../src/utils/ErrorTypes.ts","../../src/utils/ArcGISAccessDeniedError.ts","../../src/utils/ArcGISJobError.ts","../../src/utils/clean-url.ts","../../src/utils/decode-query-string.ts","../../src/fetch-token.ts","../../src/AuthenticationManagerBase.ts","../../src/ApplicationCredentialsManager.ts","../../src/ApiKeyManager.ts","../../src/federation-utils.ts","../../src/validate-app-access.ts","../../src/revoke-token.ts","../../src/utils/base-64-url.ts","../../src/utils/generate-random-string.ts","../../src/ArcGISIdentityManager.ts","../../src/utils/generate-code-challenge.ts","../../src/app-tokens.ts","../../src/types/job-statuses.ts","../../src/job.ts","../../node_modules/mitt/dist/mitt.mjs","../../src/utils/process-job-params.ts","../../src/utils/with-options.ts"],"sourcesContent":["/* Copyright (c) 2017 Environmental Systems Research Institute, Inc.\n * Apache-2.0 */\n\n/**\n * Checks parameters to see if we should use FormData to send the request\n * @param params The object whose keys will be encoded.\n * @return A boolean indicating if FormData will be required.\n */\nexport function requiresFormData(params: any) {\n  return Object.keys(params).some((key) => {\n    let value = params[key];\n\n    if (!value) {\n      return false;\n    }\n\n    if (value && value.toParam) {\n      value = value.toParam();\n    }\n\n    const type = value.constructor.name;\n\n    switch (type) {\n      case \"Array\":\n        return false;\n      case \"Object\":\n        return false;\n      case \"Date\":\n        return false;\n      case \"Function\":\n        return false;\n      case \"Boolean\":\n        return false;\n      case \"String\":\n        return false;\n      case \"Number\":\n        return false;\n      default:\n        return true;\n    }\n  });\n}\n\n/**\n * Converts parameters to the proper representation to send to the ArcGIS REST API.\n * @param params The object whose keys will be encoded.\n * @return A new object with properly encoded values.\n */\nexport function processParams(params: any): any {\n  const newParams: any = {};\n\n  Object.keys(params).forEach((key) => {\n    let param = params[key];\n\n    if (param && param.toParam) {\n      param = param.toParam();\n    }\n\n    if (\n      !param &&\n      param !== 0 &&\n      typeof param !== \"boolean\" &&\n      typeof param !== \"string\"\n    ) {\n      return;\n    }\n\n    const type = param.constructor.name;\n\n    let value: any;\n\n    // properly encodes objects, arrays and dates for arcgis.com and other services.\n    // ported from https://github.com/Esri/esri-leaflet/blob/master/src/Request.js#L22-L30\n    // also see https://github.com/Esri/arcgis-rest-js/issues/18:\n    // null, undefined, function are excluded. If you want to send an empty key you need to send an empty string \"\".\n    switch (type) {\n      case \"Array\":\n        // Based on the first element of the array, classify array as an array of arrays, an array of objects\n        // to be stringified, or an array of non-objects to be comma-separated\n        // eslint-disable-next-line no-case-declarations\n        const firstElementType = param[0]?.constructor?.name;\n        value =\n          firstElementType === \"Array\"\n            ? param // pass thru array of arrays\n            : firstElementType === \"Object\"\n            ? JSON.stringify(param) // stringify array of objects\n            : param.join(\",\"); // join other types of array elements\n        break;\n      case \"Object\":\n        value = JSON.stringify(param);\n        break;\n      case \"Date\":\n        value = param.valueOf();\n        break;\n      case \"Function\":\n        value = null;\n        break;\n      case \"Boolean\":\n        value = param + \"\";\n        break;\n      default:\n        value = param;\n        break;\n    }\n    if (\n      value ||\n      value === 0 ||\n      typeof value === \"string\" ||\n      Array.isArray(value)\n    ) {\n      newParams[key] = value;\n    }\n  });\n\n  return newParams;\n}\n","/* Copyright (c) 2017 Environmental Systems Research Institute, Inc.\n * Apache-2.0 */\n\nimport { processParams } from \"./process-params.js\";\n\n/**\n * Encodes keys and parameters for use in a URL's query string.\n *\n * @param key Parameter's key\n * @param value Parameter's value\n * @returns Query string with key and value pairs separated by \"&\"\n */\nexport function encodeParam(key: string, value: any): string {\n  // For array of arrays, repeat key=value for each element of containing array\n  if (Array.isArray(value) && value[0] && Array.isArray(value[0])) {\n    return value\n      .map((arrayElem: string) => encodeParam(key, arrayElem))\n      .join(\"&\");\n  }\n\n  return encodeURIComponent(key) + \"=\" + encodeURIComponent(value);\n}\n\n/**\n * Encodes the passed object as a query string.\n *\n * @param params An object to be encoded.\n * @returns An encoded query string.\n */\nexport function encodeQueryString(params: any): string {\n  const newParams = processParams(params);\n  return Object.keys(newParams)\n    .map((key: any) => {\n      return encodeParam(key, newParams[key]);\n    })\n    .join(\"&\");\n}\n","export const FormData = globalThis.FormData;\nexport const File = globalThis.File;\nexport const Blob = globalThis.Blob;\n","/* Copyright (c) 2017 Environmental Systems Research Institute, Inc.\n * Apache-2.0 */\n\nimport { processParams, requiresFormData } from \"./process-params.js\";\nimport { encodeQueryString } from \"./encode-query-string.js\";\nimport { FormData } from \"@esri/arcgis-rest-form-data\";\n\n/**\n * Encodes parameters in a [FormData](https://developer.mozilla.org/en-US/docs/Web/API/FormData) object in browsers or in a [FormData](https://github.com/form-data/form-data) in Node.js\n *\n * @param params An object to be encoded.\n * @returns The complete [FormData](https://developer.mozilla.org/en-US/docs/Web/API/FormData) object.\n */\nexport function encodeFormData(\n  params: any,\n  forceFormData?: boolean\n): FormData | string {\n  // see https://github.com/Esri/arcgis-rest-js/issues/499 for more info.\n  const useFormData = requiresFormData(params) || forceFormData;\n  const newParams = processParams(params);\n  if (useFormData) {\n    const formData = new FormData();\n\n    Object.keys(newParams).forEach((key: any) => {\n      if (typeof Blob !== \"undefined\" && newParams[key] instanceof Blob) {\n        /* To name the Blob:\n         1. look to an alternate request parameter called 'fileName'\n         2. see if 'name' has been tacked onto the Blob manually\n         3. if all else fails, use the request parameter\n        */\n        const filename = newParams[\"fileName\"] || newParams[key].name || key;\n        formData.append(key, newParams[key], filename);\n      } else {\n        formData.append(key, newParams[key]);\n      }\n    });\n    return formData;\n  } else {\n    return encodeQueryString(params);\n  }\n}\n","/* Copyright (c) 2017 Environmental Systems Research Institute, Inc.\n * Apache-2.0 */\n\nimport { IRequestOptions } from \"./IRequestOptions.js\";\n\n/**\n * This represents a generic error from an ArcGIS endpoint. There will be details about the error in the {@linkcode ArcGISRequestError.message},  {@linkcode ArcGISRequestError.originalMessage} properties on the error. You\n * can also access the original server response at  {@linkcode ArcGISRequestError.response} which may have additional details.\n *\n * ```js\n * request(someUrl, someOptions).catch(e => {\n *   if(e.name === \"ArcGISRequestError\") {\n *     console.log(\"Something went wrong with the request:\", e);\n *     console.log(\"Full server response\", e.response);\n *   }\n * })\n * ```\n */\nexport class ArcGISRequestError extends Error {\n  /**\n   * The name of this error. Will always be `\"ArcGISRequestError\"` to conform with the [`Error`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error) class.\n   */\n  public name: string;\n\n  /**\n   * Formatted error message. See the [`Error`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error) class for more details.\n   */\n  public message: string;\n\n  /**\n   * The errror message return from the request.\n   */\n  public originalMessage: string;\n\n  /**\n   * The error code returned from the request.\n   */\n  public code: string | number;\n\n  /**\n   * The original JSON response the caused the error.\n   */\n  public response: any;\n\n  /**\n   * The URL of the original request that caused the error\n   */\n  public url: string;\n\n  /**\n   * The options of the original request that caused the error\n   */\n  public options: IRequestOptions;\n\n  /**\n   * Create a new `ArcGISRequestError`  object.\n   *\n   * @param message - The error message from the API\n   * @param code - The error code from the API\n   * @param response - The original response from the API that caused the error\n   * @param url - The original url of the request\n   * @param options - The original options and parameters of the request\n   */\n  constructor(\n    message?: string,\n    code?: string | number,\n    response?: any,\n    url?: string,\n    options?: IRequestOptions\n  ) {\n    // 'Error' breaks prototype chain here\n    super(message);\n\n    // restore prototype chain, see https://stackoverflow.com/questions/41102060/typescript-extending-error-class\n    // we don't need to check for Object.setPrototypeOf as in the answers because we are ES2017 now.\n    // Also see https://github.com/Microsoft/TypeScript-wiki/blob/main/Breaking-Changes.md#extending-built-ins-like-error-array-and-map-may-no-longer-work\n    // and https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error#custom_error_types\n    const actualProto = new.target.prototype;\n    Object.setPrototypeOf(this, actualProto);\n\n    message = message || \"UNKNOWN_ERROR\";\n    code = code || \"UNKNOWN_ERROR_CODE\";\n\n    this.name = \"ArcGISRequestError\";\n    this.message =\n      code === \"UNKNOWN_ERROR_CODE\" ? message : `${code}: ${message}`;\n    this.originalMessage = message;\n    this.code = code;\n    this.response = response;\n    this.url = url;\n    this.options = options;\n  }\n}\n","/* istanbul ignore file */\n// Note: currently this is all internal to the package, and we are not exposing\n// anything that a user can set... but we need all this to be able to ensure\n// that multiple instances of the package can share the same config.\n\nexport interface IRequestConfig {\n  noCorsDomains: string[];\n  crossOriginNoCorsDomains: Record<string, number>;\n  pendingNoCorsRequests: PendingRequestCache;\n}\n\nexport type PendingRequestCache = {\n  [key: string]: Promise<void>;\n};\n\n/**\n * The default config for the request module. This is used to store\n * the no-cors domains and pending requests.\n */\nconst DEFAULT_ARCGIS_REQUEST_CONFIG: IRequestConfig = {\n  noCorsDomains: [],\n  crossOriginNoCorsDomains: {},\n  pendingNoCorsRequests: {}\n};\n\nconst GLOBAL_VARIABLE_NAME = \"ARCGIS_REST_JS_NO_CORS\";\n\n// Set the global variable to the default config if it is not aleady defined\n// This is done to ensure that all instances of rest-request work with a single\n// instance of the config\nif (!(globalThis as any)[GLOBAL_VARIABLE_NAME]) {\n  (globalThis as any)[GLOBAL_VARIABLE_NAME] = {\n    ...DEFAULT_ARCGIS_REQUEST_CONFIG\n  } as IRequestConfig;\n}\n\n// export the settings as immutable consts that read from the global config\nexport const requestConfig = (globalThis as any)[\n  GLOBAL_VARIABLE_NAME\n] as IRequestConfig;\n","import { requestConfig } from \"../requestConfig.js\";\n\n/**\n * Send a no-cors request to the passed uri. This is used to pick up\n * a cookie from a 3rd party server to meet a requirement of some authentication\n * flows.\n * @param url\n * @returns\n */\nexport function sendNoCorsRequest(url: string): Promise<void> {\n  // drop any query params, other than f=json\n  const urlObj = new URL(url);\n  url = urlObj.origin + urlObj.pathname;\n\n  if (urlObj.search.includes(\"f=json\")) {\n    url += \"?f=json\";\n  }\n\n  const origin = urlObj.origin;\n\n  // If we have already sent a no-cors request to this url, return the promise\n  // so we don't send multiple requests\n  if (requestConfig.pendingNoCorsRequests[origin]) {\n    return requestConfig.pendingNoCorsRequests[origin];\n  }\n\n  // Make the request and add to the cache\n  requestConfig.pendingNoCorsRequests[origin] = fetch(url, {\n    mode: \"no-cors\",\n    credentials: \"include\",\n    cache: \"no-store\"\n  })\n    .then((response) => {\n      // Add to the list of cross-origin no-cors domains\n      // if the domain is not already in the list\n      if (requestConfig.noCorsDomains.indexOf(origin) === -1) {\n        requestConfig.noCorsDomains.push(origin);\n      }\n\n      // Hold the timestamp of this request so we can decide when to\n      // send another request to this domain\n      requestConfig.crossOriginNoCorsDomains[origin.toLowerCase()] = Date.now();\n\n      // Remove the pending request from the cache\n      delete requestConfig.pendingNoCorsRequests[origin];\n\n      // Due to limitations of fetchMock at the version of the tooling\n      // in this project, we can't mock the response type of a no-cors request\n      // and thus we can't test this. So we are going to comment this out\n      // and leave it in place for now. If we need to test this, we can\n      // update the tooling to a version that supports this. Also\n      // JS SDK does not do this check, so we are going to leave it out for now.\n\n      // ================================================================\n      // no-cors requests are opaque to javascript\n      // and thus will always return a response with a type of \"opaque\"\n      // if (response.type === \"opaque\") {\n      //   return Promise.resolve();\n      // } else {\n      //   // Not sure if this is possible, but since we have a check above\n      //   // lets handle the else case\n      //   return Promise.reject(\n      //     new Error(`no-cors request to ${origin} not opaque`)\n      //   );\n      // }\n      // ================================================================\n    })\n    .catch((e) => {\n      // Not sure this is necessary, but if the request fails\n      // we should remove it from the pending requests\n      // and return a rejected promise with some information\n      delete requestConfig.pendingNoCorsRequests[origin];\n      return Promise.reject(new Error(`no-cors request to ${origin} failed`));\n    });\n  // return the promise\n  return requestConfig.pendingNoCorsRequests[origin];\n}\n\n/**\n * Allow us to get the no-cors domains that are registered\n * so we can pass them into the identity manager\n * @returns\n */\nexport function getRegisteredNoCorsDomains(): string[] {\n  // return the no-cors domains\n  return requestConfig.noCorsDomains;\n}\n\n/**\n * Register the domains that are allowed to be used in no-cors requests\n * This is called by `request` when the portal/self response is intercepted\n * and the `.authorizedCrossOriginNoCorsDomains` property is set.\n * @param authorizedCrossOriginNoCorsDomains\n */\nexport function registerNoCorsDomains(\n  authorizedCrossOriginNoCorsDomains: string[]\n): void {\n  // register the domains\n  authorizedCrossOriginNoCorsDomains.forEach((domain: string) => {\n    // ensure domain is lower case and ensure protocol is included\n    domain = domain.toLowerCase();\n    if (/^https?:\\/\\//.test(domain)) {\n      addNoCorsDomain(domain);\n    } else {\n      // no protocol present, so add http and https\n      addNoCorsDomain(\"http://\" + domain);\n      addNoCorsDomain(\"https://\" + domain);\n    }\n  });\n}\n\n/**\n * Ensure we don't get duplicate domains in the no-cors domains list\n * @param domain\n */\nfunction addNoCorsDomain(url: string): void {\n  // Since the caller of this always ensures a protocol is present\n  // we can safely use the URL constructor to get the origin\n  // and add it to the no-cors domains list\n  const uri = new URL(url);\n  const domain = uri.origin;\n  if (requestConfig.noCorsDomains.indexOf(domain) === -1) {\n    requestConfig.noCorsDomains.push(domain);\n  }\n}\n\n/**\n *  Is the origin of the passed url in the no-cors domains list?\n * @param url\n * @returns\n */\nexport function isNoCorsDomain(url: string): boolean {\n  let result = false;\n\n  if (requestConfig.noCorsDomains.length) {\n    // is the current url in the no-cors domains?\n    const origin = new URL(url).origin.toLowerCase();\n    result = requestConfig.noCorsDomains.some((domain) => {\n      return origin.includes(domain);\n    });\n  }\n\n  return result;\n}\n\n/**\n * Is the origin of the passed url in the no-cors domains list\n * and do we need to send a no-cors request?\n *\n * @param url\n * @returns\n */\nexport function isNoCorsRequestRequired(url: string): boolean {\n  let result = false;\n  // is the current origin in the no-cors domains?\n  if (isNoCorsDomain(url)) {\n    const origin = new URL(url).origin.toLowerCase();\n\n    // check if we have sent a no-cors request to this domain in the last hour\n    const lastRequest = requestConfig.crossOriginNoCorsDomains[origin] || 0;\n    if (Date.now() - 60 * 60000 > lastRequest) {\n      result = true;\n    }\n  }\n\n  return result;\n}\n","/* Copyright (c) 2017-2018 Environmental Systems Research Institute, Inc.\n * Apache-2.0 */\n\n/**\n * Method used internally to surface messages to developers.\n */\nexport function warn(message: string) {\n  if (console && console.warn) {\n    console.warn.apply(console, [message]);\n  }\n}\n","export function getFetch() {\n  return Promise.resolve({\n    fetch: globalThis.fetch,\n    Headers: globalThis.Headers,\n    Response: globalThis.Response,\n    Request: globalThis.Request\n  });\n}\n","/* Copyright (c) 2017-2018 Environmental Systems Research Institute, Inc.\n * Apache-2.0 */\n\nimport { encodeFormData } from \"./utils/encode-form-data.js\";\nimport { encodeQueryString } from \"./utils/encode-query-string.js\";\nimport { requiresFormData } from \"./utils/process-params.js\";\nimport { ArcGISRequestError } from \"./utils/ArcGISRequestError.js\";\nimport {\n  IRequestOptions,\n  InternalRequestOptions\n} from \"./utils/IRequestOptions.js\";\nimport {\n  isNoCorsDomain,\n  isNoCorsRequestRequired,\n  registerNoCorsDomains,\n  sendNoCorsRequest\n} from \"./utils/sendNoCorsRequest.js\";\nimport { IParams } from \"./utils/IParams.js\";\nimport { warn } from \"./utils/warn.js\";\nimport { IRetryAuthError } from \"./utils/retryAuthError.js\";\nimport { getFetch } from \"@esri/arcgis-rest-fetch\";\nimport { IAuthenticationManager } from \"./index.js\";\nimport { isSameOrigin } from \"./utils/isSameOrigin.js\";\n\nexport const NODEJS_DEFAULT_REFERER_HEADER = `@esri/arcgis-rest-js`;\n\n/**\n * Sets the default options that will be passed in **all requests across all `@esri/arcgis-rest-js` modules**.\n *\n * ```js\n * import { setDefaultRequestOptions } from \"@esri/arcgis-rest-request\";\n *\n * setDefaultRequestOptions({\n *   authentication: ArcGISIdentityManager // all requests will use this session by default\n * })\n * ```\n *\n * You should **never** set a default `authentication` when you are in a server side environment where you may be handling requests for many different authenticated users.\n *\n * @param options The default options to pass with every request. Existing default will be overwritten.\n * @param hideWarnings Silence warnings about setting default `authentication` in shared environments.\n */\nexport function setDefaultRequestOptions(\n  options: IRequestOptions,\n  hideWarnings?: boolean\n) {\n  if (options.authentication && !hideWarnings) {\n    warn(\n      \"You should not set `authentication` as a default in a shared environment such as a web server which will process multiple users requests. You can call `setDefaultRequestOptions` with `true` as a second argument to disable this warning.\"\n    );\n  }\n  (globalThis as any).DEFAULT_ARCGIS_REQUEST_OPTIONS = options;\n}\n\nexport function getDefaultRequestOptions() {\n  return (\n    (globalThis as any).DEFAULT_ARCGIS_REQUEST_OPTIONS || {\n      httpMethod: \"POST\",\n      params: {\n        f: \"json\"\n      }\n    }\n  );\n}\n\n/**\n * This error is thrown when a request encounters an invalid token error. Requests that use {@linkcode ArcGISIdentityManager} or\n * {@linkcode ApplicationCredentialsManager} in the `authentication` option the authentication manager will automatically try to generate\n * a fresh token using either {@linkcode ArcGISIdentityManager.refreshCredentials} or\n * {@linkcode ApplicationCredentialsManager.refreshCredentials}. If the request with the new token fails you will receive an `ArcGISAuthError`\n * if refreshing the token fails you will receive an instance of {@linkcode ArcGISTokenRequestError}.\n *\n * ```js\n * request(someUrl, {\n *   authentication: identityManager,\n *   // some additional options...\n * }).catch(e => {\n *   if(e.name === \"ArcGISAuthError\") {\n *     console.log(\"Request with a new token failed you might want to have the user authorize again.\")\n *   }\n *\n *   if(e.name === \"ArcGISTokenRequestError\") {\n *     console.log(\"There was an error refreshing the token you might want to have the user authorize again.\")\n *   }\n * })\n * ```\n */\nexport class ArcGISAuthError extends ArcGISRequestError {\n  /**\n   * Create a new `ArcGISAuthError`  object.\n   *\n   * @param message - The error message from the API\n   * @param code - The error code from the API\n   * @param response - The original response from the API that caused the error\n   * @param url - The original url of the request\n   * @param options - The original options of the request\n   */\n  constructor(\n    message = \"AUTHENTICATION_ERROR\",\n    code: string | number = \"AUTHENTICATION_ERROR_CODE\",\n    response?: any,\n    url?: string,\n    options?: IRequestOptions\n  ) {\n    super(message, code, response, url, options);\n    this.name = \"ArcGISAuthError\";\n    this.message =\n      code === \"AUTHENTICATION_ERROR_CODE\" ? message : `${code}: ${message}`;\n\n    // restore prototype chain, see https://stackoverflow.com/questions/41102060/typescript-extending-error-class\n    // we don't need to check for Object.setPrototypeOf as in the answers because we are ES2017 now.\n    // Also see https://github.com/Microsoft/TypeScript-wiki/blob/main/Breaking-Changes.md#extending-built-ins-like-error-array-and-map-may-no-longer-work\n    // and https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error#custom_error_types\n    const actualProto = new.target.prototype;\n    Object.setPrototypeOf(this, actualProto);\n  }\n\n  public retry(getSession: IRetryAuthError, retryLimit = 1) {\n    let tries = 0;\n\n    const retryRequest = (resolve: any, reject: any) => {\n      tries = tries + 1;\n\n      getSession(this.url, this.options)\n        .then((session) => {\n          const newOptions = {\n            ...this.options,\n            ...{ authentication: session }\n          };\n\n          return internalRequest(this.url, newOptions);\n        })\n        .then((response) => {\n          resolve(response);\n        })\n        .catch((e) => {\n          if (e.name === \"ArcGISAuthError\" && tries < retryLimit) {\n            retryRequest(resolve, reject);\n          } else if (\n            e.name === this.name &&\n            e.message === this.message &&\n            tries >= retryLimit\n          ) {\n            reject(this);\n          } else {\n            reject(e);\n          }\n        });\n    };\n\n    return new Promise((resolve, reject) => {\n      retryRequest(resolve, reject);\n    });\n  }\n}\n\n/**\n * Checks for errors in a JSON response from the ArcGIS REST API. If there are no errors, it will return the `data` passed in. If there is an error, it will throw an `ArcGISRequestError` or `ArcGISAuthError`.\n *\n * @param data The response JSON to check for errors.\n * @param url The url of the original request\n * @param params The parameters of the original request\n * @param options The options of the original request\n * @returns The data that was passed in the `data` parameter\n */\nexport function checkForErrors(\n  response: any,\n  url?: string,\n  params?: IParams,\n  options?: IRequestOptions,\n  originalAuthError?: ArcGISAuthError\n): any {\n  // this is an error message from billing.arcgis.com backend\n  if (response.code >= 400) {\n    const { message, code } = response;\n    throw new ArcGISRequestError(message, code, response, url, options);\n  }\n\n  // error from ArcGIS Online or an ArcGIS Portal or server instance.\n  if (response.error) {\n    const { message, code, messageCode } = response.error;\n    const errorCode = messageCode || code || \"UNKNOWN_ERROR_CODE\";\n\n    if (code === 498 || code === 499) {\n      if (originalAuthError) {\n        throw originalAuthError;\n      } else {\n        throw new ArcGISAuthError(message, errorCode, response, url, options);\n      }\n    }\n\n    throw new ArcGISRequestError(message, errorCode, response, url, options);\n  }\n\n  // error from a status check\n  if (response.status === \"failed\" || response.status === \"failure\") {\n    let message: string;\n    let code = \"UNKNOWN_ERROR_CODE\";\n\n    try {\n      message = JSON.parse(response.statusMessage).message;\n      code = JSON.parse(response.statusMessage).code;\n    } catch (e) {\n      message = response.statusMessage || response.message;\n    }\n\n    throw new ArcGISRequestError(message, code, response, url, options);\n  }\n\n  return response;\n}\n\n/**\n * This is the internal implementation of `request` without the automatic retry behavior to prevent\n * infinite loops when a server continues to return invalid token errors.\n *\n * @param url - The URL of the ArcGIS REST API endpoint.\n * @param requestOptions - Options for the request, including parameters relevant to the endpoint.\n * @returns A Promise that will resolve with the data from the response.\n * @internal\n */\nexport function internalRequest(\n  url: string,\n  requestOptions: InternalRequestOptions\n): Promise<any> {\n  const defaults = getDefaultRequestOptions();\n  const options: IRequestOptions = {\n    ...{ httpMethod: \"POST\" },\n    ...defaults,\n    ...requestOptions,\n    ...{\n      params: {\n        ...defaults.params,\n        ...requestOptions.params\n      },\n      headers: {\n        ...defaults.headers,\n        ...requestOptions.headers\n      }\n    }\n  };\n\n  const { httpMethod, rawResponse } = options;\n\n  const params: IParams = {\n    ...{ f: \"json\" },\n    ...options.params\n  };\n\n  let originalAuthError: ArcGISAuthError = null;\n\n  const fetchOptions: RequestInit = {\n    method: httpMethod,\n    signal: options.signal,\n    /* ensures behavior mimics XMLHttpRequest.\n    needed to support sending IWA cookies */\n    credentials: options.credentials || \"same-origin\"\n  };\n\n  // Is this a no-cors domain? if so we need to set credentials to include\n  if (isNoCorsDomain(url)) {\n    fetchOptions.credentials = \"include\";\n  }\n\n  // the /oauth2/platformSelf route will add X-Esri-Auth-Client-Id header\n  // and that request needs to send cookies cross domain\n  // so we need to set the credentials to \"include\"\n  if (\n    options.headers &&\n    options.headers[\"X-Esri-Auth-Client-Id\"] &&\n    url.indexOf(\"/oauth2/platformSelf\") > -1\n  ) {\n    fetchOptions.credentials = \"include\";\n  }\n\n  let authentication: IAuthenticationManager;\n\n  // Check to see if this is a raw token as a string and create a IAuthenticationManager like object for it.\n  // Otherwise this just assumes that options.authentication is an IAuthenticationManager.\n  if (typeof options.authentication === \"string\") {\n    const rawToken = options.authentication;\n\n    authentication = {\n      portal: \"https://www.arcgis.com/sharing/rest\",\n      getToken: () => {\n        return Promise.resolve(rawToken);\n      }\n    };\n\n    /* istanbul ignore else - we don't need to test NOT warning people */\n    if (\n      !options.authentication.startsWith(\"AAPK\") &&\n      !options.authentication.startsWith(\"AATK\") && // doesn't look like an API Key\n      !options.suppressWarnings && // user doesn't want to suppress warnings for this request\n      !(globalThis as any).ARCGIS_REST_JS_SUPPRESS_TOKEN_WARNING // we haven't shown the user this warning yet\n    ) {\n      warn(\n        `Using an oAuth 2.0 access token directly in the token option is discouraged. Consider using ArcGISIdentityManager or Application session. See https://esriurl.com/arcgis-rest-js-direct-token-warning for more information.`\n      );\n\n      (globalThis as any).ARCGIS_REST_JS_SUPPRESS_TOKEN_WARNING = true;\n    }\n  } else {\n    authentication = options.authentication;\n  }\n\n  // for errors in GET requests we want the URL passed to the error to be the URL before\n  // query params are applied.\n  const originalUrl = url;\n\n  // default to false, for nodejs\n  let sameOrigin = false;\n  // if we are in a browser, check if the url is same origin\n  /* istanbul ignore else */\n  if (typeof window !== \"undefined\") {\n    sameOrigin = isSameOrigin(url);\n  }\n  const requiresNoCors = !sameOrigin && isNoCorsRequestRequired(url);\n\n  // the /oauth2/platformSelf route will add X-Esri-Auth-Client-Id header\n  // and that request needs to send cookies cross domain\n  // so we need to set the credentials to \"include\"\n  if (\n    options.headers &&\n    options.headers[\"X-Esri-Auth-Client-Id\"] &&\n    url.indexOf(\"/oauth2/platformSelf\") > -1\n  ) {\n    fetchOptions.credentials = \"include\";\n  }\n\n  // Simple first promise that we may turn into the no-cors request\n  let firstPromise = Promise.resolve();\n  if (requiresNoCors) {\n    // ensure we send cookies on the request after\n    fetchOptions.credentials = \"include\";\n    firstPromise = sendNoCorsRequest(url);\n  }\n\n  return firstPromise\n    .then(() =>\n      authentication\n        ? authentication.getToken(url).catch((err) => {\n            /**\n             * append original request url and requestOptions\n             * to the error thrown by getToken()\n             * to assist with retrying\n             */\n            err.url = url;\n            err.options = options;\n            /**\n             * if an attempt is made to talk to an unfederated server\n             * first try the request anonymously. if a 'token required'\n             * error is thrown, throw the UNFEDERATED error then.\n             */\n            originalAuthError = err;\n            return Promise.resolve(\"\");\n          })\n        : Promise.resolve(\"\")\n    )\n    .then((token) => {\n      if (token.length) {\n        params.token = token;\n      }\n\n      if (authentication && authentication.getDomainCredentials) {\n        fetchOptions.credentials = authentication.getDomainCredentials(url);\n      }\n\n      // Custom headers to add to request. IRequestOptions.headers with merge over requestHeaders.\n      const requestHeaders: {\n        [key: string]: any;\n      } = {};\n\n      if (fetchOptions.method === \"GET\") {\n        // Prevents token from being passed in query params when hideToken option is used.\n        /* istanbul ignore if - window is always defined in a browser. Test case is covered by Jasmine in node test */\n        if (\n          params.token &&\n          options.hideToken &&\n          // Sharing API does not support preflight check required by modern browsers https://developer.mozilla.org/en-US/docs/Glossary/Preflight_request\n          typeof window === \"undefined\"\n        ) {\n          requestHeaders[\"X-Esri-Authorization\"] = `Bearer ${params.token}`;\n          delete params.token;\n        }\n        // encode the parameters into the query string\n        const queryParams = encodeQueryString(params);\n        // dont append a '?' unless parameters are actually present\n        const urlWithQueryString =\n          queryParams === \"\" ? url : url + \"?\" + encodeQueryString(params);\n\n        if (\n          // This would exceed the maximum length for URLs by 2000 as default or as specified by the consumer and requires POST\n          (options.maxUrlLength &&\n            urlWithQueryString.length > options.maxUrlLength) ||\n          (!options.maxUrlLength && urlWithQueryString.length > 2000) ||\n          // Or if the customer requires the token to be hidden and it has not already been hidden in the header (for browsers)\n          (params.token && options.hideToken)\n        ) {\n          // the consumer specified a maximum length for URLs\n          // and this would exceed it, so use post instead\n          fetchOptions.method = \"POST\";\n\n          // If the token was already added as a Auth header, add the token back to body with other params instead of header\n          if (token.length && options.hideToken) {\n            params.token = token;\n            // Remove existing header that was added before url query length was checked\n            delete requestHeaders[\"X-Esri-Authorization\"];\n          }\n        } else {\n          // just use GET\n          url = urlWithQueryString;\n        }\n      }\n\n      /* updateResources currently requires FormData even when the input parameters dont warrant it.\n  https://developers.arcgis.com/rest/users-groups-and-items/update-resources.htm\n      see https://github.com/Esri/arcgis-rest-js/pull/500 for more info. */\n      const forceFormData = new RegExp(\"/items/.+/updateResources\").test(url);\n\n      if (fetchOptions.method === \"POST\") {\n        fetchOptions.body = encodeFormData(params, forceFormData) as any;\n      }\n\n      // Mixin headers from request options\n      fetchOptions.headers = {\n        ...requestHeaders,\n        ...options.headers\n      };\n\n      // This should have the same conditional for Node JS as ArcGISIdentityManager.refreshWithUsernameAndPassword()\n      // to ensure that generated tokens have the same referer when used in Node with a username and password.\n      /* istanbul ignore next - karma reports coverage on browser tests only */\n      if (\n        (typeof window === \"undefined\" ||\n          (window && typeof window.document === \"undefined\")) &&\n        !fetchOptions.headers.referer\n      ) {\n        fetchOptions.headers.referer = NODEJS_DEFAULT_REFERER_HEADER;\n      }\n\n      /* istanbul ignore else blob responses are difficult to make cross platform we will just have to trust the isomorphic fetch will do its job */\n      if (!requiresFormData(params) && !forceFormData) {\n        fetchOptions.headers[\"Content-Type\"] =\n          \"application/x-www-form-urlencoded\";\n      }\n\n      /**\n       * Check for a global fetch first and use it if available. This allows us to use the default\n       * configuration of fetch-mock in tests.\n       */\n\n      /* istanbul ignore next coverage is based on browser code and we don't test for the absence of global fetch so we can skip the else here. */\n      return globalThis.fetch\n        ? globalThis.fetch(url, fetchOptions)\n        : getFetch().then(({ fetch }) => {\n            return fetch(url, fetchOptions);\n          });\n    })\n    .then((response: any) => {\n      // the request got back an error status code (4xx, 5xx)\n      if (!response.ok) {\n        // we need to determine if the server returned a JSON body with more details.\n        // this is the format used by newer services such as the Places and Style service.\n        return response\n          .json()\n          .then((jsonError: any) => {\n            // The body can be parsed as JSON\n            const { status, statusText } = response;\n            const { message, details } = jsonError.error;\n            const formattedMessage = `${message}. ${\n              details ? details.join(\" \") : \"\"\n            }`.trim();\n\n            throw new ArcGISRequestError(\n              formattedMessage,\n              `HTTP ${status} ${statusText}`,\n              jsonError,\n              url,\n              options\n            );\n          })\n          .catch((e: any) => {\n            // if we already were about to format this as an ArcGISRequestError throw that error\n            if (e.name === \"ArcGISRequestError\") {\n              throw e;\n            }\n\n            // server responded w/ an actual error (404, 500, etc) but we could not parse it as JSON\n            const { status, statusText } = response;\n            throw new ArcGISRequestError(\n              statusText,\n              `HTTP ${status}`,\n              response,\n              url,\n              options\n            );\n          });\n      }\n      if (rawResponse) {\n        return response;\n      }\n      switch (params.f) {\n        case \"json\":\n          return response.json();\n        case \"geojson\":\n          return response.json();\n        case \"html\":\n          return response.text();\n        case \"text\":\n          return response.text();\n        /* istanbul ignore next blob responses are difficult to make cross platform we will just have to trust that isomorphic fetch will do its job */\n        default:\n          return response.blob();\n      }\n    })\n    .then((data) => {\n      // Check for an error in the JSON body of a successful response.\n      // Most ArcGIS Server services will return a successful status code but include an error in the response body.\n      if ((params.f === \"json\" || params.f === \"geojson\") && !rawResponse) {\n        const response = checkForErrors(\n          data,\n          originalUrl,\n          params,\n          options,\n          originalAuthError\n        );\n\n        // If this was a portal/self call, and we got authorizedNoCorsDomains back\n        // register them\n        if (data && /\\/sharing\\/rest\\/(accounts|portals)\\/self/i.test(url)) {\n          // if we have a list of no-cors domains, register them\n          if (Array.isArray(data.authorizedCrossOriginNoCorsDomains)) {\n            registerNoCorsDomains(data.authorizedCrossOriginNoCorsDomains);\n          }\n        }\n\n        if (originalAuthError) {\n          /* If the request was made to an unfederated service that\n          didn't require authentication, add the base url and a dummy token\n          to the list of trusted servers to avoid another federation check\n          in the event of a repeat request */\n          const truncatedUrl: string = url\n            .toLowerCase()\n            .split(/\\/rest(\\/admin)?\\/services\\//)[0];\n\n          (options.authentication as any).federatedServers[truncatedUrl] = {\n            token: [],\n            // default to 24 hours\n            expires: new Date(Date.now() + 86400 * 1000)\n          };\n          originalAuthError = null;\n        }\n        return response;\n      } else {\n        return data;\n      }\n    });\n}\n\n/**\n * Generic method for making HTTP requests to ArcGIS REST API endpoints.\n *\n * ```js\n * import { request } from '@esri/arcgis-rest-request';\n *\n * request('https://www.arcgis.com/sharing/rest')\n *   .then(response) // response.currentVersion === 5.2\n *\n * request('https://www.arcgis.com/sharing/rest', {\n *   httpMethod: \"GET\"\n * })\n *\n * request('https://www.arcgis.com/sharing/rest/search', {\n *   params: { q: 'parks' }\n * })\n *   .then(response) // response.total => 78379\n * ```\n *\n * @param url - The URL of the ArcGIS REST API endpoint.\n * @param requestOptions - Options for the request, including parameters relevant to the endpoint.\n * @returns A Promise that will resolve with the data from the response.\n */\nexport function request(\n  url: string,\n  requestOptions: IRequestOptions = { params: { f: \"json\" } }\n): Promise<any> {\n  const { request, ...internalOptions } = requestOptions;\n  // if the user passed in a custom request function, use that instead of the default\n  return request\n    ? request(url, internalOptions)\n    : internalRequest(url, internalOptions).catch((e) => {\n        if (\n          e instanceof ArcGISAuthError &&\n          requestOptions.authentication &&\n          typeof requestOptions.authentication !== \"string\" &&\n          requestOptions.authentication.canRefresh &&\n          requestOptions.authentication.refreshCredentials\n        ) {\n          return e.retry(() => {\n            return (requestOptions.authentication as any).refreshCredentials();\n          }, 1);\n        } else {\n          return Promise.reject(e);\n        }\n      });\n}\n","/**\n * Is the given URL the same origin as the current window?\n * Used to determine if we need to do any additional cross-origin\n * handling for the request.\n * @param url\n * @param win - optional window object to use for origin comparison\n *             (useful for testing)\n * @returns\n */\nexport function isSameOrigin(url: string, win?: Window | undefined): boolean {\n  /* istanbul ignore next */\n  if ((!win && !window) || !url) {\n    return false;\n  } else {\n    win = win || window;\n    const origin = win.location?.origin;\n    return url.startsWith(origin);\n  }\n}\n","/* Copyright (c) 2017-2018 Environmental Systems Research Institute, Inc.\n * Apache-2.0 */\n\nimport { IRequestOptions } from \"./IRequestOptions.js\";\n\n/**\n * Helper for methods with lots of first order request options to pass through as request parameters.\n */\nexport function appendCustomParams<T extends IRequestOptions>(\n  customOptions: T,\n  keys: Array<keyof T>,\n  baseOptions?: Partial<T>\n): IRequestOptions {\n  // NOTE: this must be kept in sync with the keys in IRequestOptions\n  const requestOptionsKeys = [\n    \"params\",\n    \"httpMethod\",\n    \"rawResponse\",\n    \"authentication\",\n    \"hideToken\",\n    \"portal\",\n    \"credentials\",\n    \"maxUrlLength\",\n    \"headers\",\n    \"signal\",\n    \"suppressWarnings\",\n    \"request\"\n  ];\n\n  const options: T = {\n    ...{ params: {} },\n    ...baseOptions,\n    ...customOptions\n  };\n\n  // merge all keys in customOptions into options.params\n  options.params = keys.reduce((value, key) => {\n    if (\n      customOptions[key] ||\n      typeof customOptions[key] === \"boolean\" ||\n      (typeof customOptions[key] === \"number\" &&\n        (customOptions[key] as unknown) === 0)\n    ) {\n      value[key as any] = customOptions[key];\n    }\n    return value;\n  }, options.params);\n\n  // now remove all properties in options that don't exist in IRequestOptions\n  return requestOptionsKeys.reduce((value, key) => {\n    if ((options as any)[key]) {\n      (value as any)[key] = (options as any)[key];\n    }\n    return value;\n  }, {} as IRequestOptions);\n}\n","/* Copyright (c) 2022 Environmental Systems Research Institute, Inc.\n * Apache-2.0 */\n\nimport { IRequestOptions } from \"./IRequestOptions.js\";\n\n/**\n * There are 5 potential error codes that might be thrown by {@linkcode ArcGISTokenRequestError}. 2 of these codes are used by both\n * {@linkcode ArcGISIdentityManager} or {@linkcode ApplicationCredentialsManager}:\n *\n * * `TOKEN_REFRESH_FAILED` when a request for an new access token fails.\n * * `UNKNOWN_ERROR_CODE` the error is unknown. More information may be available in {@linkcode ArcGISTokenRequestError.response}\n *\n * The 3 remaining error codes will only be thrown when using {@linkcode ArcGISIdentityManager}:\n *\n * * `GENERATE_TOKEN_FOR_SERVER_FAILED` when a request for a token for a specific federated server fails.\n * * `REFRESH_TOKEN_EXCHANGE_FAILED` when a request for a new refresh token fails.\n * * `NOT_FEDERATED` when the requested server isn't federated with the portal specified in {@linkcode ArcGISIdentityManager.portal}.\n */\nexport enum ArcGISTokenRequestErrorCodes {\n  TOKEN_REFRESH_FAILED = \"TOKEN_REFRESH_FAILED\",\n  GENERATE_TOKEN_FOR_SERVER_FAILED = \"GENERATE_TOKEN_FOR_SERVER_FAILED\",\n  REFRESH_TOKEN_EXCHANGE_FAILED = \"REFRESH_TOKEN_EXCHANGE_FAILED\",\n  NOT_FEDERATED = \"NOT_FEDERATED\",\n  UNKNOWN_ERROR_CODE = \"UNKNOWN_ERROR_CODE\"\n}\n\n/**\n * This error is thrown when {@linkcode ArcGISIdentityManager} or {@linkcode ApplicationCredentialsManager} fails to refresh a token or generate a new token\n * for a request. Generally in this scenario the credentials are invalid for the request and the you should recreate the {@linkcode ApplicationCredentialsManager}\n * or prompt the user to authenticate again with {@linkcode ArcGISIdentityManager}. See {@linkcode ArcGISTokenRequestErrorCodes} for a more detailed description of\n * the possible error codes.\n *\n * ```js\n * request(someUrl, {\n *   authentication: someAuthenticationManager\n * }).catch(e => {\n *   if(e.name === \"ArcGISTokenRequestError\") {\n *     // ArcGIS REST JS could not generate an appropriate token for this request\n *     // All credentials are likely invalid and the authentication process should be restarted\n *   }\n * })\n * ```\n */\nexport class ArcGISTokenRequestError extends Error {\n  /**\n   * The name of this error. Will always be `\"ArcGISTokenRequestError\"` to conform with the [`Error`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error) class.\n   */\n  public name: string;\n\n  /**\n   * Formatted error message. See the [`Error`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error) class for more details.\n   */\n  public message: string;\n\n  /**\n   * The error message return from the request.\n   */\n  public originalMessage: string;\n\n  /**\n   * The error code for the request.\n   */\n  public code: ArcGISTokenRequestErrorCodes;\n\n  /**\n   * The original JSON response the caused the error.\n   */\n  public response: any;\n\n  /**\n   * The URL of the original request that caused the error\n   */\n  public url: string;\n\n  /**\n   * The options of the original request that caused the error\n   */\n  public options: IRequestOptions;\n\n  /**\n   * Create a new `ArcGISTokenRequestError`  object.\n   *\n   * @param message - The error message from the API\n   * @param code - The error code from the API\n   * @param response - The original response from the API that caused the error\n   * @param url - The original url of the request\n   * @param options - The original options and parameters of the request\n   */\n  constructor(\n    message = \"UNKNOWN_ERROR\",\n    code = ArcGISTokenRequestErrorCodes.UNKNOWN_ERROR_CODE,\n    response?: any,\n    url?: string,\n    options?: IRequestOptions\n  ) {\n    // 'Error' breaks prototype chain here\n    super(message);\n\n    // restore prototype chain, see https://stackoverflow.com/questions/41102060/typescript-extending-error-class\n    // we don't need to check for Object.setPrototypeOf as in the answers because we are ES2017 now.\n    // Also see https://github.com/Microsoft/TypeScript-wiki/blob/main/Breaking-Changes.md#extending-built-ins-like-error-array-and-map-may-no-longer-work\n    // and https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error#custom_error_types\n    const actualProto = new.target.prototype;\n    Object.setPrototypeOf(this, actualProto);\n\n    this.name = \"ArcGISTokenRequestError\";\n    this.message = `${code}: ${message}`;\n    this.originalMessage = message;\n    this.code = code;\n    this.response = response;\n    this.url = url;\n    this.options = options;\n  }\n}\n","/* Copyright (c) 2017 Environmental Systems Research Institute, Inc.\n * Apache-2.0 */\n\n/**\n * Enum describing the different errors that might be thrown by a request.\n *\n * ```ts\n * import { request, ErrorTypes } from '@esri/arcgis-rest-request';\n *\n * request(\"...\").catch((e) => {\n *   switch(e.name) {\n *     case ErrorType.ArcGISRequestError:\n *     // handle a general error from the API\n *     break;\n *\n *     case ErrorType.ArcGISAuthError:\n *     // handle an authentication error\n *     break;\n *\n *     case ErrorType.ArcGISAccessDeniedError:\n *     // handle a user denying an authorization request in an oAuth workflow\n *     break;\n *\n *     default:\n *     // handle some other error (usually a network error)\n *   }\n * });\n * ```\n */\nexport enum ErrorTypes {\n  ArcGISRequestError = \"ArcGISRequestError\",\n  ArcGISAuthError = \"ArcGISAuthError\",\n  ArcGISAccessDeniedError = \"ArcGISAccessDeniedError\",\n  ArcGISTokenRequestError = \"ArcGISTokenRequestError\"\n}\n","/* Copyright (c) 2022 Environmental Systems Research Institute, Inc.\n * Apache-2.0 */\n\n/**\n * This error code will be thrown by the following methods when the user cancels or denies an authorization request on the OAuth 2.0\n * authorization screen.\n *\n * * {@linkcode ArcGISIdentityManager.beginOAuth2} when the `popup` option is `true`\n * * {@linkcode ArcGISIdentityManager.completeOAuth2}  when the `popup` option is `false`\n *\n * ```js\n * import { ArcGISIdentityManager } from \"@esri/arcgis-rest-request\";\n *\n * ArcGISIdentityManager.beginOAuth2({\n *   clientId: \"***\"\n *   redirectUri: \"***\",\n *   popup: true\n * }).then(authenticationManager => {\n *   console.log(\"OAuth 2.0 Successful\");\n * }).catch(e => {\n *   if(e.name === \"ArcGISAccessDeniedError\") {\n *     console.log(\"The user did not authorize your app.\")\n *   } else {\n *     console.log(\"Something else went wrong. Error:\", e);\n *   }\n * })\n * ```\n */\nexport class ArcGISAccessDeniedError extends Error {\n  /**\n   * The name of this error. Will always be `\"ArcGISAccessDeniedError\"` to conform with the [`Error`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error) class.\n   */\n  public name: string;\n\n  /**\n   * Formatted error message. See the [`Error`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error) class for more details.\n   */\n  public message: string;\n\n  /**\n   * Create a new `ArcGISAccessDeniedError`  object.\n   */\n  constructor() {\n    const message = \"The user has denied your authorization request.\";\n\n    super(message);\n\n    // restore prototype chain, see https://stackoverflow.com/questions/41102060/typescript-extending-error-class\n    // we don't need to check for Object.setPrototypeOf as in the answers because we are ES2017 now.\n    // Also see https://github.com/Microsoft/TypeScript-wiki/blob/main/Breaking-Changes.md#extending-built-ins-like-error-array-and-map-may-no-longer-work\n    // and https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error#custom_error_types\n    const actualProto = new.target.prototype;\n    Object.setPrototypeOf(this, actualProto);\n\n    this.name = \"ArcGISAccessDeniedError\";\n  }\n}\n","/* Copyright (c) 2017 Environmental Systems Research Institute, Inc.\n * Apache-2.0 */\n\nimport { IJobInfo } from \"../job.js\";\nimport { JOB_STATUSES } from \"../types/job-statuses.js\";\n\n/**\n * This represents a generic error from a {@linkcode Job}. There will be details about the error in the {@linkcode ArcGISJobError.jobInfo}.\n *\n * ```js\n * job.getAllResults().catch(e => {\n *   if(e.name === \"ArcGISJobError\") {\n *     console.log(\"Something went wrong with the job\", e);\n *     console.log(\"Full job info\", e.jobInfo);\n *   }\n * })\n * ```\n */\nexport class ArcGISJobError extends Error {\n  /**\n   * The name of this error. Will always be `\"ArcGISJobError\"` to conform with the [`Error`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error) class.\n   */\n  public name: string;\n\n  /**\n   * Formatted error message. See the [`Error`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error) class for more details.\n   */\n  public message: string;\n\n  /**\n   * The status of the job.\n   */\n  public status: JOB_STATUSES;\n\n  /**\n   * The information about the current state of the job at the time of the error.\n   */\n  public jobInfo: IJobInfo;\n\n  /**\n   * The job id.\n   */\n  public id: string;\n\n  /**\n   * Create a new `ArcGISJobError` object.\n   *\n   * @param message - The error message from the API\n   * @param jobInfo - The info of the job that is in an error state\n   */\n  constructor(message = \"Unknown error\", jobInfo: IJobInfo) {\n    // 'Error' breaks prototype chain here\n    super(message);\n\n    // restore prototype chain, see https://stackoverflow.com/questions/41102060/typescript-extending-error-class\n    // we don't need to check for Object.setPrototypeOf as in the answers because we are ES2017 now.\n    // Also see https://github.com/Microsoft/TypeScript-wiki/blob/main/Breaking-Changes.md#extending-built-ins-like-error-array-and-map-may-no-longer-work\n    // and https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error#custom_error_types\n    const actualProto = new.target.prototype;\n    Object.setPrototypeOf(this, actualProto);\n\n    this.name = \"ArcGISJobError\";\n    this.message = `${jobInfo.status}: ${message}`;\n    this.status = jobInfo.status;\n    this.id = jobInfo.id;\n    this.jobInfo = jobInfo;\n  }\n}\n","/* Copyright (c) 2018 Environmental Systems Research Institute, Inc.\n * Apache-2.0 */\n\n/**\n * Helper method to ensure that user supplied urls don't include whitespace or a trailing slash.\n */\nexport function cleanUrl(url: string) {\n  // Guard so we don't try to trim something that's not a string\n  if (typeof url !== \"string\") {\n    return url;\n  }\n  // trim leading and trailing spaces, but not spaces inside the url\n  url = url.trim();\n\n  // remove the trailing slash to the url if one was included\n  if (url[url.length - 1] === \"/\") {\n    url = url.slice(0, -1);\n  }\n  return url;\n}\n","/* Copyright (c) 2017-2020 Environmental Systems Research Institute, Inc.\n * Apache-2.0 */\n\nexport function decodeParam(param: string): { key: string; value: string } {\n  const [key, value] = param.split(\"=\");\n  return { key: decodeURIComponent(key), value: decodeURIComponent(value) };\n}\n\n/**\n * Decodes the passed query string as an object.\n *\n * @param query A string to be decoded.\n * @returns A decoded query param object.\n */\nexport function decodeQueryString(query?: string): { [key: string]: string } {\n  if (!query || query.length <= 0) {\n    return {};\n  }\n\n  return query\n    .replace(/^#/, \"\")\n    .replace(/^\\?/, \"\")\n    .split(\"&\")\n    .reduce((acc, entry) => {\n      const { key, value } = decodeParam(entry);\n      acc[key] = value;\n      return acc;\n    }, {} as any);\n}\n","/* Copyright (c) 2017 Environmental Systems Research Institute, Inc.\n * Apache-2.0 */\n\nimport { request } from \"./request.js\";\nimport { IRequestOptions } from \"./utils/IRequestOptions.js\";\nimport { ITokenRequestOptions } from \"./utils/ITokenRequestOptions.js\";\n\nconst FIVE_MINUTES_IN_MILLISECONDS = 5 * 60 * 1000;\n\ninterface IoAuthTokenResponse {\n  access_token: string;\n  expires_in: number;\n  username: string;\n  ssl?: boolean;\n  refresh_token?: string;\n  refresh_token_expires_in?: number;\n}\n\ninterface IGenerateTokenRawResponse {\n  token: string;\n  expires: number;\n}\n\nexport interface IFetchTokenResponse {\n  token: string;\n  expires: Date;\n  username: string;\n  ssl?: boolean;\n  refreshToken?: string;\n  refreshTokenExpires?: Date;\n}\n\nexport function fetchToken(\n  url: string,\n  requestOptions: ITokenRequestOptions\n): Promise<IFetchTokenResponse> {\n  const options: IRequestOptions = requestOptions;\n\n  // we generate a response, so we can't return the raw response\n  options.rawResponse = false;\n\n  return request(url, options).then(\n    (response: IGenerateTokenRawResponse | IoAuthTokenResponse) => {\n      // Typescript uses the \"in\" keyword to determine we have a generateToken response or an oauth token response\n      if (\"token\" in response && \"expires\" in response) {\n        return {\n          token: response.token,\n          username: requestOptions.params.username,\n          expires: new Date(response.expires)\n        };\n      }\n\n      const portalTokenResponse: IFetchTokenResponse = {\n        token: response.access_token,\n        username: response.username,\n        expires: new Date(\n          // convert seconds in response to milliseconds and add the value to the current time to calculate a static expiration timestamp\n          // we subtract 5 minutes here to make sure that we refresh the token early if the user makes requests\n          Date.now() + response.expires_in * 1000 - FIVE_MINUTES_IN_MILLISECONDS\n        ),\n        ssl: response.ssl === true\n      };\n\n      if (response.refresh_token) {\n        portalTokenResponse.refreshToken = response.refresh_token;\n      }\n\n      if (response.refresh_token_expires_in) {\n        portalTokenResponse.refreshTokenExpires = new Date(\n          // convert seconds in response to milliseconds and add the value to the current time to calculate a static expiration timestamp\n          // we subtract 5 minutes here to make sure that we refresh the token early if the user makes requests\n          Date.now() +\n            response.refresh_token_expires_in * 1000 -\n            FIVE_MINUTES_IN_MILLISECONDS\n        );\n      }\n\n      return portalTokenResponse;\n    }\n  );\n}\n","import { IUser } from \"./types/user.js\";\nimport { IRequestOptions } from \"./utils/IRequestOptions.js\";\nimport { request } from \"./request.js\";\nimport { cleanUrl } from \"./utils/clean-url.js\";\n\nclass AuthenticationManagerBase {\n  /**\n   * The current portal the user is authenticated with.\n   */\n  public readonly portal: string;\n\n  /**\n   * The username of the currently authenticated user.\n   */\n  get username() {\n    if (this._username) {\n      return this._username;\n    }\n\n    if (this._user && this._user.username) {\n      return this._user.username;\n    }\n  }\n\n  constructor(options: any) {\n    this.portal = options.portal\n      ? cleanUrl(options.portal)\n      : \"https://www.arcgis.com/sharing/rest\";\n    this._username = options.username;\n  }\n\n  /**\n   * Internal varible to track the pending user request so we do not make multiple requests.\n   */\n  private _pendingUserRequest: Promise<IUser>;\n\n  /**\n   * Hydrated by a call to [getUser()](#getUser-summary).\n   */\n  private _user: IUser;\n\n  /**\n   * Internal variable to store the username.\n   */\n  private _username: string;\n\n  /**\n   * Returns the username for the currently logged in [user](https://developers.arcgis.com/rest/users-groups-and-items/user.htm). Subsequent calls will *not* result in additional web traffic. This is also used internally when a username is required for some requests but is not present in the options.\n   *\n   * ```js\n   * manager.getUsername()\n   *   .then(response => {\n   *     console.log(response); // \"casey_jones\"\n   *   })\n   * ```\n   */\n  public getUsername() {\n    if (this.username) {\n      return Promise.resolve(this.username);\n    } else {\n      return this.getUser().then((user) => {\n        return user.username;\n      });\n    }\n  }\n\n  /**\n   * Returns information about the currently logged in [user](https://developers.arcgis.com/rest/users-groups-and-items/user.htm). Subsequent calls will *not* result in additional web traffic.\n   *\n   * ```js\n   * manager.getUser()\n   *   .then(response => {\n   *     console.log(response.role); // \"org_admin\"\n   *   })\n   * ```\n   *\n   * @param requestOptions - Options for the request. NOTE: `rawResponse` is not supported by this operation.\n   * @returns A Promise that will resolve with the data from the response.\n   */\n  public getUser(requestOptions?: IRequestOptions): Promise<IUser> {\n    if (this._pendingUserRequest) {\n      return this._pendingUserRequest;\n    } else if (this._user) {\n      return Promise.resolve(this._user);\n    } else {\n      const url = `${this.portal}/community/self`;\n\n      const options = {\n        httpMethod: \"GET\",\n        authentication: this,\n        ...requestOptions,\n        rawResponse: false\n      } as IRequestOptions;\n\n      this._pendingUserRequest = request(url, options).then((response) => {\n        this._user = response;\n        this._pendingUserRequest = null;\n        return response;\n      });\n\n      return this._pendingUserRequest;\n    }\n  }\n\n  /**\n   * Clear the cached user infornation. Usefull to ensure that the most recent user information from {@linkcode AuthenticationManagerBase.getUser} is used.\n   */\n  public clearCachedUserInfo() {\n    this._user = null;\n  }\n}\n\nexport { AuthenticationManagerBase };\n","/* Copyright (c) 2017-2018 Environmental Systems Research Institute, Inc.\n * Apache-2.0 */\n\nimport { IAuthenticationManager } from \"./utils/IAuthenticationManager.js\";\nimport { ITokenRequestOptions } from \"./utils/ITokenRequestOptions.js\";\nimport { fetchToken } from \"./fetch-token.js\";\nimport {\n  ArcGISTokenRequestError,\n  ArcGISTokenRequestErrorCodes\n} from \"./utils/ArcGISTokenRequestError.js\";\nimport { ArcGISRequestError } from \"./utils/ArcGISRequestError.js\";\nimport { AuthenticationManagerBase } from \"./AuthenticationManagerBase.js\";\nimport { Writable } from \"./utils/writable.js\";\n\nexport interface IApplicationCredentialsManagerOptions {\n  /**\n   * Client ID of your application. Can be obtained by registering an application\n   * on [ArcGIS for Developers](https://developers.arcgis.com/documentation/core-concepts/security-and-authentication/signing-in-arcgis-online-users/#registering-your-application),\n   * [ArcGIS Online](http://doc.arcgis.com/en/arcgis-online/share-maps/add-items.htm#ESRI_SECTION1_0D1B620254F745AE84F394289F8AF44B) or on your instance of ArcGIS Enterprise.\n   */\n  clientId: string;\n\n  /**\n   * A Client Secret is also obtained by registering an application\n   * on [ArcGIS for Developers](https://developers.arcgis.com/documentation/core-concepts/security-and-authentication/signing-in-arcgis-online-users/#registering-your-application),\n   * [ArcGIS Online](http://doc.arcgis.com/en/arcgis-online/share-maps/add-items.htm#ESRI_SECTION1_0D1B620254F745AE84F394289F8AF44B) or on your instance of ArcGIS Enterprise. Treat it like a password.\n   */\n  clientSecret: string;\n\n  /**\n   * OAuth 2.0 access token from a previous application session.\n   */\n  token?: string;\n\n  /**\n   * Expiration date for the `token`\n   */\n  expires?: Date;\n\n  /**\n   * URL of ArcGIS REST base, defaults to \"https://www.arcgis.com/sharing/rest\"\n   */\n  portal?: string;\n\n  /**\n   * Duration of requested tokens in minutes. defaults to 7200 (5 days).\n   */\n  duration?: number;\n}\n\n/**\n * Used to authenticate methods in ArcGIS REST JS with oAuth 2.0 application credentials. The instance of `ApplicationCredentialsManager` can be passed to {@linkcode IRequestOptions.authentication} to authenticate requests.\n *\n * ```js\n * import { ApplicationCredentialsManager } from '@esri/arcgis-rest-request';\n *\n * const session = ApplicationCredentialsManager.fromCredentials({\n *   clientId: \"abc123\",\n *   clientSecret: \"••••••\"\n * })\n * ```\n */\nexport class ApplicationCredentialsManager\n  extends AuthenticationManagerBase\n  implements IAuthenticationManager\n{\n  public readonly portal: string;\n  public readonly token: string;\n  public readonly clientId: string;\n  public readonly clientSecret: string;\n  public readonly expires: Date;\n  public readonly duration: number;\n\n  /**\n   * Preferred method for creating an `ApplicationCredentialsManager`\n   */\n  public static fromCredentials(\n    options: IApplicationCredentialsManagerOptions\n  ) {\n    return new ApplicationCredentialsManager(options);\n  }\n\n  /**\n   * Internal object to keep track of pending token requests. Used to prevent\n   *  duplicate token requests.\n   */\n  private _pendingTokenRequest: Promise<string>;\n\n  constructor(options: IApplicationCredentialsManagerOptions) {\n    super(options);\n    this.clientId = options.clientId;\n    this.clientSecret = options.clientSecret;\n    this.token = options.token;\n    this.expires = options.expires;\n    this.portal = options.portal || \"https://www.arcgis.com/sharing/rest\";\n    this.duration = options.duration || 7200;\n  }\n\n  // URL is not actually read or passed through.\n  public getToken(\n    url: string,\n    requestOptions?: ITokenRequestOptions\n  ): Promise<string> {\n    if (this.token && this.expires && this.expires.getTime() > Date.now()) {\n      return Promise.resolve(this.token);\n    }\n\n    if (this._pendingTokenRequest) {\n      return this._pendingTokenRequest;\n    }\n\n    this._pendingTokenRequest = this.refreshToken(requestOptions);\n\n    return this._pendingTokenRequest;\n  }\n\n  public refreshToken(requestOptions?: ITokenRequestOptions): Promise<string> {\n    const options = {\n      params: {\n        client_id: this.clientId,\n        client_secret: this.clientSecret,\n        grant_type: \"client_credentials\",\n        expiration: this.duration\n      },\n      ...requestOptions\n    };\n\n    return fetchToken(`${this.portal}/oauth2/token/`, options)\n      .then((response) => {\n        this._pendingTokenRequest = null;\n        this.setToken(response.token);\n        this.setExpires(response.expires);\n        return response.token;\n      })\n      .catch((e: ArcGISRequestError) => {\n        throw new ArcGISTokenRequestError(\n          e.message,\n          ArcGISTokenRequestErrorCodes.TOKEN_REFRESH_FAILED,\n          e.response,\n          e.url,\n          e.options\n        );\n      });\n  }\n\n  public refreshCredentials() {\n    this.clearCachedUserInfo();\n    return this.refreshToken().then(() => this);\n  }\n\n  /**\n   * Converts the `ApplicationCredentialsManager` instance to a JSON object. This is called when the instance is serialized to JSON with [`JSON.stringify()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON/stringify).\n   *\n   * ```js\n   * import { ApplicationCredentialsManager } from '@esri/arcgis-rest-request';\n   *\n   * const session = ApplicationCredentialsManager.fromCredentials({\n   *   clientId: \"abc123\",\n   *   clientSecret: \"••••••\"\n   * })\n   *\n   * const json = JSON.stringify(session);\n   * ```\n   *\n   * @returns A plain object representation of the instance.\n   */\n  public toJSON() {\n    return {\n      type: \"ApplicationCredentialsManager\",\n      clientId: this.clientId,\n      clientSecret: this.clientSecret,\n      token: this.token,\n      expires: this.expires,\n      portal: this.portal,\n      duration: this.duration\n    };\n  }\n\n  /**\n   * Serializes the `ApplicationCredentialsManager` instance to a JSON string.\n   * @returns The serialized JSON string.\n   */\n  public serialize(): string {\n    return JSON.stringify(this.toJSON());\n  }\n\n  /**\n   * Deserializes a JSON string previously created with {@linkcode ApplicationCredentialsManager.serialize} to an {@linkcode ApplicationCredentialsManager} instance.\n   * @param serialized - The serialized JSON string.\n   * @returns An instance of `ApplicationCredentialsManager`.\n   */\n  public static deserialize(serialized: string): ApplicationCredentialsManager {\n    const data: IApplicationCredentialsManagerOptions = JSON.parse(serialized);\n\n    return new ApplicationCredentialsManager({\n      clientId: data.clientId,\n      clientSecret: data.clientSecret,\n      token: data.token,\n      expires: new Date(data.expires),\n      portal: data.portal,\n      duration: data.duration\n    });\n  }\n\n  /*\n   * Used to update the token when the session is refreshed.\n   * @param newToken - Sets the token for the session.\n   * @internal\n   */\n  private setToken(newToken: string) {\n    (this as Writable<ApplicationCredentialsManager>).token = newToken;\n  }\n\n  /*\n   * Used to update the expiration date when the session is refreshed.\n   * @param newExpires - Sets the expiration date for the session.\n   * @internal\n   */\n  private setExpires(newExpires: Date) {\n    (this as Writable<ApplicationCredentialsManager>).expires = newExpires;\n  }\n}\n\n/**\n * @deprecated - Use {@linkcode ApplicationCredentialsManager}.\n * @internal\n */ /* istanbul ignore next */\nexport function ApplicationSession(\n  options: IApplicationCredentialsManagerOptions\n) {\n  console.log(\n    \"DEPRECATED: 'ApplicationSession' is deprecated. Use 'ApplicationCredentialsManager' instead.\"\n  );\n\n  return new ApplicationCredentialsManager(options);\n}\n","/* Copyright (c) 2017-2019 Environmental Systems Research Institute, Inc.\n * Apache-2.0 */\n\nimport { IAuthenticationManager } from \"./utils/IAuthenticationManager.js\";\nimport { AuthenticationManagerBase } from \"./AuthenticationManagerBase.js\";\n\n/**\n * Options for the `ApiKey` constructor.\n */\nexport interface IApiKeyOptions {\n  key: string;\n  username?: string;\n  portal?: string;\n}\n\n/**\n * Used to authenticate methods in ArcGIS REST JS with an API keys. The instance of `ApiKeyManager` can be passed to  {@linkcode IRequestOptions.authentication} to authenticate requests.\n * \n * ```js\n * import { ApiKeyManager } from '@esri/arcgis-rest-request';\n \n * const apiKey = new ApiKeyManager.fromKey(\"...\");\n * ```\n * \n * In most cases however the API key can be passed directly to the {@linkcode IRequestOptions.authentication}.\n */\nexport class ApiKeyManager\n  extends AuthenticationManagerBase\n  implements IAuthenticationManager\n{\n  /**\n   * The current portal the user is authenticated with.\n   */\n  public readonly portal: string = \"https://www.arcgis.com/sharing/rest\";\n\n  /**\n   * The original API Key used to create this instance.\n   */\n  private readonly key: string;\n\n  /**\n   * The preferred method for creating an instance of `ApiKeyManager`.\n   */\n  public static fromKey(apiKey: string | IApiKeyOptions) {\n    if (typeof apiKey === \"string\") {\n      return new ApiKeyManager({ key: apiKey });\n    } else {\n      return new ApiKeyManager(apiKey);\n    }\n  }\n\n  constructor(options: IApiKeyOptions) {\n    super(options);\n    this.key = options.key;\n  }\n\n  /**\n   * Gets the current access token (the API Key).\n   */\n  get token() {\n    return this.key;\n  }\n\n  /**\n   * Gets the current access token (the API Key).\n   */\n  public getToken(url: string) {\n    return Promise.resolve(this.key);\n  }\n\n  /**\n   * Converts the `ApiKeyManager` instance to a JSON object. This is called when the instance is serialized to JSON with [`JSON.stringify()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON/stringify).\n   *\n   * ```js\n   * import { ApiKeyManager } from '@esri/arcgis-rest-request';\n   *\n   * const apiKey = new ApiKeyManager.fromKey(\"...\")\n   *\n   * const json = JSON.stringify(session);\n   * ```\n   *\n   * @returns A plain object representation of the instance.\n   */\n  toJSON() {\n    return {\n      type: \"ApiKeyManager\",\n      token: this.key,\n      username: this.username,\n      portal: this.portal\n    };\n  }\n\n  /**\n   * Serializes the ApiKeyManager instance to a JSON string.\n   *\n   * ```js\n   * import { ApiKeyManager } from '@esri/arcgis-rest-request';\n   *\n   * const apiKey = new ApiKeyManager.fromKey(\"...\")\n   *\n   * localStorage.setItem(\"apiKey\", apiKey.serialize());\n   * ```\n   * @returns {string} The serialized JSON string.\n   */\n  serialize() {\n    return JSON.stringify(this);\n  }\n\n  /**\n   * Deserializes a JSON string previously created with {@linkcode ApiKeyManager.deserialize} to an {@linkcode ApiKeyManager} instance.\n   *\n   * ```js\n   * import { ApiKeyManager } from '@esri/arcgis-rest-request';\n   *\n   * const apiKey = ApiKeyManager.deserialize(localStorage.getItem(\"apiKey\"));\n   * ```\n   * @param {string} serialized - The serialized JSON string.\n   * @returns {ApiKeyManager} The deserialized ApiKeyManager instance.\n   */\n  static deserialize(serialized: string) {\n    const data = JSON.parse(serialized);\n\n    return new ApiKeyManager({\n      key: data.token,\n      username: data.username,\n      portal: data.portal\n    });\n  }\n}\n\n/**\n * @deprecated - Use {@linkcode ApiKeyManager}.\n * @internal\n */ /* istanbul ignore next */\nexport function ApiKey(options: IApiKeyOptions) {\n  console.log(\n    \"DEPRECATED:, 'ApiKey' is deprecated. Use 'ApiKeyManager' instead.\"\n  );\n\n  return new ApiKeyManager(options);\n}\n","import { cleanUrl } from \"./utils/clean-url.js\";\n\n/**\n * Used to test if a URL is an ArcGIS Online URL\n */\nconst arcgisOnlineUrlRegex = /^https?:\\/\\/(\\S+)\\.arcgis\\.com.+/;\n\n/**\n * Used to test if a URL is production ArcGIS Online Portal\n */\nconst arcgisOnlinePortalRegex =\n  /^https?:\\/\\/(dev|devext|qa|qaext|www)\\.arcgis\\.com\\/sharing\\/rest+/;\n\n/**\n * Used to test if a URL is an ArcGIS Online Organization Portal\n */\nconst arcgisOnlineOrgPortalRegex =\n  /^https?:\\/\\/(?:[a-z0-9-]+\\.maps(dev|devext|qa|qaext)?)?.arcgis\\.com\\/sharing\\/rest/;\n\nexport function isOnline(url: string): boolean {\n  return arcgisOnlineUrlRegex.test(url);\n}\n\nexport function normalizeOnlinePortalUrl(portalUrl: string): string {\n  if (!arcgisOnlineUrlRegex.test(portalUrl)) {\n    return portalUrl;\n  }\n\n  switch (getOnlineEnvironment(portalUrl)) {\n    case \"dev\":\n      return \"https://devext.arcgis.com/sharing/rest\";\n    case \"qa\":\n      return \"https://qaext.arcgis.com/sharing/rest\";\n    default:\n      return \"https://www.arcgis.com/sharing/rest\";\n  }\n}\n\nexport function getOnlineEnvironment(url: string): string {\n  if (!arcgisOnlineUrlRegex.test(url)) {\n    return null;\n  }\n\n  const match = url.match(arcgisOnlineUrlRegex);\n  const subdomain = match[1].split(\".\").pop();\n\n  if (subdomain.includes(\"dev\")) {\n    return \"dev\";\n  }\n\n  if (subdomain.includes(\"qa\")) {\n    return \"qa\";\n  }\n\n  return \"production\";\n}\n\nexport function isFederated(\n  owningSystemUrl: string,\n  portalUrl: string\n): boolean {\n  const normalizedPortalUrl = cleanUrl(\n    normalizeOnlinePortalUrl(portalUrl)\n  ).replace(/https?:\\/\\//, \"\");\n\n  const normalizedOwningSystemUrl = cleanUrl(owningSystemUrl).replace(\n    /https?:\\/\\//,\n    \"\"\n  );\n\n  return new RegExp(normalizedOwningSystemUrl, \"i\").test(normalizedPortalUrl);\n}\n\nexport function canUseOnlineToken(\n  portalUrl: string,\n  requestUrl: string\n): boolean {\n  const portalIsOnline = isOnline(portalUrl);\n  const requestIsOnline = isOnline(requestUrl);\n  const portalEnv = getOnlineEnvironment(portalUrl);\n  const requestEnv = getOnlineEnvironment(requestUrl);\n\n  if (portalIsOnline && requestIsOnline && portalEnv === requestEnv) {\n    return true;\n  }\n\n  return false;\n}\n","/* Copyright (c) 2018-2020 Environmental Systems Research Institute, Inc.\n * Apache-2.0 */\n\nimport { request } from \"./request.js\";\nimport { IRequestOptions } from \"./utils/IRequestOptions.js\";\n\nexport interface IAppAccess {\n  /**\n   * Verifies that the token is valid and the user has access to\n   * the specified app (clientId)\n   */\n  valid: boolean;\n  /**\n   * Should the app present the current user with a \"View Only\" mode\n   */\n  viewOnlyUserTypeApp: boolean;\n}\n\n/**\n * Validates that the user has access to the application\n * and if they user should be presented a \"View Only\" mode\n *\n * This is only needed/valid for Esri applications that are \"licensed\"\n * and shipped in ArcGIS Online or ArcGIS Enterprise. Most custom applications\n * should not need or use this.\n *\n * ```js\n * import { validateAppAccess } from '@esri/arcgis-rest-request';\n *\n * return validateAppAccess('your-token', 'theClientId')\n * .then((result) => {\n *    if (!result.value) {\n *      // redirect or show some other ui\n *    } else {\n *      if (result.viewOnlyUserTypeApp) {\n *        // use this to inform your app to show a \"View Only\" mode\n *      }\n *    }\n * })\n * .catch((err) => {\n *  // two possible errors\n *  // invalid clientId: {\"error\":{\"code\":400,\"messageCode\":\"GWM_0007\",\"message\":\"Invalid request\",\"details\":[]}}\n *  // invalid token: {\"error\":{\"code\":498,\"message\":\"Invalid token.\",\"details\":[]}}\n * })\n * ```\n *\n * Note: This is only usable by Esri applications hosted on *arcgis.com, *esri.com or within\n * an ArcGIS Enterprise installation. Custom applications can not use this.\n *\n * @param token platform token\n * @param clientId application client id\n * @param portal Optional\n */\nexport function validateAppAccess(\n  token: string,\n  clientId: string,\n  portal = \"https://www.arcgis.com/sharing/rest\"\n): Promise<IAppAccess> {\n  const url = `${portal}/oauth2/validateAppAccess`;\n  const ro = {\n    method: \"POST\",\n    params: {\n      f: \"json\",\n      client_id: clientId,\n      token\n    }\n  } as IRequestOptions;\n  return request(url, ro);\n}\n","import {\n  IRequestOptions,\n  request,\n  cleanUrl,\n  ArcGISRequestError,\n  appendCustomParams\n} from \"./index.js\";\n\nexport interface IRevokeTokenOptions extends IRequestOptions {\n  /**\n   * The token or refresh token to revoke. If a refresh token is passed all access tokens generated with that refresh token are also revoked.\n   */\n  token: string;\n\n  /**\n   * The portal of the tokens to revoke. Defaults to `https://www.arcgis.com/sharing/rest`.\n   */\n  portal?: string;\n\n  /**\n   * The client id fo the application that generated the tokens. Applications can only revoke tokens they created.\n   */\n  clientId: string;\n}\n\nexport interface IRevokeTokenResponse {\n  /**\n   * Indicates if the token was revoked. A success response will also returned for invalid tokens, expired tokens or of an unsupported type of token to prevent leaking information about the provided token.\n   */\n  success: boolean;\n}\n\n/**\n * Revokes a token generated via any oAuth 2.0 method. `token` can be either a refresh token OR an access token. If you are using  {@linkcode ArcGISIdentityManager} you should use  {@linkcode ArcGISIdentityManager.destroy} instead. Cannot revoke API keys or tokens generated by {@linkcode ApplicationCredentialsManager}.\n *\n * See [`revokeToken`](https://developers.arcgis.com/rest/users-groups-and-items/revoke-token.htm) on the ArcGIS REST API for more details.\n */\nexport function revokeToken(\n  requestOptions: IRevokeTokenOptions\n): Promise<IRevokeTokenResponse> {\n  const url = `${cleanUrl(\n    requestOptions.portal || \"https://www.arcgis.com/sharing/rest\"\n  )}/oauth2/revokeToken/`;\n\n  const token = requestOptions.token;\n  const clientId = requestOptions.clientId;\n\n  delete requestOptions.portal;\n  delete requestOptions.clientId;\n  delete requestOptions.token;\n\n  const options: IRequestOptions = {\n    ...requestOptions,\n    httpMethod: \"POST\",\n    params: {\n      client_id: clientId,\n      auth_token: token\n    }\n  };\n\n  return request(url, options).then((response) => {\n    if (!response.success) {\n      throw new ArcGISRequestError(\n        \"Unable to revoke token\",\n        500,\n        response,\n        url,\n        options\n      );\n    }\n    return response;\n  });\n}\n","/**\n * Encodes a `Uint8Array` to base 64. Used internally for hashing the `code_verifier` and `code_challenge` for PKCE.\n */\nexport function base64UrlEncode(value: any, win = window) {\n  /* istanbul ignore next: must pass in a mockwindow for tests so we can't cover the other branch */\n  if (!win && window) {\n    win = window;\n  }\n  return win\n    .btoa(String.fromCharCode.apply(null, value))\n    .replace(/\\+/g, \"-\") // replace + with -\n    .replace(/\\//g, \"_\") // replace / with _\n    .replace(/=+$/, \"\"); // trim trailing =\n}\n","import { base64UrlEncode } from \"./base-64-url.js\";\n\n/**\n * Utility to generate a random string to use as our `code_verifier`\n *\n * @param win the global `window` object for accepting a mock while testing.\n */\nexport function generateRandomString(win?: any) {\n  /* istanbul ignore next: must pass in a mockwindow for tests so we can't cover the other branch */\n  if (!win && window) {\n    win = window;\n  }\n\n  const randomBytes = win.crypto.getRandomValues(new Uint8Array(32));\n  return base64UrlEncode(randomBytes);\n}\n","/* Copyright (c) 2017-2019 Environmental Systems Research Institute, Inc.\n * Apache-2.0 */\n\nimport * as http from \"http\";\nimport { ArcGISAuthError, request } from \"./request.js\";\nimport { IRequestOptions } from \"./utils/IRequestOptions.js\";\nimport { IAuthenticationManager } from \"./utils/IAuthenticationManager.js\";\nimport { ITokenRequestOptions } from \"./utils/ITokenRequestOptions.js\";\nimport { decodeQueryString } from \"./utils/decode-query-string.js\";\nimport { encodeQueryString } from \"./utils/encode-query-string.js\";\nimport { IUser } from \"./types/user.js\";\nimport { fetchToken, IFetchTokenResponse } from \"./fetch-token.js\";\nimport { canUseOnlineToken, isFederated } from \"./federation-utils.js\";\nimport { IAppAccess, validateAppAccess } from \"./validate-app-access.js\";\nimport { cleanUrl } from \"./utils/clean-url.js\";\nimport { revokeToken } from \"./revoke-token.js\";\nimport { generateCodeChallenge } from \"./utils/generate-code-challenge.js\";\nimport { generateRandomString } from \"./utils/generate-random-string.js\";\nimport { ArcGISAccessDeniedError } from \"./utils/ArcGISAccessDeniedError.js\";\nimport {\n  ArcGISTokenRequestError,\n  ArcGISTokenRequestErrorCodes\n} from \"./utils/ArcGISTokenRequestError.js\";\nimport { NODEJS_DEFAULT_REFERER_HEADER } from \"./index.js\";\nimport { AuthenticationManagerBase } from \"./AuthenticationManagerBase.js\";\n\n/**\n * distinguish between an ICredential and IArcGISIdentityManagerOptions\n */\nfunction isCredential(credential: any): credential is ICredential {\n  return (\n    typeof credential.userId === \"string\" ||\n    typeof credential.expires === \"number\"\n  );\n}\n\n/**\n * Options for {@linkcode ArcGISIdentityManager.fromToken}.\n */\nexport interface IFromTokenOptions {\n  /**\n   * The token you want to create the {@linkcode ArcGISIdentityManager} instance with.\n   */\n  token: string;\n  /**\n   * Date when this token will expire.\n   */\n  tokenExpires?: Date;\n  /**\n   * The portal that the token was generated from. Defaults to `https://www.arcgis.com/sharing/rest`. Required if you are not using the default portal.\n   */\n  portal?: string;\n  /**\n   * If the token is for a specific instance of ArcGIS Server, set `portal` to `null` or `undefined` and set `server` the URL of the ArcGIS Server.\n   */\n  server?: string;\n  /**\n   * Optionally set the username. Recommended if available.\n   */\n  username?: string;\n  /**\n   * Optional client ID. Used for refreshing expired tokens.\n   */\n  clientId?: string;\n  /**\n   * Optional set a valid redirect URL for the registered client ID. Used internally to refresh expired tokens.\n   */\n  redirectUri?: string;\n}\n\n/**\n * Options for {@linkcode ArcGISIdentityManager.signIn}.\n */\nexport interface ISignInOptions {\n  username: string;\n  password: string;\n  portal?: string;\n  referer?: string;\n}\n\nexport type AuthenticationProvider =\n  | \"arcgis\"\n  | \"facebook\"\n  | \"google\"\n  | \"github\"\n  | \"apple\";\n\n/**\n * Represents a [credential](https://developers.arcgis.com/javascript/latest/api-reference/esri-identity-Credential.html)\n * object used to access a secure ArcGIS resource.\n */\nexport interface ICredential {\n  expires: number;\n  server: string;\n  ssl: boolean;\n  token: string;\n  userId: string;\n}\n\n/**\n * Represents the [`ServerInfo`](https://developers.arcgis.com/javascript/latest/api-reference/esri-identity-ServerInfo.html) class\n * in the ArcGIS API for JavaScript.\n */\nexport interface IServerInfo {\n  server: string;\n  hasPortal: boolean;\n  hasServer: boolean;\n}\n\n/**\n * Options for static OAuth 2.0 helper methods on `ArcGISIdentityManager`.\n */\nexport interface IOAuth2Options {\n  /**\n   * Client ID of your application. Can be obtained by registering an application\n   * on [ArcGIS for Developers](https://developers.arcgis.com/documentation/core-concepts/security-and-authentication/signing-in-arcgis-online-users/#registering-your-application),\n   * [ArcGIS Online](http://doc.arcgis.com/en/arcgis-online/share-maps/add-items.htm#ESRI_SECTION1_0D1B620254F745AE84F394289F8AF44B) or on your instance of ArcGIS Enterprise.\n   */\n  clientId: string;\n\n  /**\n   * A valid URL to redirect to after a user authorizes your application. Can be set on [ArcGIS for Developers](https://developers.arcgis.com/documentation/core-concepts/security-and-authentication/signing-in-arcgis-online-users/#registering-your-application),\n   * [ArcGIS Online](http://doc.arcgis.com/en/arcgis-online/share-maps/add-items.htm#ESRI_SECTION1_0D1B620254F745AE84F394289F8AF44B) or on your instance of ArcGIS Enterprise.\n   */\n  redirectUri: string;\n\n  /**\n   * The ArcGIS Online or ArcGIS Enterprise portal you want to use for authentication. Defaults to `https://www.arcgis.com/sharing/rest` for the ArcGIS Online portal.\n   */\n  portal?: string;\n\n  /**\n   * ArcGIS Authentication is used by default. Specifying an alternative will take users directly to the corresponding provider's OAuth page.\n   */\n\n  provider?: AuthenticationProvider;\n\n  /**\n   * The requested validity in minutes for a refresh token/access token. Defaults to 20160 (2 weeks).\n   *\n   * When using PKCE or server-based OAuth this will control the duration of the refresh token. In this scenario, access tokens will always have a 30 minute validity.\n   *\n   * When using implicit auth (`pkce: false`) in {@linkcode ArcGISIdentityManager.beginOAuth2}, this controls the duration of the access token and no refresh token will be granted.\n   */\n  expiration?: number;\n\n  /**\n   * If `true` will use the PKCE oAuth 2.0 extension spec in to authorize the user and obtain a token. A value of `false` will use the deprecated oAuth 2.0 implicit grant type.\n   *\n   * @browserOnly\n   */\n  pkce?: boolean;\n\n  /**\n   * Determines whether to open the authorization window in a new tab/window or in the current window.\n   *\n   * @browserOnly\n   */\n  popup?: boolean;\n\n  /**\n   * The window features passed to [window.open()](https://developer.mozilla.org/en-US/docs/Web/API/Window/open) when `popup` is true. Defaults to `height=400,width=600,menubar=no,location=yes,resizable=yes,scrollbars=yes,status=yes`\n   *\n   * @browserOnly\n   */\n  popupWindowFeatures?: string;\n\n  /**\n   * The locale assumed to render the login page.\n   *\n   * @browserOnly\n   */\n  locale?: string;\n\n  /**\n   * Sets the color theme of the oAuth 2.0 authorization screen. Will use the system preference or a light theme by default.\n   */\n  style?: \"\" | \"light\" | \"dark\";\n\n  /**\n   * Custom value for oAuth 2.0 state. A random identifier will be generated if this is not passed.\n   */\n  state?: string;\n\n  [key: string]: any;\n}\n\n/**\n * Options for the {@linkcode ArcGISIdentityManager} constructor.\n */\nexport interface IArcGISIdentityManagerOptions {\n  /**\n   * Client ID of your application. Can be obtained by registering an application\n   * on [ArcGIS for Developers](https://developers.arcgis.com/documentation/core-concepts/security-and-authentication/signing-in-arcgis-online-users/#registering-your-application),\n   * [ArcGIS Online](http://doc.arcgis.com/en/arcgis-online/share-maps/add-items.htm#ESRI_SECTION1_0D1B620254F745AE84F394289F8AF44B) or on your instance of ArcGIS Enterprise.\n   */\n  clientId?: string;\n\n  /**\n   * A valid URL to redirect to after a user authorizes your application. Can be set on [ArcGIS for Developers](https://developers.arcgis.com/documentation/core-concepts/security-and-authentication/signing-in-arcgis-online-users/#registering-your-application),\n   * [ArcGIS Online](http://doc.arcgis.com/en/arcgis-online/share-maps/add-items.htm#ESRI_SECTION1_0D1B620254F745AE84F394289F8AF44B) or on your instance of ArcGIS Enterprise.\n   */\n  redirectUri?: string;\n\n  /**\n   * OAuth 2.0 refresh token.\n   */\n  refreshToken?: string;\n\n  /**\n   * Expiration date of the `refreshToken`\n   */\n  refreshTokenExpires?: Date;\n\n  /**\n   * The authenticated user's username. Guaranteed to be unique across ArcGIS Online or your instance of ArcGIS Enterprise.\n   */\n  username?: string;\n\n  /**\n   * Password for this user. Used in CLI apps where users cannot do OAuth 2.0.\n   */\n  password?: string;\n\n  /**\n   * OAuth 2.0 access token.\n   */\n  token?: string;\n\n  /**\n   * Expiration date for the `token`\n   */\n  tokenExpires?: Date;\n\n  /**\n   * The ArcGIS Online or ArcGIS Enterprise portal you want to use for authentication. Defaults to `https://www.arcgis.com/sharing/rest` for the ArcGIS Online portal.\n   */\n  portal?: string;\n\n  /**\n   * This value is set to true automatically if the ArcGIS Organization requires that requests be made over https.\n   */\n  ssl?: boolean;\n\n  /**\n   * ArcGIS Authentication is used by default. Specifying an alternative will take users directly to the corresponding provider's OAuth page.\n   */\n  provider?: AuthenticationProvider;\n\n  /**\n   * Duration of requested token validity in minutes. Used when requesting tokens with `username` and `password` or when validating the identity of unknown servers. Defaults to two weeks.\n   */\n  tokenDuration?: number;\n\n  /**\n   * An unfederated ArcGIS Server instance known to recognize credentials supplied manually.\n   *\n   * ```js\n   * {\n   *   server: \"https://sampleserver6.arcgisonline.com/arcgis\",\n   *   token: \"SOSlV3v..\",\n   *   tokenExpires: new Date(1545415669763)\n   * }\n   * ```\n   */\n  server?: string;\n\n  /**\n   * The referer to use when getting the token with `.signIn()`\n   */\n  referer?: string;\n}\n\n/**\n * Used to authenticate both ArcGIS Online and ArcGIS Enterprise users. `ArcGISIdentityManager` includes helper methods for [OAuth 2.0](https://developers.arcgis.com/documentation/mapping-apis-and-services/security/oauth-2.0/) in both browser and server applications.\n *\n * **It is not recommended to construct `ArcGISIdentityManager` directly**. Instead there are several static methods used for specific workflows. The 2 primary workflows relate to oAuth 2.0:\n *\n * * {@linkcode ArcGISIdentityManager.beginOAuth2} and {@linkcode ArcGISIdentityManager.completeOAuth2} for oAuth 2.0 in browser-only environment.\n * * {@linkcode ArcGISIdentityManager.authorize} and {@linkcode ArcGISIdentityManager.exchangeAuthorizationCode} for oAuth 2.0 for server-enabled application.\n *\n * Other more specialized helpers for less common workflows also exist:\n *\n * * {@linkcode ArcGISIdentityManager.fromToken} for when you have an existing token from another source and would like create an `ArcGISIdentityManager` instance.\n * * {@linkcode ArcGISIdentityManager.fromCredential} for creating  an `ArcGISIdentityManager` instance from a `Credentials` object in the ArcGIS JS API `IdentityManager`\n * * {@linkcode ArcGISIdentityManager.signIn} for authenticating directly with a user's username and password for environments with a user interface for oAuth 2.0.\n *\n * Once a manager is created there are additional utilities:\n *\n * * {@linkcode ArcGISIdentityManager.serialize} can be used to create a JSON object representing an instance of `ArcGISIdentityManager`\n * * {@linkcode ArcGISIdentityManager.deserialize} will create a new `ArcGISIdentityManager` from a JSON object created with {@linkcode ArcGISIdentityManager.serialize}\n * * {@linkcode ArcGISIdentityManager.destroy} or {@linkcode ArcGISIdentityManager.signOut} will invalidate any tokens in use by the  `ArcGISIdentityManager`.\n */\nexport class ArcGISIdentityManager\n  extends AuthenticationManagerBase\n  implements IAuthenticationManager\n{\n  /**\n   * The current ArcGIS Online or ArcGIS Enterprise `token`.\n   */\n  get token() {\n    return this._token;\n  }\n\n  /**\n   * The expiration time of the current `token`.\n   */\n  get tokenExpires() {\n    return this._tokenExpires;\n  }\n\n  /**\n   * The current token to ArcGIS Online or ArcGIS Enterprise.\n   */\n  get refreshToken() {\n    return this._refreshToken;\n  }\n\n  /**\n   * The expiration time of the current `refreshToken`.\n   */\n  get refreshTokenExpires() {\n    return this._refreshTokenExpires;\n  }\n\n  /**\n   * Returns `true` if these credentials can be refreshed and `false` if it cannot.\n   */\n  get canRefresh() {\n    if (this.username && this.password) {\n      return true;\n    }\n\n    if (this.clientId && this.refreshToken && this.redirectUri) {\n      return true;\n    }\n\n    return false;\n  }\n\n  /**\n   * Begins a new browser-based OAuth 2.0 sign in. If `options.popup` is `true` the authentication window will open in a new tab/window. Otherwise, the user will be redirected to the authorization page in their current tab/window and the function will return `undefined`.\n   *\n   * If `popup` is `true` (the default) this method will return a `Promise` that resolves to an `ArcGISIdentityManager` instance and you must call {@linkcode ArcGISIdentityManager.completeOAuth2()} on the page defined in the `redirectUri`. Otherwise it will return undefined and the {@linkcode ArcGISIdentityManager.completeOAuth2()} method will return a `Promise` that resolves to an `ArcGISIdentityManager` instance.\n   *\n   * A {@linkcode ArcGISAccessDeniedError} error will be thrown if the user denies the request on the authorization screen.\n   *\n   * @browserOnly\n   */\n  public static beginOAuth2(\n    options: IOAuth2Options,\n    win?: any\n  ): Promise<ArcGISIdentityManager> | undefined {\n    /* istanbul ignore next: must pass in a mockwindow for tests so we can't cover the other branch */\n    if (!win && window) {\n      win = window;\n    }\n\n    const {\n      portal,\n      provider,\n      clientId,\n      expiration,\n      redirectUri,\n      popup,\n      popupWindowFeatures,\n      locale,\n      params,\n      style,\n      pkce,\n      state\n    }: IOAuth2Options = {\n      ...{\n        portal: \"https://www.arcgis.com/sharing/rest\",\n        provider: \"arcgis\",\n        expiration: 20160,\n        popup: true,\n        popupWindowFeatures:\n          \"height=400,width=600,menubar=no,location=yes,resizable=yes,scrollbars=yes,status=yes\",\n        locale: \"\",\n        style: \"\",\n        pkce: true\n      },\n      ...options\n    };\n\n    /**\n     * Generate a  random string for the `state` param and store it in local storage. This is used\n     * to validate that all parts of the oAuth process were performed on the same client.\n     */\n    const stateId = state || generateRandomString(win);\n    const stateStorageKey = `ARCGIS_REST_JS_AUTH_STATE_${clientId}`;\n\n    win.localStorage.setItem(stateStorageKey, stateId);\n\n    // Start setting up the URL to the authorization screen.\n    let authorizeUrl = `${cleanUrl(portal)}/oauth2/authorize`;\n    const authorizeUrlParams: any = {\n      client_id: clientId,\n      response_type: pkce ? \"code\" : \"token\",\n      expiration: expiration,\n      redirect_uri: redirectUri,\n      state: JSON.stringify({\n        id: stateId,\n        originalUrl: win.location.href // this is used to reset the URL back the original URL upon return\n      }),\n      locale: locale,\n      style: style\n    };\n\n    // If we are authorizing through a specific social provider update the params and base URL.\n    if (provider !== \"arcgis\") {\n      authorizeUrl = `${cleanUrl(portal)}/oauth2/social/authorize`;\n      authorizeUrlParams.socialLoginProviderName = provider;\n      authorizeUrlParams.autoAccountCreateForSocial = true;\n    }\n\n    /**\n     * set a value that will be set to a promise which will later resolve when we are ready\n     * to send users to the authorization page.\n     */\n    let setupAuth;\n\n    if (pkce) {\n      /**\n       * If we are authenticating with PKCE we need to generate the code challenge which is\n       * async so we generate the code challenge and assign the resulting Promise to `setupAuth`\n       */\n      const codeVerifier = generateRandomString(win);\n      const codeVerifierStorageKey = `ARCGIS_REST_JS_CODE_VERIFIER_${clientId}`;\n\n      win.localStorage.setItem(codeVerifierStorageKey, codeVerifier);\n\n      setupAuth = generateCodeChallenge(codeVerifier, win).then(function (\n        codeChallenge\n      ) {\n        authorizeUrlParams.code_challenge_method = codeChallenge\n          ? \"S256\"\n          : \"plain\";\n\n        authorizeUrlParams.code_challenge = codeChallenge\n          ? codeChallenge\n          : codeVerifier;\n      });\n    } else {\n      /**\n       * If we aren't authenticating with PKCE we can just assign a resolved promise to `setupAuth`\n       */\n      setupAuth = Promise.resolve();\n    }\n\n    /**\n     * Once we are done setting up with (for PKCE) we can start the auth process.\n     */\n    return setupAuth.then(() => {\n      // combine the authorize URL and params\n      authorizeUrl = `${authorizeUrl}?${encodeQueryString(authorizeUrlParams)}`;\n\n      // append additional params passed by the user\n      if (params) {\n        authorizeUrl = `${authorizeUrl}&${encodeQueryString(params)}`;\n      }\n\n      if (popup) {\n        // If we are authenticating a popup we need to return a Promise that will resolve to an ArcGISIdentityManager later.\n        return new Promise((resolve, reject) => {\n          // Add an event listener to listen for when a user calls `ArcGISIdentityManager.completeOAuth2()` in the popup.\n          win.addEventListener(\n            `arcgis-rest-js-popup-auth-${clientId}`,\n            (e: CustomEvent<any>) => {\n              if (e.detail.error === \"access_denied\") {\n                const error = new ArcGISAccessDeniedError();\n                reject(error);\n                return error;\n              }\n\n              if (e.detail.errorMessage) {\n                const error = new ArcGISAuthError(\n                  e.detail.errorMessage,\n                  e.detail.error\n                );\n                reject(error);\n                return error;\n              }\n\n              resolve(\n                new ArcGISIdentityManager({\n                  clientId,\n                  portal,\n                  ssl: e.detail.ssl,\n                  token: e.detail.token,\n                  tokenExpires: e.detail.expires,\n                  username: e.detail.username,\n                  refreshToken: e.detail.refreshToken,\n                  refreshTokenExpires: e.detail.refreshTokenExpires,\n                  redirectUri\n                })\n              );\n            },\n            {\n              once: true\n            }\n          );\n\n          // open the popup\n          win.open(authorizeUrl, \"oauth-window\", popupWindowFeatures);\n\n          win.dispatchEvent(new CustomEvent(\"arcgis-rest-js-popup-auth-start\"));\n        });\n      } else {\n        // If we aren't authenticating with a popup just send the user to the authorization page.\n        win.location.href = authorizeUrl;\n        return undefined;\n      }\n    });\n  }\n\n  /**\n   * Completes a browser-based OAuth 2.0 sign in. If `options.popup` is `true` the user\n   * will be returned to the previous window and the popup will close. Otherwise a new `ArcGISIdentityManager` will be returned. You must pass the same values for `clientId`, `popup`, `portal`, and `pkce` as you used in `beginOAuth2()`.\n   *\n   * A {@linkcode ArcGISAccessDeniedError} error will be thrown if the user denies the request on the authorization screen.\n   * @browserOnly\n   */\n  public static completeOAuth2(options: IOAuth2Options, win?: any) {\n    /* istanbul ignore next: must pass in a mockwindow for tests so we can't cover the other branch */\n    if (!win && window) {\n      win = window;\n    }\n\n    // pull out necessary options\n    const { portal, clientId, popup, pkce, redirectUri }: IOAuth2Options = {\n      ...{\n        portal: \"https://www.arcgis.com/sharing/rest\",\n        popup: true,\n        pkce: true\n      },\n      ...options\n    };\n\n    // pull the saved state id out of local storage\n    const stateStorageKey = `ARCGIS_REST_JS_AUTH_STATE_${clientId}`;\n    const stateId = win.localStorage.getItem(stateStorageKey);\n\n    // get the params provided by the server and compare the server state with the client saved state\n    const params = decodeQueryString(\n      pkce\n        ? win.location.search.replace(/^\\?/, \"\")\n        : win.location.hash.replace(/^#/, \"\")\n    );\n\n    const state = params && params.state ? JSON.parse(params.state) : undefined;\n\n    function reportError(\n      errorMessage: string,\n      error: string,\n      originalUrl?: string\n    ) {\n      win.localStorage.removeItem(stateStorageKey);\n\n      if (popup && win.opener) {\n        win.opener.dispatchEvent(\n          new CustomEvent(`arcgis-rest-js-popup-auth-${clientId}`, {\n            detail: {\n              error,\n              errorMessage\n            }\n          })\n        );\n\n        win.close();\n\n        return;\n      }\n\n      if (originalUrl) {\n        win.history.replaceState(win.history.state, \"\", originalUrl);\n      }\n\n      if (error === \"access_denied\") {\n        return Promise.reject(new ArcGISAccessDeniedError());\n      }\n\n      return Promise.reject(new ArcGISAuthError(errorMessage, error));\n    }\n\n    // create a function to create the final ArcGISIdentityManager from the token info.\n    function createManager(\n      oauthInfo: IFetchTokenResponse,\n      originalUrl: string\n    ) {\n      win.localStorage.removeItem(stateStorageKey);\n\n      if (popup && win.opener) {\n        win.opener.dispatchEvent(\n          new CustomEvent(`arcgis-rest-js-popup-auth-${clientId}`, {\n            detail: {\n              ...oauthInfo\n            }\n          })\n        );\n\n        win.close();\n\n        return;\n      }\n\n      win.history.replaceState(win.history.state, \"\", originalUrl);\n\n      return new ArcGISIdentityManager({\n        clientId,\n        portal,\n        ssl: oauthInfo.ssl,\n        token: oauthInfo.token,\n        tokenExpires: oauthInfo.expires,\n        username: oauthInfo.username,\n        refreshToken: oauthInfo.refreshToken,\n        refreshTokenExpires: oauthInfo.refreshTokenExpires,\n        // At 4.0.0 it was possible (in JS code) to not pass redirectUri and fallback to win.location.href, however this broke support for redirect URIs with query params.\n        // Now similar to 3.x.x you must pass the redirectUri parameter explicitly. See https://github.com/Esri/arcgis-rest-js/issues/995\n        redirectUri:\n          redirectUri ||\n          /* istanbul ignore next: TypeScript wont compile if we omit redirectUri */ location.href.replace(\n            location.search,\n            \"\"\n          )\n      });\n    }\n\n    if (!stateId || !state) {\n      return reportError(\n        \"No authentication state was found, call `ArcGISIdentityManager.beginOAuth2(...)` to start the authentication process.\",\n        \"no-auth-state\"\n      );\n    }\n\n    if (state.id !== stateId) {\n      return reportError(\n        \"Saved client state did not match server sent state.\",\n        \"mismatched-auth-state\"\n      );\n    }\n\n    if (params.error) {\n      const error = params.error;\n      const errorMessage = params.error_description || \"Unknown error\";\n\n      return reportError(errorMessage, error, state.originalUrl);\n    }\n    /**\n     * If we are using PKCE the authorization code will be in the query params.\n     * For implicit grants the token will be in the hash.\n     */\n    if (pkce && params.code) {\n      const tokenEndpoint = cleanUrl(`${portal}/oauth2/token/`);\n\n      const codeVerifierStorageKey = `ARCGIS_REST_JS_CODE_VERIFIER_${clientId}`;\n      const codeVerifier = win.localStorage.getItem(codeVerifierStorageKey);\n      win.localStorage.removeItem(codeVerifierStorageKey);\n\n      // exchange our auth code for a token + refresh token\n      return fetchToken(tokenEndpoint, {\n        httpMethod: \"POST\",\n        params: {\n          client_id: clientId,\n          code_verifier: codeVerifier,\n          grant_type: \"authorization_code\",\n          // using location.href here does not support query params but shipped with 4.0.0. See https://github.com/Esri/arcgis-rest-js/issues/995\n          redirect_uri:\n            redirectUri || location.href.replace(location.search, \"\"),\n          code: params.code\n        }\n      })\n        .then((tokenResponse) => {\n          return createManager(\n            { ...tokenResponse, ...state },\n            state.originalUrl\n          );\n        })\n        .catch((e) => {\n          return reportError(e.originalMessage, e.code, state.originalUrl);\n        });\n    }\n\n    if (!pkce && params.access_token) {\n      return Promise.resolve(\n        createManager(\n          {\n            token: params.access_token,\n            expires: new Date(\n              Date.now() + parseInt(params.expires_in, 10) * 1000\n            ),\n            ssl: params.ssl === \"true\",\n            username: params.username,\n            ...state\n          },\n          state.originalUrl\n        )\n      );\n    }\n\n    return reportError(\"Unknown error\", \"oauth-error\", state.originalUrl);\n  }\n\n  /**\n   * Request credentials information from the parent application\n   *\n   * When an application is embedded into another application via an IFrame, the embedded app can\n   * use `window.postMessage` to request credentials from the host application. This function wraps\n   * that behavior.\n   *\n   * The ArcGIS API for Javascript has this built into the Identity Manager as of the 4.19 release.\n   *\n   * Note: The parent application will not respond if the embedded app's origin is not:\n   * - the same origin as the parent or *.arcgis.com (JSAPI)\n   * - in the list of valid child origins (REST-JS)\n   *\n   *\n   * @param parentOrigin origin of the parent frame. Passed into the embedded application as `parentOrigin` query param\n   * @browserOnly\n   */\n  public static fromParent(parentOrigin: string, win?: any): Promise<any> {\n    /* istanbul ignore next: must pass in a mockwindow for tests so we can't cover the other branch */\n    if (!win && window) {\n      win = window;\n    }\n    // Declare handler outside of promise scope so we can detach it\n    let handler: (event: any) => void;\n    // return a promise that will resolve when the handler receives\n    // session information from the correct origin\n    return new Promise((resolve, reject) => {\n      // create an event handler that just wraps the parentMessageHandler\n      handler = (event: any) => {\n        // ensure we only listen to events from the parent\n        if (event.source === win.parent && event.data) {\n          try {\n            return resolve(ArcGISIdentityManager.parentMessageHandler(event));\n          } catch (err) {\n            return reject(err);\n          }\n        }\n      };\n      // add listener\n      win.addEventListener(\"message\", handler, false);\n      win.parent.postMessage(\n        { type: \"arcgis:auth:requestCredential\" },\n        parentOrigin\n      );\n    }).then((manager) => {\n      win.removeEventListener(\"message\", handler, false);\n      return manager;\n    });\n  }\n\n  /**\n   * Begins a new server-based OAuth 2.0 sign in. This will redirect the user to\n   * the ArcGIS Online or ArcGIS Enterprise authorization page.\n   *\n   * @nodeOnly\n   */\n  public static authorize(\n    options: IOAuth2Options,\n    response: http.ServerResponse\n  ) {\n    const { portal, clientId, expiration, redirectUri, state }: IOAuth2Options =\n      {\n        ...{ portal: \"https://arcgis.com/sharing/rest\", expiration: 20160 },\n        ...options\n      };\n\n    const queryParams: any = {\n      client_id: clientId,\n      expiration,\n      response_type: \"code\",\n      redirect_uri: redirectUri\n    };\n\n    if (state) {\n      queryParams.state = state;\n    }\n\n    const url = `${portal}/oauth2/authorize?${encodeQueryString(queryParams)}`;\n\n    response.writeHead(301, {\n      Location: url\n    });\n\n    response.end();\n  }\n\n  /**\n   * Completes the server-based OAuth 2.0 sign in process by exchanging the `authorizationCode`\n   * for a `access_token`.\n   *\n   * @nodeOnly\n   */\n  public static exchangeAuthorizationCode(\n    options: IOAuth2Options,\n    authorizationCode: string\n  ): Promise<ArcGISIdentityManager> {\n    const { portal, clientId, redirectUri }: IOAuth2Options = {\n      ...{\n        portal: \"https://www.arcgis.com/sharing/rest\"\n      },\n      ...options\n    };\n\n    return fetchToken(`${portal}/oauth2/token`, {\n      params: {\n        grant_type: \"authorization_code\",\n        client_id: clientId,\n        redirect_uri: redirectUri,\n        code: authorizationCode\n      }\n    })\n      .then((response) => {\n        return new ArcGISIdentityManager({\n          clientId,\n          portal,\n          ssl: response.ssl,\n          redirectUri,\n          refreshToken: response.refreshToken,\n          refreshTokenExpires: response.refreshTokenExpires,\n          token: response.token,\n          tokenExpires: response.expires,\n          username: response.username\n        });\n      })\n      .catch((e) => {\n        throw new ArcGISTokenRequestError(\n          e.message,\n          ArcGISTokenRequestErrorCodes.REFRESH_TOKEN_EXCHANGE_FAILED,\n          e.response,\n          e.url,\n          e.options\n        );\n      });\n  }\n\n  /**\n   * Deserializes a JSON string previously created with {@linkcode ArcGISIdentityManager.serialize} to an {@linkcode ArcGISIdentityManager} instance.\n   *\n   * ```js\n   * // create an ArcGISIdentityManager instance\n   * const serializedString = manager.serialize();\n   * localStorage.setItem(\"arcgis-identity-manager\", serializedString);\n   *\n   * // later, you can retrieve the manager from localStorage\n   * const serializedString = localStorage.getItem(\"arcgis-identity-manager\");\n   * const manager = ArcGISIdentityManager.deserialize(serializedString);\n   * ```\n   *\n   * @param str A JSON string representing an instance of `ArcGISIdentityManager`. This can be created with {@linkcode ArcGISIdentityManager.serialize}.\n   */\n  public static deserialize(str: string) {\n    const options = JSON.parse(str);\n    return new ArcGISIdentityManager({\n      clientId: options.clientId,\n      refreshToken: options.refreshToken,\n      refreshTokenExpires: options.refreshTokenExpires\n        ? new Date(options.refreshTokenExpires)\n        : undefined,\n      username: options.username,\n      password: options.password,\n      token: options.token,\n      tokenExpires: options.tokenExpires\n        ? new Date(options.tokenExpires)\n        : undefined,\n      portal: options.portal,\n      ssl: options.ssl,\n      tokenDuration: options.tokenDuration,\n      redirectUri: options.redirectUri,\n      server: options.server\n    });\n  }\n\n  /**\n   * Translates authentication from the format used in the [`IdentityManager` class in the ArcGIS API for JavaScript](https://developers.arcgis.com/javascript/latest/api-reference/esri-identity-Credential.html).\n   *\n   * You will need to call both [`IdentityManger.findCredential`](https://developers.arcgis.com/javascript/latest/api-reference/esri-identity-IdentityManager.html#findCredential) and [`IdentityManger.findServerInfo`](https://developers.arcgis.com/javascript/latest/api-reference/esri-identity-IdentityManager.html#findServerInfo) to obtain both parameters for this method.\n   *\n   * This method can be used with {@linkcode ArcGISIdentityManager.toCredential} to interop with the ArcGIS API for JavaScript.\n   *\n   * ```js\n   * require([\"esri/id\"], (esriId) => {\n   *   const credential = esriId.findCredential(\"https://www.arcgis.com/sharing/rest\");\n   *   const serverInfo = esriId.findServerInfo(\"https://www.arcgis.com/sharing/rest\");\n   *\n   *   const manager = ArcGISIdentityManager.fromCredential(credential, serverInfo);\n   * });\n   * ```\n   *\n   * @returns ArcGISIdentityManager\n   */\n  public static fromCredential(\n    credential: ICredential,\n    serverInfo: IServerInfo\n  ) {\n    // At ArcGIS Online 9.1, credentials no longer include the ssl and expires properties\n    // Here, we provide default values for them to cover this condition\n    const ssl = typeof credential.ssl !== \"undefined\" ? credential.ssl : true;\n    const expires = credential.expires || Date.now() + 7200000; /* 2 hours */\n\n    if (serverInfo.hasServer) {\n      return new ArcGISIdentityManager({\n        server: credential.server,\n        ssl,\n        token: credential.token,\n        username: credential.userId,\n        tokenExpires: new Date(expires)\n      });\n    }\n    return new ArcGISIdentityManager({\n      portal: cleanUrl(\n        credential.server.includes(\"sharing/rest\")\n          ? credential.server\n          : credential.server + `/sharing/rest`\n      ),\n      ssl,\n      token: credential.token,\n      username: credential.userId,\n      tokenExpires: new Date(expires)\n    });\n  }\n\n  /**\n   * Handle the response from the parent\n   * @param event DOM Event\n   */\n  private static parentMessageHandler(event: any): ArcGISIdentityManager {\n    if (event.data.type === \"arcgis:auth:credential\") {\n      const credential = event.data.credential as ICredential;\n      // at 4.x - 4.5 we were passing .toJSON() instead of .toCredential()\n      // so we attempt to handle either payload for backwards compatibility\n      // but at the next breaking change we should only support an ICredential\n      return isCredential(credential)\n        ? ArcGISIdentityManager.fromCredential(credential, {\n            hasPortal: true,\n            hasServer: false,\n            server: credential.server\n          } as IServerInfo)\n        : new ArcGISIdentityManager(credential);\n    }\n    if (event.data.type === \"arcgis:auth:error\") {\n      const err = new Error(event.data.error.message);\n      err.name = event.data.error.name;\n      throw err;\n    } else {\n      throw new Error(\"Unknown message type.\");\n    }\n  }\n\n  /**\n   * Revokes all active tokens for a provided {@linkcode ArcGISIdentityManager}. The can be considered the equivalent to signing the user out of your application.\n   */\n  public static destroy(manager: ArcGISIdentityManager) {\n    return revokeToken({\n      clientId: manager.clientId,\n      portal: manager.portal,\n      token: manager.refreshToken || manager.token\n    });\n  }\n\n  /**\n   * Create a  {@linkcode ArcGISIdentityManager} from an existing token. Useful for when you have a users token from a different authentication system and want to get a  {@linkcode ArcGISIdentityManager}.\n   */\n  public static fromToken(\n    options: IFromTokenOptions\n  ): Promise<ArcGISIdentityManager> {\n    const manager = new ArcGISIdentityManager(options);\n\n    return manager.getUser().then(() => {\n      return manager;\n    });\n  }\n\n  /**\n   * Initialize a {@linkcode ArcGISIdentityManager} with a user's `username` and `password`. **This method is intended ONLY for applications without a user interface such as CLI tools.**.\n   *\n   * If possible you should use {@linkcode ArcGISIdentityManager.beginOAuth2} to authenticate users in a browser or {@linkcode ArcGISIdentityManager.authorize} for authenticating users with a web server.\n   */\n  public static signIn(options: ISignInOptions) {\n    const manager = new ArcGISIdentityManager(options);\n\n    return manager.getUser().then(() => {\n      return manager;\n    });\n  }\n\n  /**\n   * Client ID being used for authentication if provided in the `constructor`.\n   */\n  public readonly clientId: string;\n\n  /**\n   * The currently authenticated user's password if provided in the `constructor`.\n   */\n  public readonly password: string;\n\n  /**\n   * The current portal the user is authenticated with.\n   */\n  public readonly portal: string;\n\n  /**\n   * This value is set to true automatically if the ArcGIS Organization requires that requests be made over https.\n   */\n  public readonly ssl: boolean;\n\n  /**\n   * The authentication provider to use.\n   */\n  public readonly provider: AuthenticationProvider;\n\n  /**\n   * Determines how long new tokens requested are valid.\n   */\n  public readonly tokenDuration: number;\n\n  /**\n   * A valid redirect URI for this application if provided in the `constructor`.\n   */\n  public readonly redirectUri: string;\n\n  /**\n   * An unfederated ArcGIS Server instance known to recognize credentials supplied manually.\n   *\n   * ```js\n   * {\n   *   server: \"https://sampleserver6.arcgisonline.com/arcgis\",\n   *   token: \"SOSlV3v..\",\n   *   tokenExpires: new Date(1545415669763)\n   * }\n   * ```\n   */\n  public readonly server: string;\n\n  /**\n   * The referer to use when getting the token with `.signIn()`\n   */\n  public readonly referer: string;\n\n  /**\n   * Hydrated by a call to [getPortal()](#getPortal-summary).\n   */\n  private _portalInfo: any;\n\n  private _token: string;\n  private _tokenExpires: Date;\n  private _refreshToken: string;\n  private _refreshTokenExpires: Date;\n  private _pendingPortalRequest: Promise<any>;\n\n  /**\n   * Internal object to keep track of pending token requests. Used to prevent\n   *  duplicate token requests.\n   */\n  private _pendingTokenRequests: {\n    [key: string]: Promise<string>;\n  };\n\n  /**\n   * Internal list of tokens to 3rd party servers (federated servers) that have\n   *  been created via `generateToken`. The object key is the root URL of the server.\n   */\n  private federatedServers: {\n    [key: string]: {\n      token: string;\n      expires: Date;\n    };\n  };\n\n  /**\n   * Internal list of 3rd party domains that should receive all cookies (credentials: \"include\").\n   * Used to for PKI and IWA workflows in high security environments.\n   */\n  private trustedDomains: string[];\n\n  private _hostHandler: any;\n\n  constructor(options: IArcGISIdentityManagerOptions) {\n    super(options);\n    this.clientId = options.clientId;\n    this._refreshToken = options.refreshToken;\n    this._refreshTokenExpires = options.refreshTokenExpires;\n    this.password = options.password;\n    this._token = options.token;\n    this._tokenExpires = options.tokenExpires;\n    this.portal = options.portal\n      ? cleanUrl(options.portal)\n      : \"https://www.arcgis.com/sharing/rest\";\n    this.ssl = options.ssl;\n    this.provider = options.provider || \"arcgis\";\n    this.tokenDuration = options.tokenDuration || 20160;\n    this.redirectUri = options.redirectUri;\n    this.server = options.server;\n    this.referer = options.referer;\n\n    this.federatedServers = {};\n    this.trustedDomains = [];\n\n    // if a non-federated server was passed explicitly, it should be trusted.\n    if (options.server) {\n      // if the url includes more than '/arcgis/', trim the rest\n      const root = this.getServerRootUrl(options.server);\n\n      this.federatedServers[root] = {\n        token: options.token,\n        expires: options.tokenExpires\n      };\n    }\n    this._pendingTokenRequests = {};\n  }\n\n  /**\n   * Returns authentication in a format useable in the [`IdentityManager.registerToken()` method in the ArcGIS API for JavaScript](https://developers.arcgis.com/javascript/latest/api-reference/esri-identity-IdentityManager.html#registerToken).\n   *\n   * This method can be used with {@linkcode ArcGISIdentityManager.fromCredential} to interop with the ArcGIS API for JavaScript.\n   *\n   * ```js\n   * require([\"esri/id\"], (esriId) => {\n   *   esriId.registerToken(manager.toCredential());\n   * })\n\n   * ```\n   *\n   * @returns ICredential\n   */\n  public toCredential(): ICredential {\n    return {\n      expires: this.tokenExpires.getTime(),\n      server: this.server || this.portal,\n      ssl: this.ssl,\n      token: this.token,\n      userId: this.username\n    };\n  }\n\n  /**\n   * Returns information about the currently logged in user's [portal](https://developers.arcgis.com/rest/users-groups-and-items/portal-self.htm). Subsequent calls will *not* result in additional web traffic.\n   *\n   * ```js\n   * manager.getPortal()\n   *   .then(response => {\n   *     console.log(portal.name); // \"City of ...\"\n   *   })\n   * ```\n   *\n   * @param requestOptions - Options for the request. NOTE: `rawResponse` is not supported by this operation.\n   * @returns A Promise that will resolve with the data from the response.\n   */\n  public getPortal(requestOptions?: IRequestOptions): Promise<any> {\n    if (this._pendingPortalRequest) {\n      return this._pendingPortalRequest;\n    } else if (this._portalInfo) {\n      return Promise.resolve(this._portalInfo);\n    } else {\n      const url = `${this.portal}/portals/self`;\n\n      const options = {\n        httpMethod: \"GET\",\n        authentication: this,\n        ...requestOptions,\n        rawResponse: false\n      } as IRequestOptions;\n\n      this._pendingPortalRequest = request(url, options).then((response) => {\n        this._portalInfo = response;\n        this._pendingPortalRequest = null;\n        return response;\n      });\n\n      return this._pendingPortalRequest;\n    }\n  }\n\n  /**\n   * Gets an appropriate token for the given URL. If `portal` is ArcGIS Online and\n   * the request is to an ArcGIS Online domain `token` will be used. If the request\n   * is to the current `portal` the current `token` will also be used. However if\n   * the request is to an unknown server we will validate the server with a request\n   * to our current `portal`.\n   */\n  public getToken(url: string, requestOptions?: ITokenRequestOptions) {\n    if (canUseOnlineToken(this.portal, url)) {\n      return this.getFreshToken(requestOptions);\n    } else if (new RegExp(this.portal, \"i\").test(url)) {\n      return this.getFreshToken(requestOptions);\n    } else {\n      return this.getTokenForServer(url, requestOptions);\n    }\n  }\n\n  /**\n   * Get application access information for the current user\n   * see `validateAppAccess` function for details\n   *\n   * @param clientId application client id\n   */\n  public validateAppAccess(clientId: string): Promise<IAppAccess> {\n    return this.getToken(this.portal).then((token) => {\n      return validateAppAccess(token, clientId);\n    });\n  }\n\n  /**\n   * Converts the `ArcGISIdentityManager` instance to a JSON object. This is called when the instance is serialized to JSON with [`JSON.stringify()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON/stringify).\n   *\n   * ```js\n   * import { ArcGISIdentityManager } from '@esri/arcgis-rest-request';\n   *\n   * const session = ArcGISIdentityManager.fromCredentials({\n   *   clientId: \"abc123\",\n   *   clientSecret: \"••••••\"\n   * })\n   *\n   * const json = JSON.stringify(session);\n   * ```\n   *\n   * @returns A plain object representation of the instance.\n   */\n  public toJSON(): IArcGISIdentityManagerOptions & { type: string } {\n    return {\n      type: \"ArcGISIdentityManager\",\n      clientId: this.clientId,\n      refreshToken: this.refreshToken,\n      refreshTokenExpires: this.refreshTokenExpires || undefined,\n      username: this.username,\n      password: this.password,\n      token: this.token,\n      tokenExpires: this.tokenExpires || undefined,\n      portal: this.portal,\n      ssl: this.ssl,\n      tokenDuration: this.tokenDuration,\n      redirectUri: this.redirectUri,\n      server: this.server\n    };\n  }\n\n  /**\n   * Serializes the `ArcGISIdentityManager` instance to a JSON string.\n   *\n   * ```js\n   * // create an ArcGISIdentityManager instance\n   * const serializedString = manager.serialize();\n   * localStorage.setItem(\"arcgis-identity-manager\", serializedString);\n   *\n   * // later, you can retrieve the manager from localStorage\n   * const serializedString = localStorage.getItem(\"arcgis-identity-manager\");\n   * const manager = ArcGISIdentityManager.deserialize(serializedString);\n   * ```\n   *\n   * @returns The serialized JSON string.\n   */\n  public serialize() {\n    return JSON.stringify(this);\n  }\n\n  /**\n   * For a \"Host\" app that embeds other platform apps via iframes, after authenticating the user\n   * and creating a ArcGISIdentityManager, the app can then enable \"post message\" style authentication by calling\n   * this method.\n   *\n   * Internally this adds an event listener on window for the `message` event\n   *\n   * @param validChildOrigins Array of origins that are allowed to request authentication from the host app\n   */\n  public enablePostMessageAuth(validChildOrigins: string[], win?: any): any {\n    /* istanbul ignore next: must pass in a mockwindow for tests so we can't cover the other branch */\n    if (!win && window) {\n      win = window;\n    }\n    this._hostHandler = this.createPostMessageHandler(validChildOrigins);\n    win.addEventListener(\"message\", this._hostHandler, false);\n  }\n\n  /**\n   * For a \"Host\" app that has embedded other platform apps via iframes, when the host needs\n   * to transition routes, it should call `ArcGISIdentityManager.disablePostMessageAuth()` to remove\n   * the event listener and prevent memory leaks\n   */\n  public disablePostMessageAuth(win?: any) {\n    /* istanbul ignore next: must pass in a mockwindow for tests so we can't cover the other branch */\n    if (!win && window) {\n      win = window;\n    }\n    win.removeEventListener(\"message\", this._hostHandler, false);\n  }\n\n  /**\n   * Manually refreshes the current `token` and `tokenExpires`.\n   */\n  public refreshCredentials(requestOptions?: ITokenRequestOptions) {\n    // make sure subsequent calls to getUser() don't returned cached metadata\n    this.clearCachedUserInfo();\n\n    if (this.username && this.password) {\n      return this.refreshWithUsernameAndPassword(requestOptions);\n    }\n\n    if (this.clientId && this.refreshToken) {\n      return this.refreshWithRefreshToken();\n    }\n\n    return Promise.reject(\n      new ArcGISTokenRequestError(\n        \"Unable to refresh token. No refresh token or password present.\",\n        ArcGISTokenRequestErrorCodes.TOKEN_REFRESH_FAILED\n      )\n    );\n  }\n\n  /**\n   * Determines the root of the ArcGIS Server or Portal for a given URL.\n   *\n   * @param url the URl to determine the root url for.\n   */\n  public getServerRootUrl(url: string) {\n    const [root] = cleanUrl(url).split(\n      /\\/rest(\\/admin)?\\/services(?:\\/|#|\\?|$)/\n    );\n    const [match, protocol, domainAndPath] = root.match(/(https?:\\/\\/)(.+)/);\n    const [domain, ...path] = domainAndPath.split(\"/\");\n\n    // only the domain is lowercased because in some cases an org id might be\n    // in the path which cannot be lowercased.\n    return `${protocol}${domain.toLowerCase()}/${path.join(\"/\")}`;\n  }\n\n  /**\n   * Returns the proper [`credentials`] option for `fetch` for a given domain.\n   * See [trusted server](https://enterprise.arcgis.com/en/portal/latest/administer/windows/configure-security.htm#ESRI_SECTION1_70CC159B3540440AB325BE5D89DBE94A).\n   * Used internally by underlying request methods to add support for specific security considerations.\n   *\n   * @param url The url of the request\n   * @returns \"include\" or \"same-origin\"\n   */\n  public getDomainCredentials(url: string): RequestCredentials {\n    if (!this.trustedDomains || !this.trustedDomains.length) {\n      return \"same-origin\";\n    }\n\n    url = url.toLowerCase();\n    return this.trustedDomains.some((domainWithProtocol) => {\n      return url.startsWith(domainWithProtocol.toLowerCase());\n    })\n      ? \"include\"\n      : \"same-origin\";\n  }\n\n  /**\n   * Convenience method for {@linkcode ArcGISIdentityManager.destroy} for this instance of `ArcGISIdentityManager`\n   */\n  public signOut() {\n    return ArcGISIdentityManager.destroy(this);\n  }\n\n  /**\n   * Return a function that closes over the validOrigins array and\n   * can be used as an event handler for the `message` event\n   *\n   * @param validOrigins Array of valid origins\n   */\n  private createPostMessageHandler(\n    validOrigins: string[]\n  ): (event: any) => void {\n    // return a function that closes over the validOrigins and\n    // has access to the credential\n    return (event: any) => {\n      // Verify that the origin is valid\n      // Note: do not use regex's here. validOrigins is an array so we're checking that the event's origin\n      // is in the array via exact match. More info about avoiding postMessage xss issues here\n      // https://jlajara.gitlab.io/web/2020/07/17/Dom_XSS_PostMessage_2.html#tipsbypasses-in-postmessage-vulnerabilities\n      const isValidOrigin = validOrigins.indexOf(event.origin) > -1;\n      // JSAPI handles this slightly differently - instead of checking a list, it will respond if\n      // event.origin === window.location.origin || event.origin.endsWith('.arcgis.com')\n      // For Hub, and to enable cross domain debugging with port's in urls, we are opting to\n      // use a list of valid origins\n\n      // Ensure the message type is something we want to handle\n      const isValidType = event.data.type === \"arcgis:auth:requestCredential\";\n      // Ensure we don't pass an expired session forward\n      const isTokenValid = this.tokenExpires.getTime() > Date.now();\n\n      if (isValidOrigin && isValidType) {\n        let msg = {};\n        if (isTokenValid) {\n          const credential = this.toCredential();\n          // the following line allows us to conform to our spec without changing other depended-on functionality\n          // https://github.com/Esri/arcgis-rest-js/blob/master/packages/arcgis-rest-auth/post-message-auth-spec.md#arcgisauthcredential\n          credential.server = credential.server.replace(\"/sharing/rest\", \"\");\n          msg = { type: \"arcgis:auth:credential\", credential };\n        } else {\n          msg = {\n            type: \"arcgis:auth:error\",\n            error: {\n              name: \"tokenExpiredError\",\n              message:\n                \"Token was expired, and not returned to the child application\"\n            }\n          };\n        }\n\n        event.source.postMessage(msg, event.origin);\n      }\n    };\n  }\n\n  /**\n   * Validates that a given URL is properly federated with our current `portal`.\n   * Attempts to use the internal `federatedServers` cache first.\n   */\n  private getTokenForServer(\n    url: string,\n    requestOptions?: ITokenRequestOptions\n  ) {\n    // requests to /rest/services/ and /rest/admin/services/ are both valid\n    // Federated servers may have inconsistent casing, so lowerCase it\n    const root = this.getServerRootUrl(url);\n    const existingToken = this.federatedServers[root];\n\n    if (\n      existingToken &&\n      existingToken.expires &&\n      existingToken.expires.getTime() > Date.now()\n    ) {\n      return Promise.resolve(existingToken.token);\n    }\n\n    if (this._pendingTokenRequests[root]) {\n      return this._pendingTokenRequests[root];\n    }\n\n    this._pendingTokenRequests[root] = this.fetchAuthorizedDomains().then(\n      () => {\n        return request(`${root}/rest/info`, {\n          credentials: this.getDomainCredentials(url)\n        })\n          .then((serverInfo) => {\n            if (serverInfo.owningSystemUrl) {\n              /**\n               * if this server is not owned by this portal\n               * bail out with an error since we know we wont\n               * be able to generate a token\n               */\n              if (!isFederated(serverInfo.owningSystemUrl, this.portal)) {\n                throw new ArcGISTokenRequestError(\n                  `${url} is not federated with ${this.portal}.`,\n                  ArcGISTokenRequestErrorCodes.NOT_FEDERATED\n                );\n              } else {\n                /**\n                 * if the server is federated, use the relevant token endpoint.\n                 */\n                return request(\n                  `${serverInfo.owningSystemUrl}/sharing/rest/info`,\n                  requestOptions\n                );\n              }\n            } else if (\n              serverInfo.authInfo &&\n              this.federatedServers[root] !== undefined\n            ) {\n              /**\n               * if its a stand-alone instance of ArcGIS Server that doesn't advertise\n               * federation, but the root server url is recognized, use its built in token endpoint.\n               */\n              return Promise.resolve({\n                authInfo: serverInfo.authInfo\n              });\n            } else {\n              throw new ArcGISTokenRequestError(\n                `${url} is not federated with any portal and is not explicitly trusted.`,\n                ArcGISTokenRequestErrorCodes.NOT_FEDERATED\n              );\n            }\n          })\n          .then((serverInfo: any) => {\n            // an expired token cant be used to generate a new token so refresh our credentials before trying to generate a server token\n            if (this.token && this.tokenExpires.getTime() < Date.now()) {\n              // If we are authenticated to a single server just refresh with username and password and use the new credentials as the credentials for this server.\n              if (this.server) {\n                return this.refreshCredentials().then(() => {\n                  return {\n                    token: this.token,\n                    expires: this.tokenExpires\n                  };\n                });\n              }\n\n              // Otherwise refresh the credentials for the portal and generate a URL for the specific server.\n              return this.refreshCredentials().then(() => {\n                return this.generateTokenForServer(\n                  serverInfo.authInfo.tokenServicesUrl,\n                  root\n                );\n              });\n            } else {\n              return this.generateTokenForServer(\n                serverInfo.authInfo.tokenServicesUrl,\n                root\n              );\n            }\n          })\n          .then((response) => {\n            this.federatedServers[root] = response;\n            delete this._pendingTokenRequests[root];\n            return response.token;\n          });\n      }\n    );\n\n    return this._pendingTokenRequests[root];\n  }\n\n  /**\n   * Generates a token for a given `serverUrl` using a given `tokenServicesUrl`.\n   */\n  private generateTokenForServer(tokenServicesUrl: string, serverUrl: string) {\n    return request(tokenServicesUrl, {\n      params: {\n        token: this.token,\n        serverUrl,\n        expiration: this.tokenDuration\n      }\n    })\n      .then((response) => {\n        return {\n          token: response.token,\n          expires: new Date(response.expires - 1000 * 60 * 5)\n        };\n      })\n      .catch((e) => {\n        throw new ArcGISTokenRequestError(\n          e.message,\n          ArcGISTokenRequestErrorCodes.GENERATE_TOKEN_FOR_SERVER_FAILED,\n          e.response,\n          e.url,\n          e.options\n        );\n      });\n  }\n\n  /**\n   * Returns an unexpired token for the current `portal`.\n   */\n  private getFreshToken(requestOptions?: ITokenRequestOptions) {\n    if (this.token && !this.tokenExpires) {\n      return Promise.resolve(this.token);\n    }\n\n    if (\n      this.token &&\n      this.tokenExpires &&\n      this.tokenExpires.getTime() > Date.now()\n    ) {\n      return Promise.resolve(this.token);\n    }\n\n    if (!this._pendingTokenRequests[this.portal]) {\n      this._pendingTokenRequests[this.portal] = this.refreshCredentials(\n        requestOptions\n      ).then(() => {\n        this._pendingTokenRequests[this.portal] = null;\n        return this.token;\n      });\n    }\n\n    return this._pendingTokenRequests[this.portal];\n  }\n\n  /**\n   * Refreshes the current `token` and `tokenExpires` with `username` and\n   * `password`.\n   */\n  private refreshWithUsernameAndPassword(\n    requestOptions?: ITokenRequestOptions\n  ) {\n    const params = {\n      username: this.username,\n      password: this.password,\n      expiration: this.tokenDuration,\n      client: \"referer\",\n      referer: this.referer\n        ? this.referer\n        : typeof window !== \"undefined\" &&\n          typeof window.document !== \"undefined\" &&\n          window.location &&\n          window.location.origin\n        ? window.location.origin\n        : /* istanbul ignore next */\n          NODEJS_DEFAULT_REFERER_HEADER\n    };\n\n    return (\n      this.server\n        ? request(`${this.getServerRootUrl(this.server)}/rest/info`).then(\n            (response) => {\n              return request(response.authInfo.tokenServicesUrl, {\n                params,\n                ...requestOptions\n              });\n            }\n          )\n        : request(`${this.portal}/generateToken`, {\n            params,\n            ...requestOptions\n          })\n    )\n      .then((response: any) => {\n        this.updateToken(response.token, new Date(response.expires));\n        return this;\n      })\n      .catch((e) => {\n        throw new ArcGISTokenRequestError(\n          e.message,\n          ArcGISTokenRequestErrorCodes.TOKEN_REFRESH_FAILED,\n          e.response,\n          e.url,\n          e.options\n        );\n      });\n  }\n\n  /**\n   * Refreshes the current `token` and `tokenExpires` with `refreshToken`.\n   */\n  private refreshWithRefreshToken(requestOptions?: ITokenRequestOptions) {\n    // If our refresh token expires sometime in the next 24 hours then refresh the refresh token\n    const ONE_DAY_IN_MILLISECONDS = 1000 * 60 * 60 * 24;\n\n    if (\n      this.refreshToken &&\n      this.refreshTokenExpires &&\n      this.refreshTokenExpires.getTime() - ONE_DAY_IN_MILLISECONDS < Date.now()\n    ) {\n      return this.exchangeRefreshToken(requestOptions);\n    }\n\n    const options: ITokenRequestOptions = {\n      params: {\n        client_id: this.clientId,\n        refresh_token: this.refreshToken,\n        grant_type: \"refresh_token\"\n      },\n      ...requestOptions\n    };\n\n    return fetchToken(`${this.portal}/oauth2/token`, options)\n      .then((response) => {\n        return this.updateToken(response.token, response.expires);\n      })\n      .catch((e) => {\n        throw new ArcGISTokenRequestError(\n          e.message,\n          ArcGISTokenRequestErrorCodes.TOKEN_REFRESH_FAILED,\n          e.response,\n          e.url,\n          e.options\n        );\n      });\n  }\n\n  /**\n   * Update the stored {@linkcode ArcGISIdentityManager.token} and {@linkcode ArcGISIdentityManager.tokenExpires} properties. This method is used internally when refreshing tokens.\n   * You may need to call this if you want update the token with a new token from an external source.\n   *\n   * @param newToken The new token to use for this instance of `ArcGISIdentityManager`.\n   * @param newTokenExpiration The new expiration date of the token.\n   * @returns\n   */\n  updateToken(newToken: string, newTokenExpiration: Date) {\n    this._token = newToken;\n    this._tokenExpires = newTokenExpiration;\n\n    return this;\n  }\n\n  /**\n   * Exchanges an unexpired `refreshToken` for a new one, also updates `token` and\n   * `tokenExpires`.\n   */\n  exchangeRefreshToken(requestOptions?: ITokenRequestOptions) {\n    const options: ITokenRequestOptions = {\n      params: {\n        client_id: this.clientId,\n        refresh_token: this.refreshToken,\n        redirect_uri: this.redirectUri,\n        grant_type: \"exchange_refresh_token\"\n      },\n      ...requestOptions\n    };\n\n    return fetchToken(`${this.portal}/oauth2/token`, options)\n      .then((response) => {\n        this._token = response.token;\n        this._tokenExpires = response.expires;\n        this._refreshToken = response.refreshToken;\n        this._refreshTokenExpires = response.refreshTokenExpires;\n        return this;\n      })\n      .catch((e) => {\n        throw new ArcGISTokenRequestError(\n          e.message,\n          ArcGISTokenRequestErrorCodes.REFRESH_TOKEN_EXCHANGE_FAILED,\n          e.response,\n          e.url,\n          e.options\n        );\n      });\n  }\n\n  /**\n   * ensures that the authorizedCrossOriginDomains are obtained from the portal and cached\n   * so we can check them later.\n   *\n   * @returns this\n   */\n  private fetchAuthorizedDomains() {\n    // if this token is for a specific server or we don't have a portal\n    // don't get the portal info because we cant get the authorizedCrossOriginDomains\n    if (this.server || !this.portal) {\n      return Promise.resolve(this);\n    }\n\n    return this.getPortal().then((portalInfo) => {\n      /**\n       * Specific domains can be configured as secure.esri.com or https://secure.esri.com this\n       * normalizes to https://secure.esri.com so we can use startsWith later.\n       */\n      if (\n        portalInfo.authorizedCrossOriginDomains &&\n        portalInfo.authorizedCrossOriginDomains.length\n      ) {\n        this.trustedDomains = portalInfo.authorizedCrossOriginDomains\n          .filter((d: string) => !d.startsWith(\"http://\"))\n          .map((d: string) => {\n            if (d.startsWith(\"https://\")) {\n              return d;\n            } else {\n              return `https://${d}`;\n            }\n          });\n      }\n      return this;\n    });\n  }\n}\n\n/**\n * @deprecated - Use {@linkcode ArcGISIdentityManager}.\n * @internal\n *\n */ /* istanbul ignore next */\nfunction UserSession(options: IArcGISIdentityManagerOptions) {\n  console.log(\n    \"DEPRECATED:, 'UserSession' is deprecated. Use 'ArcGISIdentityManager' instead.\"\n  );\n\n  return new ArcGISIdentityManager(options);\n}\n\n/**\n * @deprecated - Use {@linkcode ArcGISIdentityManager.beginOAuth2}.\n * @internal\n *\n */ /* istanbul ignore next */\nUserSession.beginOAuth2 = function (\n  ...args: Parameters<typeof ArcGISIdentityManager.beginOAuth2>\n) {\n  console.warn(\n    \"DEPRECATED:, 'UserSession.beginOAuth2' is deprecated. Use 'ArcGISIdentityManager.beginOAuth2' instead.\"\n  );\n\n  return ArcGISIdentityManager.beginOAuth2(...args);\n};\n\n/**\n * @deprecated - Use {@linkcode ArcGISIdentityManager.completeOAuth2}.\n * @internal\n *\n */ /* istanbul ignore next */\nUserSession.completeOAuth2 = function (\n  ...args: Parameters<typeof ArcGISIdentityManager.completeOAuth2>\n) {\n  console.warn(\n    \"DEPRECATED:, 'UserSession.completeOAuth2()' is deprecated. Use 'ArcGISIdentityManager.completeOAuth2()' instead.\"\n  );\n  if (args.length <= 1) {\n    console.warn(\n      \"WARNING:, 'UserSession.completeOAuth2()' is now async and returns a promise the resolves to an instance of `ArcGISIdentityManager`.\"\n    );\n  }\n\n  return ArcGISIdentityManager.completeOAuth2(...args);\n};\n\n/**\n * @deprecated - Use {@linkcode ArcGISIdentityManager.fromParent}.\n * @internal\n *\n */ /* istanbul ignore next */\nUserSession.fromParent = function (\n  ...args: Parameters<typeof ArcGISIdentityManager.fromParent>\n) {\n  console.warn(\n    \"DEPRECATED:, 'UserSession.fromParent' is deprecated. Use 'ArcGISIdentityManager.fromParent' instead.\"\n  );\n\n  return ArcGISIdentityManager.fromParent(...args);\n};\n\n/**\n * @deprecated - Use {@linkcode ArcGISIdentityManager.authorize}.\n * @internal\n *\n */ /* istanbul ignore next */\nUserSession.authorize = function (\n  ...args: Parameters<typeof ArcGISIdentityManager.authorize>\n) {\n  console.warn(\n    \"DEPRECATED:, 'UserSession.authorize' is deprecated. Use 'ArcGISIdentityManager.authorize' instead.\"\n  );\n\n  return ArcGISIdentityManager.authorize(...args);\n};\n\n/**\n * @deprecated - Use {@linkcode ArcGISIdentityManager.exchangeAuthorizationCode}.\n * @internal\n *\n */ /* istanbul ignore next */\nUserSession.exchangeAuthorizationCode = function (\n  ...args: Parameters<typeof ArcGISIdentityManager.exchangeAuthorizationCode>\n) {\n  console.warn(\n    \"DEPRECATED:, 'UserSession.exchangeAuthorizationCode' is deprecated. Use 'ArcGISIdentityManager.exchangeAuthorizationCode' instead.\"\n  );\n\n  return ArcGISIdentityManager.exchangeAuthorizationCode(...args);\n};\n\n/**\n * @deprecated - Use {@linkcode ArcGISIdentityManager.fromCredential}.\n * @internal\n *\n */ /* istanbul ignore next */\nUserSession.fromCredential = function (\n  ...args: Parameters<typeof ArcGISIdentityManager.fromCredential>\n) {\n  console.log(\n    \"DEPRECATED:, 'UserSession.fromCredential' is deprecated. Use 'ArcGISIdentityManager.fromCredential' instead.\"\n  );\n\n  console.warn(\n    \"WARNING:, 'UserSession.fromCredential' now requires a `ServerInfo` object from the JS API as a second parameter.\"\n  );\n\n  return ArcGISIdentityManager.fromCredential(...args);\n};\n\n/**\n * @deprecated - Use {@linkcode ArcGISIdentityManager.deserialize}.\n * @internal\n *\n */ /* istanbul ignore next */\nUserSession.deserialize = function (\n  ...args: Parameters<typeof ArcGISIdentityManager.deserialize>\n) {\n  console.log(\n    \"DEPRECATED:, 'UserSession.deserialize' is deprecated. Use 'ArcGISIdentityManager.deserialize' instead.\"\n  );\n\n  return ArcGISIdentityManager.deserialize(...args);\n};\n\nexport { UserSession };\n","import { base64UrlEncode } from \"./base-64-url.js\";\n\n/**\n * Utility to hash the codeVerifier using sha256\n */\nexport function generateCodeChallenge(codeVerifier: string, win = window) {\n  /* istanbul ignore next: must pass in a mockwindow for tests so we can't cover the other branch */\n  if (!win && window) {\n    win = window;\n  }\n\n  if (codeVerifier && win.isSecureContext && win.crypto && win.crypto.subtle) {\n    const encoder = new win.TextEncoder();\n    const bytes = encoder.encode(codeVerifier);\n\n    return win.crypto.subtle\n      .digest(\"SHA-256\", bytes)\n      .then((buffer) => base64UrlEncode(new Uint8Array(buffer), win));\n  }\n\n  return Promise.resolve(null);\n}\n","/* Copyright (c) 2018-2020 Environmental Systems Research Institute, Inc.\n * Apache-2.0 */\n\nimport { request } from \"./request.js\";\nimport { IRequestOptions } from \"./utils/IRequestOptions.js\";\n\n/**\n * Request app-specific token, passing in the token for the current app.\n *\n * This call returns a token after performing the same checks made by validateAppAccess.\n * It returns an app-specific token of the signed-in user only if the user has access\n * to the app and the encrypted platform cookie is valid.\n *\n * A scenario where an app would use this is if it is iframed into another platform app\n * and receives credentials via postMessage. Those credentials contain a token that is\n * specific to the host app, so the embedded app would use `exchangeToken` to get one\n * that is specific to itself.\n *\n * Note: This is only usable by Esri applications hosted on *arcgis.com, *esri.com or within\n * an ArcGIS Enterprise installation. Custom applications can not use this.\n *\n * @param token\n * @param clientId application\n * @param portal\n */\nexport function exchangeToken(\n  token: string,\n  clientId: string,\n  portal = \"https://www.arcgis.com/sharing/rest\"\n): Promise<string> {\n  const url = `${portal}/oauth2/exchangeToken`;\n  const ro = {\n    method: \"POST\",\n    params: {\n      f: \"json\",\n      client_id: clientId,\n      token\n    }\n  } as IRequestOptions;\n  // make the request and return the token\n  return request(url, ro).then((response) => response.token);\n}\n\n/**\n * @internal\n * @private\n * Response from the `platformSelf(...)` function.\n */\nexport interface IPlatformSelfResponse {\n  /**\n   * Username of the user the encrypted cookie was issued for\n   */\n  username: string;\n  /**\n   * Token the consuming application can use, It is tied to the\n   * clientId used in the `platformSelf` call\n   */\n  token: string;\n  /**\n   * Token expiration, in seconds-from-now\n   */\n  expires_in: number;\n}\n\n/**\n * @internal\n * @private\n * Request a token for a specific application using the esri_aopc encrypted cookie\n *\n * When a client app boots up, it will know its clientId and the redirectUri for use\n * in the normal /oauth/authorize pop-out oAuth flow.\n *\n * If the app sees an `esri_aopc` cookie (only set if the app is hosted on *.arcgis.com),\n * it can call the /oauth2/platformSelf end-point passing in the clientId and redirectUri\n * in headers, and it will receive back an app-specific token, assuming the user has\n * access to the app.\n *\n * Since there are scenarios where an app can boot using credentials/token from localstorage\n * but those credentials are not for the same user as the esri_aopc cookie, it is recommended that\n * an app check the returned username against any existing identity they may have loaded.\n *\n * Note: This is only usable by Esri applications hosted on *arcgis.com, *esri.com or within\n * an ArcGIS Enterprise installation. Custom applications can not use this.\n *\n * ```js\n * // convert the encrypted platform cookie into a ArcGISIdentityManager\n * import { platformSelf, ArcGISIdentityManager } from '@esri/arcgis-rest-request';\n *\n * const portal = 'https://www.arcgis.com/sharing/rest';\n * const clientId = 'YOURAPPCLIENTID';\n *\n * // exchange esri_aopc cookie\n * return platformSelf(clientId, 'https://your-app-redirect-uri', portal)\n * .then((response) => {\n *  const currentTimestamp = new Date().getTime();\n *  const tokenExpiresTimestamp = currentTimestamp + (response.expires_in * 1000);\n *  // Construct the session and return it\n *  return new ArcGISIdentityManager({\n *    portal,\n *    clientId,\n *    username: response.username,\n *    token: response.token,\n *    tokenExpires: new Date(tokenExpiresTimestamp),\n *    ssl: true\n *  });\n * })\n *\n * ```\n *\n *\n * @param clientId\n * @param redirectUri\n * @param portal\n */\nexport function platformSelf(\n  clientId: string,\n  redirectUri: string,\n  portal = \"https://www.arcgis.com/sharing/rest\"\n): Promise<IPlatformSelfResponse> {\n  // TEMPORARY: the f=json should not be needed, but currently is\n  const url = `${portal}/oauth2/platformSelf?f=json`;\n  const ro = {\n    method: \"POST\",\n    headers: {\n      \"X-Esri-Auth-Client-Id\": clientId,\n      \"X-Esri-Auth-Redirect-Uri\": redirectUri\n    },\n    // Note: request has logic to include the cookie\n    // for platformSelf calls w/ the X-Esri-Auth-Client-Id header\n    params: {\n      f: \"json\"\n    }\n  } as IRequestOptions;\n  // make the request and return the token\n  return request(url, ro);\n}\n","/**\n * These statuses are based on what are returned from the job request task and have been into an enum type.\n *\n * Reference https://developers.arcgis.com/rest/services-reference/enterprise/geoanalytics-checking-job-status.htm\n */\nexport enum JOB_STATUSES {\n  Success = \"Succeeded\",\n  Failed = \"Failed\",\n  Waiting = \"Waiting\",\n  Cancelled = \"Cancelled\",\n  Cancelling = \"Cancelling\",\n  New = \"New\",\n  Executing = \"Executing\",\n  Submitted = \"Submitted\",\n  Failure = \"Failure\",\n  TimedOut = \"TimedOut\",\n  Error = \"Error\",\n  Status = \"Etatus\",\n  Unknown = \"Unknown\"\n}\n","import { request } from \"./request.js\";\nimport { cleanUrl } from \"./utils/clean-url.js\";\nimport { ArcGISJobError } from \"./utils/ArcGISJobError.js\";\nimport { JOB_STATUSES } from \"./types/job-statuses.js\";\nimport { IAuthenticationManager } from \"./utils/IAuthenticationManager.js\";\nimport mitt from \"mitt\";\nimport { processJobParams } from \"./utils/process-job-params.js\";\n\n/**\n * Options for creating a new {@linkcode Job}.\n */\nexport interface IJobOptions {\n  /**\n   * The ID of the job. Can be used to rehydrate an instance of {@linkcode Job} with {@linkcode Job.fromExistingJob} or {@linkcode Job.deserialize}.\n   */\n  id: string;\n\n  /**\n   * The base URL of the job without `/submitJob` or a trailing job id.\n   */\n  url: string;\n\n  /**\n   * Automatically monitor the job for status changes once it is created. Defaults to `false`.\n   */\n  startMonitoring?: boolean;\n\n  /**\n   * Rate in milliseconds to poll for job status changes. Defaults to `2000`.\n   */\n  pollingRate?: number;\n\n  /**\n   * Authentication manager or access token to use for all job requests.\n   */\n  authentication?: IAuthenticationManager | string;\n}\n\n/**\n * Options for {@linkcode Job.submitJob}.\n */\nexport interface ISubmitJobOptions {\n  /**\n   * Parameters necessary that are passed to the {@linkcode Job.submitJob} method.\n   */\n  params: any;\n\n  /**\n   * The base URL of the job without `/submitJob` or a trailing job id.\n   */\n  url: string;\n\n  /**\n   * Automatically monitor the job for status changes once it is created. Defaults to `false`.\n   */\n  startMonitoring?: boolean;\n\n  /**\n   * Rate in milliseconds to poll for job status changes. Defaults to `2000`.\n   */\n  pollingRate?: number;\n\n  /**\n   * Authentication manager or access token to use for all job requests.\n   */\n  authentication?: IAuthenticationManager | string;\n}\n\n/**\n * Describes the status of a job. See the [GP Job documentation for more information](https://developers.arcgis.com/rest/services-reference/enterprise/gp-job.htm).\n */\nexport interface IJobInfo {\n  /**\n   * The ID of the job. Can be used to rehydrate an instance of {@linkcode Job} with {@linkcode Job.fromExistingJob} or {@linkcode Job.deserialize}.\n   */\n  id: string;\n  /**\n   * Represents the status of the current job.\n   */\n  status: JOB_STATUSES;\n  /**\n   * A results property that are returned from a successful job.\n   */\n  results?: {\n    [key: string]: {\n      paramUrl: string;\n    };\n  };\n  /**\n   * An input property that are returned from a successful job.\n   */\n  inputs?: {\n    [key: string]: {\n      paramUrl: string;\n    };\n  };\n  /**\n   * A message property that are returned from a successful job.\n   */\n  messages?: Array<{\n    type: string;\n    description: string;\n  }>;\n  /**\n   * A progress property that is returned while the job status is {@linkcode JOB_STATUSES.Executing}\n   */\n  progress?: {\n    type: string;\n    message: string;\n    percentage: number;\n  };\n}\n\nconst DefaultJobOptions: Partial<IJobOptions> = {\n  pollingRate: 2000,\n  startMonitoring: false\n};\n\n/**\n * Jobs represent long running processing tasks running on ArcGIS Services. Typically these represent complex analysis tasks such as [geoprocessing tasks](https://developers.arcgis.com/rest/services-reference/enterprise/submit-gp-job.htm), [logistics analysis such as fleet routing](https://developers.arcgis.com/rest/network/api-reference/vehicle-routing-problem-service.htm) or [spatial analysis tasks](https://developers.arcgis.com/rest/analysis/api-reference/tasks-overview.htm).\n *\n * To create a {@linkcode Job}, use the {@linkcode Job.submitJob} method which will return an instance of the {@linkcode Job} class with a unique id.\n *\n * If you have an existing job you can use {@linkcode Job.serialize} and {@linkcode Job.deserialize} to save job information as a string and recreate the job to get results later.\n *\n * ```js\n * import { Job,  JOB_STATUSES  } from \"@esri/arcgis-rest-request\";\n *\n * const job  = async Job.submitJob(options);\n *\n * // will automatically wait for job completion and get results when the job is finished.\n * job.getAllResults().then((results) => {console.log(results)})\n *\n * // watch for all status updates\n * job.on(\"status\", ({jobStatus}) => {console.log(job.status)})\n * ```\n *\n * By default event monitoring is started when you call {@linkcode Job.waitForCompletion}, {@linkcode Job.getAllResults} or, {@linkcode Job.getResult} and stops automatically when those promises complete. Use {@linkcode Job.startEventMonitoring} and {@linkcode Job.stopEventMonitoring} to manually start and stop event monitoring outside those methods. Starting monitoring with {@linkcode Job.startEventMonitoring} will not stop monitoring when {@linkcode Job.waitForCompletion}, {@linkcode Job.getAllResults} or, {@linkcode Job.getResult} complete.\n */\nexport class Job {\n  static deserialize(serializeString: string, options?: IJobOptions) {\n    const jobOptions: IJobOptions = {\n      ...DefaultJobOptions,\n      ...JSON.parse(serializeString),\n      ...options\n    };\n\n    return request(`${jobOptions.url}/jobs/${jobOptions.id}`, {\n      authentication: jobOptions.authentication\n    }).then(() => {\n      return new Job(jobOptions);\n    });\n  }\n\n  /**\n   * Creates a new instance of {@linkcode Job} from an existing job id.\n   *\n   * @param options Requires request endpoint url and id from an existing job id.\n   * @returns An new instance of Job class with options.\n   */\n  static fromExistingJob(options: IJobOptions) {\n    const jobOptions: IJobOptions = {\n      ...DefaultJobOptions,\n      ...options\n    };\n    const baseUrl = cleanUrl(jobOptions.url.replace(/\\/submitJob\\/?/, \"\"));\n    return request(`${baseUrl}/jobs/${jobOptions.id}`, {\n      authentication: jobOptions.authentication\n    }).then(() => {\n      return new Job(jobOptions);\n    });\n  }\n\n  /**\n   * Submits a job request that will return a new instance of {@linkcode Job}.\n   *\n   * @param requestOptions Requires url and params from requestOptions.\n   * @returns An new instance of Job class with the returned job id from submitJob request and requestOptions;\n   */\n  static submitJob(requestOptions: ISubmitJobOptions) {\n    const {\n      url,\n      params,\n      authentication,\n      pollingRate,\n      startMonitoring\n    }: Partial<ISubmitJobOptions> = {\n      ...DefaultJobOptions,\n      ...requestOptions\n    };\n\n    const processedParams = processJobParams(params);\n    const baseUrl = cleanUrl(url.replace(/\\/submitJob\\/?/, \"\"));\n    const submitUrl = baseUrl + \"/submitJob\";\n    return request(submitUrl, {\n      params: processedParams,\n      authentication\n    }).then(\n      (response) =>\n        new Job({\n          url: baseUrl,\n          authentication,\n          id: response.jobId,\n          startMonitoring,\n          pollingRate\n        })\n    );\n  }\n\n  /**\n   * The base URL of the job.\n   */\n  readonly url: string;\n  /**\n   * The job id indicating the specific job.\n   */\n  readonly id: string;\n  /**\n   * Authentication manager or access token to use for all job requests.\n   */\n  readonly authentication: IAuthenticationManager | string;\n\n  /**\n   * Internal instance of [`mitt`](https://github.com/developit/mitt) used for event handlers. It is recommended to use {@linkcode Job.on}, {@linkcode Job.off} or {@linkcode Job.once} instead of `emitter.`\n   */\n  private emitter: any;\n\n  /**\n   * Private pollingRate that is set if the user changes the pollingRate.\n   */\n  private _pollingRate: number;\n  /**\n   * Private boolean that checks to see if the user enables startMonitoring.\n   */\n  private didUserEnableMonitoring: any;\n  /**\n   * Internal handler for `setInterval()` used when polling.;\n   */\n  private setIntervalHandler: any;\n\n\n  constructor(options: IJobOptions) {\n    const { url, id, pollingRate, authentication }: Partial<IJobOptions> = {\n      ...DefaultJobOptions,\n      ...options\n    };\n\n    // Setup internal properties\n    this.url = url;\n    this.id = id;\n    this.authentication = authentication;\n    this._pollingRate = pollingRate;\n    this.emitter = mitt();\n\n    if (options.startMonitoring) {\n      this.startEventMonitoring(pollingRate);\n    }\n  }\n\n  /**\n   * Getter that appends the job id to the base url.\n   */\n  private get jobUrl() {\n    return `${this.url}/jobs/${this.id}`;\n  }\n\n  /**\n   * Returns `true` if the job is polling for status changes.\n   */\n  get isMonitoring() {\n    return !!this.setIntervalHandler;\n  }\n\n  /**\n   * The rate at which event monitoring is occurring in milliseconds.\n   */\n  get pollingRate() {\n    return this._pollingRate;\n  }\n\n  /**\n   * Sets a new polling rate and restart polling for status changes.\n   */\n  set pollingRate(newRate: number) {\n    this.stopEventMonitoring();\n    this.startEventMonitoring(newRate);\n  }\n\n  /**\n   * Retrieves the status of the current job.\n   *\n   * @returns An object with the job id and jobStatus.\n   */\n  getJobInfo(): Promise<IJobInfo> {\n    return request(this.jobUrl, {\n      authentication: this.authentication\n    }).then((rawJobInfo: any) => {\n      const info: any = Object.assign(\n        {\n          id: rawJobInfo.jobId,\n          status: undefined\n        },\n        rawJobInfo\n      );\n\n      delete info.jobId;\n      delete info.jobStatus;\n\n      switch (rawJobInfo.jobStatus) {\n        case \"esriJobCancelled\":\n          info.status = JOB_STATUSES.Cancelled;\n          break;\n        case \"esriJobCancelling\":\n          info.status = JOB_STATUSES.Cancelling;\n          break;\n        case \"esriJobNew\":\n          info.status = JOB_STATUSES.New;\n          break;\n        case \"esriJobWaiting\":\n          info.status = JOB_STATUSES.Waiting;\n          break;\n        case \"esriJobExecuting\":\n          info.status = JOB_STATUSES.Executing;\n          break;\n        case \"esriJobSubmitted\":\n          info.status = JOB_STATUSES.Submitted;\n          break;\n        case \"esriJobTimedOut\":\n          info.status = JOB_STATUSES.TimedOut;\n          break;\n        case \"esriJobFailed\":\n          info.status = JOB_STATUSES.Failed;\n          break;\n        case \"expectedFailure\":\n          info.status = JOB_STATUSES.Failure;\n          break;\n        case \"esriJobSucceeded\":\n          info.status = JOB_STATUSES.Success;\n          break;\n      }\n\n      return info as IJobInfo;\n    });\n  }\n\n  /**\n   * Function that calls the {@linkcode Job.getJobInfo} to check the job status, and emits the current job status. There are custom event emitters that\n   * the user is able to listen based on the job status. Refer to {@linkcode JOB_STATUSES} to see the various enums of the job status.\n   * To get results array from the job task, the job status must be {@linkcode JOB_STATUSES.Success}.\n   *\n   * These job statuses are based on what are returned from the job request task and have been into an enum type in {@linkcode JOB_STATUSES}.\n   *\n   * Reference https://developers.arcgis.com/rest/services-reference/enterprise/geoanalytics-checking-job-status.htm\n   */\n  private executePoll = async () => {\n    let result;\n    try {\n      result = await this.getJobInfo();\n    } catch (error) {\n      this.emitter.emit(JOB_STATUSES.Error, error);\n      return;\n    }\n\n    this.emitter.emit(JOB_STATUSES.Status, result);\n    this.emitter.emit(result.status, result);\n  };\n\n  /**\n   * A handler that listens for an eventName and returns custom handler.\n   *\n   * @param eventName A string of what event to listen for.\n   * @param handler A function of what to do when eventName was called.\n   */\n  on(eventName: string, handler: (e: IJobInfo) => void) {\n    this.emitter.on(eventName, handler);\n  }\n\n  /**\n   * A handler that listens for an event once and returns a custom handler.\n   *\n   * @param eventName A string of what event to listen for.\n   * @param handler A function of what to do when eventName was called.\n   */\n  once(eventName: string, handler: (e: IJobInfo) => void) {\n    const fn = (arg: any) => {\n      this.emitter.off(eventName, fn);\n      handler(arg);\n    };\n\n    this.emitter.on(eventName, fn);\n\n    (handler as any).__arcgis_job_once_original_function__ = fn;\n  }\n\n  /**\n   * A handler that will remove a listener after its emitted and returns a custom handler.\n   *\n   * @param eventName A string of what event to listen for.\n   * @param handler A function of what to do when eventName was called.\n   */\n  off(eventName: string, handler: (e: IJobInfo) => void) {\n    if ((handler as any).__arcgis_job_once_original_function__) {\n      this.emitter.off(\n        eventName,\n        (handler as any).__arcgis_job_once_original_function__\n      );\n      return;\n    }\n    this.emitter.off(eventName, handler);\n  }\n\n  /**\n   * Get the specific results of a successful job by result name. To get all results see {@linkcode Job.getAllResults}.\n   *\n   * If monitoring is disabled it will be enabled until the job classes resolves or rejects this promise.\n   *\n   * ```\n   * Job.submitJob(options)\n   *  .then((job) => {\n   *    return job.getResult(\"result_name\")\n   *  }).then(result => {\n   *    console.log(result);\n   *  }).catch(e => {\n   *    if(e.name === \"ArcGISJobError\") {\n   *      console.log(\"Something went wrong while running the job\", e.jobInfo);\n   *    }\n   *  })\n   * ```\n   *\n   *  Will throw a {@linkcode ArcGISJobError} if it encounters a cancelled or failure status in the job.\n   *\n   * @param result The name of the result that you want to retrieve.\n   * @returns An object representing the individual result of the job.\n   */\n  async getResult(result: string) {\n    return this.waitForCompletion().then((jobInfo: any) => {\n      return request(this.jobUrl + \"/\" + jobInfo.results[result].paramUrl, {\n        authentication: this.authentication\n      });\n    });\n  }\n\n  /**\n   * Formats the requestOptions to JSON format.\n   *\n   * @returns The `Job` as a plain JavaScript object.\n   */\n  toJSON(): IJobOptions {\n    return {\n      id: this.id,\n      url: this.url,\n      startMonitoring: this.isMonitoring,\n      pollingRate: this.pollingRate\n    };\n  }\n\n  /**\n   * Converts the `Job` to a JSON string. You can rehydrate the state of the `Job` with {@linkcode Job.deserialize}.\n   *\n   * @returns A JSON string representing the `Job`.\n   */\n  serialize() {\n    return JSON.stringify(this);\n  }\n\n  /**\n   * Checks for job status and if the job status is successful it resolves the job information. Otherwise will throw a {@linkcode ArcGISJobError} if it encounters a cancelled or failure status in the job.\n   *\n   * ```\n   * Job.submitJob(options)\n   *  .then((job) => {\n   *    return job.waitForCompletion();\n   *  })\n   * .then((jobInfo) => {\n   *    console.log(\"job finished\", e.jobInfo);\n   *  })\n   * .catch(e => {\n   *    if(e.name === \"ArcGISJobError\") {\n   *      console.log(\"Something went wrong while running the job\", e.jobInfo);\n   *    }\n   *  })\n   * ```\n   *\n   * @returns An object with a successful job status, id, and results.\n   */\n  async waitForCompletion(): Promise<IJobInfo> {\n    const jobInfo = await this.getJobInfo();\n    if (jobInfo.status === JOB_STATUSES.Success) {\n      return Promise.resolve(jobInfo);\n    }\n    //if jobStatus comes back immediately with one of the statuses\n    if (\n      jobInfo.status === JOB_STATUSES.Cancelling ||\n      jobInfo.status === JOB_STATUSES.Cancelled ||\n      jobInfo.status === JOB_STATUSES.Failed ||\n      jobInfo.status === JOB_STATUSES.Failure ||\n      jobInfo.status === JOB_STATUSES.TimedOut\n    ) {\n      this.stopInternalEventMonitoring();\n\n      return Promise.reject(\n        new ArcGISJobError(\"Job cancelled or failed.\", jobInfo)\n      );\n    }\n\n    //waits to see what the status is if not immediate\n    return new Promise((resolve, reject) => {\n      this.startInternalEventMonitoring();\n\n      this.once(JOB_STATUSES.Cancelled, (jobInfo) => {\n        this.stopInternalEventMonitoring();\n        reject(new ArcGISJobError(\"Job cancelled.\", jobInfo));\n      });\n\n      this.once(JOB_STATUSES.TimedOut, (jobInfo) => {\n        this.stopInternalEventMonitoring();\n        reject(new ArcGISJobError(\"Job timed out.\", jobInfo));\n      });\n\n      this.once(JOB_STATUSES.Failed, (jobInfo) => {\n        this.stopInternalEventMonitoring();\n        reject(new ArcGISJobError(\"Job failed.\", jobInfo));\n      });\n\n      this.once(JOB_STATUSES.Success, (jobInfo) => {\n        this.stopInternalEventMonitoring();\n        resolve(jobInfo);\n      });\n    });\n  }\n\n  /**\n   * Gets all the results from a successful job by ordering all the result paramUrl requests and calling each of them until all of them are complete and returns an object with all the results.\n   *\n   * If monitoring is disabled it will be enabled until the job classes resolves or rejects this promise.\n   *\n   * ```\n   * Job.submitJob(options)\n   *  .then((job) => {\n   *    return job.getAllResults();\n   *  }).then(allResults => {\n   *    console.log(allResults);\n   *  }).catch(e => {\n   *    if(e.name === \"ArcGISJobError\") {\n   *      console.log(\"Something went wrong while running the job\", e.jobInfo);\n   *    }\n   *  })\n   * ```\n   *\n   * Will throw a {@linkcode ArcGISJobError} if it encounters a cancelled or failure status in the job.\n   *\n   * @returns An object representing all the results from a job.\n   */\n  async getAllResults() {\n    return this.waitForCompletion().then((jobInfo: any) => {\n      const keys = Object.keys(jobInfo.results);\n\n      const requests = keys.map((key) => {\n        return request(this.jobUrl + \"/\" + jobInfo.results[key].paramUrl, {\n          authentication: this.authentication\n        }).then((results) => {\n          return results;\n        });\n      });\n\n      return Promise.all(requests).then((resultsArray: any) => {\n        return keys.reduce((finalResults: any, key: string, index: number) => {\n          finalResults[keys[index]] = resultsArray[index];\n          return finalResults;\n        }, {});\n      });\n    });\n  }\n\n  /**\n   * Cancels the job request and voids the job.\n   *\n   * @returns An object that has job id, job status and messages array sequencing the status of the cancellation being submitted and completed.\n   */\n  cancelJob() {\n    return request(this.jobUrl + \"/cancel\", {\n      authentication: this.authentication,\n      params: { id: this.id, returnMessages: false }\n    }).then((response: any) => {\n      this.emitter.emit(\"cancelled\", response);\n      return response;\n    });\n  }\n\n  /**\n   * An internal monitoring if the user specifies startMonitoring: false, we need to check the status to see when the results are returned.\n   */\n  private startInternalEventMonitoring(\n    pollingRate = DefaultJobOptions.pollingRate\n  ) {\n    this._pollingRate = pollingRate;\n\n    /* istanbul ignore else - if monitoring is already running do nothing */\n    if (!this.isMonitoring) {\n      this.setIntervalHandler = setInterval(this.executePoll, this.pollingRate);\n    }\n  }\n\n  /**\n   * Stops the internal monitoring once the job has been successfully completed with results.\n   */\n  private stopInternalEventMonitoring() {\n    if (this.isMonitoring && !this.didUserEnableMonitoring) {\n      clearTimeout(this.setIntervalHandler);\n    }\n  }\n\n  /**\n   * Starts the event polling if the user enables the startMonitoring param.\n   *\n   * @param pollingRate Able to pass in a specific number or will default to 5000.\n   */\n  startEventMonitoring(pollingRate = DefaultJobOptions.pollingRate) {\n    this._pollingRate = pollingRate;\n    this.didUserEnableMonitoring = true;\n\n    /* istanbul ignore else - if not monitoring do nothing */\n    if (!this.isMonitoring) {\n      this.setIntervalHandler = setInterval(this.executePoll, this.pollingRate);\n    }\n  }\n\n  /**\n   * Stops the event polling rate. This is can only be enabled if the user calls this method directly.\n   */\n  stopEventMonitoring() {\n    /* istanbul ignore else - if not monitoring do nothing */\n    if (this.isMonitoring && this.didUserEnableMonitoring) {\n      clearTimeout(this.setIntervalHandler);\n    }\n  }\n}\n","export default function(n){return{all:n=n||new Map,on:function(t,e){var i=n.get(t);i?i.push(e):n.set(t,[e])},off:function(t,e){var i=n.get(t);i&&(e?i.splice(i.indexOf(e)>>>0,1):n.set(t,[]))},emit:function(t,e){var i=n.get(t);i&&i.slice().map(function(n){n(e)}),(i=n.get(\"*\"))&&i.slice().map(function(n){n(t,e)})}}}\n//# sourceMappingURL=mitt.mjs.map\n"," /**\n   * Processes arrays to JSON strings for Geoprocessing services. See “GPMultiValue” in https://developers.arcgis.com/rest/services-reference/enterprise/gp-data-types.htm\n   */\n  export function processJobParams(params: any) {\n  const processedParams = Object.keys(params).reduce((newParams: any, key) => {\n    const value = params[key]\n    const type = value.constructor.name;\n    newParams[key] = type === \"Array\" ? JSON.stringify(value) : value;\n    return newParams;\n  }, {});\n\n  return processedParams\n}","import { IRequestOptions } from \"../utils/IRequestOptions.js\";\n\n/**\n * Allows you to wrap individual methods with a default set of request options. This is useful to avoid setting the same option more then once and allows for interacting and setting defaults in a functional manner.\n *\n * ```js\n * import { withOptions } from \"@esri/arcgis-rest-request\";\n * import { queryFeatures } from '@esri/arcgis-rest-feature-service';\n *\n * const queryTrails = withOptions({\n *   url: \"https://services3.arcgis.com/GVgbJbqm8hXASVYi/arcgis/rest/services/Trailheads/FeatureServer/0/\"}, queryFeatures);\n *\n * queryTrails({\n *   where: \"ELEV_FT > 1000\"\n * }).then(result);\n *\n * const queryTrailsAsUser = withOptions({\n *   authentication: ArcGISIdentityManager\n * }, queryTrails);\n *\n * queryTrailsAsUser({\n *   where: \"TRL_NAME LIKE '%backbone%'\"\n * }).then(result);\n * ```\n *\n * @param defaultOptions The options to pass into to the `func`.\n * @param func Any function that accepts anything extending `IRequestOptions` as its last parameter.\n * @returns A copy of `func` with the `defaultOptions` passed in as defaults.\n */\nexport function withOptions<\n  K extends IRequestOptions,\n  T extends (...args: any[]) => any\n>(\n  defaultOptions: IRequestOptions,\n  func: T\n): (...funcArgs: Parameters<T>) => ReturnType<T> {\n  return (...args: Parameters<T>): ReturnType<T> => {\n    const options: K =\n      typeof args[args.length - 1] === \"object\"\n        ? {\n            ...defaultOptions,\n            ...args.pop()\n          }\n        : defaultOptions;\n\n    return func(...[...args, options]);\n  };\n}\n"],"names":["requiresFormData","params","Object","keys","some","key","value","toParam","constructor","name","processParams","newParams","forEach","param","firstElementType","JSON","stringify","join","valueOf","Array","isArray","encodeParam","map","arrayElem","encodeURIComponent","encodeQueryString","FormData","globalThis","File","Blob","encodeFormData","forceFormData","useFormData","formData","filename","append","ArcGISRequestError","Error","message","code","response","url","options","super","actualProto","prototype","setPrototypeOf","this","originalMessage","DEFAULT_ARCGIS_REQUEST_CONFIG","noCorsDomains","crossOriginNoCorsDomains","pendingNoCorsRequests","GLOBAL_VARIABLE_NAME","requestConfig","sendNoCorsRequest","urlObj","URL","origin","pathname","search","includes","fetch","mode","credentials","cache","then","indexOf","push","toLowerCase","Date","now","catch","e","Promise","reject","getRegisteredNoCorsDomains","registerNoCorsDomains","authorizedCrossOriginNoCorsDomains","domain","test","addNoCorsDomain","isNoCorsDomain","result","length","isNoCorsRequestRequired","lastRequest","warn","console","apply","getFetch","resolve","Headers","Response","Request","NODEJS_DEFAULT_REFERER_HEADER","setDefaultRequestOptions","hideWarnings","authentication","DEFAULT_ARCGIS_REQUEST_OPTIONS","getDefaultRequestOptions","httpMethod","f","ArcGISAuthError","retry","getSession","retryLimit","tries","retryRequest","session","newOptions","internalRequest","checkForErrors","originalAuthError","error","messageCode","errorCode","status","parse","statusMessage","requestOptions","defaults","headers","rawResponse","fetchOptions","method","signal","rawToken","portal","getToken","startsWith","suppressWarnings","ARCGIS_REST_JS_SUPPRESS_TOKEN_WARNING","originalUrl","sameOrigin","window","win","location","isSameOrigin","requiresNoCors","firstPromise","err","token","getDomainCredentials","requestHeaders","hideToken","urlWithQueryString","maxUrlLength","RegExp","body","document","referer","ok","json","jsonError","statusText","details","formattedMessage","trim","text","blob","data","truncatedUrl","split","federatedServers","expires","request","internalOptions","canRefresh","refreshCredentials","appendCustomParams","customOptions","baseOptions","reduce","ArcGISTokenRequestErrorCodes","ErrorTypes","ArcGISTokenRequestError","UNKNOWN_ERROR_CODE","ArcGISAccessDeniedError","ArcGISJobError","jobInfo","id","cleanUrl","slice","decodeParam","decodeURIComponent","decodeQueryString","query","replace","acc","entry","FIVE_MINUTES_IN_MILLISECONDS","fetchToken","username","portalTokenResponse","access_token","expires_in","ssl","refresh_token","refreshToken","refresh_token_expires_in","refreshTokenExpires","AuthenticationManagerBase","_username","_user","getUsername","getUser","user","_pendingUserRequest","clearCachedUserInfo","ApplicationCredentialsManager","clientId","clientSecret","duration","static","getTime","_pendingTokenRequest","client_id","client_secret","grant_type","expiration","setToken","setExpires","TOKEN_REFRESH_FAILED","toJSON","type","serialize","serialized","newToken","newExpires","ApplicationSession","log","ApiKeyManager","apiKey","ApiKey","arcgisOnlineUrlRegex","isOnline","normalizeOnlinePortalUrl","portalUrl","getOnlineEnvironment","subdomain","match","pop","isFederated","owningSystemUrl","normalizedPortalUrl","normalizedOwningSystemUrl","canUseOnlineToken","requestUrl","portalIsOnline","requestIsOnline","portalEnv","requestEnv","validateAppAccess","revokeToken","auth_token","success","base64UrlEncode","btoa","String","fromCharCode","generateRandomString","crypto","getRandomValues","Uint8Array","ArcGISIdentityManager","_refreshToken","_refreshTokenExpires","password","_token","_tokenExpires","tokenExpires","provider","tokenDuration","redirectUri","server","trustedDomains","root","getServerRootUrl","_pendingTokenRequests","popup","popupWindowFeatures","locale","style","pkce","state","stateId","stateStorageKey","localStorage","setItem","authorizeUrl","authorizeUrlParams","response_type","redirect_uri","href","setupAuth","socialLoginProviderName","autoAccountCreateForSocial","codeVerifier","codeVerifierStorageKey","isSecureContext","subtle","bytes","TextEncoder","encode","digest","buffer","generateCodeChallenge","codeChallenge","code_challenge_method","code_challenge","addEventListener","detail","errorMessage","once","open","dispatchEvent","CustomEvent","getItem","hash","undefined","reportError","removeItem","opener","close","history","replaceState","createManager","oauthInfo","error_description","tokenEndpoint","code_verifier","tokenResponse","parseInt","parentOrigin","handler","event","source","parent","parentMessageHandler","postMessage","manager","removeEventListener","queryParams","writeHead","Location","end","authorizationCode","REFRESH_TOKEN_EXCHANGE_FAILED","str","credential","serverInfo","hasServer","userId","isCredential","fromCredential","hasPortal","toCredential","getPortal","_pendingPortalRequest","_portalInfo","getFreshToken","getTokenForServer","enablePostMessageAuth","validChildOrigins","_hostHandler","createPostMessageHandler","disablePostMessageAuth","refreshWithUsernameAndPassword","refreshWithRefreshToken","protocol","domainAndPath","path","domainWithProtocol","signOut","destroy","validOrigins","isValidOrigin","isValidType","isTokenValid","msg","existingToken","fetchAuthorizedDomains","NOT_FEDERATED","authInfo","generateTokenForServer","tokenServicesUrl","serverUrl","GENERATE_TOKEN_FOR_SERVER_FAILED","client","updateToken","exchangeRefreshToken","newTokenExpiration","portalInfo","authorizedCrossOriginDomains","filter","d","UserSession","exchangeToken","platformSelf","JOB_STATUSES","beginOAuth2","args","completeOAuth2","fromParent","authorize","exchangeAuthorizationCode","deserialize","DefaultJobOptions","pollingRate","startMonitoring","Job","async","getJobInfo","emitter","emit","Status","n","_pollingRate","all","Map","on","t","i","get","set","off","splice","startEventMonitoring","serializeString","jobOptions","processedParams","processJobParams","baseUrl","jobId","jobUrl","isMonitoring","setIntervalHandler","newRate","stopEventMonitoring","rawJobInfo","info","assign","jobStatus","Cancelled","Cancelling","New","Waiting","Executing","Submitted","TimedOut","Failed","Failure","Success","eventName","fn","arg","__arcgis_job_once_original_function__","waitForCompletion","results","paramUrl","stopInternalEventMonitoring","startInternalEventMonitoring","requests","resultsArray","finalResults","index","cancelJob","returnMessages","setInterval","executePoll","didUserEnableMonitoring","clearTimeout","withOptions","defaultOptions","func"],"mappings":"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"}