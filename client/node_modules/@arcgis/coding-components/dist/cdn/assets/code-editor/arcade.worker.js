class Uo {
  constructor() {
    this.listeners = [], this.unexpectedErrorHandler = function(e) {
      setTimeout(() => {
        throw e.stack ? bt.isErrorNoTelemetry(e) ? new bt(e.message + `

` + e.stack) : new Error(e.message + `

` + e.stack) : e;
      }, 0);
    };
  }
  emit(e) {
    this.listeners.forEach((n) => {
      n(e);
    });
  }
  onUnexpectedError(e) {
    this.unexpectedErrorHandler(e), this.emit(e);
  }
  // For external errors, we don't want the listeners to be called
  onUnexpectedExternalError(e) {
    this.unexpectedErrorHandler(e);
  }
}
const Vo = new Uo();
function yt(t) {
  $o(t) || Vo.onUnexpectedError(t);
}
function Hi(t) {
  if (t instanceof Error) {
    const { name: e, message: n } = t, i = t.stacktrace || t.stack;
    return {
      $isError: !0,
      name: e,
      message: n,
      stack: i,
      noTelemetry: bt.isErrorNoTelemetry(t)
    };
  }
  return t;
}
const jn = "Canceled";
function $o(t) {
  return t instanceof qo ? !0 : t instanceof Error && t.name === jn && t.message === jn;
}
class qo extends Error {
  constructor() {
    super(jn), this.name = this.message;
  }
}
class bt extends Error {
  constructor(e) {
    super(e), this.name = "CodeExpectedError";
  }
  static fromError(e) {
    if (e instanceof bt)
      return e;
    const n = new bt();
    return n.message = e.message, n.stack = e.stack, n;
  }
  static isErrorNoTelemetry(e) {
    return e.name === "CodeExpectedError";
  }
}
class Ae extends Error {
  constructor(e) {
    super(e || "An unexpected bug occurred."), Object.setPrototypeOf(this, Ae.prototype);
  }
}
function zo(t, e) {
  const n = this;
  let i = !1, r;
  return function() {
    return i || (i = !0, r = t.apply(n, arguments)), r;
  };
}
var tn;
(function(t) {
  function e(C) {
    return C && typeof C == "object" && typeof C[Symbol.iterator] == "function";
  }
  t.is = e;
  const n = Object.freeze([]);
  function i() {
    return n;
  }
  t.empty = i;
  function* r(C) {
    yield C;
  }
  t.single = r;
  function s(C) {
    return e(C) ? C : r(C);
  }
  t.wrap = s;
  function a(C) {
    return C || n;
  }
  t.from = a;
  function* o(C) {
    for (let x = C.length - 1; x >= 0; x--)
      yield C[x];
  }
  t.reverse = o;
  function l(C) {
    return !C || C[Symbol.iterator]().next().done === !0;
  }
  t.isEmpty = l;
  function c(C) {
    return C[Symbol.iterator]().next().value;
  }
  t.first = c;
  function d(C, x) {
    let w = 0;
    for (const N of C)
      if (x(N, w++))
        return !0;
    return !1;
  }
  t.some = d;
  function h(C, x) {
    for (const w of C)
      if (x(w))
        return w;
  }
  t.find = h;
  function* f(C, x) {
    for (const w of C)
      x(w) && (yield w);
  }
  t.filter = f;
  function* m(C, x) {
    let w = 0;
    for (const N of C)
      yield x(N, w++);
  }
  t.map = m;
  function* b(C, x) {
    let w = 0;
    for (const N of C)
      yield* x(N, w++);
  }
  t.flatMap = b;
  function* D(...C) {
    for (const x of C)
      yield* x;
  }
  t.concat = D;
  function E(C, x, w) {
    let N = w;
    for (const B of C)
      N = x(N, B);
    return N;
  }
  t.reduce = E;
  function* L(C, x, w = C.length) {
    for (x < 0 && (x += C.length), w < 0 ? w += C.length : w > C.length && (w = C.length); x < w; x++)
      yield C[x];
  }
  t.slice = L;
  function _(C, x = Number.POSITIVE_INFINITY) {
    const w = [];
    if (x === 0)
      return [w, C];
    const N = C[Symbol.iterator]();
    for (let B = 0; B < x; B++) {
      const j = N.next();
      if (j.done)
        return [w, t.empty()];
      w.push(j.value);
    }
    return [w, { [Symbol.iterator]() {
      return N;
    } }];
  }
  t.consume = _;
  async function v(C) {
    const x = [];
    for await (const w of C)
      x.push(w);
    return Promise.resolve(x);
  }
  t.asyncToArray = v;
})(tn || (tn = {}));
function ja(t) {
  if (tn.is(t)) {
    const e = [];
    for (const n of t)
      if (n)
        try {
          n.dispose();
        } catch (i) {
          e.push(i);
        }
    if (e.length === 1)
      throw e[0];
    if (e.length > 1)
      throw new AggregateError(e, "Encountered errors while disposing of store");
    return Array.isArray(t) ? [] : t;
  } else if (t)
    return t.dispose(), t;
}
function Wo(...t) {
  return nn(() => ja(t));
}
function nn(t) {
  return {
    dispose: zo(() => {
      t();
    })
  };
}
class Ut {
  static {
    this.DISABLE_DISPOSED_WARNING = !1;
  }
  constructor() {
    this._toDispose = /* @__PURE__ */ new Set(), this._isDisposed = !1;
  }
  /**
   * Dispose of all registered disposables and mark this object as disposed.
   *
   * Any future disposables added to this object will be disposed of on `add`.
   */
  dispose() {
    this._isDisposed || (this._isDisposed = !0, this.clear());
  }
  /**
   * @return `true` if this object has been disposed of.
   */
  get isDisposed() {
    return this._isDisposed;
  }
  /**
   * Dispose of all registered disposables but do not mark this object as disposed.
   */
  clear() {
    if (this._toDispose.size !== 0)
      try {
        ja(this._toDispose);
      } finally {
        this._toDispose.clear();
      }
  }
  /**
   * Add a new {@link IDisposable disposable} to the collection.
   */
  add(e) {
    if (!e)
      return e;
    if (e === this)
      throw new Error("Cannot register a disposable on itself!");
    return this._isDisposed ? Ut.DISABLE_DISPOSED_WARNING || console.warn(new Error("Trying to add a disposable to a DisposableStore that has already been disposed of. The added object will be leaked!").stack) : this._toDispose.add(e), e;
  }
  /**
   * Deletes the value from the store, but does not dispose it.
   */
  deleteAndLeak(e) {
    e && this._toDispose.has(e) && this._toDispose.delete(e);
  }
}
class rn {
  static {
    this.None = Object.freeze({ dispose() {
    } });
  }
  constructor() {
    this._store = new Ut(), this._store;
  }
  dispose() {
    this._store.dispose();
  }
  /**
   * Adds `o` to the collection of disposables managed by this object.
   */
  _register(e) {
    if (e === this)
      throw new Error("Cannot register a disposable on itself!");
    return this._store.add(e);
  }
}
class Y {
  static {
    this.Undefined = new Y(void 0);
  }
  constructor(e) {
    this.element = e, this.next = Y.Undefined, this.prev = Y.Undefined;
  }
}
class Oo {
  constructor() {
    this._first = Y.Undefined, this._last = Y.Undefined, this._size = 0;
  }
  get size() {
    return this._size;
  }
  isEmpty() {
    return this._first === Y.Undefined;
  }
  clear() {
    let e = this._first;
    for (; e !== Y.Undefined; ) {
      const n = e.next;
      e.prev = Y.Undefined, e.next = Y.Undefined, e = n;
    }
    this._first = Y.Undefined, this._last = Y.Undefined, this._size = 0;
  }
  unshift(e) {
    return this._insert(e, !1);
  }
  push(e) {
    return this._insert(e, !0);
  }
  _insert(e, n) {
    const i = new Y(e);
    if (this._first === Y.Undefined)
      this._first = i, this._last = i;
    else if (n) {
      const s = this._last;
      this._last = i, i.prev = s, s.next = i;
    } else {
      const s = this._first;
      this._first = i, i.next = s, s.prev = i;
    }
    this._size += 1;
    let r = !1;
    return () => {
      r || (r = !0, this._remove(i));
    };
  }
  shift() {
    if (this._first !== Y.Undefined) {
      const e = this._first.element;
      return this._remove(this._first), e;
    }
  }
  pop() {
    if (this._last !== Y.Undefined) {
      const e = this._last.element;
      return this._remove(this._last), e;
    }
  }
  _remove(e) {
    if (e.prev !== Y.Undefined && e.next !== Y.Undefined) {
      const n = e.prev;
      n.next = e.next, e.next.prev = n;
    } else e.prev === Y.Undefined && e.next === Y.Undefined ? (this._first = Y.Undefined, this._last = Y.Undefined) : e.next === Y.Undefined ? (this._last = this._last.prev, this._last.next = Y.Undefined) : e.prev === Y.Undefined && (this._first = this._first.next, this._first.prev = Y.Undefined);
    this._size -= 1;
  }
  *[Symbol.iterator]() {
    let e = this._first;
    for (; e !== Y.Undefined; )
      yield e.element, e = e.next;
  }
}
const Ho = globalThis.performance && typeof globalThis.performance.now == "function";
class Sn {
  static create(e) {
    return new Sn(e);
  }
  constructor(e) {
    this._now = Ho && e === !1 ? Date.now : globalThis.performance.now.bind(globalThis.performance), this._startTime = this._now(), this._stopTime = -1;
  }
  stop() {
    this._stopTime = this._now();
  }
  reset() {
    this._startTime = this._now(), this._stopTime = -1;
  }
  elapsed() {
    return this._stopTime !== -1 ? this._stopTime - this._startTime : this._now() - this._startTime;
  }
}
var sn;
(function(t) {
  t.None = () => rn.None;
  function e(y, A) {
    return f(y, () => {
    }, 0, void 0, !0, void 0, A);
  }
  t.defer = e;
  function n(y) {
    return (A, R = null, k) => {
      let T = !1, z;
      return z = y((X) => {
        if (!T)
          return z ? z.dispose() : T = !0, A.call(R, X);
      }, null, k), T && z.dispose(), z;
    };
  }
  t.once = n;
  function i(y, A) {
    return t.once(t.filter(y, A));
  }
  t.onceIf = i;
  function r(y, A, R) {
    return d((k, T = null, z) => y((X) => k.call(T, A(X)), null, z), R);
  }
  t.map = r;
  function s(y, A, R) {
    return d((k, T = null, z) => y((X) => {
      A(X), k.call(T, X);
    }, null, z), R);
  }
  t.forEach = s;
  function a(y, A, R) {
    return d((k, T = null, z) => y((X) => A(X) && k.call(T, X), null, z), R);
  }
  t.filter = a;
  function o(y) {
    return y;
  }
  t.signal = o;
  function l(...y) {
    return (A, R = null, k) => {
      const T = Wo(...y.map((z) => z((X) => A.call(R, X))));
      return h(T, k);
    };
  }
  t.any = l;
  function c(y, A, R, k) {
    let T = R;
    return r(y, (z) => (T = A(T, z), T), k);
  }
  t.reduce = c;
  function d(y, A) {
    let R;
    const k = {
      onWillAddFirstListener() {
        R = y(T.fire, T);
      },
      onDidRemoveLastListener() {
        R?.dispose();
      }
    }, T = new we(k);
    return A?.add(T), T.event;
  }
  function h(y, A) {
    return A instanceof Array ? A.push(y) : A && A.add(y), y;
  }
  function f(y, A, R = 100, k = !1, T = !1, z, X) {
    let le, de, rt, $t = 0, wt;
    const Mo = {
      leakWarningThreshold: z,
      onWillAddFirstListener() {
        le = y((Po) => {
          $t++, de = A(de, Po), k && !rt && (qt.fire(de), de = void 0), wt = () => {
            const To = de;
            de = void 0, rt = void 0, (!k || $t > 1) && qt.fire(To), $t = 0;
          }, typeof R == "number" ? (clearTimeout(rt), rt = setTimeout(wt, R)) : rt === void 0 && (rt = 0, queueMicrotask(wt));
        });
      },
      onWillRemoveListener() {
        T && $t > 0 && wt?.();
      },
      onDidRemoveLastListener() {
        wt = void 0, le.dispose();
      }
    }, qt = new we(Mo);
    return X?.add(qt), qt.event;
  }
  t.debounce = f;
  function m(y, A = 0, R) {
    return t.debounce(y, (k, T) => k ? (k.push(T), k) : [T], A, void 0, !0, void 0, R);
  }
  t.accumulate = m;
  function b(y, A = (k, T) => k === T, R) {
    let k = !0, T;
    return a(y, (z) => {
      const X = k || !A(z, T);
      return k = !1, T = z, X;
    }, R);
  }
  t.latch = b;
  function D(y, A, R) {
    return [
      t.filter(y, A, R),
      t.filter(y, (k) => !A(k), R)
    ];
  }
  t.split = D;
  function E(y, A = !1, R = [], k) {
    let T = R.slice(), z = y((de) => {
      T ? T.push(de) : le.fire(de);
    });
    k && k.add(z);
    const X = () => {
      T?.forEach((de) => le.fire(de)), T = null;
    }, le = new we({
      onWillAddFirstListener() {
        z || (z = y((de) => le.fire(de)), k && k.add(z));
      },
      onDidAddFirstListener() {
        T && (A ? setTimeout(X) : X());
      },
      onDidRemoveLastListener() {
        z && z.dispose(), z = null;
      }
    });
    return k && k.add(le), le.event;
  }
  t.buffer = E;
  function L(y, A) {
    return (k, T, z) => {
      const X = A(new v());
      return y(function(le) {
        const de = X.evaluate(le);
        de !== _ && k.call(T, de);
      }, void 0, z);
    };
  }
  t.chain = L;
  const _ = Symbol("HaltChainable");
  class v {
    constructor() {
      this.steps = [];
    }
    map(A) {
      return this.steps.push(A), this;
    }
    forEach(A) {
      return this.steps.push((R) => (A(R), R)), this;
    }
    filter(A) {
      return this.steps.push((R) => A(R) ? R : _), this;
    }
    reduce(A, R) {
      let k = R;
      return this.steps.push((T) => (k = A(k, T), k)), this;
    }
    latch(A = (R, k) => R === k) {
      let R = !0, k;
      return this.steps.push((T) => {
        const z = R || !A(T, k);
        return R = !1, k = T, z ? T : _;
      }), this;
    }
    evaluate(A) {
      for (const R of this.steps)
        if (A = R(A), A === _)
          break;
      return A;
    }
  }
  function C(y, A, R = (k) => k) {
    const k = (...le) => X.fire(R(...le)), T = () => y.on(A, k), z = () => y.removeListener(A, k), X = new we({ onWillAddFirstListener: T, onDidRemoveLastListener: z });
    return X.event;
  }
  t.fromNodeEventEmitter = C;
  function x(y, A, R = (k) => k) {
    const k = (...le) => X.fire(R(...le)), T = () => y.addEventListener(A, k), z = () => y.removeEventListener(A, k), X = new we({ onWillAddFirstListener: T, onDidRemoveLastListener: z });
    return X.event;
  }
  t.fromDOMEventEmitter = x;
  function w(y) {
    return new Promise((A) => n(y)(A));
  }
  t.toPromise = w;
  function N(y) {
    const A = new we();
    return y.then((R) => {
      A.fire(R);
    }, () => {
      A.fire(void 0);
    }).finally(() => {
      A.dispose();
    }), A.event;
  }
  t.fromPromise = N;
  function B(y, A) {
    return y((R) => A.fire(R));
  }
  t.forward = B;
  function j(y, A, R) {
    return A(R), y((k) => A(k));
  }
  t.runAndSubscribe = j;
  class ue {
    constructor(A, R) {
      this._observable = A, this._counter = 0, this._hasChanged = !1;
      const k = {
        onWillAddFirstListener: () => {
          A.addObserver(this), this._observable.reportChanges();
        },
        onDidRemoveLastListener: () => {
          A.removeObserver(this);
        }
      };
      this.emitter = new we(k), R && R.add(this.emitter);
    }
    beginUpdate(A) {
      this._counter++;
    }
    handlePossibleChange(A) {
    }
    handleChange(A, R) {
      this._hasChanged = !0;
    }
    endUpdate(A) {
      this._counter--, this._counter === 0 && (this._observable.reportChanges(), this._hasChanged && (this._hasChanged = !1, this.emitter.fire(this._observable.get())));
    }
  }
  function G(y, A) {
    return new ue(y, A).emitter.event;
  }
  t.fromObservable = G;
  function U(y) {
    return (A, R, k) => {
      let T = 0, z = !1;
      const X = {
        beginUpdate() {
          T++;
        },
        endUpdate() {
          T--, T === 0 && (y.reportChanges(), z && (z = !1, A.call(R)));
        },
        handlePossibleChange() {
        },
        handleChange() {
          z = !0;
        }
      };
      y.addObserver(X), y.reportChanges();
      const le = {
        dispose() {
          y.removeObserver(X);
        }
      };
      return k instanceof Ut ? k.add(le) : Array.isArray(k) && k.push(le), le;
    };
  }
  t.fromObservableLight = U;
})(sn || (sn = {}));
class an {
  static {
    this.all = /* @__PURE__ */ new Set();
  }
  static {
    this._idPool = 0;
  }
  constructor(e) {
    this.listenerCount = 0, this.invocationCount = 0, this.elapsedOverall = 0, this.durations = [], this.name = `${e}_${an._idPool++}`, an.all.add(this);
  }
  start(e) {
    this._stopWatch = new Sn(), this.listenerCount = e;
  }
  stop() {
    if (this._stopWatch) {
      const e = this._stopWatch.elapsed();
      this.durations.push(e), this.elapsedOverall += e, this.invocationCount += 1, this._stopWatch = void 0;
    }
  }
}
let jo = -1;
class Bi {
  static {
    this._idPool = 1;
  }
  constructor(e, n, i = (Bi._idPool++).toString(16).padStart(3, "0")) {
    this._errorHandler = e, this.threshold = n, this.name = i, this._warnCountdown = 0;
  }
  dispose() {
    this._stacks?.clear();
  }
  check(e, n) {
    const i = this.threshold;
    if (i <= 0 || n < i)
      return;
    this._stacks || (this._stacks = /* @__PURE__ */ new Map());
    const r = this._stacks.get(e.value) || 0;
    if (this._stacks.set(e.value, r + 1), this._warnCountdown -= 1, this._warnCountdown <= 0) {
      this._warnCountdown = i * 0.5;
      const [s, a] = this.getMostFrequentStack(), o = `[${this.name}] potential listener LEAK detected, having ${n} listeners already. MOST frequent listener (${a}):`;
      console.warn(o), console.warn(s);
      const l = new Go(o, s);
      this._errorHandler(l);
    }
    return () => {
      const s = this._stacks.get(e.value) || 0;
      this._stacks.set(e.value, s - 1);
    };
  }
  getMostFrequentStack() {
    if (!this._stacks)
      return;
    let e, n = 0;
    for (const [i, r] of this._stacks)
      (!e || n < r) && (e = [i, r], n = r);
    return e;
  }
}
class Ii {
  static create() {
    const e = new Error();
    return new Ii(e.stack ?? "");
  }
  constructor(e) {
    this.value = e;
  }
  print() {
    console.warn(this.value.split(`
`).slice(2).join(`
`));
  }
}
class Go extends Error {
  constructor(e, n) {
    super(e), this.name = "ListenerLeakError", this.stack = n;
  }
}
class Xo extends Error {
  constructor(e, n) {
    super(e), this.name = "ListenerRefusalError", this.stack = n;
  }
}
class Bn {
  constructor(e) {
    this.value = e;
  }
}
const Jo = 2;
class we {
  constructor(e) {
    this._size = 0, this._options = e, this._leakageMon = this._options?.leakWarningThreshold ? new Bi(e?.onListenerError ?? yt, this._options?.leakWarningThreshold ?? jo) : void 0, this._perfMon = this._options?._profName ? new an(this._options._profName) : void 0, this._deliveryQueue = this._options?.deliveryQueue;
  }
  dispose() {
    this._disposed || (this._disposed = !0, this._deliveryQueue?.current === this && this._deliveryQueue.reset(), this._listeners && (this._listeners = void 0, this._size = 0), this._options?.onDidRemoveLastListener?.(), this._leakageMon?.dispose());
  }
  /**
   * For the public to allow to subscribe
   * to events from this Emitter
   */
  get event() {
    return this._event ??= (e, n, i) => {
      if (this._leakageMon && this._size > this._leakageMon.threshold ** 2) {
        const o = `[${this._leakageMon.name}] REFUSES to accept new listeners because it exceeded its threshold by far (${this._size} vs ${this._leakageMon.threshold})`;
        console.warn(o);
        const l = this._leakageMon.getMostFrequentStack() ?? ["UNKNOWN stack", -1], c = new Xo(`${o}. HINT: Stack shows most frequent listener (${l[1]}-times)`, l[0]);
        return (this._options?.onListenerError || yt)(c), rn.None;
      }
      if (this._disposed)
        return rn.None;
      n && (e = e.bind(n));
      const r = new Bn(e);
      let s;
      this._leakageMon && this._size >= Math.ceil(this._leakageMon.threshold * 0.2) && (r.stack = Ii.create(), s = this._leakageMon.check(r.stack, this._size + 1)), this._listeners ? this._listeners instanceof Bn ? (this._deliveryQueue ??= new Qo(), this._listeners = [this._listeners, r]) : this._listeners.push(r) : (this._options?.onWillAddFirstListener?.(this), this._listeners = r, this._options?.onDidAddFirstListener?.(this)), this._size++;
      const a = nn(() => {
        s?.(), this._removeListener(r);
      });
      return i instanceof Ut ? i.add(a) : Array.isArray(i) && i.push(a), a;
    }, this._event;
  }
  _removeListener(e) {
    if (this._options?.onWillRemoveListener?.(this), !this._listeners)
      return;
    if (this._size === 1) {
      this._listeners = void 0, this._options?.onDidRemoveLastListener?.(this), this._size = 0;
      return;
    }
    const n = this._listeners, i = n.indexOf(e);
    if (i === -1)
      throw console.log("disposed?", this._disposed), console.log("size?", this._size), console.log("arr?", JSON.stringify(this._listeners)), new Error("Attempted to dispose unknown listener");
    this._size--, n[i] = void 0;
    const r = this._deliveryQueue.current === this;
    if (this._size * Jo <= n.length) {
      let s = 0;
      for (let a = 0; a < n.length; a++)
        n[a] ? n[s++] = n[a] : r && (this._deliveryQueue.end--, s < this._deliveryQueue.i && this._deliveryQueue.i--);
      n.length = s;
    }
  }
  _deliver(e, n) {
    if (!e)
      return;
    const i = this._options?.onListenerError || yt;
    if (!i) {
      e.value(n);
      return;
    }
    try {
      e.value(n);
    } catch (r) {
      i(r);
    }
  }
  /** Delivers items in the queue. Assumes the queue is ready to go. */
  _deliverQueue(e) {
    const n = e.current._listeners;
    for (; e.i < e.end; )
      this._deliver(n[e.i++], e.value);
    e.reset();
  }
  /**
   * To be kept private to fire an event to
   * subscribers
   */
  fire(e) {
    if (this._deliveryQueue?.current && (this._deliverQueue(this._deliveryQueue), this._perfMon?.stop()), this._perfMon?.start(this._size), this._listeners) if (this._listeners instanceof Bn)
      this._deliver(this._listeners, e);
    else {
      const n = this._deliveryQueue;
      n.enqueue(this, e, this._listeners.length), this._deliverQueue(n);
    }
    this._perfMon?.stop();
  }
  hasListeners() {
    return this._size > 0;
  }
}
class Qo {
  constructor() {
    this.i = -1, this.end = 0;
  }
  enqueue(e, n, i) {
    this.i = 0, this.end = i, this.current = e, this.value = n;
  }
  reset() {
    this.i = this.end, this.current = void 0, this.value = void 0;
  }
}
function Yo() {
  return globalThis._VSCODE_NLS_MESSAGES;
}
function Ga() {
  return globalThis._VSCODE_NLS_LANGUAGE;
}
const Zo = Ga() === "pseudo" || typeof document < "u" && document.location && document.location.hash.indexOf("pseudo=true") >= 0;
function ji(t, e) {
  let n;
  return e.length === 0 ? n = t : n = t.replace(/\{(\d+)\}/g, (i, r) => {
    const s = r[0], a = e[s];
    let o = i;
    return typeof a == "string" ? o = a : (typeof a == "number" || typeof a == "boolean" || a === void 0 || a === null) && (o = String(a)), o;
  }), Zo && (n = "［" + n.replace(/[aouei]/g, "$&$&") + "］"), n;
}
function Z(t, e, ...n) {
  return ji(typeof t == "number" ? Ko(t, e) : e, n);
}
function Ko(t, e) {
  const n = Yo()?.[t];
  if (typeof n != "string") {
    if (typeof e == "string")
      return e;
    throw new Error(`!!! NLS MISSING: ${t} !!!`);
  }
  return n;
}
const ft = "en";
let Gn = !1, Xn = !1, In = !1, Xa = !1, Ri = !1, zt, Rn = ft, Gi = ft, eu, Me;
const Pe = globalThis;
let Ee;
typeof Pe.vscode < "u" && typeof Pe.vscode.process < "u" ? Ee = Pe.vscode.process : typeof process < "u" && typeof process?.versions?.node == "string" && (Ee = process);
const tu = typeof Ee?.versions?.electron == "string", nu = tu && Ee?.type === "renderer";
if (typeof Ee == "object") {
  Gn = Ee.platform === "win32", Xn = Ee.platform === "darwin", In = Ee.platform === "linux", In && Ee.env.SNAP && Ee.env.SNAP_REVISION, Ee.env.CI || Ee.env.BUILD_ARTIFACTSTAGINGDIRECTORY, zt = ft, Rn = ft;
  const t = Ee.env.VSCODE_NLS_CONFIG;
  if (t)
    try {
      const e = JSON.parse(t);
      zt = e.userLocale, Gi = e.osLocale, Rn = e.resolvedLanguage || ft, eu = e.languagePack?.translationsConfigFile;
    } catch {
    }
  Xa = !0;
} else typeof navigator == "object" && !nu ? (Me = navigator.userAgent, Gn = Me.indexOf("Windows") >= 0, Xn = Me.indexOf("Macintosh") >= 0, (Me.indexOf("Macintosh") >= 0 || Me.indexOf("iPad") >= 0 || Me.indexOf("iPhone") >= 0) && navigator.maxTouchPoints && navigator.maxTouchPoints > 0, In = Me.indexOf("Linux") >= 0, Me?.indexOf("Mobi") >= 0, Ri = !0, Rn = Ga() || ft, zt = navigator.language.toLowerCase(), Gi = zt) : console.error("Unable to resolve platform.");
const Bt = Gn, iu = Xn, ru = Xa, su = Ri, au = Ri && typeof Pe.importScripts == "function", ou = au ? Pe.origin : void 0, Re = Me, uu = typeof Pe.postMessage == "function" && !Pe.importScripts;
(() => {
  if (uu) {
    const t = [];
    Pe.addEventListener("message", (n) => {
      if (n.data && n.data.vscodeScheduleAsyncWork)
        for (let i = 0, r = t.length; i < r; i++) {
          const s = t[i];
          if (s.id === n.data.vscodeScheduleAsyncWork) {
            t.splice(i, 1), s.callback();
            return;
          }
        }
    });
    let e = 0;
    return (n) => {
      const i = ++e;
      t.push({
        id: i,
        callback: n
      }), Pe.postMessage({ vscodeScheduleAsyncWork: i }, "*");
    };
  }
  return (t) => setTimeout(t);
})();
const lu = !!(Re && Re.indexOf("Chrome") >= 0);
Re && Re.indexOf("Firefox") >= 0;
!lu && Re && Re.indexOf("Safari") >= 0;
Re && Re.indexOf("Edg/") >= 0;
Re && Re.indexOf("Android") >= 0;
function cu(t) {
  return t;
}
class hu {
  constructor(e, n) {
    this.lastCache = void 0, this.lastArgKey = void 0, typeof e == "function" ? (this._fn = e, this._computeKey = cu) : (this._fn = n, this._computeKey = e.getCacheKey);
  }
  get(e) {
    const n = this._computeKey(e);
    return this.lastArgKey !== n && (this.lastArgKey = n, this.lastCache = this._fn(e)), this.lastCache;
  }
}
class Xi {
  constructor(e) {
    this.executor = e, this._didRun = !1;
  }
  /**
   * Get the wrapped value.
   *
   * This will force evaluation of the lazy value if it has not been resolved yet. Lazy values are only
   * resolved once. `getValue` will re-throw exceptions that are hit while resolving the value
   */
  get value() {
    if (!this._didRun)
      try {
        this._value = this.executor();
      } catch (e) {
        this._error = e;
      } finally {
        this._didRun = !0;
      }
    if (this._error)
      throw this._error;
    return this._value;
  }
  /**
   * Get the wrapped value without forcing evaluation.
   */
  get rawValue() {
    return this._value;
  }
}
function du(t) {
  return t.replace(/[\\\{\}\*\+\?\|\^\$\.\[\]\(\)]/g, "\\$&");
}
function fu(t) {
  return t.split(/\r\n|\r|\n/);
}
function mu(t) {
  for (let e = 0, n = t.length; e < n; e++) {
    const i = t.charCodeAt(e);
    if (i !== 32 && i !== 9)
      return e;
  }
  return -1;
}
function gu(t, e = t.length - 1) {
  for (let n = e; n >= 0; n--) {
    const i = t.charCodeAt(n);
    if (i !== 32 && i !== 9)
      return n;
  }
  return -1;
}
function Ja(t) {
  return t >= 65 && t <= 90;
}
function on(t) {
  return 55296 <= t && t <= 56319;
}
function Jn(t) {
  return 56320 <= t && t <= 57343;
}
function Qa(t, e) {
  return (t - 55296 << 10) + (e - 56320) + 65536;
}
function pu(t, e, n) {
  const i = t.charCodeAt(n);
  if (on(i) && n + 1 < e) {
    const r = t.charCodeAt(n + 1);
    if (Jn(r))
      return Qa(i, r);
  }
  return i;
}
const bu = /^[\t\n\r\x20-\x7E]*$/;
function Du(t) {
  return bu.test(t);
}
class Xe {
  static {
    this.ambiguousCharacterData = new Xi(() => JSON.parse('{"_common":[8232,32,8233,32,5760,32,8192,32,8193,32,8194,32,8195,32,8196,32,8197,32,8198,32,8200,32,8201,32,8202,32,8287,32,8199,32,8239,32,2042,95,65101,95,65102,95,65103,95,8208,45,8209,45,8210,45,65112,45,1748,45,8259,45,727,45,8722,45,10134,45,11450,45,1549,44,1643,44,8218,44,184,44,42233,44,894,59,2307,58,2691,58,1417,58,1795,58,1796,58,5868,58,65072,58,6147,58,6153,58,8282,58,1475,58,760,58,42889,58,8758,58,720,58,42237,58,451,33,11601,33,660,63,577,63,2429,63,5038,63,42731,63,119149,46,8228,46,1793,46,1794,46,42510,46,68176,46,1632,46,1776,46,42232,46,1373,96,65287,96,8219,96,8242,96,1370,96,1523,96,8175,96,65344,96,900,96,8189,96,8125,96,8127,96,8190,96,697,96,884,96,712,96,714,96,715,96,756,96,699,96,701,96,700,96,702,96,42892,96,1497,96,2036,96,2037,96,5194,96,5836,96,94033,96,94034,96,65339,91,10088,40,10098,40,12308,40,64830,40,65341,93,10089,41,10099,41,12309,41,64831,41,10100,123,119060,123,10101,125,65342,94,8270,42,1645,42,8727,42,66335,42,5941,47,8257,47,8725,47,8260,47,9585,47,10187,47,10744,47,119354,47,12755,47,12339,47,11462,47,20031,47,12035,47,65340,92,65128,92,8726,92,10189,92,10741,92,10745,92,119311,92,119355,92,12756,92,20022,92,12034,92,42872,38,708,94,710,94,5869,43,10133,43,66203,43,8249,60,10094,60,706,60,119350,60,5176,60,5810,60,5120,61,11840,61,12448,61,42239,61,8250,62,10095,62,707,62,119351,62,5171,62,94015,62,8275,126,732,126,8128,126,8764,126,65372,124,65293,45,120784,50,120794,50,120804,50,120814,50,120824,50,130034,50,42842,50,423,50,1000,50,42564,50,5311,50,42735,50,119302,51,120785,51,120795,51,120805,51,120815,51,120825,51,130035,51,42923,51,540,51,439,51,42858,51,11468,51,1248,51,94011,51,71882,51,120786,52,120796,52,120806,52,120816,52,120826,52,130036,52,5070,52,71855,52,120787,53,120797,53,120807,53,120817,53,120827,53,130037,53,444,53,71867,53,120788,54,120798,54,120808,54,120818,54,120828,54,130038,54,11474,54,5102,54,71893,54,119314,55,120789,55,120799,55,120809,55,120819,55,120829,55,130039,55,66770,55,71878,55,2819,56,2538,56,2666,56,125131,56,120790,56,120800,56,120810,56,120820,56,120830,56,130040,56,547,56,546,56,66330,56,2663,57,2920,57,2541,57,3437,57,120791,57,120801,57,120811,57,120821,57,120831,57,130041,57,42862,57,11466,57,71884,57,71852,57,71894,57,9082,97,65345,97,119834,97,119886,97,119938,97,119990,97,120042,97,120094,97,120146,97,120198,97,120250,97,120302,97,120354,97,120406,97,120458,97,593,97,945,97,120514,97,120572,97,120630,97,120688,97,120746,97,65313,65,119808,65,119860,65,119912,65,119964,65,120016,65,120068,65,120120,65,120172,65,120224,65,120276,65,120328,65,120380,65,120432,65,913,65,120488,65,120546,65,120604,65,120662,65,120720,65,5034,65,5573,65,42222,65,94016,65,66208,65,119835,98,119887,98,119939,98,119991,98,120043,98,120095,98,120147,98,120199,98,120251,98,120303,98,120355,98,120407,98,120459,98,388,98,5071,98,5234,98,5551,98,65314,66,8492,66,119809,66,119861,66,119913,66,120017,66,120069,66,120121,66,120173,66,120225,66,120277,66,120329,66,120381,66,120433,66,42932,66,914,66,120489,66,120547,66,120605,66,120663,66,120721,66,5108,66,5623,66,42192,66,66178,66,66209,66,66305,66,65347,99,8573,99,119836,99,119888,99,119940,99,119992,99,120044,99,120096,99,120148,99,120200,99,120252,99,120304,99,120356,99,120408,99,120460,99,7428,99,1010,99,11429,99,43951,99,66621,99,128844,67,71922,67,71913,67,65315,67,8557,67,8450,67,8493,67,119810,67,119862,67,119914,67,119966,67,120018,67,120174,67,120226,67,120278,67,120330,67,120382,67,120434,67,1017,67,11428,67,5087,67,42202,67,66210,67,66306,67,66581,67,66844,67,8574,100,8518,100,119837,100,119889,100,119941,100,119993,100,120045,100,120097,100,120149,100,120201,100,120253,100,120305,100,120357,100,120409,100,120461,100,1281,100,5095,100,5231,100,42194,100,8558,68,8517,68,119811,68,119863,68,119915,68,119967,68,120019,68,120071,68,120123,68,120175,68,120227,68,120279,68,120331,68,120383,68,120435,68,5024,68,5598,68,5610,68,42195,68,8494,101,65349,101,8495,101,8519,101,119838,101,119890,101,119942,101,120046,101,120098,101,120150,101,120202,101,120254,101,120306,101,120358,101,120410,101,120462,101,43826,101,1213,101,8959,69,65317,69,8496,69,119812,69,119864,69,119916,69,120020,69,120072,69,120124,69,120176,69,120228,69,120280,69,120332,69,120384,69,120436,69,917,69,120492,69,120550,69,120608,69,120666,69,120724,69,11577,69,5036,69,42224,69,71846,69,71854,69,66182,69,119839,102,119891,102,119943,102,119995,102,120047,102,120099,102,120151,102,120203,102,120255,102,120307,102,120359,102,120411,102,120463,102,43829,102,42905,102,383,102,7837,102,1412,102,119315,70,8497,70,119813,70,119865,70,119917,70,120021,70,120073,70,120125,70,120177,70,120229,70,120281,70,120333,70,120385,70,120437,70,42904,70,988,70,120778,70,5556,70,42205,70,71874,70,71842,70,66183,70,66213,70,66853,70,65351,103,8458,103,119840,103,119892,103,119944,103,120048,103,120100,103,120152,103,120204,103,120256,103,120308,103,120360,103,120412,103,120464,103,609,103,7555,103,397,103,1409,103,119814,71,119866,71,119918,71,119970,71,120022,71,120074,71,120126,71,120178,71,120230,71,120282,71,120334,71,120386,71,120438,71,1292,71,5056,71,5107,71,42198,71,65352,104,8462,104,119841,104,119945,104,119997,104,120049,104,120101,104,120153,104,120205,104,120257,104,120309,104,120361,104,120413,104,120465,104,1211,104,1392,104,5058,104,65320,72,8459,72,8460,72,8461,72,119815,72,119867,72,119919,72,120023,72,120179,72,120231,72,120283,72,120335,72,120387,72,120439,72,919,72,120494,72,120552,72,120610,72,120668,72,120726,72,11406,72,5051,72,5500,72,42215,72,66255,72,731,105,9075,105,65353,105,8560,105,8505,105,8520,105,119842,105,119894,105,119946,105,119998,105,120050,105,120102,105,120154,105,120206,105,120258,105,120310,105,120362,105,120414,105,120466,105,120484,105,618,105,617,105,953,105,8126,105,890,105,120522,105,120580,105,120638,105,120696,105,120754,105,1110,105,42567,105,1231,105,43893,105,5029,105,71875,105,65354,106,8521,106,119843,106,119895,106,119947,106,119999,106,120051,106,120103,106,120155,106,120207,106,120259,106,120311,106,120363,106,120415,106,120467,106,1011,106,1112,106,65322,74,119817,74,119869,74,119921,74,119973,74,120025,74,120077,74,120129,74,120181,74,120233,74,120285,74,120337,74,120389,74,120441,74,42930,74,895,74,1032,74,5035,74,5261,74,42201,74,119844,107,119896,107,119948,107,120000,107,120052,107,120104,107,120156,107,120208,107,120260,107,120312,107,120364,107,120416,107,120468,107,8490,75,65323,75,119818,75,119870,75,119922,75,119974,75,120026,75,120078,75,120130,75,120182,75,120234,75,120286,75,120338,75,120390,75,120442,75,922,75,120497,75,120555,75,120613,75,120671,75,120729,75,11412,75,5094,75,5845,75,42199,75,66840,75,1472,108,8739,73,9213,73,65512,73,1633,108,1777,73,66336,108,125127,108,120783,73,120793,73,120803,73,120813,73,120823,73,130033,73,65321,73,8544,73,8464,73,8465,73,119816,73,119868,73,119920,73,120024,73,120128,73,120180,73,120232,73,120284,73,120336,73,120388,73,120440,73,65356,108,8572,73,8467,108,119845,108,119897,108,119949,108,120001,108,120053,108,120105,73,120157,73,120209,73,120261,73,120313,73,120365,73,120417,73,120469,73,448,73,120496,73,120554,73,120612,73,120670,73,120728,73,11410,73,1030,73,1216,73,1493,108,1503,108,1575,108,126464,108,126592,108,65166,108,65165,108,1994,108,11599,73,5825,73,42226,73,93992,73,66186,124,66313,124,119338,76,8556,76,8466,76,119819,76,119871,76,119923,76,120027,76,120079,76,120131,76,120183,76,120235,76,120287,76,120339,76,120391,76,120443,76,11472,76,5086,76,5290,76,42209,76,93974,76,71843,76,71858,76,66587,76,66854,76,65325,77,8559,77,8499,77,119820,77,119872,77,119924,77,120028,77,120080,77,120132,77,120184,77,120236,77,120288,77,120340,77,120392,77,120444,77,924,77,120499,77,120557,77,120615,77,120673,77,120731,77,1018,77,11416,77,5047,77,5616,77,5846,77,42207,77,66224,77,66321,77,119847,110,119899,110,119951,110,120003,110,120055,110,120107,110,120159,110,120211,110,120263,110,120315,110,120367,110,120419,110,120471,110,1400,110,1404,110,65326,78,8469,78,119821,78,119873,78,119925,78,119977,78,120029,78,120081,78,120185,78,120237,78,120289,78,120341,78,120393,78,120445,78,925,78,120500,78,120558,78,120616,78,120674,78,120732,78,11418,78,42208,78,66835,78,3074,111,3202,111,3330,111,3458,111,2406,111,2662,111,2790,111,3046,111,3174,111,3302,111,3430,111,3664,111,3792,111,4160,111,1637,111,1781,111,65359,111,8500,111,119848,111,119900,111,119952,111,120056,111,120108,111,120160,111,120212,111,120264,111,120316,111,120368,111,120420,111,120472,111,7439,111,7441,111,43837,111,959,111,120528,111,120586,111,120644,111,120702,111,120760,111,963,111,120532,111,120590,111,120648,111,120706,111,120764,111,11423,111,4351,111,1413,111,1505,111,1607,111,126500,111,126564,111,126596,111,65259,111,65260,111,65258,111,65257,111,1726,111,64428,111,64429,111,64427,111,64426,111,1729,111,64424,111,64425,111,64423,111,64422,111,1749,111,3360,111,4125,111,66794,111,71880,111,71895,111,66604,111,1984,79,2534,79,2918,79,12295,79,70864,79,71904,79,120782,79,120792,79,120802,79,120812,79,120822,79,130032,79,65327,79,119822,79,119874,79,119926,79,119978,79,120030,79,120082,79,120134,79,120186,79,120238,79,120290,79,120342,79,120394,79,120446,79,927,79,120502,79,120560,79,120618,79,120676,79,120734,79,11422,79,1365,79,11604,79,4816,79,2848,79,66754,79,42227,79,71861,79,66194,79,66219,79,66564,79,66838,79,9076,112,65360,112,119849,112,119901,112,119953,112,120005,112,120057,112,120109,112,120161,112,120213,112,120265,112,120317,112,120369,112,120421,112,120473,112,961,112,120530,112,120544,112,120588,112,120602,112,120646,112,120660,112,120704,112,120718,112,120762,112,120776,112,11427,112,65328,80,8473,80,119823,80,119875,80,119927,80,119979,80,120031,80,120083,80,120187,80,120239,80,120291,80,120343,80,120395,80,120447,80,929,80,120504,80,120562,80,120620,80,120678,80,120736,80,11426,80,5090,80,5229,80,42193,80,66197,80,119850,113,119902,113,119954,113,120006,113,120058,113,120110,113,120162,113,120214,113,120266,113,120318,113,120370,113,120422,113,120474,113,1307,113,1379,113,1382,113,8474,81,119824,81,119876,81,119928,81,119980,81,120032,81,120084,81,120188,81,120240,81,120292,81,120344,81,120396,81,120448,81,11605,81,119851,114,119903,114,119955,114,120007,114,120059,114,120111,114,120163,114,120215,114,120267,114,120319,114,120371,114,120423,114,120475,114,43847,114,43848,114,7462,114,11397,114,43905,114,119318,82,8475,82,8476,82,8477,82,119825,82,119877,82,119929,82,120033,82,120189,82,120241,82,120293,82,120345,82,120397,82,120449,82,422,82,5025,82,5074,82,66740,82,5511,82,42211,82,94005,82,65363,115,119852,115,119904,115,119956,115,120008,115,120060,115,120112,115,120164,115,120216,115,120268,115,120320,115,120372,115,120424,115,120476,115,42801,115,445,115,1109,115,43946,115,71873,115,66632,115,65331,83,119826,83,119878,83,119930,83,119982,83,120034,83,120086,83,120138,83,120190,83,120242,83,120294,83,120346,83,120398,83,120450,83,1029,83,1359,83,5077,83,5082,83,42210,83,94010,83,66198,83,66592,83,119853,116,119905,116,119957,116,120009,116,120061,116,120113,116,120165,116,120217,116,120269,116,120321,116,120373,116,120425,116,120477,116,8868,84,10201,84,128872,84,65332,84,119827,84,119879,84,119931,84,119983,84,120035,84,120087,84,120139,84,120191,84,120243,84,120295,84,120347,84,120399,84,120451,84,932,84,120507,84,120565,84,120623,84,120681,84,120739,84,11430,84,5026,84,42196,84,93962,84,71868,84,66199,84,66225,84,66325,84,119854,117,119906,117,119958,117,120010,117,120062,117,120114,117,120166,117,120218,117,120270,117,120322,117,120374,117,120426,117,120478,117,42911,117,7452,117,43854,117,43858,117,651,117,965,117,120534,117,120592,117,120650,117,120708,117,120766,117,1405,117,66806,117,71896,117,8746,85,8899,85,119828,85,119880,85,119932,85,119984,85,120036,85,120088,85,120140,85,120192,85,120244,85,120296,85,120348,85,120400,85,120452,85,1357,85,4608,85,66766,85,5196,85,42228,85,94018,85,71864,85,8744,118,8897,118,65366,118,8564,118,119855,118,119907,118,119959,118,120011,118,120063,118,120115,118,120167,118,120219,118,120271,118,120323,118,120375,118,120427,118,120479,118,7456,118,957,118,120526,118,120584,118,120642,118,120700,118,120758,118,1141,118,1496,118,71430,118,43945,118,71872,118,119309,86,1639,86,1783,86,8548,86,119829,86,119881,86,119933,86,119985,86,120037,86,120089,86,120141,86,120193,86,120245,86,120297,86,120349,86,120401,86,120453,86,1140,86,11576,86,5081,86,5167,86,42719,86,42214,86,93960,86,71840,86,66845,86,623,119,119856,119,119908,119,119960,119,120012,119,120064,119,120116,119,120168,119,120220,119,120272,119,120324,119,120376,119,120428,119,120480,119,7457,119,1121,119,1309,119,1377,119,71434,119,71438,119,71439,119,43907,119,71919,87,71910,87,119830,87,119882,87,119934,87,119986,87,120038,87,120090,87,120142,87,120194,87,120246,87,120298,87,120350,87,120402,87,120454,87,1308,87,5043,87,5076,87,42218,87,5742,120,10539,120,10540,120,10799,120,65368,120,8569,120,119857,120,119909,120,119961,120,120013,120,120065,120,120117,120,120169,120,120221,120,120273,120,120325,120,120377,120,120429,120,120481,120,5441,120,5501,120,5741,88,9587,88,66338,88,71916,88,65336,88,8553,88,119831,88,119883,88,119935,88,119987,88,120039,88,120091,88,120143,88,120195,88,120247,88,120299,88,120351,88,120403,88,120455,88,42931,88,935,88,120510,88,120568,88,120626,88,120684,88,120742,88,11436,88,11613,88,5815,88,42219,88,66192,88,66228,88,66327,88,66855,88,611,121,7564,121,65369,121,119858,121,119910,121,119962,121,120014,121,120066,121,120118,121,120170,121,120222,121,120274,121,120326,121,120378,121,120430,121,120482,121,655,121,7935,121,43866,121,947,121,8509,121,120516,121,120574,121,120632,121,120690,121,120748,121,1199,121,4327,121,71900,121,65337,89,119832,89,119884,89,119936,89,119988,89,120040,89,120092,89,120144,89,120196,89,120248,89,120300,89,120352,89,120404,89,120456,89,933,89,978,89,120508,89,120566,89,120624,89,120682,89,120740,89,11432,89,1198,89,5033,89,5053,89,42220,89,94019,89,71844,89,66226,89,119859,122,119911,122,119963,122,120015,122,120067,122,120119,122,120171,122,120223,122,120275,122,120327,122,120379,122,120431,122,120483,122,7458,122,43923,122,71876,122,66293,90,71909,90,65338,90,8484,90,8488,90,119833,90,119885,90,119937,90,119989,90,120041,90,120197,90,120249,90,120301,90,120353,90,120405,90,120457,90,918,90,120493,90,120551,90,120609,90,120667,90,120725,90,5059,90,42204,90,71849,90,65282,34,65284,36,65285,37,65286,38,65290,42,65291,43,65294,46,65295,47,65296,48,65297,49,65298,50,65299,51,65300,52,65301,53,65302,54,65303,55,65304,56,65305,57,65308,60,65309,61,65310,62,65312,64,65316,68,65318,70,65319,71,65324,76,65329,81,65330,82,65333,85,65334,86,65335,87,65343,95,65346,98,65348,100,65350,102,65355,107,65357,109,65358,110,65361,113,65362,114,65364,116,65365,117,65367,119,65370,122,65371,123,65373,125,119846,109],"_default":[160,32,8211,45,65374,126,65306,58,65281,33,8216,96,8217,96,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65283,35,65288,40,65289,41,65292,44,65307,59,65311,63],"cs":[65374,126,65306,58,65281,33,8216,96,8217,96,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,1093,120,1061,88,1091,121,1059,89,65283,35,65288,40,65289,41,65292,44,65307,59,65311,63],"de":[65374,126,65306,58,65281,33,8216,96,8217,96,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,1093,120,1061,88,1091,121,1059,89,65283,35,65288,40,65289,41,65292,44,65307,59,65311,63],"es":[8211,45,65374,126,65306,58,65281,33,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65283,35,65288,40,65289,41,65292,44,65307,59,65311,63],"fr":[65374,126,65306,58,65281,33,8216,96,8245,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65283,35,65288,40,65289,41,65292,44,65307,59,65311,63],"it":[160,32,8211,45,65374,126,65306,58,65281,33,8216,96,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65283,35,65288,40,65289,41,65292,44,65307,59,65311,63],"ja":[8211,45,65306,58,65281,33,8216,96,8217,96,8245,96,180,96,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65283,35,65292,44,65307,59],"ko":[8211,45,65374,126,65306,58,65281,33,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65283,35,65288,40,65289,41,65292,44,65307,59,65311,63],"pl":[65374,126,65306,58,65281,33,8216,96,8217,96,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65283,35,65288,40,65289,41,65292,44,65307,59,65311,63],"pt-BR":[65374,126,65306,58,65281,33,8216,96,8217,96,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65283,35,65288,40,65289,41,65292,44,65307,59,65311,63],"qps-ploc":[160,32,8211,45,65374,126,65306,58,65281,33,8216,96,8217,96,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65283,35,65288,40,65289,41,65292,44,65307,59,65311,63],"ru":[65374,126,65306,58,65281,33,8216,96,8217,96,8245,96,180,96,12494,47,305,105,921,73,1009,112,215,120,65283,35,65288,40,65289,41,65292,44,65307,59,65311,63],"tr":[160,32,8211,45,65374,126,65306,58,65281,33,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65283,35,65288,40,65289,41,65292,44,65307,59,65311,63],"zh-hans":[65374,126,65306,58,65281,33,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65288,40,65289,41],"zh-hant":[8211,45,65374,126,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65283,35,65307,59]}'));
  }
  static {
    this.cache = new hu({ getCacheKey: JSON.stringify }, (e) => {
      function n(d) {
        const h = /* @__PURE__ */ new Map();
        for (let f = 0; f < d.length; f += 2)
          h.set(d[f], d[f + 1]);
        return h;
      }
      function i(d, h) {
        const f = new Map(d);
        for (const [m, b] of h)
          f.set(m, b);
        return f;
      }
      function r(d, h) {
        if (!d)
          return h;
        const f = /* @__PURE__ */ new Map();
        for (const [m, b] of d)
          h.has(m) && f.set(m, b);
        return f;
      }
      const s = this.ambiguousCharacterData.value;
      let a = e.filter((d) => !d.startsWith("_") && d in s);
      a.length === 0 && (a = ["_default"]);
      let o;
      for (const d of a) {
        const h = n(s[d]);
        o = r(o, h);
      }
      const l = n(s._common), c = i(l, o);
      return new Xe(c);
    });
  }
  static getInstance(e) {
    return Xe.cache.get(Array.from(e));
  }
  static {
    this._locales = new Xi(() => Object.keys(Xe.ambiguousCharacterData.value).filter((e) => !e.startsWith("_")));
  }
  static getLocales() {
    return Xe._locales.value;
  }
  constructor(e) {
    this.confusableDictionary = e;
  }
  isAmbiguous(e) {
    return this.confusableDictionary.has(e);
  }
  /**
   * Returns the non basic ASCII code point that the given code point can be confused,
   * or undefined if such code point does note exist.
   */
  getPrimaryConfusable(e) {
    return this.confusableDictionary.get(e);
  }
  getConfusableCodePoints() {
    return new Set(this.confusableDictionary.keys());
  }
}
class et {
  static getRawData() {
    return JSON.parse("[9,10,11,12,13,32,127,160,173,847,1564,4447,4448,6068,6069,6155,6156,6157,6158,7355,7356,8192,8193,8194,8195,8196,8197,8198,8199,8200,8201,8202,8203,8204,8205,8206,8207,8234,8235,8236,8237,8238,8239,8287,8288,8289,8290,8291,8292,8293,8294,8295,8296,8297,8298,8299,8300,8301,8302,8303,10240,12288,12644,65024,65025,65026,65027,65028,65029,65030,65031,65032,65033,65034,65035,65036,65037,65038,65039,65279,65440,65520,65521,65522,65523,65524,65525,65526,65527,65528,65532,78844,119155,119156,119157,119158,119159,119160,119161,119162,917504,917505,917506,917507,917508,917509,917510,917511,917512,917513,917514,917515,917516,917517,917518,917519,917520,917521,917522,917523,917524,917525,917526,917527,917528,917529,917530,917531,917532,917533,917534,917535,917536,917537,917538,917539,917540,917541,917542,917543,917544,917545,917546,917547,917548,917549,917550,917551,917552,917553,917554,917555,917556,917557,917558,917559,917560,917561,917562,917563,917564,917565,917566,917567,917568,917569,917570,917571,917572,917573,917574,917575,917576,917577,917578,917579,917580,917581,917582,917583,917584,917585,917586,917587,917588,917589,917590,917591,917592,917593,917594,917595,917596,917597,917598,917599,917600,917601,917602,917603,917604,917605,917606,917607,917608,917609,917610,917611,917612,917613,917614,917615,917616,917617,917618,917619,917620,917621,917622,917623,917624,917625,917626,917627,917628,917629,917630,917631,917760,917761,917762,917763,917764,917765,917766,917767,917768,917769,917770,917771,917772,917773,917774,917775,917776,917777,917778,917779,917780,917781,917782,917783,917784,917785,917786,917787,917788,917789,917790,917791,917792,917793,917794,917795,917796,917797,917798,917799,917800,917801,917802,917803,917804,917805,917806,917807,917808,917809,917810,917811,917812,917813,917814,917815,917816,917817,917818,917819,917820,917821,917822,917823,917824,917825,917826,917827,917828,917829,917830,917831,917832,917833,917834,917835,917836,917837,917838,917839,917840,917841,917842,917843,917844,917845,917846,917847,917848,917849,917850,917851,917852,917853,917854,917855,917856,917857,917858,917859,917860,917861,917862,917863,917864,917865,917866,917867,917868,917869,917870,917871,917872,917873,917874,917875,917876,917877,917878,917879,917880,917881,917882,917883,917884,917885,917886,917887,917888,917889,917890,917891,917892,917893,917894,917895,917896,917897,917898,917899,917900,917901,917902,917903,917904,917905,917906,917907,917908,917909,917910,917911,917912,917913,917914,917915,917916,917917,917918,917919,917920,917921,917922,917923,917924,917925,917926,917927,917928,917929,917930,917931,917932,917933,917934,917935,917936,917937,917938,917939,917940,917941,917942,917943,917944,917945,917946,917947,917948,917949,917950,917951,917952,917953,917954,917955,917956,917957,917958,917959,917960,917961,917962,917963,917964,917965,917966,917967,917968,917969,917970,917971,917972,917973,917974,917975,917976,917977,917978,917979,917980,917981,917982,917983,917984,917985,917986,917987,917988,917989,917990,917991,917992,917993,917994,917995,917996,917997,917998,917999]");
  }
  static {
    this._data = void 0;
  }
  static getData() {
    return this._data || (this._data = new Set(et.getRawData())), this._data;
  }
  static isInvisibleCharacter(e) {
    return et.getData().has(e);
  }
  static get codePoints() {
    return et.getData();
  }
}
let gt;
const Mn = globalThis.vscode;
if (typeof Mn < "u" && typeof Mn.process < "u") {
  const t = Mn.process;
  gt = {
    get platform() {
      return t.platform;
    },
    get arch() {
      return t.arch;
    },
    get env() {
      return t.env;
    },
    cwd() {
      return t.cwd();
    }
  };
} else typeof process < "u" && typeof process?.versions?.node == "string" ? gt = {
  get platform() {
    return process.platform;
  },
  get arch() {
    return process.arch;
  },
  get env() {
    return process.env;
  },
  cwd() {
    return process.env.VSCODE_CWD || process.cwd();
  }
} : gt = {
  // Supported
  get platform() {
    return Bt ? "win32" : iu ? "darwin" : "linux";
  },
  get arch() {
  },
  // Unsupported
  get env() {
    return {};
  },
  cwd() {
    return "/";
  }
};
const un = gt.cwd, xu = gt.env, Cu = gt.platform, Eu = 65, Au = 97, wu = 90, Lu = 122, Qe = 46, he = 47, De = 92, ze = 58, vu = 63;
class Ya extends Error {
  constructor(e, n, i) {
    let r;
    typeof n == "string" && n.indexOf("not ") === 0 ? (r = "must not be", n = n.replace(/^not /, "")) : r = "must be";
    const s = e.indexOf(".") !== -1 ? "property" : "argument";
    let a = `The "${e}" ${s} ${r} of type ${n}`;
    a += `. Received type ${typeof i}`, super(a), this.code = "ERR_INVALID_ARG_TYPE";
  }
}
function _u(t, e) {
  if (t === null || typeof t != "object")
    throw new Ya(e, "Object", t);
}
function te(t, e) {
  if (typeof t != "string")
    throw new Ya(e, "string", t);
}
const Ve = Cu === "win32";
function q(t) {
  return t === he || t === De;
}
function Qn(t) {
  return t === he;
}
function We(t) {
  return t >= Eu && t <= wu || t >= Au && t <= Lu;
}
function ln(t, e, n, i) {
  let r = "", s = 0, a = -1, o = 0, l = 0;
  for (let c = 0; c <= t.length; ++c) {
    if (c < t.length)
      l = t.charCodeAt(c);
    else {
      if (i(l))
        break;
      l = he;
    }
    if (i(l)) {
      if (!(a === c - 1 || o === 1)) if (o === 2) {
        if (r.length < 2 || s !== 2 || r.charCodeAt(r.length - 1) !== Qe || r.charCodeAt(r.length - 2) !== Qe) {
          if (r.length > 2) {
            const d = r.lastIndexOf(n);
            d === -1 ? (r = "", s = 0) : (r = r.slice(0, d), s = r.length - 1 - r.lastIndexOf(n)), a = c, o = 0;
            continue;
          } else if (r.length !== 0) {
            r = "", s = 0, a = c, o = 0;
            continue;
          }
        }
        e && (r += r.length > 0 ? `${n}..` : "..", s = 2);
      } else
        r.length > 0 ? r += `${n}${t.slice(a + 1, c)}` : r = t.slice(a + 1, c), s = c - a - 1;
      a = c, o = 0;
    } else l === Qe && o !== -1 ? ++o : o = -1;
  }
  return r;
}
function Fu(t) {
  return t ? `${t[0] === "." ? "" : "."}${t}` : "";
}
function Za(t, e) {
  _u(e, "pathObject");
  const n = e.dir || e.root, i = e.base || `${e.name || ""}${Fu(e.ext)}`;
  return n ? n === e.root ? `${n}${i}` : `${n}${t}${i}` : i;
}
const pe = {
  // path.resolve([from ...], to)
  resolve(...t) {
    let e = "", n = "", i = !1;
    for (let r = t.length - 1; r >= -1; r--) {
      let s;
      if (r >= 0) {
        if (s = t[r], te(s, `paths[${r}]`), s.length === 0)
          continue;
      } else e.length === 0 ? s = un() : (s = xu[`=${e}`] || un(), (s === void 0 || s.slice(0, 2).toLowerCase() !== e.toLowerCase() && s.charCodeAt(2) === De) && (s = `${e}\\`));
      const a = s.length;
      let o = 0, l = "", c = !1;
      const d = s.charCodeAt(0);
      if (a === 1)
        q(d) && (o = 1, c = !0);
      else if (q(d))
        if (c = !0, q(s.charCodeAt(1))) {
          let h = 2, f = h;
          for (; h < a && !q(s.charCodeAt(h)); )
            h++;
          if (h < a && h !== f) {
            const m = s.slice(f, h);
            for (f = h; h < a && q(s.charCodeAt(h)); )
              h++;
            if (h < a && h !== f) {
              for (f = h; h < a && !q(s.charCodeAt(h)); )
                h++;
              (h === a || h !== f) && (l = `\\\\${m}\\${s.slice(f, h)}`, o = h);
            }
          }
        } else
          o = 1;
      else We(d) && s.charCodeAt(1) === ze && (l = s.slice(0, 2), o = 2, a > 2 && q(s.charCodeAt(2)) && (c = !0, o = 3));
      if (l.length > 0)
        if (e.length > 0) {
          if (l.toLowerCase() !== e.toLowerCase())
            continue;
        } else
          e = l;
      if (i) {
        if (e.length > 0)
          break;
      } else if (n = `${s.slice(o)}\\${n}`, i = c, c && e.length > 0)
        break;
    }
    return n = ln(n, !i, "\\", q), i ? `${e}\\${n}` : `${e}${n}` || ".";
  },
  normalize(t) {
    te(t, "path");
    const e = t.length;
    if (e === 0)
      return ".";
    let n = 0, i, r = !1;
    const s = t.charCodeAt(0);
    if (e === 1)
      return Qn(s) ? "\\" : t;
    if (q(s))
      if (r = !0, q(t.charCodeAt(1))) {
        let o = 2, l = o;
        for (; o < e && !q(t.charCodeAt(o)); )
          o++;
        if (o < e && o !== l) {
          const c = t.slice(l, o);
          for (l = o; o < e && q(t.charCodeAt(o)); )
            o++;
          if (o < e && o !== l) {
            for (l = o; o < e && !q(t.charCodeAt(o)); )
              o++;
            if (o === e)
              return `\\\\${c}\\${t.slice(l)}\\`;
            o !== l && (i = `\\\\${c}\\${t.slice(l, o)}`, n = o);
          }
        }
      } else
        n = 1;
    else We(s) && t.charCodeAt(1) === ze && (i = t.slice(0, 2), n = 2, e > 2 && q(t.charCodeAt(2)) && (r = !0, n = 3));
    let a = n < e ? ln(t.slice(n), !r, "\\", q) : "";
    return a.length === 0 && !r && (a = "."), a.length > 0 && q(t.charCodeAt(e - 1)) && (a += "\\"), i === void 0 ? r ? `\\${a}` : a : r ? `${i}\\${a}` : `${i}${a}`;
  },
  isAbsolute(t) {
    te(t, "path");
    const e = t.length;
    if (e === 0)
      return !1;
    const n = t.charCodeAt(0);
    return q(n) || // Possible device root
    e > 2 && We(n) && t.charCodeAt(1) === ze && q(t.charCodeAt(2));
  },
  join(...t) {
    if (t.length === 0)
      return ".";
    let e, n;
    for (let s = 0; s < t.length; ++s) {
      const a = t[s];
      te(a, "path"), a.length > 0 && (e === void 0 ? e = n = a : e += `\\${a}`);
    }
    if (e === void 0)
      return ".";
    let i = !0, r = 0;
    if (typeof n == "string" && q(n.charCodeAt(0))) {
      ++r;
      const s = n.length;
      s > 1 && q(n.charCodeAt(1)) && (++r, s > 2 && (q(n.charCodeAt(2)) ? ++r : i = !1));
    }
    if (i) {
      for (; r < e.length && q(e.charCodeAt(r)); )
        r++;
      r >= 2 && (e = `\\${e.slice(r)}`);
    }
    return pe.normalize(e);
  },
  // It will solve the relative path from `from` to `to`, for instance:
  //  from = 'C:\\orandea\\test\\aaa'
  //  to = 'C:\\orandea\\impl\\bbb'
  // The output of the function should be: '..\\..\\impl\\bbb'
  relative(t, e) {
    if (te(t, "from"), te(e, "to"), t === e)
      return "";
    const n = pe.resolve(t), i = pe.resolve(e);
    if (n === i || (t = n.toLowerCase(), e = i.toLowerCase(), t === e))
      return "";
    let r = 0;
    for (; r < t.length && t.charCodeAt(r) === De; )
      r++;
    let s = t.length;
    for (; s - 1 > r && t.charCodeAt(s - 1) === De; )
      s--;
    const a = s - r;
    let o = 0;
    for (; o < e.length && e.charCodeAt(o) === De; )
      o++;
    let l = e.length;
    for (; l - 1 > o && e.charCodeAt(l - 1) === De; )
      l--;
    const c = l - o, d = a < c ? a : c;
    let h = -1, f = 0;
    for (; f < d; f++) {
      const b = t.charCodeAt(r + f);
      if (b !== e.charCodeAt(o + f))
        break;
      b === De && (h = f);
    }
    if (f !== d) {
      if (h === -1)
        return i;
    } else {
      if (c > d) {
        if (e.charCodeAt(o + f) === De)
          return i.slice(o + f + 1);
        if (f === 2)
          return i.slice(o + f);
      }
      a > d && (t.charCodeAt(r + f) === De ? h = f : f === 2 && (h = 3)), h === -1 && (h = 0);
    }
    let m = "";
    for (f = r + h + 1; f <= s; ++f)
      (f === s || t.charCodeAt(f) === De) && (m += m.length === 0 ? ".." : "\\..");
    return o += h, m.length > 0 ? `${m}${i.slice(o, l)}` : (i.charCodeAt(o) === De && ++o, i.slice(o, l));
  },
  toNamespacedPath(t) {
    if (typeof t != "string" || t.length === 0)
      return t;
    const e = pe.resolve(t);
    if (e.length <= 2)
      return t;
    if (e.charCodeAt(0) === De) {
      if (e.charCodeAt(1) === De) {
        const n = e.charCodeAt(2);
        if (n !== vu && n !== Qe)
          return `\\\\?\\UNC\\${e.slice(2)}`;
      }
    } else if (We(e.charCodeAt(0)) && e.charCodeAt(1) === ze && e.charCodeAt(2) === De)
      return `\\\\?\\${e}`;
    return t;
  },
  dirname(t) {
    te(t, "path");
    const e = t.length;
    if (e === 0)
      return ".";
    let n = -1, i = 0;
    const r = t.charCodeAt(0);
    if (e === 1)
      return q(r) ? t : ".";
    if (q(r)) {
      if (n = i = 1, q(t.charCodeAt(1))) {
        let o = 2, l = o;
        for (; o < e && !q(t.charCodeAt(o)); )
          o++;
        if (o < e && o !== l) {
          for (l = o; o < e && q(t.charCodeAt(o)); )
            o++;
          if (o < e && o !== l) {
            for (l = o; o < e && !q(t.charCodeAt(o)); )
              o++;
            if (o === e)
              return t;
            o !== l && (n = i = o + 1);
          }
        }
      }
    } else We(r) && t.charCodeAt(1) === ze && (n = e > 2 && q(t.charCodeAt(2)) ? 3 : 2, i = n);
    let s = -1, a = !0;
    for (let o = e - 1; o >= i; --o)
      if (q(t.charCodeAt(o))) {
        if (!a) {
          s = o;
          break;
        }
      } else
        a = !1;
    if (s === -1) {
      if (n === -1)
        return ".";
      s = n;
    }
    return t.slice(0, s);
  },
  basename(t, e) {
    e !== void 0 && te(e, "suffix"), te(t, "path");
    let n = 0, i = -1, r = !0, s;
    if (t.length >= 2 && We(t.charCodeAt(0)) && t.charCodeAt(1) === ze && (n = 2), e !== void 0 && e.length > 0 && e.length <= t.length) {
      if (e === t)
        return "";
      let a = e.length - 1, o = -1;
      for (s = t.length - 1; s >= n; --s) {
        const l = t.charCodeAt(s);
        if (q(l)) {
          if (!r) {
            n = s + 1;
            break;
          }
        } else
          o === -1 && (r = !1, o = s + 1), a >= 0 && (l === e.charCodeAt(a) ? --a === -1 && (i = s) : (a = -1, i = o));
      }
      return n === i ? i = o : i === -1 && (i = t.length), t.slice(n, i);
    }
    for (s = t.length - 1; s >= n; --s)
      if (q(t.charCodeAt(s))) {
        if (!r) {
          n = s + 1;
          break;
        }
      } else i === -1 && (r = !1, i = s + 1);
    return i === -1 ? "" : t.slice(n, i);
  },
  extname(t) {
    te(t, "path");
    let e = 0, n = -1, i = 0, r = -1, s = !0, a = 0;
    t.length >= 2 && t.charCodeAt(1) === ze && We(t.charCodeAt(0)) && (e = i = 2);
    for (let o = t.length - 1; o >= e; --o) {
      const l = t.charCodeAt(o);
      if (q(l)) {
        if (!s) {
          i = o + 1;
          break;
        }
        continue;
      }
      r === -1 && (s = !1, r = o + 1), l === Qe ? n === -1 ? n = o : a !== 1 && (a = 1) : n !== -1 && (a = -1);
    }
    return n === -1 || r === -1 || // We saw a non-dot character immediately before the dot
    a === 0 || // The (right-most) trimmed path component is exactly '..'
    a === 1 && n === r - 1 && n === i + 1 ? "" : t.slice(n, r);
  },
  format: Za.bind(null, "\\"),
  parse(t) {
    te(t, "path");
    const e = { root: "", dir: "", base: "", ext: "", name: "" };
    if (t.length === 0)
      return e;
    const n = t.length;
    let i = 0, r = t.charCodeAt(0);
    if (n === 1)
      return q(r) ? (e.root = e.dir = t, e) : (e.base = e.name = t, e);
    if (q(r)) {
      if (i = 1, q(t.charCodeAt(1))) {
        let h = 2, f = h;
        for (; h < n && !q(t.charCodeAt(h)); )
          h++;
        if (h < n && h !== f) {
          for (f = h; h < n && q(t.charCodeAt(h)); )
            h++;
          if (h < n && h !== f) {
            for (f = h; h < n && !q(t.charCodeAt(h)); )
              h++;
            h === n ? i = h : h !== f && (i = h + 1);
          }
        }
      }
    } else if (We(r) && t.charCodeAt(1) === ze) {
      if (n <= 2)
        return e.root = e.dir = t, e;
      if (i = 2, q(t.charCodeAt(2))) {
        if (n === 3)
          return e.root = e.dir = t, e;
        i = 3;
      }
    }
    i > 0 && (e.root = t.slice(0, i));
    let s = -1, a = i, o = -1, l = !0, c = t.length - 1, d = 0;
    for (; c >= i; --c) {
      if (r = t.charCodeAt(c), q(r)) {
        if (!l) {
          a = c + 1;
          break;
        }
        continue;
      }
      o === -1 && (l = !1, o = c + 1), r === Qe ? s === -1 ? s = c : d !== 1 && (d = 1) : s !== -1 && (d = -1);
    }
    return o !== -1 && (s === -1 || // We saw a non-dot character immediately before the dot
    d === 0 || // The (right-most) trimmed path component is exactly '..'
    d === 1 && s === o - 1 && s === a + 1 ? e.base = e.name = t.slice(a, o) : (e.name = t.slice(a, s), e.base = t.slice(a, o), e.ext = t.slice(s, o))), a > 0 && a !== i ? e.dir = t.slice(0, a - 1) : e.dir = e.root, e;
  },
  sep: "\\",
  delimiter: ";",
  win32: null,
  posix: null
}, yu = (() => {
  if (Ve) {
    const t = /\\/g;
    return () => {
      const e = un().replace(t, "/");
      return e.slice(e.indexOf("/"));
    };
  }
  return () => un();
})(), be = {
  // path.resolve([from ...], to)
  resolve(...t) {
    let e = "", n = !1;
    for (let i = t.length - 1; i >= -1 && !n; i--) {
      const r = i >= 0 ? t[i] : yu();
      te(r, `paths[${i}]`), r.length !== 0 && (e = `${r}/${e}`, n = r.charCodeAt(0) === he);
    }
    return e = ln(e, !n, "/", Qn), n ? `/${e}` : e.length > 0 ? e : ".";
  },
  normalize(t) {
    if (te(t, "path"), t.length === 0)
      return ".";
    const e = t.charCodeAt(0) === he, n = t.charCodeAt(t.length - 1) === he;
    return t = ln(t, !e, "/", Qn), t.length === 0 ? e ? "/" : n ? "./" : "." : (n && (t += "/"), e ? `/${t}` : t);
  },
  isAbsolute(t) {
    return te(t, "path"), t.length > 0 && t.charCodeAt(0) === he;
  },
  join(...t) {
    if (t.length === 0)
      return ".";
    let e;
    for (let n = 0; n < t.length; ++n) {
      const i = t[n];
      te(i, "path"), i.length > 0 && (e === void 0 ? e = i : e += `/${i}`);
    }
    return e === void 0 ? "." : be.normalize(e);
  },
  relative(t, e) {
    if (te(t, "from"), te(e, "to"), t === e || (t = be.resolve(t), e = be.resolve(e), t === e))
      return "";
    const n = 1, i = t.length, r = i - n, s = 1, a = e.length - s, o = r < a ? r : a;
    let l = -1, c = 0;
    for (; c < o; c++) {
      const h = t.charCodeAt(n + c);
      if (h !== e.charCodeAt(s + c))
        break;
      h === he && (l = c);
    }
    if (c === o)
      if (a > o) {
        if (e.charCodeAt(s + c) === he)
          return e.slice(s + c + 1);
        if (c === 0)
          return e.slice(s + c);
      } else r > o && (t.charCodeAt(n + c) === he ? l = c : c === 0 && (l = 0));
    let d = "";
    for (c = n + l + 1; c <= i; ++c)
      (c === i || t.charCodeAt(c) === he) && (d += d.length === 0 ? ".." : "/..");
    return `${d}${e.slice(s + l)}`;
  },
  toNamespacedPath(t) {
    return t;
  },
  dirname(t) {
    if (te(t, "path"), t.length === 0)
      return ".";
    const e = t.charCodeAt(0) === he;
    let n = -1, i = !0;
    for (let r = t.length - 1; r >= 1; --r)
      if (t.charCodeAt(r) === he) {
        if (!i) {
          n = r;
          break;
        }
      } else
        i = !1;
    return n === -1 ? e ? "/" : "." : e && n === 1 ? "//" : t.slice(0, n);
  },
  basename(t, e) {
    e !== void 0 && te(e, "ext"), te(t, "path");
    let n = 0, i = -1, r = !0, s;
    if (e !== void 0 && e.length > 0 && e.length <= t.length) {
      if (e === t)
        return "";
      let a = e.length - 1, o = -1;
      for (s = t.length - 1; s >= 0; --s) {
        const l = t.charCodeAt(s);
        if (l === he) {
          if (!r) {
            n = s + 1;
            break;
          }
        } else
          o === -1 && (r = !1, o = s + 1), a >= 0 && (l === e.charCodeAt(a) ? --a === -1 && (i = s) : (a = -1, i = o));
      }
      return n === i ? i = o : i === -1 && (i = t.length), t.slice(n, i);
    }
    for (s = t.length - 1; s >= 0; --s)
      if (t.charCodeAt(s) === he) {
        if (!r) {
          n = s + 1;
          break;
        }
      } else i === -1 && (r = !1, i = s + 1);
    return i === -1 ? "" : t.slice(n, i);
  },
  extname(t) {
    te(t, "path");
    let e = -1, n = 0, i = -1, r = !0, s = 0;
    for (let a = t.length - 1; a >= 0; --a) {
      const o = t.charCodeAt(a);
      if (o === he) {
        if (!r) {
          n = a + 1;
          break;
        }
        continue;
      }
      i === -1 && (r = !1, i = a + 1), o === Qe ? e === -1 ? e = a : s !== 1 && (s = 1) : e !== -1 && (s = -1);
    }
    return e === -1 || i === -1 || // We saw a non-dot character immediately before the dot
    s === 0 || // The (right-most) trimmed path component is exactly '..'
    s === 1 && e === i - 1 && e === n + 1 ? "" : t.slice(e, i);
  },
  format: Za.bind(null, "/"),
  parse(t) {
    te(t, "path");
    const e = { root: "", dir: "", base: "", ext: "", name: "" };
    if (t.length === 0)
      return e;
    const n = t.charCodeAt(0) === he;
    let i;
    n ? (e.root = "/", i = 1) : i = 0;
    let r = -1, s = 0, a = -1, o = !0, l = t.length - 1, c = 0;
    for (; l >= i; --l) {
      const d = t.charCodeAt(l);
      if (d === he) {
        if (!o) {
          s = l + 1;
          break;
        }
        continue;
      }
      a === -1 && (o = !1, a = l + 1), d === Qe ? r === -1 ? r = l : c !== 1 && (c = 1) : r !== -1 && (c = -1);
    }
    if (a !== -1) {
      const d = s === 0 && n ? 1 : s;
      r === -1 || // We saw a non-dot character immediately before the dot
      c === 0 || // The (right-most) trimmed path component is exactly '..'
      c === 1 && r === a - 1 && r === s + 1 ? e.base = e.name = t.slice(d, a) : (e.name = t.slice(d, r), e.base = t.slice(d, a), e.ext = t.slice(r, a));
    }
    return s > 0 ? e.dir = t.slice(0, s - 1) : n && (e.dir = "/"), e;
  },
  sep: "/",
  delimiter: ":",
  win32: null,
  posix: null
};
be.win32 = pe.win32 = pe;
be.posix = pe.posix = be;
Ve ? pe.normalize : be.normalize;
const Su = Ve ? pe.join : be.join;
Ve ? pe.resolve : be.resolve;
Ve ? pe.relative : be.relative;
Ve ? pe.dirname : be.dirname;
Ve ? pe.basename : be.basename;
Ve ? pe.extname : be.extname;
Ve ? pe.sep : be.sep;
const Nu = /^\w[\w\d+.-]*$/, ku = /^\//, Bu = /^\/\//;
function Iu(t, e) {
  if (!t.scheme && e)
    throw new Error(`[UriError]: Scheme is missing: {scheme: "", authority: "${t.authority}", path: "${t.path}", query: "${t.query}", fragment: "${t.fragment}"}`);
  if (t.scheme && !Nu.test(t.scheme))
    throw new Error("[UriError]: Scheme contains illegal characters.");
  if (t.path) {
    if (t.authority) {
      if (!ku.test(t.path))
        throw new Error('[UriError]: If a URI contains an authority component, then the path component must either be empty or begin with a slash ("/") character');
    } else if (Bu.test(t.path))
      throw new Error('[UriError]: If a URI does not contain an authority component, then the path cannot begin with two slash characters ("//")');
  }
}
function Ru(t, e) {
  return !t && !e ? "file" : t;
}
function Mu(t, e) {
  switch (t) {
    case "https":
    case "http":
    case "file":
      e ? e[0] !== _e && (e = _e + e) : e = _e;
      break;
  }
  return e;
}
const Q = "", _e = "/", Pu = /^(([^:/?#]+?):)?(\/\/([^/?#]*))?([^?#]*)(\?([^#]*))?(#(.*))?/;
let ke = class jt {
  static isUri(e) {
    return e instanceof jt ? !0 : e ? typeof e.authority == "string" && typeof e.fragment == "string" && typeof e.path == "string" && typeof e.query == "string" && typeof e.scheme == "string" && typeof e.fsPath == "string" && typeof e.with == "function" && typeof e.toString == "function" : !1;
  }
  /**
   * @internal
   */
  constructor(e, n, i, r, s, a = !1) {
    typeof e == "object" ? (this.scheme = e.scheme || Q, this.authority = e.authority || Q, this.path = e.path || Q, this.query = e.query || Q, this.fragment = e.fragment || Q) : (this.scheme = Ru(e, a), this.authority = n || Q, this.path = Mu(this.scheme, i || Q), this.query = r || Q, this.fragment = s || Q, Iu(this, a));
  }
  // ---- filesystem path -----------------------
  /**
   * Returns a string representing the corresponding file system path of this URI.
   * Will handle UNC paths, normalizes windows drive letters to lower-case, and uses the
   * platform specific path separator.
   *
   * * Will *not* validate the path for invalid characters and semantics.
   * * Will *not* look at the scheme of this URI.
   * * The result shall *not* be used for display purposes but for accessing a file on disk.
   *
   *
   * The *difference* to `URI#path` is the use of the platform specific separator and the handling
   * of UNC paths. See the below sample of a file-uri with an authority (UNC path).
   *
   * ```ts
      const u = URI.parse('file://server/c$/folder/file.txt')
      u.authority === 'server'
      u.path === '/shares/c$/file.txt'
      u.fsPath === '\\server\c$\folder\file.txt'
  ```
   *
   * Using `URI#path` to read a file (using fs-apis) would not be enough because parts of the path,
   * namely the server name, would be missing. Therefore `URI#fsPath` exists - it's sugar to ease working
   * with URIs that represent files on disk (`file` scheme).
   */
  get fsPath() {
    return Yn(this, !1);
  }
  // ---- modify to new -------------------------
  with(e) {
    if (!e)
      return this;
    let { scheme: n, authority: i, path: r, query: s, fragment: a } = e;
    return n === void 0 ? n = this.scheme : n === null && (n = Q), i === void 0 ? i = this.authority : i === null && (i = Q), r === void 0 ? r = this.path : r === null && (r = Q), s === void 0 ? s = this.query : s === null && (s = Q), a === void 0 ? a = this.fragment : a === null && (a = Q), n === this.scheme && i === this.authority && r === this.path && s === this.query && a === this.fragment ? this : new st(n, i, r, s, a);
  }
  // ---- parse & validate ------------------------
  /**
   * Creates a new URI from a string, e.g. `http://www.example.com/some/path`,
   * `file:///usr/home`, or `scheme:with/path`.
   *
   * @param value A string which represents an URI (see `URI#toString`).
   */
  static parse(e, n = !1) {
    const i = Pu.exec(e);
    return i ? new st(i[2] || Q, Wt(i[4] || Q), Wt(i[5] || Q), Wt(i[7] || Q), Wt(i[9] || Q), n) : new st(Q, Q, Q, Q, Q);
  }
  /**
   * Creates a new URI from a file system path, e.g. `c:\my\files`,
   * `/usr/home`, or `\\server\share\some\path`.
   *
   * The *difference* between `URI#parse` and `URI#file` is that the latter treats the argument
   * as path, not as stringified-uri. E.g. `URI.file(path)` is **not the same as**
   * `URI.parse('file://' + path)` because the path might contain characters that are
   * interpreted (# and ?). See the following sample:
   * ```ts
  const good = URI.file('/coding/c#/project1');
  good.scheme === 'file';
  good.path === '/coding/c#/project1';
  good.fragment === '';
  const bad = URI.parse('file://' + '/coding/c#/project1');
  bad.scheme === 'file';
  bad.path === '/coding/c'; // path is now broken
  bad.fragment === '/project1';
  ```
   *
   * @param path A file system path (see `URI#fsPath`)
   */
  static file(e) {
    let n = Q;
    if (Bt && (e = e.replace(/\\/g, _e)), e[0] === _e && e[1] === _e) {
      const i = e.indexOf(_e, 2);
      i === -1 ? (n = e.substring(2), e = _e) : (n = e.substring(2, i), e = e.substring(i) || _e);
    }
    return new st("file", n, e, Q, Q);
  }
  /**
   * Creates new URI from uri components.
   *
   * Unless `strict` is `true` the scheme is defaults to be `file`. This function performs
   * validation and should be used for untrusted uri components retrieved from storage,
   * user input, command arguments etc
   */
  static from(e, n) {
    return new st(e.scheme, e.authority, e.path, e.query, e.fragment, n);
  }
  /**
   * Join a URI path with path fragments and normalizes the resulting path.
   *
   * @param uri The input URI.
   * @param pathFragment The path fragment to add to the URI path.
   * @returns The resulting URI.
   */
  static joinPath(e, ...n) {
    if (!e.path)
      throw new Error("[UriError]: cannot call joinPath on URI without path");
    let i;
    return Bt && e.scheme === "file" ? i = jt.file(pe.join(Yn(e, !0), ...n)).path : i = be.join(e.path, ...n), e.with({ path: i });
  }
  // ---- printing/externalize ---------------------------
  /**
   * Creates a string representation for this URI. It's guaranteed that calling
   * `URI.parse` with the result of this function creates an URI which is equal
   * to this URI.
   *
   * * The result shall *not* be used for display purposes but for externalization or transport.
   * * The result will be encoded using the percentage encoding and encoding happens mostly
   * ignore the scheme-specific encoding rules.
   *
   * @param skipEncoding Do not encode the result, default is `false`
   */
  toString(e = !1) {
    return Zn(this, e);
  }
  toJSON() {
    return this;
  }
  static revive(e) {
    if (e) {
      if (e instanceof jt)
        return e;
      {
        const n = new st(e);
        return n._formatted = e.external ?? null, n._fsPath = e._sep === Ka ? e.fsPath ?? null : null, n;
      }
    } else return e;
  }
};
const Ka = Bt ? 1 : void 0;
class st extends ke {
  constructor() {
    super(...arguments), this._formatted = null, this._fsPath = null;
  }
  get fsPath() {
    return this._fsPath || (this._fsPath = Yn(this, !1)), this._fsPath;
  }
  toString(e = !1) {
    return e ? Zn(this, !0) : (this._formatted || (this._formatted = Zn(this, !1)), this._formatted);
  }
  toJSON() {
    const e = {
      $mid: 1
      /* MarshalledId.Uri */
    };
    return this._fsPath && (e.fsPath = this._fsPath, e._sep = Ka), this._formatted && (e.external = this._formatted), this.path && (e.path = this.path), this.scheme && (e.scheme = this.scheme), this.authority && (e.authority = this.authority), this.query && (e.query = this.query), this.fragment && (e.fragment = this.fragment), e;
  }
}
const eo = {
  58: "%3A",
  // gen-delims
  47: "%2F",
  63: "%3F",
  35: "%23",
  91: "%5B",
  93: "%5D",
  64: "%40",
  33: "%21",
  // sub-delims
  36: "%24",
  38: "%26",
  39: "%27",
  40: "%28",
  41: "%29",
  42: "%2A",
  43: "%2B",
  44: "%2C",
  59: "%3B",
  61: "%3D",
  32: "%20"
};
function Ji(t, e, n) {
  let i, r = -1;
  for (let s = 0; s < t.length; s++) {
    const a = t.charCodeAt(s);
    if (a >= 97 && a <= 122 || a >= 65 && a <= 90 || a >= 48 && a <= 57 || a === 45 || a === 46 || a === 95 || a === 126 || e && a === 47 || n && a === 91 || n && a === 93 || n && a === 58)
      r !== -1 && (i += encodeURIComponent(t.substring(r, s)), r = -1), i !== void 0 && (i += t.charAt(s));
    else {
      i === void 0 && (i = t.substr(0, s));
      const o = eo[a];
      o !== void 0 ? (r !== -1 && (i += encodeURIComponent(t.substring(r, s)), r = -1), i += o) : r === -1 && (r = s);
    }
  }
  return r !== -1 && (i += encodeURIComponent(t.substring(r))), i !== void 0 ? i : t;
}
function Tu(t) {
  let e;
  for (let n = 0; n < t.length; n++) {
    const i = t.charCodeAt(n);
    i === 35 || i === 63 ? (e === void 0 && (e = t.substr(0, n)), e += eo[i]) : e !== void 0 && (e += t[n]);
  }
  return e !== void 0 ? e : t;
}
function Yn(t, e) {
  let n;
  return t.authority && t.path.length > 1 && t.scheme === "file" ? n = `//${t.authority}${t.path}` : t.path.charCodeAt(0) === 47 && (t.path.charCodeAt(1) >= 65 && t.path.charCodeAt(1) <= 90 || t.path.charCodeAt(1) >= 97 && t.path.charCodeAt(1) <= 122) && t.path.charCodeAt(2) === 58 ? e ? n = t.path.substr(1) : n = t.path[1].toLowerCase() + t.path.substr(2) : n = t.path, Bt && (n = n.replace(/\//g, "\\")), n;
}
function Zn(t, e) {
  const n = e ? Tu : Ji;
  let i = "", { scheme: r, authority: s, path: a, query: o, fragment: l } = t;
  if (r && (i += r, i += ":"), (s || r === "file") && (i += _e, i += _e), s) {
    let c = s.indexOf("@");
    if (c !== -1) {
      const d = s.substr(0, c);
      s = s.substr(c + 1), c = d.lastIndexOf(":"), c === -1 ? i += n(d, !1, !1) : (i += n(d.substr(0, c), !1, !1), i += ":", i += n(d.substr(c + 1), !1, !0)), i += "@";
    }
    s = s.toLowerCase(), c = s.lastIndexOf(":"), c === -1 ? i += n(s, !1, !0) : (i += n(s.substr(0, c), !1, !0), i += s.substr(c));
  }
  if (a) {
    if (a.length >= 3 && a.charCodeAt(0) === 47 && a.charCodeAt(2) === 58) {
      const c = a.charCodeAt(1);
      c >= 65 && c <= 90 && (a = `/${String.fromCharCode(c + 32)}:${a.substr(3)}`);
    } else if (a.length >= 2 && a.charCodeAt(1) === 58) {
      const c = a.charCodeAt(0);
      c >= 65 && c <= 90 && (a = `${String.fromCharCode(c + 32)}:${a.substr(2)}`);
    }
    i += n(a, !0, !1);
  }
  return o && (i += "?", i += n(o, !1, !1)), l && (i += "#", i += e ? l : Ji(l, !1, !1)), i;
}
function to(t) {
  try {
    return decodeURIComponent(t);
  } catch {
    return t.length > 3 ? t.substr(0, 3) + to(t.substr(3)) : t;
  }
}
const Qi = /(%[0-9A-Za-z][0-9A-Za-z])+/g;
function Wt(t) {
  return t.match(Qi) ? t.replace(Qi, (e) => to(e)) : t;
}
var Je;
(function(t) {
  t.inMemory = "inmemory", t.vscode = "vscode", t.internal = "private", t.walkThrough = "walkThrough", t.walkThroughSnippet = "walkThroughSnippet", t.http = "http", t.https = "https", t.file = "file", t.mailto = "mailto", t.untitled = "untitled", t.data = "data", t.command = "command", t.vscodeRemote = "vscode-remote", t.vscodeRemoteResource = "vscode-remote-resource", t.vscodeManagedRemoteResource = "vscode-managed-remote-resource", t.vscodeUserData = "vscode-userdata", t.vscodeCustomEditor = "vscode-custom-editor", t.vscodeNotebookCell = "vscode-notebook-cell", t.vscodeNotebookCellMetadata = "vscode-notebook-cell-metadata", t.vscodeNotebookCellMetadataDiff = "vscode-notebook-cell-metadata-diff", t.vscodeNotebookCellOutput = "vscode-notebook-cell-output", t.vscodeNotebookCellOutputDiff = "vscode-notebook-cell-output-diff", t.vscodeNotebookMetadata = "vscode-notebook-metadata", t.vscodeInteractiveInput = "vscode-interactive-input", t.vscodeSettings = "vscode-settings", t.vscodeWorkspaceTrust = "vscode-workspace-trust", t.vscodeTerminal = "vscode-terminal", t.vscodeChatCodeBlock = "vscode-chat-code-block", t.vscodeChatCodeCompareBlock = "vscode-chat-code-compare-block", t.vscodeChatSesssion = "vscode-chat-editor", t.webviewPanel = "webview-panel", t.vscodeWebview = "vscode-webview", t.extension = "extension", t.vscodeFileResource = "vscode-file", t.tmp = "tmp", t.vsls = "vsls", t.vscodeSourceControl = "vscode-scm", t.commentsInput = "comment", t.codeSetting = "code-setting", t.outputChannel = "output";
})(Je || (Je = {}));
const Uu = "tkn";
class Vu {
  constructor() {
    this._hosts = /* @__PURE__ */ Object.create(null), this._ports = /* @__PURE__ */ Object.create(null), this._connectionTokens = /* @__PURE__ */ Object.create(null), this._preferredWebSchema = "http", this._delegate = null, this._serverRootPath = "/";
  }
  setPreferredWebSchema(e) {
    this._preferredWebSchema = e;
  }
  get _remoteResourcesPath() {
    return be.join(this._serverRootPath, Je.vscodeRemoteResource);
  }
  rewrite(e) {
    if (this._delegate)
      try {
        return this._delegate(e);
      } catch (o) {
        return yt(o), e;
      }
    const n = e.authority;
    let i = this._hosts[n];
    i && i.indexOf(":") !== -1 && i.indexOf("[") === -1 && (i = `[${i}]`);
    const r = this._ports[n], s = this._connectionTokens[n];
    let a = `path=${encodeURIComponent(e.path)}`;
    return typeof s == "string" && (a += `&${Uu}=${encodeURIComponent(s)}`), ke.from({
      scheme: su ? this._preferredWebSchema : Je.vscodeRemoteResource,
      authority: `${i}:${r}`,
      path: this._remoteResourcesPath,
      query: a
    });
  }
}
const $u = new Vu(), qu = "vscode-app";
class cn {
  static {
    this.FALLBACK_AUTHORITY = qu;
  }
  /**
   * Returns a URI to use in contexts where the browser is responsible
   * for loading (e.g. fetch()) or when used within the DOM.
   *
   * **Note:** use `dom.ts#asCSSUrl` whenever the URL is to be used in CSS context.
   */
  asBrowserUri(e) {
    const n = this.toUri(e);
    return this.uriToBrowserUri(n);
  }
  /**
   * Returns a URI to use in contexts where the browser is responsible
   * for loading (e.g. fetch()) or when used within the DOM.
   *
   * **Note:** use `dom.ts#asCSSUrl` whenever the URL is to be used in CSS context.
   */
  uriToBrowserUri(e) {
    return e.scheme === Je.vscodeRemote ? $u.rewrite(e) : (
      // ...only ever for `file` resources
      e.scheme === Je.file && // ...and we run in native environments
      (ru || // ...or web worker extensions on desktop
      ou === `${Je.vscodeFileResource}://${cn.FALLBACK_AUTHORITY}`) ? e.with({
        scheme: Je.vscodeFileResource,
        // We need to provide an authority here so that it can serve
        // as origin for network and loading matters in chromium.
        // If the URI is not coming with an authority already, we
        // add our own
        authority: e.authority || cn.FALLBACK_AUTHORITY,
        query: null,
        fragment: null
      }) : e
    );
  }
  toUri(e, n) {
    if (ke.isUri(e))
      return e;
    if (globalThis._VSCODE_FILE_ROOT) {
      const i = globalThis._VSCODE_FILE_ROOT;
      if (/^\w[\w\d+.-]*:\/\//.test(i))
        return ke.joinPath(ke.parse(i, !0), e);
      const r = Su(i, e);
      return ke.file(r);
    }
    return ke.parse(n.toUrl(e));
  }
}
const no = new cn();
var Yi;
(function(t) {
  const e = /* @__PURE__ */ new Map([
    ["1", { "Cross-Origin-Opener-Policy": "same-origin" }],
    ["2", { "Cross-Origin-Embedder-Policy": "require-corp" }],
    ["3", { "Cross-Origin-Opener-Policy": "same-origin", "Cross-Origin-Embedder-Policy": "require-corp" }]
  ]);
  t.CoopAndCoep = Object.freeze(e.get("3"));
  const n = "vscode-coi";
  function i(s) {
    let a;
    typeof s == "string" ? a = new URL(s).searchParams : s instanceof URL ? a = s.searchParams : ke.isUri(s) && (a = new URL(s.toString(!0)).searchParams);
    const o = a?.get(n);
    if (o)
      return e.get(o);
  }
  t.getHeadersFromQuery = i;
  function r(s, a, o) {
    if (!globalThis.crossOriginIsolated)
      return;
    const l = a && o ? "3" : o ? "2" : "1";
    s instanceof URLSearchParams ? s.set(n, l) : s[n] = l;
  }
  t.addSearchParam = r;
})(Yi || (Yi = {}));
const Pn = "default", zu = "$initialize";
class Wu {
  constructor(e, n, i, r, s) {
    this.vsWorker = e, this.req = n, this.channel = i, this.method = r, this.args = s, this.type = 0;
  }
}
class Zi {
  constructor(e, n, i, r) {
    this.vsWorker = e, this.seq = n, this.res = i, this.err = r, this.type = 1;
  }
}
class Ou {
  constructor(e, n, i, r, s) {
    this.vsWorker = e, this.req = n, this.channel = i, this.eventName = r, this.arg = s, this.type = 2;
  }
}
class Hu {
  constructor(e, n, i) {
    this.vsWorker = e, this.req = n, this.event = i, this.type = 3;
  }
}
class ju {
  constructor(e, n) {
    this.vsWorker = e, this.req = n, this.type = 4;
  }
}
class Gu {
  constructor(e) {
    this._workerId = -1, this._handler = e, this._lastSentReq = 0, this._pendingReplies = /* @__PURE__ */ Object.create(null), this._pendingEmitters = /* @__PURE__ */ new Map(), this._pendingEvents = /* @__PURE__ */ new Map();
  }
  setWorkerId(e) {
    this._workerId = e;
  }
  sendMessage(e, n, i) {
    const r = String(++this._lastSentReq);
    return new Promise((s, a) => {
      this._pendingReplies[r] = {
        resolve: s,
        reject: a
      }, this._send(new Wu(this._workerId, r, e, n, i));
    });
  }
  listen(e, n, i) {
    let r = null;
    const s = new we({
      onWillAddFirstListener: () => {
        r = String(++this._lastSentReq), this._pendingEmitters.set(r, s), this._send(new Ou(this._workerId, r, e, n, i));
      },
      onDidRemoveLastListener: () => {
        this._pendingEmitters.delete(r), this._send(new ju(this._workerId, r)), r = null;
      }
    });
    return s.event;
  }
  handleMessage(e) {
    !e || !e.vsWorker || this._workerId !== -1 && e.vsWorker !== this._workerId || this._handleMessage(e);
  }
  createProxyToRemoteChannel(e, n) {
    const i = {
      get: (r, s) => (typeof s == "string" && !r[s] && (ro(s) ? r[s] = (a) => this.listen(e, s, a) : io(s) ? r[s] = this.listen(e, s, void 0) : s.charCodeAt(0) === 36 && (r[s] = async (...a) => (await n?.(), this.sendMessage(e, s, a)))), r[s])
    };
    return new Proxy(/* @__PURE__ */ Object.create(null), i);
  }
  _handleMessage(e) {
    switch (e.type) {
      case 1:
        return this._handleReplyMessage(e);
      case 0:
        return this._handleRequestMessage(e);
      case 2:
        return this._handleSubscribeEventMessage(e);
      case 3:
        return this._handleEventMessage(e);
      case 4:
        return this._handleUnsubscribeEventMessage(e);
    }
  }
  _handleReplyMessage(e) {
    if (!this._pendingReplies[e.seq]) {
      console.warn("Got reply to unknown seq");
      return;
    }
    const n = this._pendingReplies[e.seq];
    if (delete this._pendingReplies[e.seq], e.err) {
      let i = e.err;
      e.err.$isError && (i = new Error(), i.name = e.err.name, i.message = e.err.message, i.stack = e.err.stack), n.reject(i);
      return;
    }
    n.resolve(e.res);
  }
  _handleRequestMessage(e) {
    const n = e.req;
    this._handler.handleMessage(e.channel, e.method, e.args).then((r) => {
      this._send(new Zi(this._workerId, n, r, void 0));
    }, (r) => {
      r.detail instanceof Error && (r.detail = Hi(r.detail)), this._send(new Zi(this._workerId, n, void 0, Hi(r)));
    });
  }
  _handleSubscribeEventMessage(e) {
    const n = e.req, i = this._handler.handleEvent(e.channel, e.eventName, e.arg)((r) => {
      this._send(new Hu(this._workerId, n, r));
    });
    this._pendingEvents.set(n, i);
  }
  _handleEventMessage(e) {
    if (!this._pendingEmitters.has(e.req)) {
      console.warn("Got event for unknown req");
      return;
    }
    this._pendingEmitters.get(e.req).fire(e.event);
  }
  _handleUnsubscribeEventMessage(e) {
    if (!this._pendingEvents.has(e.req)) {
      console.warn("Got unsubscribe for unknown req");
      return;
    }
    this._pendingEvents.get(e.req).dispose(), this._pendingEvents.delete(e.req);
  }
  _send(e) {
    const n = [];
    if (e.type === 0)
      for (let i = 0; i < e.args.length; i++)
        e.args[i] instanceof ArrayBuffer && n.push(e.args[i]);
    else e.type === 1 && e.res instanceof ArrayBuffer && n.push(e.res);
    this._handler.sendMessage(e, n);
  }
}
function io(t) {
  return t[0] === "o" && t[1] === "n" && Ja(t.charCodeAt(2));
}
function ro(t) {
  return /^onDynamic/.test(t) && Ja(t.charCodeAt(9));
}
class Xu {
  constructor(e, n) {
    this._localChannels = /* @__PURE__ */ new Map(), this._remoteChannels = /* @__PURE__ */ new Map(), this._requestHandlerFactory = n, this._requestHandler = null, this._protocol = new Gu({
      sendMessage: (i, r) => {
        e(i, r);
      },
      handleMessage: (i, r, s) => this._handleMessage(i, r, s),
      handleEvent: (i, r, s) => this._handleEvent(i, r, s)
    });
  }
  onmessage(e) {
    this._protocol.handleMessage(e);
  }
  _handleMessage(e, n, i) {
    if (e === Pn && n === zu)
      return this.initialize(i[0], i[1], i[2]);
    const r = e === Pn ? this._requestHandler : this._localChannels.get(e);
    if (!r)
      return Promise.reject(new Error(`Missing channel ${e} on worker thread`));
    if (typeof r[n] != "function")
      return Promise.reject(new Error(`Missing method ${n} on worker thread channel ${e}`));
    try {
      return Promise.resolve(r[n].apply(r, i));
    } catch (s) {
      return Promise.reject(s);
    }
  }
  _handleEvent(e, n, i) {
    const r = e === Pn ? this._requestHandler : this._localChannels.get(e);
    if (!r)
      throw new Error(`Missing channel ${e} on worker thread`);
    if (ro(n)) {
      const s = r[n].call(r, i);
      if (typeof s != "function")
        throw new Error(`Missing dynamic event ${n} on request handler.`);
      return s;
    }
    if (io(n)) {
      const s = r[n];
      if (typeof s != "function")
        throw new Error(`Missing event ${n} on request handler.`);
      return s;
    }
    throw new Error(`Malformed event name ${n}`);
  }
  getChannel(e) {
    if (!this._remoteChannels.has(e)) {
      const n = this._protocol.createProxyToRemoteChannel(e);
      this._remoteChannels.set(e, n);
    }
    return this._remoteChannels.get(e);
  }
  async initialize(e, n, i) {
    if (this._protocol.setWorkerId(e), this._requestHandlerFactory) {
      this._requestHandler = this._requestHandlerFactory(this);
      return;
    }
    return n && (typeof n.baseUrl < "u" && delete n.baseUrl, typeof n.paths < "u" && typeof n.paths.vs < "u" && delete n.paths.vs, typeof n.trustedTypesPolicy < "u" && delete n.trustedTypesPolicy, n.catchError = !0, globalThis.require.config(n)), import(`${no.asBrowserUri(`${i}.js`).toString(!0)}`).then((s) => {
      if (this._requestHandler = s.create(this), !this._requestHandler)
        throw new Error("No RequestHandler!");
    });
  }
}
class He {
  /**
   * Constructs a new DiffChange with the given sequence information
   * and content.
   */
  constructor(e, n, i, r) {
    this.originalStart = e, this.originalLength = n, this.modifiedStart = i, this.modifiedLength = r;
  }
  /**
   * The end point (exclusive) of the change in the original sequence.
   */
  getOriginalEnd() {
    return this.originalStart + this.originalLength;
  }
  /**
   * The end point (exclusive) of the change in the modified sequence.
   */
  getModifiedEnd() {
    return this.modifiedStart + this.modifiedLength;
  }
}
function Ki(t, e) {
  return (e << 5) - e + t | 0;
}
function Ju(t, e) {
  e = Ki(149417, e);
  for (let n = 0, i = t.length; n < i; n++)
    e = Ki(t.charCodeAt(n), e);
  return e;
}
function Tn(t, e, n = 32) {
  const i = n - e, r = ~((1 << i) - 1);
  return (t << e | (r & t) >>> i) >>> 0;
}
function er(t, e = 0, n = t.byteLength, i = 0) {
  for (let r = 0; r < n; r++)
    t[e + r] = i;
}
function Qu(t, e, n = "0") {
  for (; t.length < e; )
    t = n + t;
  return t;
}
function Lt(t, e = 32) {
  return t instanceof ArrayBuffer ? Array.from(new Uint8Array(t)).map((n) => n.toString(16).padStart(2, "0")).join("") : Qu((t >>> 0).toString(16), e / 4);
}
class so {
  static {
    this._bigBlock32 = new DataView(new ArrayBuffer(320));
  }
  // 80 * 4 = 320
  constructor() {
    this._h0 = 1732584193, this._h1 = 4023233417, this._h2 = 2562383102, this._h3 = 271733878, this._h4 = 3285377520, this._buff = new Uint8Array(
      67
      /* to fit any utf-8 */
    ), this._buffDV = new DataView(this._buff.buffer), this._buffLen = 0, this._totalLen = 0, this._leftoverHighSurrogate = 0, this._finished = !1;
  }
  update(e) {
    const n = e.length;
    if (n === 0)
      return;
    const i = this._buff;
    let r = this._buffLen, s = this._leftoverHighSurrogate, a, o;
    for (s !== 0 ? (a = s, o = -1, s = 0) : (a = e.charCodeAt(0), o = 0); ; ) {
      let l = a;
      if (on(a))
        if (o + 1 < n) {
          const c = e.charCodeAt(o + 1);
          Jn(c) ? (o++, l = Qa(a, c)) : l = 65533;
        } else {
          s = a;
          break;
        }
      else Jn(a) && (l = 65533);
      if (r = this._push(i, r, l), o++, o < n)
        a = e.charCodeAt(o);
      else
        break;
    }
    this._buffLen = r, this._leftoverHighSurrogate = s;
  }
  _push(e, n, i) {
    return i < 128 ? e[n++] = i : i < 2048 ? (e[n++] = 192 | (i & 1984) >>> 6, e[n++] = 128 | (i & 63) >>> 0) : i < 65536 ? (e[n++] = 224 | (i & 61440) >>> 12, e[n++] = 128 | (i & 4032) >>> 6, e[n++] = 128 | (i & 63) >>> 0) : (e[n++] = 240 | (i & 1835008) >>> 18, e[n++] = 128 | (i & 258048) >>> 12, e[n++] = 128 | (i & 4032) >>> 6, e[n++] = 128 | (i & 63) >>> 0), n >= 64 && (this._step(), n -= 64, this._totalLen += 64, e[0] = e[64], e[1] = e[65], e[2] = e[66]), n;
  }
  digest() {
    return this._finished || (this._finished = !0, this._leftoverHighSurrogate && (this._leftoverHighSurrogate = 0, this._buffLen = this._push(
      this._buff,
      this._buffLen,
      65533
      /* SHA1Constant.UNICODE_REPLACEMENT */
    )), this._totalLen += this._buffLen, this._wrapUp()), Lt(this._h0) + Lt(this._h1) + Lt(this._h2) + Lt(this._h3) + Lt(this._h4);
  }
  _wrapUp() {
    this._buff[this._buffLen++] = 128, er(this._buff, this._buffLen), this._buffLen > 56 && (this._step(), er(this._buff));
    const e = 8 * this._totalLen;
    this._buffDV.setUint32(56, Math.floor(e / 4294967296), !1), this._buffDV.setUint32(60, e % 4294967296, !1), this._step();
  }
  _step() {
    const e = so._bigBlock32, n = this._buffDV;
    for (let h = 0; h < 64; h += 4)
      e.setUint32(h, n.getUint32(h, !1), !1);
    for (let h = 64; h < 320; h += 4)
      e.setUint32(h, Tn(e.getUint32(h - 12, !1) ^ e.getUint32(h - 32, !1) ^ e.getUint32(h - 56, !1) ^ e.getUint32(h - 64, !1), 1), !1);
    let i = this._h0, r = this._h1, s = this._h2, a = this._h3, o = this._h4, l, c, d;
    for (let h = 0; h < 80; h++)
      h < 20 ? (l = r & s | ~r & a, c = 1518500249) : h < 40 ? (l = r ^ s ^ a, c = 1859775393) : h < 60 ? (l = r & s | r & a | s & a, c = 2400959708) : (l = r ^ s ^ a, c = 3395469782), d = Tn(i, 5) + l + o + c + e.getUint32(h * 4, !1) & 4294967295, o = a, a = s, s = Tn(r, 30), r = i, i = d;
    this._h0 = this._h0 + i & 4294967295, this._h1 = this._h1 + r & 4294967295, this._h2 = this._h2 + s & 4294967295, this._h3 = this._h3 + a & 4294967295, this._h4 = this._h4 + o & 4294967295;
  }
}
class tr {
  constructor(e) {
    this.source = e;
  }
  getElements() {
    const e = this.source, n = new Int32Array(e.length);
    for (let i = 0, r = e.length; i < r; i++)
      n[i] = e.charCodeAt(i);
    return n;
  }
}
function Yu(t, e, n) {
  return new Ge(new tr(t), new tr(e)).ComputeDiff(n).changes;
}
class at {
  static Assert(e, n) {
    if (!e)
      throw new Error(n);
  }
}
class ot {
  /**
   * Copies a range of elements from an Array starting at the specified source index and pastes
   * them to another Array starting at the specified destination index. The length and the indexes
   * are specified as 64-bit integers.
   * sourceArray:
   *		The Array that contains the data to copy.
   * sourceIndex:
   *		A 64-bit integer that represents the index in the sourceArray at which copying begins.
   * destinationArray:
   *		The Array that receives the data.
   * destinationIndex:
   *		A 64-bit integer that represents the index in the destinationArray at which storing begins.
   * length:
   *		A 64-bit integer that represents the number of elements to copy.
   */
  static Copy(e, n, i, r, s) {
    for (let a = 0; a < s; a++)
      i[r + a] = e[n + a];
  }
  static Copy2(e, n, i, r, s) {
    for (let a = 0; a < s; a++)
      i[r + a] = e[n + a];
  }
}
class nr {
  /**
   * Constructs a new DiffChangeHelper for the given DiffSequences.
   */
  constructor() {
    this.m_changes = [], this.m_originalStart = 1073741824, this.m_modifiedStart = 1073741824, this.m_originalCount = 0, this.m_modifiedCount = 0;
  }
  /**
   * Marks the beginning of the next change in the set of differences.
   */
  MarkNextChange() {
    (this.m_originalCount > 0 || this.m_modifiedCount > 0) && this.m_changes.push(new He(this.m_originalStart, this.m_originalCount, this.m_modifiedStart, this.m_modifiedCount)), this.m_originalCount = 0, this.m_modifiedCount = 0, this.m_originalStart = 1073741824, this.m_modifiedStart = 1073741824;
  }
  /**
   * Adds the original element at the given position to the elements
   * affected by the current change. The modified index gives context
   * to the change position with respect to the original sequence.
   * @param originalIndex The index of the original element to add.
   * @param modifiedIndex The index of the modified element that provides corresponding position in the modified sequence.
   */
  AddOriginalElement(e, n) {
    this.m_originalStart = Math.min(this.m_originalStart, e), this.m_modifiedStart = Math.min(this.m_modifiedStart, n), this.m_originalCount++;
  }
  /**
   * Adds the modified element at the given position to the elements
   * affected by the current change. The original index gives context
   * to the change position with respect to the modified sequence.
   * @param originalIndex The index of the original element that provides corresponding position in the original sequence.
   * @param modifiedIndex The index of the modified element to add.
   */
  AddModifiedElement(e, n) {
    this.m_originalStart = Math.min(this.m_originalStart, e), this.m_modifiedStart = Math.min(this.m_modifiedStart, n), this.m_modifiedCount++;
  }
  /**
   * Retrieves all of the changes marked by the class.
   */
  getChanges() {
    return (this.m_originalCount > 0 || this.m_modifiedCount > 0) && this.MarkNextChange(), this.m_changes;
  }
  /**
   * Retrieves all of the changes marked by the class in the reverse order
   */
  getReverseChanges() {
    return (this.m_originalCount > 0 || this.m_modifiedCount > 0) && this.MarkNextChange(), this.m_changes.reverse(), this.m_changes;
  }
}
class Ge {
  /**
   * Constructs the DiffFinder
   */
  constructor(e, n, i = null) {
    this.ContinueProcessingPredicate = i, this._originalSequence = e, this._modifiedSequence = n;
    const [r, s, a] = Ge._getElements(e), [o, l, c] = Ge._getElements(n);
    this._hasStrings = a && c, this._originalStringElements = r, this._originalElementsOrHash = s, this._modifiedStringElements = o, this._modifiedElementsOrHash = l, this.m_forwardHistory = [], this.m_reverseHistory = [];
  }
  static _isStringArray(e) {
    return e.length > 0 && typeof e[0] == "string";
  }
  static _getElements(e) {
    const n = e.getElements();
    if (Ge._isStringArray(n)) {
      const i = new Int32Array(n.length);
      for (let r = 0, s = n.length; r < s; r++)
        i[r] = Ju(n[r], 0);
      return [n, i, !0];
    }
    return n instanceof Int32Array ? [[], n, !1] : [[], new Int32Array(n), !1];
  }
  ElementsAreEqual(e, n) {
    return this._originalElementsOrHash[e] !== this._modifiedElementsOrHash[n] ? !1 : this._hasStrings ? this._originalStringElements[e] === this._modifiedStringElements[n] : !0;
  }
  ElementsAreStrictEqual(e, n) {
    if (!this.ElementsAreEqual(e, n))
      return !1;
    const i = Ge._getStrictElement(this._originalSequence, e), r = Ge._getStrictElement(this._modifiedSequence, n);
    return i === r;
  }
  static _getStrictElement(e, n) {
    return typeof e.getStrictElement == "function" ? e.getStrictElement(n) : null;
  }
  OriginalElementsAreEqual(e, n) {
    return this._originalElementsOrHash[e] !== this._originalElementsOrHash[n] ? !1 : this._hasStrings ? this._originalStringElements[e] === this._originalStringElements[n] : !0;
  }
  ModifiedElementsAreEqual(e, n) {
    return this._modifiedElementsOrHash[e] !== this._modifiedElementsOrHash[n] ? !1 : this._hasStrings ? this._modifiedStringElements[e] === this._modifiedStringElements[n] : !0;
  }
  ComputeDiff(e) {
    return this._ComputeDiff(0, this._originalElementsOrHash.length - 1, 0, this._modifiedElementsOrHash.length - 1, e);
  }
  /**
   * Computes the differences between the original and modified input
   * sequences on the bounded range.
   * @returns An array of the differences between the two input sequences.
   */
  _ComputeDiff(e, n, i, r, s) {
    const a = [!1];
    let o = this.ComputeDiffRecursive(e, n, i, r, a);
    return s && (o = this.PrettifyChanges(o)), {
      quitEarly: a[0],
      changes: o
    };
  }
  /**
   * Private helper method which computes the differences on the bounded range
   * recursively.
   * @returns An array of the differences between the two input sequences.
   */
  ComputeDiffRecursive(e, n, i, r, s) {
    for (s[0] = !1; e <= n && i <= r && this.ElementsAreEqual(e, i); )
      e++, i++;
    for (; n >= e && r >= i && this.ElementsAreEqual(n, r); )
      n--, r--;
    if (e > n || i > r) {
      let h;
      return i <= r ? (at.Assert(e === n + 1, "originalStart should only be one more than originalEnd"), h = [
        new He(e, 0, i, r - i + 1)
      ]) : e <= n ? (at.Assert(i === r + 1, "modifiedStart should only be one more than modifiedEnd"), h = [
        new He(e, n - e + 1, i, 0)
      ]) : (at.Assert(e === n + 1, "originalStart should only be one more than originalEnd"), at.Assert(i === r + 1, "modifiedStart should only be one more than modifiedEnd"), h = []), h;
    }
    const a = [0], o = [0], l = this.ComputeRecursionPoint(e, n, i, r, a, o, s), c = a[0], d = o[0];
    if (l !== null)
      return l;
    if (!s[0]) {
      const h = this.ComputeDiffRecursive(e, c, i, d, s);
      let f = [];
      return s[0] ? f = [
        new He(c + 1, n - (c + 1) + 1, d + 1, r - (d + 1) + 1)
      ] : f = this.ComputeDiffRecursive(c + 1, n, d + 1, r, s), this.ConcatenateChanges(h, f);
    }
    return [
      new He(e, n - e + 1, i, r - i + 1)
    ];
  }
  WALKTRACE(e, n, i, r, s, a, o, l, c, d, h, f, m, b, D, E, L, _) {
    let v = null, C = null, x = new nr(), w = n, N = i, B = m[0] - E[0] - r, j = -1073741824, ue = this.m_forwardHistory.length - 1;
    do {
      const G = B + e;
      G === w || G < N && c[G - 1] < c[G + 1] ? (h = c[G + 1], b = h - B - r, h < j && x.MarkNextChange(), j = h, x.AddModifiedElement(h + 1, b), B = G + 1 - e) : (h = c[G - 1] + 1, b = h - B - r, h < j && x.MarkNextChange(), j = h - 1, x.AddOriginalElement(h, b + 1), B = G - 1 - e), ue >= 0 && (c = this.m_forwardHistory[ue], e = c[0], w = 1, N = c.length - 1);
    } while (--ue >= -1);
    if (v = x.getReverseChanges(), _[0]) {
      let G = m[0] + 1, U = E[0] + 1;
      if (v !== null && v.length > 0) {
        const y = v[v.length - 1];
        G = Math.max(G, y.getOriginalEnd()), U = Math.max(U, y.getModifiedEnd());
      }
      C = [
        new He(G, f - G + 1, U, D - U + 1)
      ];
    } else {
      x = new nr(), w = a, N = o, B = m[0] - E[0] - l, j = 1073741824, ue = L ? this.m_reverseHistory.length - 1 : this.m_reverseHistory.length - 2;
      do {
        const G = B + s;
        G === w || G < N && d[G - 1] >= d[G + 1] ? (h = d[G + 1] - 1, b = h - B - l, h > j && x.MarkNextChange(), j = h + 1, x.AddOriginalElement(h + 1, b + 1), B = G + 1 - s) : (h = d[G - 1], b = h - B - l, h > j && x.MarkNextChange(), j = h, x.AddModifiedElement(h + 1, b + 1), B = G - 1 - s), ue >= 0 && (d = this.m_reverseHistory[ue], s = d[0], w = 1, N = d.length - 1);
      } while (--ue >= -1);
      C = x.getChanges();
    }
    return this.ConcatenateChanges(v, C);
  }
  /**
   * Given the range to compute the diff on, this method finds the point:
   * (midOriginal, midModified)
   * that exists in the middle of the LCS of the two sequences and
   * is the point at which the LCS problem may be broken down recursively.
   * This method will try to keep the LCS trace in memory. If the LCS recursion
   * point is calculated and the full trace is available in memory, then this method
   * will return the change list.
   * @param originalStart The start bound of the original sequence range
   * @param originalEnd The end bound of the original sequence range
   * @param modifiedStart The start bound of the modified sequence range
   * @param modifiedEnd The end bound of the modified sequence range
   * @param midOriginal The middle point of the original sequence range
   * @param midModified The middle point of the modified sequence range
   * @returns The diff changes, if available, otherwise null
   */
  ComputeRecursionPoint(e, n, i, r, s, a, o) {
    let l = 0, c = 0, d = 0, h = 0, f = 0, m = 0;
    e--, i--, s[0] = 0, a[0] = 0, this.m_forwardHistory = [], this.m_reverseHistory = [];
    const b = n - e + (r - i), D = b + 1, E = new Int32Array(D), L = new Int32Array(D), _ = r - i, v = n - e, C = e - i, x = n - r, N = (v - _) % 2 === 0;
    E[_] = e, L[v] = n, o[0] = !1;
    for (let B = 1; B <= b / 2 + 1; B++) {
      let j = 0, ue = 0;
      d = this.ClipDiagonalBound(_ - B, B, _, D), h = this.ClipDiagonalBound(_ + B, B, _, D);
      for (let U = d; U <= h; U += 2) {
        U === d || U < h && E[U - 1] < E[U + 1] ? l = E[U + 1] : l = E[U - 1] + 1, c = l - (U - _) - C;
        const y = l;
        for (; l < n && c < r && this.ElementsAreEqual(l + 1, c + 1); )
          l++, c++;
        if (E[U] = l, l + c > j + ue && (j = l, ue = c), !N && Math.abs(U - v) <= B - 1 && l >= L[U])
          return s[0] = l, a[0] = c, y <= L[U] && B <= 1448 ? this.WALKTRACE(_, d, h, C, v, f, m, x, E, L, l, n, s, c, r, a, N, o) : null;
      }
      const G = (j - e + (ue - i) - B) / 2;
      if (this.ContinueProcessingPredicate !== null && !this.ContinueProcessingPredicate(j, G))
        return o[0] = !0, s[0] = j, a[0] = ue, G > 0 && B <= 1448 ? this.WALKTRACE(_, d, h, C, v, f, m, x, E, L, l, n, s, c, r, a, N, o) : (e++, i++, [
          new He(e, n - e + 1, i, r - i + 1)
        ]);
      f = this.ClipDiagonalBound(v - B, B, v, D), m = this.ClipDiagonalBound(v + B, B, v, D);
      for (let U = f; U <= m; U += 2) {
        U === f || U < m && L[U - 1] >= L[U + 1] ? l = L[U + 1] - 1 : l = L[U - 1], c = l - (U - v) - x;
        const y = l;
        for (; l > e && c > i && this.ElementsAreEqual(l, c); )
          l--, c--;
        if (L[U] = l, N && Math.abs(U - _) <= B && l <= E[U])
          return s[0] = l, a[0] = c, y >= E[U] && B <= 1448 ? this.WALKTRACE(_, d, h, C, v, f, m, x, E, L, l, n, s, c, r, a, N, o) : null;
      }
      if (B <= 1447) {
        let U = new Int32Array(h - d + 2);
        U[0] = _ - d + 1, ot.Copy2(E, d, U, 1, h - d + 1), this.m_forwardHistory.push(U), U = new Int32Array(m - f + 2), U[0] = v - f + 1, ot.Copy2(L, f, U, 1, m - f + 1), this.m_reverseHistory.push(U);
      }
    }
    return this.WALKTRACE(_, d, h, C, v, f, m, x, E, L, l, n, s, c, r, a, N, o);
  }
  /**
   * Shifts the given changes to provide a more intuitive diff.
   * While the first element in a diff matches the first element after the diff,
   * we shift the diff down.
   *
   * @param changes The list of changes to shift
   * @returns The shifted changes
   */
  PrettifyChanges(e) {
    for (let n = 0; n < e.length; n++) {
      const i = e[n], r = n < e.length - 1 ? e[n + 1].originalStart : this._originalElementsOrHash.length, s = n < e.length - 1 ? e[n + 1].modifiedStart : this._modifiedElementsOrHash.length, a = i.originalLength > 0, o = i.modifiedLength > 0;
      for (; i.originalStart + i.originalLength < r && i.modifiedStart + i.modifiedLength < s && (!a || this.OriginalElementsAreEqual(i.originalStart, i.originalStart + i.originalLength)) && (!o || this.ModifiedElementsAreEqual(i.modifiedStart, i.modifiedStart + i.modifiedLength)); ) {
        const c = this.ElementsAreStrictEqual(i.originalStart, i.modifiedStart);
        if (this.ElementsAreStrictEqual(i.originalStart + i.originalLength, i.modifiedStart + i.modifiedLength) && !c)
          break;
        i.originalStart++, i.modifiedStart++;
      }
      const l = [null];
      if (n < e.length - 1 && this.ChangesOverlap(e[n], e[n + 1], l)) {
        e[n] = l[0], e.splice(n + 1, 1), n--;
        continue;
      }
    }
    for (let n = e.length - 1; n >= 0; n--) {
      const i = e[n];
      let r = 0, s = 0;
      if (n > 0) {
        const h = e[n - 1];
        r = h.originalStart + h.originalLength, s = h.modifiedStart + h.modifiedLength;
      }
      const a = i.originalLength > 0, o = i.modifiedLength > 0;
      let l = 0, c = this._boundaryScore(i.originalStart, i.originalLength, i.modifiedStart, i.modifiedLength);
      for (let h = 1; ; h++) {
        const f = i.originalStart - h, m = i.modifiedStart - h;
        if (f < r || m < s || a && !this.OriginalElementsAreEqual(f, f + i.originalLength) || o && !this.ModifiedElementsAreEqual(m, m + i.modifiedLength))
          break;
        const D = (f === r && m === s ? 5 : 0) + this._boundaryScore(f, i.originalLength, m, i.modifiedLength);
        D > c && (c = D, l = h);
      }
      i.originalStart -= l, i.modifiedStart -= l;
      const d = [null];
      if (n > 0 && this.ChangesOverlap(e[n - 1], e[n], d)) {
        e[n - 1] = d[0], e.splice(n, 1), n++;
        continue;
      }
    }
    if (this._hasStrings)
      for (let n = 1, i = e.length; n < i; n++) {
        const r = e[n - 1], s = e[n], a = s.originalStart - r.originalStart - r.originalLength, o = r.originalStart, l = s.originalStart + s.originalLength, c = l - o, d = r.modifiedStart, h = s.modifiedStart + s.modifiedLength, f = h - d;
        if (a < 5 && c < 20 && f < 20) {
          const m = this._findBetterContiguousSequence(o, c, d, f, a);
          if (m) {
            const [b, D] = m;
            (b !== r.originalStart + r.originalLength || D !== r.modifiedStart + r.modifiedLength) && (r.originalLength = b - r.originalStart, r.modifiedLength = D - r.modifiedStart, s.originalStart = b + a, s.modifiedStart = D + a, s.originalLength = l - s.originalStart, s.modifiedLength = h - s.modifiedStart);
          }
        }
      }
    return e;
  }
  _findBetterContiguousSequence(e, n, i, r, s) {
    if (n < s || r < s)
      return null;
    const a = e + n - s + 1, o = i + r - s + 1;
    let l = 0, c = 0, d = 0;
    for (let h = e; h < a; h++)
      for (let f = i; f < o; f++) {
        const m = this._contiguousSequenceScore(h, f, s);
        m > 0 && m > l && (l = m, c = h, d = f);
      }
    return l > 0 ? [c, d] : null;
  }
  _contiguousSequenceScore(e, n, i) {
    let r = 0;
    for (let s = 0; s < i; s++) {
      if (!this.ElementsAreEqual(e + s, n + s))
        return 0;
      r += this._originalStringElements[e + s].length;
    }
    return r;
  }
  _OriginalIsBoundary(e) {
    return e <= 0 || e >= this._originalElementsOrHash.length - 1 ? !0 : this._hasStrings && /^\s*$/.test(this._originalStringElements[e]);
  }
  _OriginalRegionIsBoundary(e, n) {
    if (this._OriginalIsBoundary(e) || this._OriginalIsBoundary(e - 1))
      return !0;
    if (n > 0) {
      const i = e + n;
      if (this._OriginalIsBoundary(i - 1) || this._OriginalIsBoundary(i))
        return !0;
    }
    return !1;
  }
  _ModifiedIsBoundary(e) {
    return e <= 0 || e >= this._modifiedElementsOrHash.length - 1 ? !0 : this._hasStrings && /^\s*$/.test(this._modifiedStringElements[e]);
  }
  _ModifiedRegionIsBoundary(e, n) {
    if (this._ModifiedIsBoundary(e) || this._ModifiedIsBoundary(e - 1))
      return !0;
    if (n > 0) {
      const i = e + n;
      if (this._ModifiedIsBoundary(i - 1) || this._ModifiedIsBoundary(i))
        return !0;
    }
    return !1;
  }
  _boundaryScore(e, n, i, r) {
    const s = this._OriginalRegionIsBoundary(e, n) ? 1 : 0, a = this._ModifiedRegionIsBoundary(i, r) ? 1 : 0;
    return s + a;
  }
  /**
   * Concatenates the two input DiffChange lists and returns the resulting
   * list.
   * @param The left changes
   * @param The right changes
   * @returns The concatenated list
   */
  ConcatenateChanges(e, n) {
    const i = [];
    if (e.length === 0 || n.length === 0)
      return n.length > 0 ? n : e;
    if (this.ChangesOverlap(e[e.length - 1], n[0], i)) {
      const r = new Array(e.length + n.length - 1);
      return ot.Copy(e, 0, r, 0, e.length - 1), r[e.length - 1] = i[0], ot.Copy(n, 1, r, e.length, n.length - 1), r;
    } else {
      const r = new Array(e.length + n.length);
      return ot.Copy(e, 0, r, 0, e.length), ot.Copy(n, 0, r, e.length, n.length), r;
    }
  }
  /**
   * Returns true if the two changes overlap and can be merged into a single
   * change
   * @param left The left change
   * @param right The right change
   * @param mergedChange The merged change if the two overlap, null otherwise
   * @returns True if the two changes overlap
   */
  ChangesOverlap(e, n, i) {
    if (at.Assert(e.originalStart <= n.originalStart, "Left change is not less than or equal to right change"), at.Assert(e.modifiedStart <= n.modifiedStart, "Left change is not less than or equal to right change"), e.originalStart + e.originalLength >= n.originalStart || e.modifiedStart + e.modifiedLength >= n.modifiedStart) {
      const r = e.originalStart;
      let s = e.originalLength;
      const a = e.modifiedStart;
      let o = e.modifiedLength;
      return e.originalStart + e.originalLength >= n.originalStart && (s = n.originalStart + n.originalLength - e.originalStart), e.modifiedStart + e.modifiedLength >= n.modifiedStart && (o = n.modifiedStart + n.modifiedLength - e.modifiedStart), i[0] = new He(r, s, a, o), !0;
    } else
      return i[0] = null, !1;
  }
  /**
   * Helper method used to clip a diagonal index to the range of valid
   * diagonals. This also decides whether or not the diagonal index,
   * if it exceeds the boundary, should be clipped to the boundary or clipped
   * one inside the boundary depending on the Even/Odd status of the boundary
   * and numDifferences.
   * @param diagonal The index of the diagonal to clip.
   * @param numDifferences The current number of differences being iterated upon.
   * @param diagonalBaseIndex The base reference diagonal.
   * @param numDiagonals The total number of diagonals.
   * @returns The clipped diagonal index.
   */
  ClipDiagonalBound(e, n, i, r) {
    if (e >= 0 && e < r)
      return e;
    const s = i, a = r - i - 1, o = n % 2 === 0;
    if (e < 0) {
      const l = s % 2 === 0;
      return o === l ? 0 : 1;
    } else {
      const l = a % 2 === 0;
      return o === l ? r - 1 : r - 2;
    }
  }
}
let ne = class Ze {
  constructor(e, n) {
    this.lineNumber = e, this.column = n;
  }
  /**
   * Create a new position from this position.
   *
   * @param newLineNumber new line number
   * @param newColumn new column
   */
  with(e = this.lineNumber, n = this.column) {
    return e === this.lineNumber && n === this.column ? this : new Ze(e, n);
  }
  /**
   * Derive a new position from this position.
   *
   * @param deltaLineNumber line number delta
   * @param deltaColumn column delta
   */
  delta(e = 0, n = 0) {
    return this.with(this.lineNumber + e, this.column + n);
  }
  /**
   * Test if this position equals other position
   */
  equals(e) {
    return Ze.equals(this, e);
  }
  /**
   * Test if position `a` equals position `b`
   */
  static equals(e, n) {
    return !e && !n ? !0 : !!e && !!n && e.lineNumber === n.lineNumber && e.column === n.column;
  }
  /**
   * Test if this position is before other position.
   * If the two positions are equal, the result will be false.
   */
  isBefore(e) {
    return Ze.isBefore(this, e);
  }
  /**
   * Test if position `a` is before position `b`.
   * If the two positions are equal, the result will be false.
   */
  static isBefore(e, n) {
    return e.lineNumber < n.lineNumber ? !0 : n.lineNumber < e.lineNumber ? !1 : e.column < n.column;
  }
  /**
   * Test if this position is before other position.
   * If the two positions are equal, the result will be true.
   */
  isBeforeOrEqual(e) {
    return Ze.isBeforeOrEqual(this, e);
  }
  /**
   * Test if position `a` is before position `b`.
   * If the two positions are equal, the result will be true.
   */
  static isBeforeOrEqual(e, n) {
    return e.lineNumber < n.lineNumber ? !0 : n.lineNumber < e.lineNumber ? !1 : e.column <= n.column;
  }
  /**
   * A function that compares positions, useful for sorting
   */
  static compare(e, n) {
    const i = e.lineNumber | 0, r = n.lineNumber | 0;
    if (i === r) {
      const s = e.column | 0, a = n.column | 0;
      return s - a;
    }
    return i - r;
  }
  /**
   * Clone this position.
   */
  clone() {
    return new Ze(this.lineNumber, this.column);
  }
  /**
   * Convert to a human-readable representation.
   */
  toString() {
    return "(" + this.lineNumber + "," + this.column + ")";
  }
  // ---
  /**
   * Create a `Position` from an `IPosition`.
   */
  static lift(e) {
    return new Ze(e.lineNumber, e.column);
  }
  /**
   * Test if `obj` is an `IPosition`.
   */
  static isIPosition(e) {
    return e && typeof e.lineNumber == "number" && typeof e.column == "number";
  }
  toJSON() {
    return {
      lineNumber: this.lineNumber,
      column: this.column
    };
  }
}, H = class ie {
  constructor(e, n, i, r) {
    e > i || e === i && n > r ? (this.startLineNumber = i, this.startColumn = r, this.endLineNumber = e, this.endColumn = n) : (this.startLineNumber = e, this.startColumn = n, this.endLineNumber = i, this.endColumn = r);
  }
  /**
   * Test if this range is empty.
   */
  isEmpty() {
    return ie.isEmpty(this);
  }
  /**
   * Test if `range` is empty.
   */
  static isEmpty(e) {
    return e.startLineNumber === e.endLineNumber && e.startColumn === e.endColumn;
  }
  /**
   * Test if position is in this range. If the position is at the edges, will return true.
   */
  containsPosition(e) {
    return ie.containsPosition(this, e);
  }
  /**
   * Test if `position` is in `range`. If the position is at the edges, will return true.
   */
  static containsPosition(e, n) {
    return !(n.lineNumber < e.startLineNumber || n.lineNumber > e.endLineNumber || n.lineNumber === e.startLineNumber && n.column < e.startColumn || n.lineNumber === e.endLineNumber && n.column > e.endColumn);
  }
  /**
   * Test if `position` is in `range`. If the position is at the edges, will return false.
   * @internal
   */
  static strictContainsPosition(e, n) {
    return !(n.lineNumber < e.startLineNumber || n.lineNumber > e.endLineNumber || n.lineNumber === e.startLineNumber && n.column <= e.startColumn || n.lineNumber === e.endLineNumber && n.column >= e.endColumn);
  }
  /**
   * Test if range is in this range. If the range is equal to this range, will return true.
   */
  containsRange(e) {
    return ie.containsRange(this, e);
  }
  /**
   * Test if `otherRange` is in `range`. If the ranges are equal, will return true.
   */
  static containsRange(e, n) {
    return !(n.startLineNumber < e.startLineNumber || n.endLineNumber < e.startLineNumber || n.startLineNumber > e.endLineNumber || n.endLineNumber > e.endLineNumber || n.startLineNumber === e.startLineNumber && n.startColumn < e.startColumn || n.endLineNumber === e.endLineNumber && n.endColumn > e.endColumn);
  }
  /**
   * Test if `range` is strictly in this range. `range` must start after and end before this range for the result to be true.
   */
  strictContainsRange(e) {
    return ie.strictContainsRange(this, e);
  }
  /**
   * Test if `otherRange` is strictly in `range` (must start after, and end before). If the ranges are equal, will return false.
   */
  static strictContainsRange(e, n) {
    return !(n.startLineNumber < e.startLineNumber || n.endLineNumber < e.startLineNumber || n.startLineNumber > e.endLineNumber || n.endLineNumber > e.endLineNumber || n.startLineNumber === e.startLineNumber && n.startColumn <= e.startColumn || n.endLineNumber === e.endLineNumber && n.endColumn >= e.endColumn);
  }
  /**
   * A reunion of the two ranges.
   * The smallest position will be used as the start point, and the largest one as the end point.
   */
  plusRange(e) {
    return ie.plusRange(this, e);
  }
  /**
   * A reunion of the two ranges.
   * The smallest position will be used as the start point, and the largest one as the end point.
   */
  static plusRange(e, n) {
    let i, r, s, a;
    return n.startLineNumber < e.startLineNumber ? (i = n.startLineNumber, r = n.startColumn) : n.startLineNumber === e.startLineNumber ? (i = n.startLineNumber, r = Math.min(n.startColumn, e.startColumn)) : (i = e.startLineNumber, r = e.startColumn), n.endLineNumber > e.endLineNumber ? (s = n.endLineNumber, a = n.endColumn) : n.endLineNumber === e.endLineNumber ? (s = n.endLineNumber, a = Math.max(n.endColumn, e.endColumn)) : (s = e.endLineNumber, a = e.endColumn), new ie(i, r, s, a);
  }
  /**
   * A intersection of the two ranges.
   */
  intersectRanges(e) {
    return ie.intersectRanges(this, e);
  }
  /**
   * A intersection of the two ranges.
   */
  static intersectRanges(e, n) {
    let i = e.startLineNumber, r = e.startColumn, s = e.endLineNumber, a = e.endColumn;
    const o = n.startLineNumber, l = n.startColumn, c = n.endLineNumber, d = n.endColumn;
    return i < o ? (i = o, r = l) : i === o && (r = Math.max(r, l)), s > c ? (s = c, a = d) : s === c && (a = Math.min(a, d)), i > s || i === s && r > a ? null : new ie(i, r, s, a);
  }
  /**
   * Test if this range equals other.
   */
  equalsRange(e) {
    return ie.equalsRange(this, e);
  }
  /**
   * Test if range `a` equals `b`.
   */
  static equalsRange(e, n) {
    return !e && !n ? !0 : !!e && !!n && e.startLineNumber === n.startLineNumber && e.startColumn === n.startColumn && e.endLineNumber === n.endLineNumber && e.endColumn === n.endColumn;
  }
  /**
   * Return the end position (which will be after or equal to the start position)
   */
  getEndPosition() {
    return ie.getEndPosition(this);
  }
  /**
   * Return the end position (which will be after or equal to the start position)
   */
  static getEndPosition(e) {
    return new ne(e.endLineNumber, e.endColumn);
  }
  /**
   * Return the start position (which will be before or equal to the end position)
   */
  getStartPosition() {
    return ie.getStartPosition(this);
  }
  /**
   * Return the start position (which will be before or equal to the end position)
   */
  static getStartPosition(e) {
    return new ne(e.startLineNumber, e.startColumn);
  }
  /**
   * Transform to a user presentable string representation.
   */
  toString() {
    return "[" + this.startLineNumber + "," + this.startColumn + " -> " + this.endLineNumber + "," + this.endColumn + "]";
  }
  /**
   * Create a new range using this range's start position, and using endLineNumber and endColumn as the end position.
   */
  setEndPosition(e, n) {
    return new ie(this.startLineNumber, this.startColumn, e, n);
  }
  /**
   * Create a new range using this range's end position, and using startLineNumber and startColumn as the start position.
   */
  setStartPosition(e, n) {
    return new ie(e, n, this.endLineNumber, this.endColumn);
  }
  /**
   * Create a new empty range using this range's start position.
   */
  collapseToStart() {
    return ie.collapseToStart(this);
  }
  /**
   * Create a new empty range using this range's start position.
   */
  static collapseToStart(e) {
    return new ie(e.startLineNumber, e.startColumn, e.startLineNumber, e.startColumn);
  }
  /**
   * Create a new empty range using this range's end position.
   */
  collapseToEnd() {
    return ie.collapseToEnd(this);
  }
  /**
   * Create a new empty range using this range's end position.
   */
  static collapseToEnd(e) {
    return new ie(e.endLineNumber, e.endColumn, e.endLineNumber, e.endColumn);
  }
  /**
   * Moves the range by the given amount of lines.
   */
  delta(e) {
    return new ie(this.startLineNumber + e, this.startColumn, this.endLineNumber + e, this.endColumn);
  }
  // ---
  static fromPositions(e, n = e) {
    return new ie(e.lineNumber, e.column, n.lineNumber, n.column);
  }
  static lift(e) {
    return e ? new ie(e.startLineNumber, e.startColumn, e.endLineNumber, e.endColumn) : null;
  }
  /**
   * Test if `obj` is an `IRange`.
   */
  static isIRange(e) {
    return e && typeof e.startLineNumber == "number" && typeof e.startColumn == "number" && typeof e.endLineNumber == "number" && typeof e.endColumn == "number";
  }
  /**
   * Test if the two ranges are touching in any way.
   */
  static areIntersectingOrTouching(e, n) {
    return !(e.endLineNumber < n.startLineNumber || e.endLineNumber === n.startLineNumber && e.endColumn < n.startColumn || n.endLineNumber < e.startLineNumber || n.endLineNumber === e.startLineNumber && n.endColumn < e.startColumn);
  }
  /**
   * Test if the two ranges are intersecting. If the ranges are touching it returns true.
   */
  static areIntersecting(e, n) {
    return !(e.endLineNumber < n.startLineNumber || e.endLineNumber === n.startLineNumber && e.endColumn <= n.startColumn || n.endLineNumber < e.startLineNumber || n.endLineNumber === e.startLineNumber && n.endColumn <= e.startColumn);
  }
  /**
   * A function that compares ranges, useful for sorting ranges
   * It will first compare ranges on the startPosition and then on the endPosition
   */
  static compareRangesUsingStarts(e, n) {
    if (e && n) {
      const s = e.startLineNumber | 0, a = n.startLineNumber | 0;
      if (s === a) {
        const o = e.startColumn | 0, l = n.startColumn | 0;
        if (o === l) {
          const c = e.endLineNumber | 0, d = n.endLineNumber | 0;
          if (c === d) {
            const h = e.endColumn | 0, f = n.endColumn | 0;
            return h - f;
          }
          return c - d;
        }
        return o - l;
      }
      return s - a;
    }
    return (e ? 1 : 0) - (n ? 1 : 0);
  }
  /**
   * A function that compares ranges, useful for sorting ranges
   * It will first compare ranges on the endPosition and then on the startPosition
   */
  static compareRangesUsingEnds(e, n) {
    return e.endLineNumber === n.endLineNumber ? e.endColumn === n.endColumn ? e.startLineNumber === n.startLineNumber ? e.startColumn - n.startColumn : e.startLineNumber - n.startLineNumber : e.endColumn - n.endColumn : e.endLineNumber - n.endLineNumber;
  }
  /**
   * Test if the range spans multiple lines.
   */
  static spansMultipleLines(e) {
    return e.endLineNumber > e.startLineNumber;
  }
  toJSON() {
    return this;
  }
};
function ir(t) {
  return t < 0 ? 0 : t > 255 ? 255 : t | 0;
}
function ut(t) {
  return t < 0 ? 0 : t > 4294967295 ? 4294967295 : t | 0;
}
class Mi {
  constructor(e) {
    const n = ir(e);
    this._defaultValue = n, this._asciiMap = Mi._createAsciiMap(n), this._map = /* @__PURE__ */ new Map();
  }
  static _createAsciiMap(e) {
    const n = new Uint8Array(256);
    return n.fill(e), n;
  }
  set(e, n) {
    const i = ir(n);
    e >= 0 && e < 256 ? this._asciiMap[e] = i : this._map.set(e, i);
  }
  get(e) {
    return e >= 0 && e < 256 ? this._asciiMap[e] : this._map.get(e) || this._defaultValue;
  }
  clear() {
    this._asciiMap.fill(this._defaultValue), this._map.clear();
  }
}
class Zu {
  constructor(e, n, i) {
    const r = new Uint8Array(e * n);
    for (let s = 0, a = e * n; s < a; s++)
      r[s] = i;
    this._data = r, this.rows = e, this.cols = n;
  }
  get(e, n) {
    return this._data[e * this.cols + n];
  }
  set(e, n, i) {
    this._data[e * this.cols + n] = i;
  }
}
class Ku {
  constructor(e) {
    let n = 0, i = 0;
    for (let s = 0, a = e.length; s < a; s++) {
      const [o, l, c] = e[s];
      l > n && (n = l), o > i && (i = o), c > i && (i = c);
    }
    n++, i++;
    const r = new Zu(
      i,
      n,
      0
      /* State.Invalid */
    );
    for (let s = 0, a = e.length; s < a; s++) {
      const [o, l, c] = e[s];
      r.set(o, l, c);
    }
    this._states = r, this._maxCharCode = n;
  }
  nextState(e, n) {
    return n < 0 || n >= this._maxCharCode ? 0 : this._states.get(e, n);
  }
}
let Un = null;
function el() {
  return Un === null && (Un = new Ku([
    [
      1,
      104,
      2
      /* State.H */
    ],
    [
      1,
      72,
      2
      /* State.H */
    ],
    [
      1,
      102,
      6
      /* State.F */
    ],
    [
      1,
      70,
      6
      /* State.F */
    ],
    [
      2,
      116,
      3
      /* State.HT */
    ],
    [
      2,
      84,
      3
      /* State.HT */
    ],
    [
      3,
      116,
      4
      /* State.HTT */
    ],
    [
      3,
      84,
      4
      /* State.HTT */
    ],
    [
      4,
      112,
      5
      /* State.HTTP */
    ],
    [
      4,
      80,
      5
      /* State.HTTP */
    ],
    [
      5,
      115,
      9
      /* State.BeforeColon */
    ],
    [
      5,
      83,
      9
      /* State.BeforeColon */
    ],
    [
      5,
      58,
      10
      /* State.AfterColon */
    ],
    [
      6,
      105,
      7
      /* State.FI */
    ],
    [
      6,
      73,
      7
      /* State.FI */
    ],
    [
      7,
      108,
      8
      /* State.FIL */
    ],
    [
      7,
      76,
      8
      /* State.FIL */
    ],
    [
      8,
      101,
      9
      /* State.BeforeColon */
    ],
    [
      8,
      69,
      9
      /* State.BeforeColon */
    ],
    [
      9,
      58,
      10
      /* State.AfterColon */
    ],
    [
      10,
      47,
      11
      /* State.AlmostThere */
    ],
    [
      11,
      47,
      12
      /* State.End */
    ]
  ])), Un;
}
let vt = null;
function tl() {
  if (vt === null) {
    vt = new Mi(
      0
      /* CharacterClass.None */
    );
    const t = ` 	<>'"、。｡､，．：；‘〈「『〔（［｛｢｣｝］）〕』」〉’｀～…`;
    for (let n = 0; n < t.length; n++)
      vt.set(
        t.charCodeAt(n),
        1
        /* CharacterClass.ForceTermination */
      );
    const e = ".,;:";
    for (let n = 0; n < e.length; n++)
      vt.set(
        e.charCodeAt(n),
        2
        /* CharacterClass.CannotEndIn */
      );
  }
  return vt;
}
class hn {
  static _createLink(e, n, i, r, s) {
    let a = s - 1;
    do {
      const o = n.charCodeAt(a);
      if (e.get(o) !== 2)
        break;
      a--;
    } while (a > r);
    if (r > 0) {
      const o = n.charCodeAt(r - 1), l = n.charCodeAt(a);
      (o === 40 && l === 41 || o === 91 && l === 93 || o === 123 && l === 125) && a--;
    }
    return {
      range: {
        startLineNumber: i,
        startColumn: r + 1,
        endLineNumber: i,
        endColumn: a + 2
      },
      url: n.substring(r, a + 1)
    };
  }
  static computeLinks(e, n = el()) {
    const i = tl(), r = [];
    for (let s = 1, a = e.getLineCount(); s <= a; s++) {
      const o = e.getLineContent(s), l = o.length;
      let c = 0, d = 0, h = 0, f = 1, m = !1, b = !1, D = !1, E = !1;
      for (; c < l; ) {
        let L = !1;
        const _ = o.charCodeAt(c);
        if (f === 13) {
          let v;
          switch (_) {
            case 40:
              m = !0, v = 0;
              break;
            case 41:
              v = m ? 0 : 1;
              break;
            case 91:
              D = !0, b = !0, v = 0;
              break;
            case 93:
              D = !1, v = b ? 0 : 1;
              break;
            case 123:
              E = !0, v = 0;
              break;
            case 125:
              v = E ? 0 : 1;
              break;
            // The following three rules make it that ' or " or ` are allowed inside links
            // only if the link is wrapped by some other quote character
            case 39:
            case 34:
            case 96:
              h === _ ? v = 1 : h === 39 || h === 34 || h === 96 ? v = 0 : v = 1;
              break;
            case 42:
              v = h === 42 ? 1 : 0;
              break;
            case 124:
              v = h === 124 ? 1 : 0;
              break;
            case 32:
              v = D ? 0 : 1;
              break;
            default:
              v = i.get(_);
          }
          v === 1 && (r.push(hn._createLink(i, o, s, d, c)), L = !0);
        } else if (f === 12) {
          let v;
          _ === 91 ? (b = !0, v = 0) : v = i.get(_), v === 1 ? L = !0 : f = 13;
        } else
          f = n.nextState(f, _), f === 0 && (L = !0);
        L && (f = 1, m = !1, b = !1, E = !1, d = c + 1, h = _), c++;
      }
      f === 13 && r.push(hn._createLink(i, o, s, d, l));
    }
    return r;
  }
}
function nl(t) {
  return !t || typeof t.getLineCount != "function" || typeof t.getLineContent != "function" ? [] : hn.computeLinks(t);
}
class Pi {
  constructor() {
    this._defaultValueSet = [
      ["true", "false"],
      ["True", "False"],
      ["Private", "Public", "Friend", "ReadOnly", "Partial", "Protected", "WriteOnly"],
      ["public", "protected", "private"]
    ];
  }
  static {
    this.INSTANCE = new Pi();
  }
  navigateValueSet(e, n, i, r, s) {
    if (e && n) {
      const a = this.doNavigateValueSet(n, s);
      if (a)
        return {
          range: e,
          value: a
        };
    }
    if (i && r) {
      const a = this.doNavigateValueSet(r, s);
      if (a)
        return {
          range: i,
          value: a
        };
    }
    return null;
  }
  doNavigateValueSet(e, n) {
    const i = this.numberReplace(e, n);
    return i !== null ? i : this.textReplace(e, n);
  }
  numberReplace(e, n) {
    const i = Math.pow(10, e.length - (e.lastIndexOf(".") + 1));
    let r = Number(e);
    const s = parseFloat(e);
    return !isNaN(r) && !isNaN(s) && r === s ? r === 0 && !n ? null : (r = Math.floor(r * i), r += n ? i : -i, String(r / i)) : null;
  }
  textReplace(e, n) {
    return this.valueSetsReplace(this._defaultValueSet, e, n);
  }
  valueSetsReplace(e, n, i) {
    let r = null;
    for (let s = 0, a = e.length; r === null && s < a; s++)
      r = this.valueSetReplace(e[s], n, i);
    return r;
  }
  valueSetReplace(e, n, i) {
    let r = e.indexOf(n);
    return r >= 0 ? (r += i ? 1 : -1, r < 0 ? r = e.length - 1 : r %= e.length, e[r]) : null;
  }
}
const ao = Object.freeze(function(t, e) {
  const n = setTimeout(t.bind(e), 0);
  return { dispose() {
    clearTimeout(n);
  } };
});
var dn;
(function(t) {
  function e(n) {
    return n === t.None || n === t.Cancelled || n instanceof Gt ? !0 : !n || typeof n != "object" ? !1 : typeof n.isCancellationRequested == "boolean" && typeof n.onCancellationRequested == "function";
  }
  t.isCancellationToken = e, t.None = Object.freeze({
    isCancellationRequested: !1,
    onCancellationRequested: sn.None
  }), t.Cancelled = Object.freeze({
    isCancellationRequested: !0,
    onCancellationRequested: ao
  });
})(dn || (dn = {}));
class Gt {
  constructor() {
    this._isCancelled = !1, this._emitter = null;
  }
  cancel() {
    this._isCancelled || (this._isCancelled = !0, this._emitter && (this._emitter.fire(void 0), this.dispose()));
  }
  get isCancellationRequested() {
    return this._isCancelled;
  }
  get onCancellationRequested() {
    return this._isCancelled ? ao : (this._emitter || (this._emitter = new we()), this._emitter.event);
  }
  dispose() {
    this._emitter && (this._emitter.dispose(), this._emitter = null);
  }
}
class il {
  constructor(e) {
    this._token = void 0, this._parentListener = void 0, this._parentListener = e && e.onCancellationRequested(this.cancel, this);
  }
  get token() {
    return this._token || (this._token = new Gt()), this._token;
  }
  cancel() {
    this._token ? this._token instanceof Gt && this._token.cancel() : this._token = dn.Cancelled;
  }
  dispose(e = !1) {
    e && this.cancel(), this._parentListener?.dispose(), this._token ? this._token instanceof Gt && this._token.dispose() : this._token = dn.None;
  }
}
class Ti {
  constructor() {
    this._keyCodeToStr = [], this._strToKeyCode = /* @__PURE__ */ Object.create(null);
  }
  define(e, n) {
    this._keyCodeToStr[e] = n, this._strToKeyCode[n.toLowerCase()] = e;
  }
  keyCodeToStr(e) {
    return this._keyCodeToStr[e];
  }
  strToKeyCode(e) {
    return this._strToKeyCode[e.toLowerCase()] || 0;
  }
}
const Xt = new Ti(), Kn = new Ti(), ei = new Ti(), rl = new Array(230), sl = /* @__PURE__ */ Object.create(null), al = /* @__PURE__ */ Object.create(null);
(function() {
  const t = "", e = [
    // immutable, scanCode, scanCodeStr, keyCode, keyCodeStr, eventKeyCode, vkey, usUserSettingsLabel, generalUserSettingsLabel
    [1, 0, "None", 0, "unknown", 0, "VK_UNKNOWN", t, t],
    [1, 1, "Hyper", 0, t, 0, t, t, t],
    [1, 2, "Super", 0, t, 0, t, t, t],
    [1, 3, "Fn", 0, t, 0, t, t, t],
    [1, 4, "FnLock", 0, t, 0, t, t, t],
    [1, 5, "Suspend", 0, t, 0, t, t, t],
    [1, 6, "Resume", 0, t, 0, t, t, t],
    [1, 7, "Turbo", 0, t, 0, t, t, t],
    [1, 8, "Sleep", 0, t, 0, "VK_SLEEP", t, t],
    [1, 9, "WakeUp", 0, t, 0, t, t, t],
    [0, 10, "KeyA", 31, "A", 65, "VK_A", t, t],
    [0, 11, "KeyB", 32, "B", 66, "VK_B", t, t],
    [0, 12, "KeyC", 33, "C", 67, "VK_C", t, t],
    [0, 13, "KeyD", 34, "D", 68, "VK_D", t, t],
    [0, 14, "KeyE", 35, "E", 69, "VK_E", t, t],
    [0, 15, "KeyF", 36, "F", 70, "VK_F", t, t],
    [0, 16, "KeyG", 37, "G", 71, "VK_G", t, t],
    [0, 17, "KeyH", 38, "H", 72, "VK_H", t, t],
    [0, 18, "KeyI", 39, "I", 73, "VK_I", t, t],
    [0, 19, "KeyJ", 40, "J", 74, "VK_J", t, t],
    [0, 20, "KeyK", 41, "K", 75, "VK_K", t, t],
    [0, 21, "KeyL", 42, "L", 76, "VK_L", t, t],
    [0, 22, "KeyM", 43, "M", 77, "VK_M", t, t],
    [0, 23, "KeyN", 44, "N", 78, "VK_N", t, t],
    [0, 24, "KeyO", 45, "O", 79, "VK_O", t, t],
    [0, 25, "KeyP", 46, "P", 80, "VK_P", t, t],
    [0, 26, "KeyQ", 47, "Q", 81, "VK_Q", t, t],
    [0, 27, "KeyR", 48, "R", 82, "VK_R", t, t],
    [0, 28, "KeyS", 49, "S", 83, "VK_S", t, t],
    [0, 29, "KeyT", 50, "T", 84, "VK_T", t, t],
    [0, 30, "KeyU", 51, "U", 85, "VK_U", t, t],
    [0, 31, "KeyV", 52, "V", 86, "VK_V", t, t],
    [0, 32, "KeyW", 53, "W", 87, "VK_W", t, t],
    [0, 33, "KeyX", 54, "X", 88, "VK_X", t, t],
    [0, 34, "KeyY", 55, "Y", 89, "VK_Y", t, t],
    [0, 35, "KeyZ", 56, "Z", 90, "VK_Z", t, t],
    [0, 36, "Digit1", 22, "1", 49, "VK_1", t, t],
    [0, 37, "Digit2", 23, "2", 50, "VK_2", t, t],
    [0, 38, "Digit3", 24, "3", 51, "VK_3", t, t],
    [0, 39, "Digit4", 25, "4", 52, "VK_4", t, t],
    [0, 40, "Digit5", 26, "5", 53, "VK_5", t, t],
    [0, 41, "Digit6", 27, "6", 54, "VK_6", t, t],
    [0, 42, "Digit7", 28, "7", 55, "VK_7", t, t],
    [0, 43, "Digit8", 29, "8", 56, "VK_8", t, t],
    [0, 44, "Digit9", 30, "9", 57, "VK_9", t, t],
    [0, 45, "Digit0", 21, "0", 48, "VK_0", t, t],
    [1, 46, "Enter", 3, "Enter", 13, "VK_RETURN", t, t],
    [1, 47, "Escape", 9, "Escape", 27, "VK_ESCAPE", t, t],
    [1, 48, "Backspace", 1, "Backspace", 8, "VK_BACK", t, t],
    [1, 49, "Tab", 2, "Tab", 9, "VK_TAB", t, t],
    [1, 50, "Space", 10, "Space", 32, "VK_SPACE", t, t],
    [0, 51, "Minus", 88, "-", 189, "VK_OEM_MINUS", "-", "OEM_MINUS"],
    [0, 52, "Equal", 86, "=", 187, "VK_OEM_PLUS", "=", "OEM_PLUS"],
    [0, 53, "BracketLeft", 92, "[", 219, "VK_OEM_4", "[", "OEM_4"],
    [0, 54, "BracketRight", 94, "]", 221, "VK_OEM_6", "]", "OEM_6"],
    [0, 55, "Backslash", 93, "\\", 220, "VK_OEM_5", "\\", "OEM_5"],
    [0, 56, "IntlHash", 0, t, 0, t, t, t],
    // has been dropped from the w3c spec
    [0, 57, "Semicolon", 85, ";", 186, "VK_OEM_1", ";", "OEM_1"],
    [0, 58, "Quote", 95, "'", 222, "VK_OEM_7", "'", "OEM_7"],
    [0, 59, "Backquote", 91, "`", 192, "VK_OEM_3", "`", "OEM_3"],
    [0, 60, "Comma", 87, ",", 188, "VK_OEM_COMMA", ",", "OEM_COMMA"],
    [0, 61, "Period", 89, ".", 190, "VK_OEM_PERIOD", ".", "OEM_PERIOD"],
    [0, 62, "Slash", 90, "/", 191, "VK_OEM_2", "/", "OEM_2"],
    [1, 63, "CapsLock", 8, "CapsLock", 20, "VK_CAPITAL", t, t],
    [1, 64, "F1", 59, "F1", 112, "VK_F1", t, t],
    [1, 65, "F2", 60, "F2", 113, "VK_F2", t, t],
    [1, 66, "F3", 61, "F3", 114, "VK_F3", t, t],
    [1, 67, "F4", 62, "F4", 115, "VK_F4", t, t],
    [1, 68, "F5", 63, "F5", 116, "VK_F5", t, t],
    [1, 69, "F6", 64, "F6", 117, "VK_F6", t, t],
    [1, 70, "F7", 65, "F7", 118, "VK_F7", t, t],
    [1, 71, "F8", 66, "F8", 119, "VK_F8", t, t],
    [1, 72, "F9", 67, "F9", 120, "VK_F9", t, t],
    [1, 73, "F10", 68, "F10", 121, "VK_F10", t, t],
    [1, 74, "F11", 69, "F11", 122, "VK_F11", t, t],
    [1, 75, "F12", 70, "F12", 123, "VK_F12", t, t],
    [1, 76, "PrintScreen", 0, t, 0, t, t, t],
    [1, 77, "ScrollLock", 84, "ScrollLock", 145, "VK_SCROLL", t, t],
    [1, 78, "Pause", 7, "PauseBreak", 19, "VK_PAUSE", t, t],
    [1, 79, "Insert", 19, "Insert", 45, "VK_INSERT", t, t],
    [1, 80, "Home", 14, "Home", 36, "VK_HOME", t, t],
    [1, 81, "PageUp", 11, "PageUp", 33, "VK_PRIOR", t, t],
    [1, 82, "Delete", 20, "Delete", 46, "VK_DELETE", t, t],
    [1, 83, "End", 13, "End", 35, "VK_END", t, t],
    [1, 84, "PageDown", 12, "PageDown", 34, "VK_NEXT", t, t],
    [1, 85, "ArrowRight", 17, "RightArrow", 39, "VK_RIGHT", "Right", t],
    [1, 86, "ArrowLeft", 15, "LeftArrow", 37, "VK_LEFT", "Left", t],
    [1, 87, "ArrowDown", 18, "DownArrow", 40, "VK_DOWN", "Down", t],
    [1, 88, "ArrowUp", 16, "UpArrow", 38, "VK_UP", "Up", t],
    [1, 89, "NumLock", 83, "NumLock", 144, "VK_NUMLOCK", t, t],
    [1, 90, "NumpadDivide", 113, "NumPad_Divide", 111, "VK_DIVIDE", t, t],
    [1, 91, "NumpadMultiply", 108, "NumPad_Multiply", 106, "VK_MULTIPLY", t, t],
    [1, 92, "NumpadSubtract", 111, "NumPad_Subtract", 109, "VK_SUBTRACT", t, t],
    [1, 93, "NumpadAdd", 109, "NumPad_Add", 107, "VK_ADD", t, t],
    [1, 94, "NumpadEnter", 3, t, 0, t, t, t],
    [1, 95, "Numpad1", 99, "NumPad1", 97, "VK_NUMPAD1", t, t],
    [1, 96, "Numpad2", 100, "NumPad2", 98, "VK_NUMPAD2", t, t],
    [1, 97, "Numpad3", 101, "NumPad3", 99, "VK_NUMPAD3", t, t],
    [1, 98, "Numpad4", 102, "NumPad4", 100, "VK_NUMPAD4", t, t],
    [1, 99, "Numpad5", 103, "NumPad5", 101, "VK_NUMPAD5", t, t],
    [1, 100, "Numpad6", 104, "NumPad6", 102, "VK_NUMPAD6", t, t],
    [1, 101, "Numpad7", 105, "NumPad7", 103, "VK_NUMPAD7", t, t],
    [1, 102, "Numpad8", 106, "NumPad8", 104, "VK_NUMPAD8", t, t],
    [1, 103, "Numpad9", 107, "NumPad9", 105, "VK_NUMPAD9", t, t],
    [1, 104, "Numpad0", 98, "NumPad0", 96, "VK_NUMPAD0", t, t],
    [1, 105, "NumpadDecimal", 112, "NumPad_Decimal", 110, "VK_DECIMAL", t, t],
    [0, 106, "IntlBackslash", 97, "OEM_102", 226, "VK_OEM_102", t, t],
    [1, 107, "ContextMenu", 58, "ContextMenu", 93, t, t, t],
    [1, 108, "Power", 0, t, 0, t, t, t],
    [1, 109, "NumpadEqual", 0, t, 0, t, t, t],
    [1, 110, "F13", 71, "F13", 124, "VK_F13", t, t],
    [1, 111, "F14", 72, "F14", 125, "VK_F14", t, t],
    [1, 112, "F15", 73, "F15", 126, "VK_F15", t, t],
    [1, 113, "F16", 74, "F16", 127, "VK_F16", t, t],
    [1, 114, "F17", 75, "F17", 128, "VK_F17", t, t],
    [1, 115, "F18", 76, "F18", 129, "VK_F18", t, t],
    [1, 116, "F19", 77, "F19", 130, "VK_F19", t, t],
    [1, 117, "F20", 78, "F20", 131, "VK_F20", t, t],
    [1, 118, "F21", 79, "F21", 132, "VK_F21", t, t],
    [1, 119, "F22", 80, "F22", 133, "VK_F22", t, t],
    [1, 120, "F23", 81, "F23", 134, "VK_F23", t, t],
    [1, 121, "F24", 82, "F24", 135, "VK_F24", t, t],
    [1, 122, "Open", 0, t, 0, t, t, t],
    [1, 123, "Help", 0, t, 0, t, t, t],
    [1, 124, "Select", 0, t, 0, t, t, t],
    [1, 125, "Again", 0, t, 0, t, t, t],
    [1, 126, "Undo", 0, t, 0, t, t, t],
    [1, 127, "Cut", 0, t, 0, t, t, t],
    [1, 128, "Copy", 0, t, 0, t, t, t],
    [1, 129, "Paste", 0, t, 0, t, t, t],
    [1, 130, "Find", 0, t, 0, t, t, t],
    [1, 131, "AudioVolumeMute", 117, "AudioVolumeMute", 173, "VK_VOLUME_MUTE", t, t],
    [1, 132, "AudioVolumeUp", 118, "AudioVolumeUp", 175, "VK_VOLUME_UP", t, t],
    [1, 133, "AudioVolumeDown", 119, "AudioVolumeDown", 174, "VK_VOLUME_DOWN", t, t],
    [1, 134, "NumpadComma", 110, "NumPad_Separator", 108, "VK_SEPARATOR", t, t],
    [0, 135, "IntlRo", 115, "ABNT_C1", 193, "VK_ABNT_C1", t, t],
    [1, 136, "KanaMode", 0, t, 0, t, t, t],
    [0, 137, "IntlYen", 0, t, 0, t, t, t],
    [1, 138, "Convert", 0, t, 0, t, t, t],
    [1, 139, "NonConvert", 0, t, 0, t, t, t],
    [1, 140, "Lang1", 0, t, 0, t, t, t],
    [1, 141, "Lang2", 0, t, 0, t, t, t],
    [1, 142, "Lang3", 0, t, 0, t, t, t],
    [1, 143, "Lang4", 0, t, 0, t, t, t],
    [1, 144, "Lang5", 0, t, 0, t, t, t],
    [1, 145, "Abort", 0, t, 0, t, t, t],
    [1, 146, "Props", 0, t, 0, t, t, t],
    [1, 147, "NumpadParenLeft", 0, t, 0, t, t, t],
    [1, 148, "NumpadParenRight", 0, t, 0, t, t, t],
    [1, 149, "NumpadBackspace", 0, t, 0, t, t, t],
    [1, 150, "NumpadMemoryStore", 0, t, 0, t, t, t],
    [1, 151, "NumpadMemoryRecall", 0, t, 0, t, t, t],
    [1, 152, "NumpadMemoryClear", 0, t, 0, t, t, t],
    [1, 153, "NumpadMemoryAdd", 0, t, 0, t, t, t],
    [1, 154, "NumpadMemorySubtract", 0, t, 0, t, t, t],
    [1, 155, "NumpadClear", 131, "Clear", 12, "VK_CLEAR", t, t],
    [1, 156, "NumpadClearEntry", 0, t, 0, t, t, t],
    [1, 0, t, 5, "Ctrl", 17, "VK_CONTROL", t, t],
    [1, 0, t, 4, "Shift", 16, "VK_SHIFT", t, t],
    [1, 0, t, 6, "Alt", 18, "VK_MENU", t, t],
    [1, 0, t, 57, "Meta", 91, "VK_COMMAND", t, t],
    [1, 157, "ControlLeft", 5, t, 0, "VK_LCONTROL", t, t],
    [1, 158, "ShiftLeft", 4, t, 0, "VK_LSHIFT", t, t],
    [1, 159, "AltLeft", 6, t, 0, "VK_LMENU", t, t],
    [1, 160, "MetaLeft", 57, t, 0, "VK_LWIN", t, t],
    [1, 161, "ControlRight", 5, t, 0, "VK_RCONTROL", t, t],
    [1, 162, "ShiftRight", 4, t, 0, "VK_RSHIFT", t, t],
    [1, 163, "AltRight", 6, t, 0, "VK_RMENU", t, t],
    [1, 164, "MetaRight", 57, t, 0, "VK_RWIN", t, t],
    [1, 165, "BrightnessUp", 0, t, 0, t, t, t],
    [1, 166, "BrightnessDown", 0, t, 0, t, t, t],
    [1, 167, "MediaPlay", 0, t, 0, t, t, t],
    [1, 168, "MediaRecord", 0, t, 0, t, t, t],
    [1, 169, "MediaFastForward", 0, t, 0, t, t, t],
    [1, 170, "MediaRewind", 0, t, 0, t, t, t],
    [1, 171, "MediaTrackNext", 124, "MediaTrackNext", 176, "VK_MEDIA_NEXT_TRACK", t, t],
    [1, 172, "MediaTrackPrevious", 125, "MediaTrackPrevious", 177, "VK_MEDIA_PREV_TRACK", t, t],
    [1, 173, "MediaStop", 126, "MediaStop", 178, "VK_MEDIA_STOP", t, t],
    [1, 174, "Eject", 0, t, 0, t, t, t],
    [1, 175, "MediaPlayPause", 127, "MediaPlayPause", 179, "VK_MEDIA_PLAY_PAUSE", t, t],
    [1, 176, "MediaSelect", 128, "LaunchMediaPlayer", 181, "VK_MEDIA_LAUNCH_MEDIA_SELECT", t, t],
    [1, 177, "LaunchMail", 129, "LaunchMail", 180, "VK_MEDIA_LAUNCH_MAIL", t, t],
    [1, 178, "LaunchApp2", 130, "LaunchApp2", 183, "VK_MEDIA_LAUNCH_APP2", t, t],
    [1, 179, "LaunchApp1", 0, t, 0, "VK_MEDIA_LAUNCH_APP1", t, t],
    [1, 180, "SelectTask", 0, t, 0, t, t, t],
    [1, 181, "LaunchScreenSaver", 0, t, 0, t, t, t],
    [1, 182, "BrowserSearch", 120, "BrowserSearch", 170, "VK_BROWSER_SEARCH", t, t],
    [1, 183, "BrowserHome", 121, "BrowserHome", 172, "VK_BROWSER_HOME", t, t],
    [1, 184, "BrowserBack", 122, "BrowserBack", 166, "VK_BROWSER_BACK", t, t],
    [1, 185, "BrowserForward", 123, "BrowserForward", 167, "VK_BROWSER_FORWARD", t, t],
    [1, 186, "BrowserStop", 0, t, 0, "VK_BROWSER_STOP", t, t],
    [1, 187, "BrowserRefresh", 0, t, 0, "VK_BROWSER_REFRESH", t, t],
    [1, 188, "BrowserFavorites", 0, t, 0, "VK_BROWSER_FAVORITES", t, t],
    [1, 189, "ZoomToggle", 0, t, 0, t, t, t],
    [1, 190, "MailReply", 0, t, 0, t, t, t],
    [1, 191, "MailForward", 0, t, 0, t, t, t],
    [1, 192, "MailSend", 0, t, 0, t, t, t],
    // See https://lists.w3.org/Archives/Public/www-dom/2010JulSep/att-0182/keyCode-spec.html
    // If an Input Method Editor is processing key input and the event is keydown, return 229.
    [1, 0, t, 114, "KeyInComposition", 229, t, t, t],
    [1, 0, t, 116, "ABNT_C2", 194, "VK_ABNT_C2", t, t],
    [1, 0, t, 96, "OEM_8", 223, "VK_OEM_8", t, t],
    [1, 0, t, 0, t, 0, "VK_KANA", t, t],
    [1, 0, t, 0, t, 0, "VK_HANGUL", t, t],
    [1, 0, t, 0, t, 0, "VK_JUNJA", t, t],
    [1, 0, t, 0, t, 0, "VK_FINAL", t, t],
    [1, 0, t, 0, t, 0, "VK_HANJA", t, t],
    [1, 0, t, 0, t, 0, "VK_KANJI", t, t],
    [1, 0, t, 0, t, 0, "VK_CONVERT", t, t],
    [1, 0, t, 0, t, 0, "VK_NONCONVERT", t, t],
    [1, 0, t, 0, t, 0, "VK_ACCEPT", t, t],
    [1, 0, t, 0, t, 0, "VK_MODECHANGE", t, t],
    [1, 0, t, 0, t, 0, "VK_SELECT", t, t],
    [1, 0, t, 0, t, 0, "VK_PRINT", t, t],
    [1, 0, t, 0, t, 0, "VK_EXECUTE", t, t],
    [1, 0, t, 0, t, 0, "VK_SNAPSHOT", t, t],
    [1, 0, t, 0, t, 0, "VK_HELP", t, t],
    [1, 0, t, 0, t, 0, "VK_APPS", t, t],
    [1, 0, t, 0, t, 0, "VK_PROCESSKEY", t, t],
    [1, 0, t, 0, t, 0, "VK_PACKET", t, t],
    [1, 0, t, 0, t, 0, "VK_DBE_SBCSCHAR", t, t],
    [1, 0, t, 0, t, 0, "VK_DBE_DBCSCHAR", t, t],
    [1, 0, t, 0, t, 0, "VK_ATTN", t, t],
    [1, 0, t, 0, t, 0, "VK_CRSEL", t, t],
    [1, 0, t, 0, t, 0, "VK_EXSEL", t, t],
    [1, 0, t, 0, t, 0, "VK_EREOF", t, t],
    [1, 0, t, 0, t, 0, "VK_PLAY", t, t],
    [1, 0, t, 0, t, 0, "VK_ZOOM", t, t],
    [1, 0, t, 0, t, 0, "VK_NONAME", t, t],
    [1, 0, t, 0, t, 0, "VK_PA1", t, t],
    [1, 0, t, 0, t, 0, "VK_OEM_CLEAR", t, t]
  ], n = [], i = [];
  for (const r of e) {
    const [s, a, o, l, c, d, h, f, m] = r;
    if (i[a] || (i[a] = !0, sl[o] = a, al[o.toLowerCase()] = a), !n[l]) {
      if (n[l] = !0, !c)
        throw new Error(`String representation missing for key code ${l} around scan code ${o}`);
      Xt.define(l, c), Kn.define(l, f || c), ei.define(l, m || f || c);
    }
    d && (rl[d] = l);
  }
})();
var rr;
(function(t) {
  function e(o) {
    return Xt.keyCodeToStr(o);
  }
  t.toString = e;
  function n(o) {
    return Xt.strToKeyCode(o);
  }
  t.fromString = n;
  function i(o) {
    return Kn.keyCodeToStr(o);
  }
  t.toUserSettingsUS = i;
  function r(o) {
    return ei.keyCodeToStr(o);
  }
  t.toUserSettingsGeneral = r;
  function s(o) {
    return Kn.strToKeyCode(o) || ei.strToKeyCode(o);
  }
  t.fromUserSettings = s;
  function a(o) {
    if (o >= 98 && o <= 113)
      return null;
    switch (o) {
      case 16:
        return "Up";
      case 18:
        return "Down";
      case 15:
        return "Left";
      case 17:
        return "Right";
    }
    return Xt.keyCodeToStr(o);
  }
  t.toElectronAccelerator = a;
})(rr || (rr = {}));
function ol(t, e) {
  const n = (e & 65535) << 16 >>> 0;
  return (t | n) >>> 0;
}
class Ce extends H {
  constructor(e, n, i, r) {
    super(e, n, i, r), this.selectionStartLineNumber = e, this.selectionStartColumn = n, this.positionLineNumber = i, this.positionColumn = r;
  }
  /**
   * Transform to a human-readable representation.
   */
  toString() {
    return "[" + this.selectionStartLineNumber + "," + this.selectionStartColumn + " -> " + this.positionLineNumber + "," + this.positionColumn + "]";
  }
  /**
   * Test if equals other selection.
   */
  equalsSelection(e) {
    return Ce.selectionsEqual(this, e);
  }
  /**
   * Test if the two selections are equal.
   */
  static selectionsEqual(e, n) {
    return e.selectionStartLineNumber === n.selectionStartLineNumber && e.selectionStartColumn === n.selectionStartColumn && e.positionLineNumber === n.positionLineNumber && e.positionColumn === n.positionColumn;
  }
  /**
   * Get directions (LTR or RTL).
   */
  getDirection() {
    return this.selectionStartLineNumber === this.startLineNumber && this.selectionStartColumn === this.startColumn ? 0 : 1;
  }
  /**
   * Create a new selection with a different `positionLineNumber` and `positionColumn`.
   */
  setEndPosition(e, n) {
    return this.getDirection() === 0 ? new Ce(this.startLineNumber, this.startColumn, e, n) : new Ce(e, n, this.startLineNumber, this.startColumn);
  }
  /**
   * Get the position at `positionLineNumber` and `positionColumn`.
   */
  getPosition() {
    return new ne(this.positionLineNumber, this.positionColumn);
  }
  /**
   * Get the position at the start of the selection.
  */
  getSelectionStart() {
    return new ne(this.selectionStartLineNumber, this.selectionStartColumn);
  }
  /**
   * Create a new selection with a different `selectionStartLineNumber` and `selectionStartColumn`.
   */
  setStartPosition(e, n) {
    return this.getDirection() === 0 ? new Ce(e, n, this.endLineNumber, this.endColumn) : new Ce(this.endLineNumber, this.endColumn, e, n);
  }
  // ----
  /**
   * Create a `Selection` from one or two positions
   */
  static fromPositions(e, n = e) {
    return new Ce(e.lineNumber, e.column, n.lineNumber, n.column);
  }
  /**
   * Creates a `Selection` from a range, given a direction.
   */
  static fromRange(e, n) {
    return n === 0 ? new Ce(e.startLineNumber, e.startColumn, e.endLineNumber, e.endColumn) : new Ce(e.endLineNumber, e.endColumn, e.startLineNumber, e.startColumn);
  }
  /**
   * Create a `Selection` from an `ISelection`.
   */
  static liftSelection(e) {
    return new Ce(e.selectionStartLineNumber, e.selectionStartColumn, e.positionLineNumber, e.positionColumn);
  }
  /**
   * `a` equals `b`.
   */
  static selectionsArrEqual(e, n) {
    if (e && !n || !e && n)
      return !1;
    if (!e && !n)
      return !0;
    if (e.length !== n.length)
      return !1;
    for (let i = 0, r = e.length; i < r; i++)
      if (!this.selectionsEqual(e[i], n[i]))
        return !1;
    return !0;
  }
  /**
   * Test if `obj` is an `ISelection`.
   */
  static isISelection(e) {
    return e && typeof e.selectionStartLineNumber == "number" && typeof e.selectionStartColumn == "number" && typeof e.positionLineNumber == "number" && typeof e.positionColumn == "number";
  }
  /**
   * Create with a direction.
   */
  static createWithDirection(e, n, i, r, s) {
    return s === 0 ? new Ce(e, n, i, r) : new Ce(i, r, e, n);
  }
}
function ul(t) {
  return typeof t == "string";
}
const sr = /* @__PURE__ */ Object.create(null);
function u(t, e) {
  if (ul(e)) {
    const n = sr[e];
    if (n === void 0)
      throw new Error(`${t} references an unknown codicon: ${e}`);
    e = n;
  }
  return sr[t] = e, { id: t };
}
const ll = {
  add: u("add", 6e4),
  plus: u("plus", 6e4),
  gistNew: u("gist-new", 6e4),
  repoCreate: u("repo-create", 6e4),
  lightbulb: u("lightbulb", 60001),
  lightBulb: u("light-bulb", 60001),
  repo: u("repo", 60002),
  repoDelete: u("repo-delete", 60002),
  gistFork: u("gist-fork", 60003),
  repoForked: u("repo-forked", 60003),
  gitPullRequest: u("git-pull-request", 60004),
  gitPullRequestAbandoned: u("git-pull-request-abandoned", 60004),
  recordKeys: u("record-keys", 60005),
  keyboard: u("keyboard", 60005),
  tag: u("tag", 60006),
  gitPullRequestLabel: u("git-pull-request-label", 60006),
  tagAdd: u("tag-add", 60006),
  tagRemove: u("tag-remove", 60006),
  person: u("person", 60007),
  personFollow: u("person-follow", 60007),
  personOutline: u("person-outline", 60007),
  personFilled: u("person-filled", 60007),
  gitBranch: u("git-branch", 60008),
  gitBranchCreate: u("git-branch-create", 60008),
  gitBranchDelete: u("git-branch-delete", 60008),
  sourceControl: u("source-control", 60008),
  mirror: u("mirror", 60009),
  mirrorPublic: u("mirror-public", 60009),
  star: u("star", 60010),
  starAdd: u("star-add", 60010),
  starDelete: u("star-delete", 60010),
  starEmpty: u("star-empty", 60010),
  comment: u("comment", 60011),
  commentAdd: u("comment-add", 60011),
  alert: u("alert", 60012),
  warning: u("warning", 60012),
  search: u("search", 60013),
  searchSave: u("search-save", 60013),
  logOut: u("log-out", 60014),
  signOut: u("sign-out", 60014),
  logIn: u("log-in", 60015),
  signIn: u("sign-in", 60015),
  eye: u("eye", 60016),
  eyeUnwatch: u("eye-unwatch", 60016),
  eyeWatch: u("eye-watch", 60016),
  circleFilled: u("circle-filled", 60017),
  primitiveDot: u("primitive-dot", 60017),
  closeDirty: u("close-dirty", 60017),
  debugBreakpoint: u("debug-breakpoint", 60017),
  debugBreakpointDisabled: u("debug-breakpoint-disabled", 60017),
  debugHint: u("debug-hint", 60017),
  terminalDecorationSuccess: u("terminal-decoration-success", 60017),
  primitiveSquare: u("primitive-square", 60018),
  edit: u("edit", 60019),
  pencil: u("pencil", 60019),
  info: u("info", 60020),
  issueOpened: u("issue-opened", 60020),
  gistPrivate: u("gist-private", 60021),
  gitForkPrivate: u("git-fork-private", 60021),
  lock: u("lock", 60021),
  mirrorPrivate: u("mirror-private", 60021),
  close: u("close", 60022),
  removeClose: u("remove-close", 60022),
  x: u("x", 60022),
  repoSync: u("repo-sync", 60023),
  sync: u("sync", 60023),
  clone: u("clone", 60024),
  desktopDownload: u("desktop-download", 60024),
  beaker: u("beaker", 60025),
  microscope: u("microscope", 60025),
  vm: u("vm", 60026),
  deviceDesktop: u("device-desktop", 60026),
  file: u("file", 60027),
  fileText: u("file-text", 60027),
  more: u("more", 60028),
  ellipsis: u("ellipsis", 60028),
  kebabHorizontal: u("kebab-horizontal", 60028),
  mailReply: u("mail-reply", 60029),
  reply: u("reply", 60029),
  organization: u("organization", 60030),
  organizationFilled: u("organization-filled", 60030),
  organizationOutline: u("organization-outline", 60030),
  newFile: u("new-file", 60031),
  fileAdd: u("file-add", 60031),
  newFolder: u("new-folder", 60032),
  fileDirectoryCreate: u("file-directory-create", 60032),
  trash: u("trash", 60033),
  trashcan: u("trashcan", 60033),
  history: u("history", 60034),
  clock: u("clock", 60034),
  folder: u("folder", 60035),
  fileDirectory: u("file-directory", 60035),
  symbolFolder: u("symbol-folder", 60035),
  logoGithub: u("logo-github", 60036),
  markGithub: u("mark-github", 60036),
  github: u("github", 60036),
  terminal: u("terminal", 60037),
  console: u("console", 60037),
  repl: u("repl", 60037),
  zap: u("zap", 60038),
  symbolEvent: u("symbol-event", 60038),
  error: u("error", 60039),
  stop: u("stop", 60039),
  variable: u("variable", 60040),
  symbolVariable: u("symbol-variable", 60040),
  array: u("array", 60042),
  symbolArray: u("symbol-array", 60042),
  symbolModule: u("symbol-module", 60043),
  symbolPackage: u("symbol-package", 60043),
  symbolNamespace: u("symbol-namespace", 60043),
  symbolObject: u("symbol-object", 60043),
  symbolMethod: u("symbol-method", 60044),
  symbolFunction: u("symbol-function", 60044),
  symbolConstructor: u("symbol-constructor", 60044),
  symbolBoolean: u("symbol-boolean", 60047),
  symbolNull: u("symbol-null", 60047),
  symbolNumeric: u("symbol-numeric", 60048),
  symbolNumber: u("symbol-number", 60048),
  symbolStructure: u("symbol-structure", 60049),
  symbolStruct: u("symbol-struct", 60049),
  symbolParameter: u("symbol-parameter", 60050),
  symbolTypeParameter: u("symbol-type-parameter", 60050),
  symbolKey: u("symbol-key", 60051),
  symbolText: u("symbol-text", 60051),
  symbolReference: u("symbol-reference", 60052),
  goToFile: u("go-to-file", 60052),
  symbolEnum: u("symbol-enum", 60053),
  symbolValue: u("symbol-value", 60053),
  symbolRuler: u("symbol-ruler", 60054),
  symbolUnit: u("symbol-unit", 60054),
  activateBreakpoints: u("activate-breakpoints", 60055),
  archive: u("archive", 60056),
  arrowBoth: u("arrow-both", 60057),
  arrowDown: u("arrow-down", 60058),
  arrowLeft: u("arrow-left", 60059),
  arrowRight: u("arrow-right", 60060),
  arrowSmallDown: u("arrow-small-down", 60061),
  arrowSmallLeft: u("arrow-small-left", 60062),
  arrowSmallRight: u("arrow-small-right", 60063),
  arrowSmallUp: u("arrow-small-up", 60064),
  arrowUp: u("arrow-up", 60065),
  bell: u("bell", 60066),
  bold: u("bold", 60067),
  book: u("book", 60068),
  bookmark: u("bookmark", 60069),
  debugBreakpointConditionalUnverified: u("debug-breakpoint-conditional-unverified", 60070),
  debugBreakpointConditional: u("debug-breakpoint-conditional", 60071),
  debugBreakpointConditionalDisabled: u("debug-breakpoint-conditional-disabled", 60071),
  debugBreakpointDataUnverified: u("debug-breakpoint-data-unverified", 60072),
  debugBreakpointData: u("debug-breakpoint-data", 60073),
  debugBreakpointDataDisabled: u("debug-breakpoint-data-disabled", 60073),
  debugBreakpointLogUnverified: u("debug-breakpoint-log-unverified", 60074),
  debugBreakpointLog: u("debug-breakpoint-log", 60075),
  debugBreakpointLogDisabled: u("debug-breakpoint-log-disabled", 60075),
  briefcase: u("briefcase", 60076),
  broadcast: u("broadcast", 60077),
  browser: u("browser", 60078),
  bug: u("bug", 60079),
  calendar: u("calendar", 60080),
  caseSensitive: u("case-sensitive", 60081),
  check: u("check", 60082),
  checklist: u("checklist", 60083),
  chevronDown: u("chevron-down", 60084),
  chevronLeft: u("chevron-left", 60085),
  chevronRight: u("chevron-right", 60086),
  chevronUp: u("chevron-up", 60087),
  chromeClose: u("chrome-close", 60088),
  chromeMaximize: u("chrome-maximize", 60089),
  chromeMinimize: u("chrome-minimize", 60090),
  chromeRestore: u("chrome-restore", 60091),
  circleOutline: u("circle-outline", 60092),
  circle: u("circle", 60092),
  debugBreakpointUnverified: u("debug-breakpoint-unverified", 60092),
  terminalDecorationIncomplete: u("terminal-decoration-incomplete", 60092),
  circleSlash: u("circle-slash", 60093),
  circuitBoard: u("circuit-board", 60094),
  clearAll: u("clear-all", 60095),
  clippy: u("clippy", 60096),
  closeAll: u("close-all", 60097),
  cloudDownload: u("cloud-download", 60098),
  cloudUpload: u("cloud-upload", 60099),
  code: u("code", 60100),
  collapseAll: u("collapse-all", 60101),
  colorMode: u("color-mode", 60102),
  commentDiscussion: u("comment-discussion", 60103),
  creditCard: u("credit-card", 60105),
  dash: u("dash", 60108),
  dashboard: u("dashboard", 60109),
  database: u("database", 60110),
  debugContinue: u("debug-continue", 60111),
  debugDisconnect: u("debug-disconnect", 60112),
  debugPause: u("debug-pause", 60113),
  debugRestart: u("debug-restart", 60114),
  debugStart: u("debug-start", 60115),
  debugStepInto: u("debug-step-into", 60116),
  debugStepOut: u("debug-step-out", 60117),
  debugStepOver: u("debug-step-over", 60118),
  debugStop: u("debug-stop", 60119),
  debug: u("debug", 60120),
  deviceCameraVideo: u("device-camera-video", 60121),
  deviceCamera: u("device-camera", 60122),
  deviceMobile: u("device-mobile", 60123),
  diffAdded: u("diff-added", 60124),
  diffIgnored: u("diff-ignored", 60125),
  diffModified: u("diff-modified", 60126),
  diffRemoved: u("diff-removed", 60127),
  diffRenamed: u("diff-renamed", 60128),
  diff: u("diff", 60129),
  diffSidebyside: u("diff-sidebyside", 60129),
  discard: u("discard", 60130),
  editorLayout: u("editor-layout", 60131),
  emptyWindow: u("empty-window", 60132),
  exclude: u("exclude", 60133),
  extensions: u("extensions", 60134),
  eyeClosed: u("eye-closed", 60135),
  fileBinary: u("file-binary", 60136),
  fileCode: u("file-code", 60137),
  fileMedia: u("file-media", 60138),
  filePdf: u("file-pdf", 60139),
  fileSubmodule: u("file-submodule", 60140),
  fileSymlinkDirectory: u("file-symlink-directory", 60141),
  fileSymlinkFile: u("file-symlink-file", 60142),
  fileZip: u("file-zip", 60143),
  files: u("files", 60144),
  filter: u("filter", 60145),
  flame: u("flame", 60146),
  foldDown: u("fold-down", 60147),
  foldUp: u("fold-up", 60148),
  fold: u("fold", 60149),
  folderActive: u("folder-active", 60150),
  folderOpened: u("folder-opened", 60151),
  gear: u("gear", 60152),
  gift: u("gift", 60153),
  gistSecret: u("gist-secret", 60154),
  gist: u("gist", 60155),
  gitCommit: u("git-commit", 60156),
  gitCompare: u("git-compare", 60157),
  compareChanges: u("compare-changes", 60157),
  gitMerge: u("git-merge", 60158),
  githubAction: u("github-action", 60159),
  githubAlt: u("github-alt", 60160),
  globe: u("globe", 60161),
  grabber: u("grabber", 60162),
  graph: u("graph", 60163),
  gripper: u("gripper", 60164),
  heart: u("heart", 60165),
  home: u("home", 60166),
  horizontalRule: u("horizontal-rule", 60167),
  hubot: u("hubot", 60168),
  inbox: u("inbox", 60169),
  issueReopened: u("issue-reopened", 60171),
  issues: u("issues", 60172),
  italic: u("italic", 60173),
  jersey: u("jersey", 60174),
  json: u("json", 60175),
  kebabVertical: u("kebab-vertical", 60176),
  key: u("key", 60177),
  law: u("law", 60178),
  lightbulbAutofix: u("lightbulb-autofix", 60179),
  linkExternal: u("link-external", 60180),
  link: u("link", 60181),
  listOrdered: u("list-ordered", 60182),
  listUnordered: u("list-unordered", 60183),
  liveShare: u("live-share", 60184),
  loading: u("loading", 60185),
  location: u("location", 60186),
  mailRead: u("mail-read", 60187),
  mail: u("mail", 60188),
  markdown: u("markdown", 60189),
  megaphone: u("megaphone", 60190),
  mention: u("mention", 60191),
  milestone: u("milestone", 60192),
  gitPullRequestMilestone: u("git-pull-request-milestone", 60192),
  mortarBoard: u("mortar-board", 60193),
  move: u("move", 60194),
  multipleWindows: u("multiple-windows", 60195),
  mute: u("mute", 60196),
  noNewline: u("no-newline", 60197),
  note: u("note", 60198),
  octoface: u("octoface", 60199),
  openPreview: u("open-preview", 60200),
  package: u("package", 60201),
  paintcan: u("paintcan", 60202),
  pin: u("pin", 60203),
  play: u("play", 60204),
  run: u("run", 60204),
  plug: u("plug", 60205),
  preserveCase: u("preserve-case", 60206),
  preview: u("preview", 60207),
  project: u("project", 60208),
  pulse: u("pulse", 60209),
  question: u("question", 60210),
  quote: u("quote", 60211),
  radioTower: u("radio-tower", 60212),
  reactions: u("reactions", 60213),
  references: u("references", 60214),
  refresh: u("refresh", 60215),
  regex: u("regex", 60216),
  remoteExplorer: u("remote-explorer", 60217),
  remote: u("remote", 60218),
  remove: u("remove", 60219),
  replaceAll: u("replace-all", 60220),
  replace: u("replace", 60221),
  repoClone: u("repo-clone", 60222),
  repoForcePush: u("repo-force-push", 60223),
  repoPull: u("repo-pull", 60224),
  repoPush: u("repo-push", 60225),
  report: u("report", 60226),
  requestChanges: u("request-changes", 60227),
  rocket: u("rocket", 60228),
  rootFolderOpened: u("root-folder-opened", 60229),
  rootFolder: u("root-folder", 60230),
  rss: u("rss", 60231),
  ruby: u("ruby", 60232),
  saveAll: u("save-all", 60233),
  saveAs: u("save-as", 60234),
  save: u("save", 60235),
  screenFull: u("screen-full", 60236),
  screenNormal: u("screen-normal", 60237),
  searchStop: u("search-stop", 60238),
  server: u("server", 60240),
  settingsGear: u("settings-gear", 60241),
  settings: u("settings", 60242),
  shield: u("shield", 60243),
  smiley: u("smiley", 60244),
  sortPrecedence: u("sort-precedence", 60245),
  splitHorizontal: u("split-horizontal", 60246),
  splitVertical: u("split-vertical", 60247),
  squirrel: u("squirrel", 60248),
  starFull: u("star-full", 60249),
  starHalf: u("star-half", 60250),
  symbolClass: u("symbol-class", 60251),
  symbolColor: u("symbol-color", 60252),
  symbolConstant: u("symbol-constant", 60253),
  symbolEnumMember: u("symbol-enum-member", 60254),
  symbolField: u("symbol-field", 60255),
  symbolFile: u("symbol-file", 60256),
  symbolInterface: u("symbol-interface", 60257),
  symbolKeyword: u("symbol-keyword", 60258),
  symbolMisc: u("symbol-misc", 60259),
  symbolOperator: u("symbol-operator", 60260),
  symbolProperty: u("symbol-property", 60261),
  wrench: u("wrench", 60261),
  wrenchSubaction: u("wrench-subaction", 60261),
  symbolSnippet: u("symbol-snippet", 60262),
  tasklist: u("tasklist", 60263),
  telescope: u("telescope", 60264),
  textSize: u("text-size", 60265),
  threeBars: u("three-bars", 60266),
  thumbsdown: u("thumbsdown", 60267),
  thumbsup: u("thumbsup", 60268),
  tools: u("tools", 60269),
  triangleDown: u("triangle-down", 60270),
  triangleLeft: u("triangle-left", 60271),
  triangleRight: u("triangle-right", 60272),
  triangleUp: u("triangle-up", 60273),
  twitter: u("twitter", 60274),
  unfold: u("unfold", 60275),
  unlock: u("unlock", 60276),
  unmute: u("unmute", 60277),
  unverified: u("unverified", 60278),
  verified: u("verified", 60279),
  versions: u("versions", 60280),
  vmActive: u("vm-active", 60281),
  vmOutline: u("vm-outline", 60282),
  vmRunning: u("vm-running", 60283),
  watch: u("watch", 60284),
  whitespace: u("whitespace", 60285),
  wholeWord: u("whole-word", 60286),
  window: u("window", 60287),
  wordWrap: u("word-wrap", 60288),
  zoomIn: u("zoom-in", 60289),
  zoomOut: u("zoom-out", 60290),
  listFilter: u("list-filter", 60291),
  listFlat: u("list-flat", 60292),
  listSelection: u("list-selection", 60293),
  selection: u("selection", 60293),
  listTree: u("list-tree", 60294),
  debugBreakpointFunctionUnverified: u("debug-breakpoint-function-unverified", 60295),
  debugBreakpointFunction: u("debug-breakpoint-function", 60296),
  debugBreakpointFunctionDisabled: u("debug-breakpoint-function-disabled", 60296),
  debugStackframeActive: u("debug-stackframe-active", 60297),
  circleSmallFilled: u("circle-small-filled", 60298),
  debugStackframeDot: u("debug-stackframe-dot", 60298),
  terminalDecorationMark: u("terminal-decoration-mark", 60298),
  debugStackframe: u("debug-stackframe", 60299),
  debugStackframeFocused: u("debug-stackframe-focused", 60299),
  debugBreakpointUnsupported: u("debug-breakpoint-unsupported", 60300),
  symbolString: u("symbol-string", 60301),
  debugReverseContinue: u("debug-reverse-continue", 60302),
  debugStepBack: u("debug-step-back", 60303),
  debugRestartFrame: u("debug-restart-frame", 60304),
  debugAlt: u("debug-alt", 60305),
  callIncoming: u("call-incoming", 60306),
  callOutgoing: u("call-outgoing", 60307),
  menu: u("menu", 60308),
  expandAll: u("expand-all", 60309),
  feedback: u("feedback", 60310),
  gitPullRequestReviewer: u("git-pull-request-reviewer", 60310),
  groupByRefType: u("group-by-ref-type", 60311),
  ungroupByRefType: u("ungroup-by-ref-type", 60312),
  account: u("account", 60313),
  gitPullRequestAssignee: u("git-pull-request-assignee", 60313),
  bellDot: u("bell-dot", 60314),
  debugConsole: u("debug-console", 60315),
  library: u("library", 60316),
  output: u("output", 60317),
  runAll: u("run-all", 60318),
  syncIgnored: u("sync-ignored", 60319),
  pinned: u("pinned", 60320),
  githubInverted: u("github-inverted", 60321),
  serverProcess: u("server-process", 60322),
  serverEnvironment: u("server-environment", 60323),
  pass: u("pass", 60324),
  issueClosed: u("issue-closed", 60324),
  stopCircle: u("stop-circle", 60325),
  playCircle: u("play-circle", 60326),
  record: u("record", 60327),
  debugAltSmall: u("debug-alt-small", 60328),
  vmConnect: u("vm-connect", 60329),
  cloud: u("cloud", 60330),
  merge: u("merge", 60331),
  export: u("export", 60332),
  graphLeft: u("graph-left", 60333),
  magnet: u("magnet", 60334),
  notebook: u("notebook", 60335),
  redo: u("redo", 60336),
  checkAll: u("check-all", 60337),
  pinnedDirty: u("pinned-dirty", 60338),
  passFilled: u("pass-filled", 60339),
  circleLargeFilled: u("circle-large-filled", 60340),
  circleLarge: u("circle-large", 60341),
  circleLargeOutline: u("circle-large-outline", 60341),
  combine: u("combine", 60342),
  gather: u("gather", 60342),
  table: u("table", 60343),
  variableGroup: u("variable-group", 60344),
  typeHierarchy: u("type-hierarchy", 60345),
  typeHierarchySub: u("type-hierarchy-sub", 60346),
  typeHierarchySuper: u("type-hierarchy-super", 60347),
  gitPullRequestCreate: u("git-pull-request-create", 60348),
  runAbove: u("run-above", 60349),
  runBelow: u("run-below", 60350),
  notebookTemplate: u("notebook-template", 60351),
  debugRerun: u("debug-rerun", 60352),
  workspaceTrusted: u("workspace-trusted", 60353),
  workspaceUntrusted: u("workspace-untrusted", 60354),
  workspaceUnknown: u("workspace-unknown", 60355),
  terminalCmd: u("terminal-cmd", 60356),
  terminalDebian: u("terminal-debian", 60357),
  terminalLinux: u("terminal-linux", 60358),
  terminalPowershell: u("terminal-powershell", 60359),
  terminalTmux: u("terminal-tmux", 60360),
  terminalUbuntu: u("terminal-ubuntu", 60361),
  terminalBash: u("terminal-bash", 60362),
  arrowSwap: u("arrow-swap", 60363),
  copy: u("copy", 60364),
  personAdd: u("person-add", 60365),
  filterFilled: u("filter-filled", 60366),
  wand: u("wand", 60367),
  debugLineByLine: u("debug-line-by-line", 60368),
  inspect: u("inspect", 60369),
  layers: u("layers", 60370),
  layersDot: u("layers-dot", 60371),
  layersActive: u("layers-active", 60372),
  compass: u("compass", 60373),
  compassDot: u("compass-dot", 60374),
  compassActive: u("compass-active", 60375),
  azure: u("azure", 60376),
  issueDraft: u("issue-draft", 60377),
  gitPullRequestClosed: u("git-pull-request-closed", 60378),
  gitPullRequestDraft: u("git-pull-request-draft", 60379),
  debugAll: u("debug-all", 60380),
  debugCoverage: u("debug-coverage", 60381),
  runErrors: u("run-errors", 60382),
  folderLibrary: u("folder-library", 60383),
  debugContinueSmall: u("debug-continue-small", 60384),
  beakerStop: u("beaker-stop", 60385),
  graphLine: u("graph-line", 60386),
  graphScatter: u("graph-scatter", 60387),
  pieChart: u("pie-chart", 60388),
  bracket: u("bracket", 60175),
  bracketDot: u("bracket-dot", 60389),
  bracketError: u("bracket-error", 60390),
  lockSmall: u("lock-small", 60391),
  azureDevops: u("azure-devops", 60392),
  verifiedFilled: u("verified-filled", 60393),
  newline: u("newline", 60394),
  layout: u("layout", 60395),
  layoutActivitybarLeft: u("layout-activitybar-left", 60396),
  layoutActivitybarRight: u("layout-activitybar-right", 60397),
  layoutPanelLeft: u("layout-panel-left", 60398),
  layoutPanelCenter: u("layout-panel-center", 60399),
  layoutPanelJustify: u("layout-panel-justify", 60400),
  layoutPanelRight: u("layout-panel-right", 60401),
  layoutPanel: u("layout-panel", 60402),
  layoutSidebarLeft: u("layout-sidebar-left", 60403),
  layoutSidebarRight: u("layout-sidebar-right", 60404),
  layoutStatusbar: u("layout-statusbar", 60405),
  layoutMenubar: u("layout-menubar", 60406),
  layoutCentered: u("layout-centered", 60407),
  target: u("target", 60408),
  indent: u("indent", 60409),
  recordSmall: u("record-small", 60410),
  errorSmall: u("error-small", 60411),
  terminalDecorationError: u("terminal-decoration-error", 60411),
  arrowCircleDown: u("arrow-circle-down", 60412),
  arrowCircleLeft: u("arrow-circle-left", 60413),
  arrowCircleRight: u("arrow-circle-right", 60414),
  arrowCircleUp: u("arrow-circle-up", 60415),
  layoutSidebarRightOff: u("layout-sidebar-right-off", 60416),
  layoutPanelOff: u("layout-panel-off", 60417),
  layoutSidebarLeftOff: u("layout-sidebar-left-off", 60418),
  blank: u("blank", 60419),
  heartFilled: u("heart-filled", 60420),
  map: u("map", 60421),
  mapHorizontal: u("map-horizontal", 60421),
  foldHorizontal: u("fold-horizontal", 60421),
  mapFilled: u("map-filled", 60422),
  mapHorizontalFilled: u("map-horizontal-filled", 60422),
  foldHorizontalFilled: u("fold-horizontal-filled", 60422),
  circleSmall: u("circle-small", 60423),
  bellSlash: u("bell-slash", 60424),
  bellSlashDot: u("bell-slash-dot", 60425),
  commentUnresolved: u("comment-unresolved", 60426),
  gitPullRequestGoToChanges: u("git-pull-request-go-to-changes", 60427),
  gitPullRequestNewChanges: u("git-pull-request-new-changes", 60428),
  searchFuzzy: u("search-fuzzy", 60429),
  commentDraft: u("comment-draft", 60430),
  send: u("send", 60431),
  sparkle: u("sparkle", 60432),
  insert: u("insert", 60433),
  mic: u("mic", 60434),
  thumbsdownFilled: u("thumbsdown-filled", 60435),
  thumbsupFilled: u("thumbsup-filled", 60436),
  coffee: u("coffee", 60437),
  snake: u("snake", 60438),
  game: u("game", 60439),
  vr: u("vr", 60440),
  chip: u("chip", 60441),
  piano: u("piano", 60442),
  music: u("music", 60443),
  micFilled: u("mic-filled", 60444),
  repoFetch: u("repo-fetch", 60445),
  copilot: u("copilot", 60446),
  lightbulbSparkle: u("lightbulb-sparkle", 60447),
  robot: u("robot", 60448),
  sparkleFilled: u("sparkle-filled", 60449),
  diffSingle: u("diff-single", 60450),
  diffMultiple: u("diff-multiple", 60451),
  surroundWith: u("surround-with", 60452),
  share: u("share", 60453),
  gitStash: u("git-stash", 60454),
  gitStashApply: u("git-stash-apply", 60455),
  gitStashPop: u("git-stash-pop", 60456),
  vscode: u("vscode", 60457),
  vscodeInsiders: u("vscode-insiders", 60458),
  codeOss: u("code-oss", 60459),
  runCoverage: u("run-coverage", 60460),
  runAllCoverage: u("run-all-coverage", 60461),
  coverage: u("coverage", 60462),
  githubProject: u("github-project", 60463),
  mapVertical: u("map-vertical", 60464),
  foldVertical: u("fold-vertical", 60464),
  mapVerticalFilled: u("map-vertical-filled", 60465),
  foldVerticalFilled: u("fold-vertical-filled", 60465),
  goToSearch: u("go-to-search", 60466),
  percentage: u("percentage", 60467),
  sortPercentage: u("sort-percentage", 60467),
  attach: u("attach", 60468)
}, cl = {
  dialogError: u("dialog-error", "error"),
  dialogWarning: u("dialog-warning", "warning"),
  dialogInfo: u("dialog-info", "info"),
  dialogClose: u("dialog-close", "close"),
  treeItemExpanded: u("tree-item-expanded", "chevron-down"),
  // collapsed is done with rotation
  treeFilterOnTypeOn: u("tree-filter-on-type-on", "list-filter"),
  treeFilterOnTypeOff: u("tree-filter-on-type-off", "list-selection"),
  treeFilterClear: u("tree-filter-clear", "close"),
  treeItemLoading: u("tree-item-loading", "loading"),
  menuSelection: u("menu-selection", "check"),
  menuSubmenu: u("menu-submenu", "chevron-right"),
  menuBarMore: u("menubar-more", "more"),
  scrollbarButtonLeft: u("scrollbar-button-left", "triangle-left"),
  scrollbarButtonRight: u("scrollbar-button-right", "triangle-right"),
  scrollbarButtonUp: u("scrollbar-button-up", "triangle-up"),
  scrollbarButtonDown: u("scrollbar-button-down", "triangle-down"),
  toolBarMore: u("toolbar-more", "more"),
  quickInputBack: u("quick-input-back", "arrow-left"),
  dropDownButton: u("drop-down-button", 60084),
  symbolCustomColor: u("symbol-customcolor", 60252),
  exportIcon: u("export", 60332),
  workspaceUnspecified: u("workspace-unspecified", 60355),
  newLine: u("newline", 60394),
  thumbsDownFilled: u("thumbsdown-filled", 60435),
  thumbsUpFilled: u("thumbsup-filled", 60436),
  gitFetch: u("git-fetch", 60445),
  lightbulbSparkleAutofix: u("lightbulb-sparkle-autofix", 60447),
  debugBreakpointPending: u("debug-breakpoint-pending", 60377)
}, M = {
  ...ll,
  ...cl
};
class oo {
  constructor() {
    this._tokenizationSupports = /* @__PURE__ */ new Map(), this._factories = /* @__PURE__ */ new Map(), this._onDidChange = new we(), this.onDidChange = this._onDidChange.event, this._colorMap = null;
  }
  handleChange(e) {
    this._onDidChange.fire({
      changedLanguages: e,
      changedColorMap: !1
    });
  }
  register(e, n) {
    return this._tokenizationSupports.set(e, n), this.handleChange([e]), nn(() => {
      this._tokenizationSupports.get(e) === n && (this._tokenizationSupports.delete(e), this.handleChange([e]));
    });
  }
  get(e) {
    return this._tokenizationSupports.get(e) || null;
  }
  registerFactory(e, n) {
    this._factories.get(e)?.dispose();
    const i = new hl(this, e, n);
    return this._factories.set(e, i), nn(() => {
      const r = this._factories.get(e);
      !r || r !== i || (this._factories.delete(e), r.dispose());
    });
  }
  async getOrCreate(e) {
    const n = this.get(e);
    if (n)
      return n;
    const i = this._factories.get(e);
    return !i || i.isResolved ? null : (await i.resolve(), this.get(e));
  }
  isResolved(e) {
    if (this.get(e))
      return !0;
    const i = this._factories.get(e);
    return !!(!i || i.isResolved);
  }
  setColorMap(e) {
    this._colorMap = e, this._onDidChange.fire({
      changedLanguages: Array.from(this._tokenizationSupports.keys()),
      changedColorMap: !0
    });
  }
  getColorMap() {
    return this._colorMap;
  }
  getDefaultBackground() {
    return this._colorMap && this._colorMap.length > 2 ? this._colorMap[
      2
      /* ColorId.DefaultBackground */
    ] : null;
  }
}
class hl extends rn {
  get isResolved() {
    return this._isResolved;
  }
  constructor(e, n, i) {
    super(), this._registry = e, this._languageId = n, this._factory = i, this._isDisposed = !1, this._resolvePromise = null, this._isResolved = !1;
  }
  dispose() {
    this._isDisposed = !0, super.dispose();
  }
  async resolve() {
    return this._resolvePromise || (this._resolvePromise = this._create()), this._resolvePromise;
  }
  async _create() {
    const e = await this._factory.tokenizationSupport;
    this._isResolved = !0, e && !this._isDisposed && this._register(this._registry.register(this._languageId, e));
  }
}
class dl {
  constructor(e, n, i) {
    this.offset = e, this.type = n, this.language = i, this._tokenBrand = void 0;
  }
  toString() {
    return "(" + this.offset + ", " + this.type + ")";
  }
}
var ar;
(function(t) {
  t[t.Increase = 0] = "Increase", t[t.Decrease = 1] = "Decrease";
})(ar || (ar = {}));
var or;
(function(t) {
  const e = /* @__PURE__ */ new Map();
  e.set(0, M.symbolMethod), e.set(1, M.symbolFunction), e.set(2, M.symbolConstructor), e.set(3, M.symbolField), e.set(4, M.symbolVariable), e.set(5, M.symbolClass), e.set(6, M.symbolStruct), e.set(7, M.symbolInterface), e.set(8, M.symbolModule), e.set(9, M.symbolProperty), e.set(10, M.symbolEvent), e.set(11, M.symbolOperator), e.set(12, M.symbolUnit), e.set(13, M.symbolValue), e.set(15, M.symbolEnum), e.set(14, M.symbolConstant), e.set(15, M.symbolEnum), e.set(16, M.symbolEnumMember), e.set(17, M.symbolKeyword), e.set(27, M.symbolSnippet), e.set(18, M.symbolText), e.set(19, M.symbolColor), e.set(20, M.symbolFile), e.set(21, M.symbolReference), e.set(22, M.symbolCustomColor), e.set(23, M.symbolFolder), e.set(24, M.symbolTypeParameter), e.set(25, M.account), e.set(26, M.issues);
  function n(s) {
    let a = e.get(s);
    return a || (console.info("No codicon found for CompletionItemKind " + s), a = M.symbolProperty), a;
  }
  t.toIcon = n;
  const i = /* @__PURE__ */ new Map();
  i.set(
    "method",
    0
    /* CompletionItemKind.Method */
  ), i.set(
    "function",
    1
    /* CompletionItemKind.Function */
  ), i.set(
    "constructor",
    2
    /* CompletionItemKind.Constructor */
  ), i.set(
    "field",
    3
    /* CompletionItemKind.Field */
  ), i.set(
    "variable",
    4
    /* CompletionItemKind.Variable */
  ), i.set(
    "class",
    5
    /* CompletionItemKind.Class */
  ), i.set(
    "struct",
    6
    /* CompletionItemKind.Struct */
  ), i.set(
    "interface",
    7
    /* CompletionItemKind.Interface */
  ), i.set(
    "module",
    8
    /* CompletionItemKind.Module */
  ), i.set(
    "property",
    9
    /* CompletionItemKind.Property */
  ), i.set(
    "event",
    10
    /* CompletionItemKind.Event */
  ), i.set(
    "operator",
    11
    /* CompletionItemKind.Operator */
  ), i.set(
    "unit",
    12
    /* CompletionItemKind.Unit */
  ), i.set(
    "value",
    13
    /* CompletionItemKind.Value */
  ), i.set(
    "constant",
    14
    /* CompletionItemKind.Constant */
  ), i.set(
    "enum",
    15
    /* CompletionItemKind.Enum */
  ), i.set(
    "enum-member",
    16
    /* CompletionItemKind.EnumMember */
  ), i.set(
    "enumMember",
    16
    /* CompletionItemKind.EnumMember */
  ), i.set(
    "keyword",
    17
    /* CompletionItemKind.Keyword */
  ), i.set(
    "snippet",
    27
    /* CompletionItemKind.Snippet */
  ), i.set(
    "text",
    18
    /* CompletionItemKind.Text */
  ), i.set(
    "color",
    19
    /* CompletionItemKind.Color */
  ), i.set(
    "file",
    20
    /* CompletionItemKind.File */
  ), i.set(
    "reference",
    21
    /* CompletionItemKind.Reference */
  ), i.set(
    "customcolor",
    22
    /* CompletionItemKind.Customcolor */
  ), i.set(
    "folder",
    23
    /* CompletionItemKind.Folder */
  ), i.set(
    "type-parameter",
    24
    /* CompletionItemKind.TypeParameter */
  ), i.set(
    "typeParameter",
    24
    /* CompletionItemKind.TypeParameter */
  ), i.set(
    "account",
    25
    /* CompletionItemKind.User */
  ), i.set(
    "issue",
    26
    /* CompletionItemKind.Issue */
  );
  function r(s, a) {
    let o = i.get(s);
    return typeof o > "u" && !a && (o = 9), o;
  }
  t.fromString = r;
})(or || (or = {}));
var ur;
(function(t) {
  t[t.Automatic = 0] = "Automatic", t[t.Explicit = 1] = "Explicit";
})(ur || (ur = {}));
var lr;
(function(t) {
  t[t.Automatic = 0] = "Automatic", t[t.PasteAs = 1] = "PasteAs";
})(lr || (lr = {}));
var cr;
(function(t) {
  t[t.Invoke = 1] = "Invoke", t[t.TriggerCharacter = 2] = "TriggerCharacter", t[t.ContentChange = 3] = "ContentChange";
})(cr || (cr = {}));
var hr;
(function(t) {
  t[t.Text = 0] = "Text", t[t.Read = 1] = "Read", t[t.Write = 2] = "Write";
})(hr || (hr = {}));
Z("Array", "array"), Z("Boolean", "boolean"), Z("Class", "class"), Z("Constant", "constant"), Z("Constructor", "constructor"), Z("Enum", "enumeration"), Z("EnumMember", "enumeration member"), Z("Event", "event"), Z("Field", "field"), Z("File", "file"), Z("Function", "function"), Z("Interface", "interface"), Z("Key", "key"), Z("Method", "method"), Z("Module", "module"), Z("Namespace", "namespace"), Z("Null", "null"), Z("Number", "number"), Z("Object", "object"), Z("Operator", "operator"), Z("Package", "package"), Z("Property", "property"), Z("String", "string"), Z("Struct", "struct"), Z("TypeParameter", "type parameter"), Z("Variable", "variable");
var dr;
(function(t) {
  const e = /* @__PURE__ */ new Map();
  e.set(0, M.symbolFile), e.set(1, M.symbolModule), e.set(2, M.symbolNamespace), e.set(3, M.symbolPackage), e.set(4, M.symbolClass), e.set(5, M.symbolMethod), e.set(6, M.symbolProperty), e.set(7, M.symbolField), e.set(8, M.symbolConstructor), e.set(9, M.symbolEnum), e.set(10, M.symbolInterface), e.set(11, M.symbolFunction), e.set(12, M.symbolVariable), e.set(13, M.symbolConstant), e.set(14, M.symbolString), e.set(15, M.symbolNumber), e.set(16, M.symbolBoolean), e.set(17, M.symbolArray), e.set(18, M.symbolObject), e.set(19, M.symbolKey), e.set(20, M.symbolNull), e.set(21, M.symbolEnumMember), e.set(22, M.symbolStruct), e.set(23, M.symbolEvent), e.set(24, M.symbolOperator), e.set(25, M.symbolTypeParameter);
  function n(i) {
    let r = e.get(i);
    return r || (console.info("No codicon found for SymbolKind " + i), r = M.symbolProperty), r;
  }
  t.toIcon = n;
})(dr || (dr = {}));
let X1 = class je {
  static {
    this.Comment = new je("comment");
  }
  static {
    this.Imports = new je("imports");
  }
  static {
    this.Region = new je("region");
  }
  /**
   * Returns a {@link FoldingRangeKind} for the given value.
   *
   * @param value of the kind.
   */
  static fromValue(e) {
    switch (e) {
      case "comment":
        return je.Comment;
      case "imports":
        return je.Imports;
      case "region":
        return je.Region;
    }
    return new je(e);
  }
  /**
   * Creates a new {@link FoldingRangeKind}.
   *
   * @param value of the kind.
   */
  constructor(e) {
    this.value = e;
  }
};
var fr;
(function(t) {
  t[t.AIGenerated = 1] = "AIGenerated";
})(fr || (fr = {}));
var mr;
(function(t) {
  t[t.Invoke = 0] = "Invoke", t[t.Automatic = 1] = "Automatic";
})(mr || (mr = {}));
var gr;
(function(t) {
  function e(n) {
    return !n || typeof n != "object" ? !1 : typeof n.id == "string" && typeof n.title == "string";
  }
  t.is = e;
})(gr || (gr = {}));
var pr;
(function(t) {
  t[t.Type = 1] = "Type", t[t.Parameter = 2] = "Parameter";
})(pr || (pr = {}));
new oo();
new oo();
var br;
(function(t) {
  t[t.Invoke = 0] = "Invoke", t[t.Automatic = 1] = "Automatic";
})(br || (br = {}));
var Dr;
(function(t) {
  t[t.Unknown = 0] = "Unknown", t[t.Disabled = 1] = "Disabled", t[t.Enabled = 2] = "Enabled";
})(Dr || (Dr = {}));
var xr;
(function(t) {
  t[t.Invoke = 1] = "Invoke", t[t.Auto = 2] = "Auto";
})(xr || (xr = {}));
var Cr;
(function(t) {
  t[t.None = 0] = "None", t[t.KeepWhitespace = 1] = "KeepWhitespace", t[t.InsertAsSnippet = 4] = "InsertAsSnippet";
})(Cr || (Cr = {}));
var Er;
(function(t) {
  t[t.Method = 0] = "Method", t[t.Function = 1] = "Function", t[t.Constructor = 2] = "Constructor", t[t.Field = 3] = "Field", t[t.Variable = 4] = "Variable", t[t.Class = 5] = "Class", t[t.Struct = 6] = "Struct", t[t.Interface = 7] = "Interface", t[t.Module = 8] = "Module", t[t.Property = 9] = "Property", t[t.Event = 10] = "Event", t[t.Operator = 11] = "Operator", t[t.Unit = 12] = "Unit", t[t.Value = 13] = "Value", t[t.Constant = 14] = "Constant", t[t.Enum = 15] = "Enum", t[t.EnumMember = 16] = "EnumMember", t[t.Keyword = 17] = "Keyword", t[t.Text = 18] = "Text", t[t.Color = 19] = "Color", t[t.File = 20] = "File", t[t.Reference = 21] = "Reference", t[t.Customcolor = 22] = "Customcolor", t[t.Folder = 23] = "Folder", t[t.TypeParameter = 24] = "TypeParameter", t[t.User = 25] = "User", t[t.Issue = 26] = "Issue", t[t.Snippet = 27] = "Snippet";
})(Er || (Er = {}));
var Ar;
(function(t) {
  t[t.Deprecated = 1] = "Deprecated";
})(Ar || (Ar = {}));
var wr;
(function(t) {
  t[t.Invoke = 0] = "Invoke", t[t.TriggerCharacter = 1] = "TriggerCharacter", t[t.TriggerForIncompleteCompletions = 2] = "TriggerForIncompleteCompletions";
})(wr || (wr = {}));
var Lr;
(function(t) {
  t[t.EXACT = 0] = "EXACT", t[t.ABOVE = 1] = "ABOVE", t[t.BELOW = 2] = "BELOW";
})(Lr || (Lr = {}));
var vr;
(function(t) {
  t[t.NotSet = 0] = "NotSet", t[t.ContentFlush = 1] = "ContentFlush", t[t.RecoverFromMarkers = 2] = "RecoverFromMarkers", t[t.Explicit = 3] = "Explicit", t[t.Paste = 4] = "Paste", t[t.Undo = 5] = "Undo", t[t.Redo = 6] = "Redo";
})(vr || (vr = {}));
var _r;
(function(t) {
  t[t.LF = 1] = "LF", t[t.CRLF = 2] = "CRLF";
})(_r || (_r = {}));
var Fr;
(function(t) {
  t[t.Text = 0] = "Text", t[t.Read = 1] = "Read", t[t.Write = 2] = "Write";
})(Fr || (Fr = {}));
var yr;
(function(t) {
  t[t.None = 0] = "None", t[t.Keep = 1] = "Keep", t[t.Brackets = 2] = "Brackets", t[t.Advanced = 3] = "Advanced", t[t.Full = 4] = "Full";
})(yr || (yr = {}));
var Sr;
(function(t) {
  t[t.acceptSuggestionOnCommitCharacter = 0] = "acceptSuggestionOnCommitCharacter", t[t.acceptSuggestionOnEnter = 1] = "acceptSuggestionOnEnter", t[t.accessibilitySupport = 2] = "accessibilitySupport", t[t.accessibilityPageSize = 3] = "accessibilityPageSize", t[t.ariaLabel = 4] = "ariaLabel", t[t.ariaRequired = 5] = "ariaRequired", t[t.autoClosingBrackets = 6] = "autoClosingBrackets", t[t.autoClosingComments = 7] = "autoClosingComments", t[t.screenReaderAnnounceInlineSuggestion = 8] = "screenReaderAnnounceInlineSuggestion", t[t.autoClosingDelete = 9] = "autoClosingDelete", t[t.autoClosingOvertype = 10] = "autoClosingOvertype", t[t.autoClosingQuotes = 11] = "autoClosingQuotes", t[t.autoIndent = 12] = "autoIndent", t[t.automaticLayout = 13] = "automaticLayout", t[t.autoSurround = 14] = "autoSurround", t[t.bracketPairColorization = 15] = "bracketPairColorization", t[t.guides = 16] = "guides", t[t.codeLens = 17] = "codeLens", t[t.codeLensFontFamily = 18] = "codeLensFontFamily", t[t.codeLensFontSize = 19] = "codeLensFontSize", t[t.colorDecorators = 20] = "colorDecorators", t[t.colorDecoratorsLimit = 21] = "colorDecoratorsLimit", t[t.columnSelection = 22] = "columnSelection", t[t.comments = 23] = "comments", t[t.contextmenu = 24] = "contextmenu", t[t.copyWithSyntaxHighlighting = 25] = "copyWithSyntaxHighlighting", t[t.cursorBlinking = 26] = "cursorBlinking", t[t.cursorSmoothCaretAnimation = 27] = "cursorSmoothCaretAnimation", t[t.cursorStyle = 28] = "cursorStyle", t[t.cursorSurroundingLines = 29] = "cursorSurroundingLines", t[t.cursorSurroundingLinesStyle = 30] = "cursorSurroundingLinesStyle", t[t.cursorWidth = 31] = "cursorWidth", t[t.disableLayerHinting = 32] = "disableLayerHinting", t[t.disableMonospaceOptimizations = 33] = "disableMonospaceOptimizations", t[t.domReadOnly = 34] = "domReadOnly", t[t.dragAndDrop = 35] = "dragAndDrop", t[t.dropIntoEditor = 36] = "dropIntoEditor", t[t.emptySelectionClipboard = 37] = "emptySelectionClipboard", t[t.experimentalWhitespaceRendering = 38] = "experimentalWhitespaceRendering", t[t.extraEditorClassName = 39] = "extraEditorClassName", t[t.fastScrollSensitivity = 40] = "fastScrollSensitivity", t[t.find = 41] = "find", t[t.fixedOverflowWidgets = 42] = "fixedOverflowWidgets", t[t.folding = 43] = "folding", t[t.foldingStrategy = 44] = "foldingStrategy", t[t.foldingHighlight = 45] = "foldingHighlight", t[t.foldingImportsByDefault = 46] = "foldingImportsByDefault", t[t.foldingMaximumRegions = 47] = "foldingMaximumRegions", t[t.unfoldOnClickAfterEndOfLine = 48] = "unfoldOnClickAfterEndOfLine", t[t.fontFamily = 49] = "fontFamily", t[t.fontInfo = 50] = "fontInfo", t[t.fontLigatures = 51] = "fontLigatures", t[t.fontSize = 52] = "fontSize", t[t.fontWeight = 53] = "fontWeight", t[t.fontVariations = 54] = "fontVariations", t[t.formatOnPaste = 55] = "formatOnPaste", t[t.formatOnType = 56] = "formatOnType", t[t.glyphMargin = 57] = "glyphMargin", t[t.gotoLocation = 58] = "gotoLocation", t[t.hideCursorInOverviewRuler = 59] = "hideCursorInOverviewRuler", t[t.hover = 60] = "hover", t[t.inDiffEditor = 61] = "inDiffEditor", t[t.inlineSuggest = 62] = "inlineSuggest", t[t.inlineEdit = 63] = "inlineEdit", t[t.letterSpacing = 64] = "letterSpacing", t[t.lightbulb = 65] = "lightbulb", t[t.lineDecorationsWidth = 66] = "lineDecorationsWidth", t[t.lineHeight = 67] = "lineHeight", t[t.lineNumbers = 68] = "lineNumbers", t[t.lineNumbersMinChars = 69] = "lineNumbersMinChars", t[t.linkedEditing = 70] = "linkedEditing", t[t.links = 71] = "links", t[t.matchBrackets = 72] = "matchBrackets", t[t.minimap = 73] = "minimap", t[t.mouseStyle = 74] = "mouseStyle", t[t.mouseWheelScrollSensitivity = 75] = "mouseWheelScrollSensitivity", t[t.mouseWheelZoom = 76] = "mouseWheelZoom", t[t.multiCursorMergeOverlapping = 77] = "multiCursorMergeOverlapping", t[t.multiCursorModifier = 78] = "multiCursorModifier", t[t.multiCursorPaste = 79] = "multiCursorPaste", t[t.multiCursorLimit = 80] = "multiCursorLimit", t[t.occurrencesHighlight = 81] = "occurrencesHighlight", t[t.overviewRulerBorder = 82] = "overviewRulerBorder", t[t.overviewRulerLanes = 83] = "overviewRulerLanes", t[t.padding = 84] = "padding", t[t.pasteAs = 85] = "pasteAs", t[t.parameterHints = 86] = "parameterHints", t[t.peekWidgetDefaultFocus = 87] = "peekWidgetDefaultFocus", t[t.placeholder = 88] = "placeholder", t[t.definitionLinkOpensInPeek = 89] = "definitionLinkOpensInPeek", t[t.quickSuggestions = 90] = "quickSuggestions", t[t.quickSuggestionsDelay = 91] = "quickSuggestionsDelay", t[t.readOnly = 92] = "readOnly", t[t.readOnlyMessage = 93] = "readOnlyMessage", t[t.renameOnType = 94] = "renameOnType", t[t.renderControlCharacters = 95] = "renderControlCharacters", t[t.renderFinalNewline = 96] = "renderFinalNewline", t[t.renderLineHighlight = 97] = "renderLineHighlight", t[t.renderLineHighlightOnlyWhenFocus = 98] = "renderLineHighlightOnlyWhenFocus", t[t.renderValidationDecorations = 99] = "renderValidationDecorations", t[t.renderWhitespace = 100] = "renderWhitespace", t[t.revealHorizontalRightPadding = 101] = "revealHorizontalRightPadding", t[t.roundedSelection = 102] = "roundedSelection", t[t.rulers = 103] = "rulers", t[t.scrollbar = 104] = "scrollbar", t[t.scrollBeyondLastColumn = 105] = "scrollBeyondLastColumn", t[t.scrollBeyondLastLine = 106] = "scrollBeyondLastLine", t[t.scrollPredominantAxis = 107] = "scrollPredominantAxis", t[t.selectionClipboard = 108] = "selectionClipboard", t[t.selectionHighlight = 109] = "selectionHighlight", t[t.selectOnLineNumbers = 110] = "selectOnLineNumbers", t[t.showFoldingControls = 111] = "showFoldingControls", t[t.showUnused = 112] = "showUnused", t[t.snippetSuggestions = 113] = "snippetSuggestions", t[t.smartSelect = 114] = "smartSelect", t[t.smoothScrolling = 115] = "smoothScrolling", t[t.stickyScroll = 116] = "stickyScroll", t[t.stickyTabStops = 117] = "stickyTabStops", t[t.stopRenderingLineAfter = 118] = "stopRenderingLineAfter", t[t.suggest = 119] = "suggest", t[t.suggestFontSize = 120] = "suggestFontSize", t[t.suggestLineHeight = 121] = "suggestLineHeight", t[t.suggestOnTriggerCharacters = 122] = "suggestOnTriggerCharacters", t[t.suggestSelection = 123] = "suggestSelection", t[t.tabCompletion = 124] = "tabCompletion", t[t.tabIndex = 125] = "tabIndex", t[t.unicodeHighlighting = 126] = "unicodeHighlighting", t[t.unusualLineTerminators = 127] = "unusualLineTerminators", t[t.useShadowDOM = 128] = "useShadowDOM", t[t.useTabStops = 129] = "useTabStops", t[t.wordBreak = 130] = "wordBreak", t[t.wordSegmenterLocales = 131] = "wordSegmenterLocales", t[t.wordSeparators = 132] = "wordSeparators", t[t.wordWrap = 133] = "wordWrap", t[t.wordWrapBreakAfterCharacters = 134] = "wordWrapBreakAfterCharacters", t[t.wordWrapBreakBeforeCharacters = 135] = "wordWrapBreakBeforeCharacters", t[t.wordWrapColumn = 136] = "wordWrapColumn", t[t.wordWrapOverride1 = 137] = "wordWrapOverride1", t[t.wordWrapOverride2 = 138] = "wordWrapOverride2", t[t.wrappingIndent = 139] = "wrappingIndent", t[t.wrappingStrategy = 140] = "wrappingStrategy", t[t.showDeprecated = 141] = "showDeprecated", t[t.inlayHints = 142] = "inlayHints", t[t.editorClassName = 143] = "editorClassName", t[t.pixelRatio = 144] = "pixelRatio", t[t.tabFocusMode = 145] = "tabFocusMode", t[t.layoutInfo = 146] = "layoutInfo", t[t.wrappingInfo = 147] = "wrappingInfo", t[t.defaultColorDecorators = 148] = "defaultColorDecorators", t[t.colorDecoratorsActivatedOn = 149] = "colorDecoratorsActivatedOn", t[t.inlineCompletionsAccessibilityVerbose = 150] = "inlineCompletionsAccessibilityVerbose";
})(Sr || (Sr = {}));
var Nr;
(function(t) {
  t[t.TextDefined = 0] = "TextDefined", t[t.LF = 1] = "LF", t[t.CRLF = 2] = "CRLF";
})(Nr || (Nr = {}));
var kr;
(function(t) {
  t[t.LF = 0] = "LF", t[t.CRLF = 1] = "CRLF";
})(kr || (kr = {}));
var Br;
(function(t) {
  t[t.Left = 1] = "Left", t[t.Center = 2] = "Center", t[t.Right = 3] = "Right";
})(Br || (Br = {}));
var Ir;
(function(t) {
  t[t.Increase = 0] = "Increase", t[t.Decrease = 1] = "Decrease";
})(Ir || (Ir = {}));
var Rr;
(function(t) {
  t[t.None = 0] = "None", t[t.Indent = 1] = "Indent", t[t.IndentOutdent = 2] = "IndentOutdent", t[t.Outdent = 3] = "Outdent";
})(Rr || (Rr = {}));
var Mr;
(function(t) {
  t[t.Both = 0] = "Both", t[t.Right = 1] = "Right", t[t.Left = 2] = "Left", t[t.None = 3] = "None";
})(Mr || (Mr = {}));
var Pr;
(function(t) {
  t[t.Type = 1] = "Type", t[t.Parameter = 2] = "Parameter";
})(Pr || (Pr = {}));
var Tr;
(function(t) {
  t[t.Automatic = 0] = "Automatic", t[t.Explicit = 1] = "Explicit";
})(Tr || (Tr = {}));
var Ur;
(function(t) {
  t[t.Invoke = 0] = "Invoke", t[t.Automatic = 1] = "Automatic";
})(Ur || (Ur = {}));
var ti;
(function(t) {
  t[t.DependsOnKbLayout = -1] = "DependsOnKbLayout", t[t.Unknown = 0] = "Unknown", t[t.Backspace = 1] = "Backspace", t[t.Tab = 2] = "Tab", t[t.Enter = 3] = "Enter", t[t.Shift = 4] = "Shift", t[t.Ctrl = 5] = "Ctrl", t[t.Alt = 6] = "Alt", t[t.PauseBreak = 7] = "PauseBreak", t[t.CapsLock = 8] = "CapsLock", t[t.Escape = 9] = "Escape", t[t.Space = 10] = "Space", t[t.PageUp = 11] = "PageUp", t[t.PageDown = 12] = "PageDown", t[t.End = 13] = "End", t[t.Home = 14] = "Home", t[t.LeftArrow = 15] = "LeftArrow", t[t.UpArrow = 16] = "UpArrow", t[t.RightArrow = 17] = "RightArrow", t[t.DownArrow = 18] = "DownArrow", t[t.Insert = 19] = "Insert", t[t.Delete = 20] = "Delete", t[t.Digit0 = 21] = "Digit0", t[t.Digit1 = 22] = "Digit1", t[t.Digit2 = 23] = "Digit2", t[t.Digit3 = 24] = "Digit3", t[t.Digit4 = 25] = "Digit4", t[t.Digit5 = 26] = "Digit5", t[t.Digit6 = 27] = "Digit6", t[t.Digit7 = 28] = "Digit7", t[t.Digit8 = 29] = "Digit8", t[t.Digit9 = 30] = "Digit9", t[t.KeyA = 31] = "KeyA", t[t.KeyB = 32] = "KeyB", t[t.KeyC = 33] = "KeyC", t[t.KeyD = 34] = "KeyD", t[t.KeyE = 35] = "KeyE", t[t.KeyF = 36] = "KeyF", t[t.KeyG = 37] = "KeyG", t[t.KeyH = 38] = "KeyH", t[t.KeyI = 39] = "KeyI", t[t.KeyJ = 40] = "KeyJ", t[t.KeyK = 41] = "KeyK", t[t.KeyL = 42] = "KeyL", t[t.KeyM = 43] = "KeyM", t[t.KeyN = 44] = "KeyN", t[t.KeyO = 45] = "KeyO", t[t.KeyP = 46] = "KeyP", t[t.KeyQ = 47] = "KeyQ", t[t.KeyR = 48] = "KeyR", t[t.KeyS = 49] = "KeyS", t[t.KeyT = 50] = "KeyT", t[t.KeyU = 51] = "KeyU", t[t.KeyV = 52] = "KeyV", t[t.KeyW = 53] = "KeyW", t[t.KeyX = 54] = "KeyX", t[t.KeyY = 55] = "KeyY", t[t.KeyZ = 56] = "KeyZ", t[t.Meta = 57] = "Meta", t[t.ContextMenu = 58] = "ContextMenu", t[t.F1 = 59] = "F1", t[t.F2 = 60] = "F2", t[t.F3 = 61] = "F3", t[t.F4 = 62] = "F4", t[t.F5 = 63] = "F5", t[t.F6 = 64] = "F6", t[t.F7 = 65] = "F7", t[t.F8 = 66] = "F8", t[t.F9 = 67] = "F9", t[t.F10 = 68] = "F10", t[t.F11 = 69] = "F11", t[t.F12 = 70] = "F12", t[t.F13 = 71] = "F13", t[t.F14 = 72] = "F14", t[t.F15 = 73] = "F15", t[t.F16 = 74] = "F16", t[t.F17 = 75] = "F17", t[t.F18 = 76] = "F18", t[t.F19 = 77] = "F19", t[t.F20 = 78] = "F20", t[t.F21 = 79] = "F21", t[t.F22 = 80] = "F22", t[t.F23 = 81] = "F23", t[t.F24 = 82] = "F24", t[t.NumLock = 83] = "NumLock", t[t.ScrollLock = 84] = "ScrollLock", t[t.Semicolon = 85] = "Semicolon", t[t.Equal = 86] = "Equal", t[t.Comma = 87] = "Comma", t[t.Minus = 88] = "Minus", t[t.Period = 89] = "Period", t[t.Slash = 90] = "Slash", t[t.Backquote = 91] = "Backquote", t[t.BracketLeft = 92] = "BracketLeft", t[t.Backslash = 93] = "Backslash", t[t.BracketRight = 94] = "BracketRight", t[t.Quote = 95] = "Quote", t[t.OEM_8 = 96] = "OEM_8", t[t.IntlBackslash = 97] = "IntlBackslash", t[t.Numpad0 = 98] = "Numpad0", t[t.Numpad1 = 99] = "Numpad1", t[t.Numpad2 = 100] = "Numpad2", t[t.Numpad3 = 101] = "Numpad3", t[t.Numpad4 = 102] = "Numpad4", t[t.Numpad5 = 103] = "Numpad5", t[t.Numpad6 = 104] = "Numpad6", t[t.Numpad7 = 105] = "Numpad7", t[t.Numpad8 = 106] = "Numpad8", t[t.Numpad9 = 107] = "Numpad9", t[t.NumpadMultiply = 108] = "NumpadMultiply", t[t.NumpadAdd = 109] = "NumpadAdd", t[t.NUMPAD_SEPARATOR = 110] = "NUMPAD_SEPARATOR", t[t.NumpadSubtract = 111] = "NumpadSubtract", t[t.NumpadDecimal = 112] = "NumpadDecimal", t[t.NumpadDivide = 113] = "NumpadDivide", t[t.KEY_IN_COMPOSITION = 114] = "KEY_IN_COMPOSITION", t[t.ABNT_C1 = 115] = "ABNT_C1", t[t.ABNT_C2 = 116] = "ABNT_C2", t[t.AudioVolumeMute = 117] = "AudioVolumeMute", t[t.AudioVolumeUp = 118] = "AudioVolumeUp", t[t.AudioVolumeDown = 119] = "AudioVolumeDown", t[t.BrowserSearch = 120] = "BrowserSearch", t[t.BrowserHome = 121] = "BrowserHome", t[t.BrowserBack = 122] = "BrowserBack", t[t.BrowserForward = 123] = "BrowserForward", t[t.MediaTrackNext = 124] = "MediaTrackNext", t[t.MediaTrackPrevious = 125] = "MediaTrackPrevious", t[t.MediaStop = 126] = "MediaStop", t[t.MediaPlayPause = 127] = "MediaPlayPause", t[t.LaunchMediaPlayer = 128] = "LaunchMediaPlayer", t[t.LaunchMail = 129] = "LaunchMail", t[t.LaunchApp2 = 130] = "LaunchApp2", t[t.Clear = 131] = "Clear", t[t.MAX_VALUE = 132] = "MAX_VALUE";
})(ti || (ti = {}));
var ni;
(function(t) {
  t[t.Hint = 1] = "Hint", t[t.Info = 2] = "Info", t[t.Warning = 4] = "Warning", t[t.Error = 8] = "Error";
})(ni || (ni = {}));
var ii;
(function(t) {
  t[t.Unnecessary = 1] = "Unnecessary", t[t.Deprecated = 2] = "Deprecated";
})(ii || (ii = {}));
var Vr;
(function(t) {
  t[t.Inline = 1] = "Inline", t[t.Gutter = 2] = "Gutter";
})(Vr || (Vr = {}));
var $r;
(function(t) {
  t[t.Normal = 1] = "Normal", t[t.Underlined = 2] = "Underlined";
})($r || ($r = {}));
var qr;
(function(t) {
  t[t.UNKNOWN = 0] = "UNKNOWN", t[t.TEXTAREA = 1] = "TEXTAREA", t[t.GUTTER_GLYPH_MARGIN = 2] = "GUTTER_GLYPH_MARGIN", t[t.GUTTER_LINE_NUMBERS = 3] = "GUTTER_LINE_NUMBERS", t[t.GUTTER_LINE_DECORATIONS = 4] = "GUTTER_LINE_DECORATIONS", t[t.GUTTER_VIEW_ZONE = 5] = "GUTTER_VIEW_ZONE", t[t.CONTENT_TEXT = 6] = "CONTENT_TEXT", t[t.CONTENT_EMPTY = 7] = "CONTENT_EMPTY", t[t.CONTENT_VIEW_ZONE = 8] = "CONTENT_VIEW_ZONE", t[t.CONTENT_WIDGET = 9] = "CONTENT_WIDGET", t[t.OVERVIEW_RULER = 10] = "OVERVIEW_RULER", t[t.SCROLLBAR = 11] = "SCROLLBAR", t[t.OVERLAY_WIDGET = 12] = "OVERLAY_WIDGET", t[t.OUTSIDE_EDITOR = 13] = "OUTSIDE_EDITOR";
})(qr || (qr = {}));
var zr;
(function(t) {
  t[t.AIGenerated = 1] = "AIGenerated";
})(zr || (zr = {}));
var Wr;
(function(t) {
  t[t.Invoke = 0] = "Invoke", t[t.Automatic = 1] = "Automatic";
})(Wr || (Wr = {}));
var Or;
(function(t) {
  t[t.TOP_RIGHT_CORNER = 0] = "TOP_RIGHT_CORNER", t[t.BOTTOM_RIGHT_CORNER = 1] = "BOTTOM_RIGHT_CORNER", t[t.TOP_CENTER = 2] = "TOP_CENTER";
})(Or || (Or = {}));
var Hr;
(function(t) {
  t[t.Left = 1] = "Left", t[t.Center = 2] = "Center", t[t.Right = 4] = "Right", t[t.Full = 7] = "Full";
})(Hr || (Hr = {}));
var jr;
(function(t) {
  t[t.Word = 0] = "Word", t[t.Line = 1] = "Line", t[t.Suggest = 2] = "Suggest";
})(jr || (jr = {}));
var Gr;
(function(t) {
  t[t.Left = 0] = "Left", t[t.Right = 1] = "Right", t[t.None = 2] = "None", t[t.LeftOfInjectedText = 3] = "LeftOfInjectedText", t[t.RightOfInjectedText = 4] = "RightOfInjectedText";
})(Gr || (Gr = {}));
var Xr;
(function(t) {
  t[t.Off = 0] = "Off", t[t.On = 1] = "On", t[t.Relative = 2] = "Relative", t[t.Interval = 3] = "Interval", t[t.Custom = 4] = "Custom";
})(Xr || (Xr = {}));
var Jr;
(function(t) {
  t[t.None = 0] = "None", t[t.Text = 1] = "Text", t[t.Blocks = 2] = "Blocks";
})(Jr || (Jr = {}));
var Qr;
(function(t) {
  t[t.Smooth = 0] = "Smooth", t[t.Immediate = 1] = "Immediate";
})(Qr || (Qr = {}));
var Yr;
(function(t) {
  t[t.Auto = 1] = "Auto", t[t.Hidden = 2] = "Hidden", t[t.Visible = 3] = "Visible";
})(Yr || (Yr = {}));
var ri;
(function(t) {
  t[t.LTR = 0] = "LTR", t[t.RTL = 1] = "RTL";
})(ri || (ri = {}));
var Zr;
(function(t) {
  t.Off = "off", t.OnCode = "onCode", t.On = "on";
})(Zr || (Zr = {}));
var Kr;
(function(t) {
  t[t.Invoke = 1] = "Invoke", t[t.TriggerCharacter = 2] = "TriggerCharacter", t[t.ContentChange = 3] = "ContentChange";
})(Kr || (Kr = {}));
var es;
(function(t) {
  t[t.File = 0] = "File", t[t.Module = 1] = "Module", t[t.Namespace = 2] = "Namespace", t[t.Package = 3] = "Package", t[t.Class = 4] = "Class", t[t.Method = 5] = "Method", t[t.Property = 6] = "Property", t[t.Field = 7] = "Field", t[t.Constructor = 8] = "Constructor", t[t.Enum = 9] = "Enum", t[t.Interface = 10] = "Interface", t[t.Function = 11] = "Function", t[t.Variable = 12] = "Variable", t[t.Constant = 13] = "Constant", t[t.String = 14] = "String", t[t.Number = 15] = "Number", t[t.Boolean = 16] = "Boolean", t[t.Array = 17] = "Array", t[t.Object = 18] = "Object", t[t.Key = 19] = "Key", t[t.Null = 20] = "Null", t[t.EnumMember = 21] = "EnumMember", t[t.Struct = 22] = "Struct", t[t.Event = 23] = "Event", t[t.Operator = 24] = "Operator", t[t.TypeParameter = 25] = "TypeParameter";
})(es || (es = {}));
var ts;
(function(t) {
  t[t.Deprecated = 1] = "Deprecated";
})(ts || (ts = {}));
var ns;
(function(t) {
  t[t.Hidden = 0] = "Hidden", t[t.Blink = 1] = "Blink", t[t.Smooth = 2] = "Smooth", t[t.Phase = 3] = "Phase", t[t.Expand = 4] = "Expand", t[t.Solid = 5] = "Solid";
})(ns || (ns = {}));
var is;
(function(t) {
  t[t.Line = 1] = "Line", t[t.Block = 2] = "Block", t[t.Underline = 3] = "Underline", t[t.LineThin = 4] = "LineThin", t[t.BlockOutline = 5] = "BlockOutline", t[t.UnderlineThin = 6] = "UnderlineThin";
})(is || (is = {}));
var rs;
(function(t) {
  t[t.AlwaysGrowsWhenTypingAtEdges = 0] = "AlwaysGrowsWhenTypingAtEdges", t[t.NeverGrowsWhenTypingAtEdges = 1] = "NeverGrowsWhenTypingAtEdges", t[t.GrowsOnlyWhenTypingBefore = 2] = "GrowsOnlyWhenTypingBefore", t[t.GrowsOnlyWhenTypingAfter = 3] = "GrowsOnlyWhenTypingAfter";
})(rs || (rs = {}));
var ss;
(function(t) {
  t[t.None = 0] = "None", t[t.Same = 1] = "Same", t[t.Indent = 2] = "Indent", t[t.DeepIndent = 3] = "DeepIndent";
})(ss || (ss = {}));
class fl {
  static {
    this.CtrlCmd = 2048;
  }
  static {
    this.Shift = 1024;
  }
  static {
    this.Alt = 512;
  }
  static {
    this.WinCtrl = 256;
  }
  static chord(e, n) {
    return ol(e, n);
  }
}
function ml() {
  return {
    editor: void 0,
    // undefined override expected here
    languages: void 0,
    // undefined override expected here
    CancellationTokenSource: il,
    Emitter: we,
    KeyCode: ti,
    KeyMod: fl,
    Position: ne,
    Range: H,
    Selection: Ce,
    SelectionDirection: ri,
    MarkerSeverity: ni,
    MarkerTag: ii,
    Uri: ke,
    Token: dl
  };
}
class fn {
  static {
    this.CHANNEL_NAME = "editorWorkerHost";
  }
  static getChannel(e) {
    return e.getChannel(fn.CHANNEL_NAME);
  }
  static setChannel(e, n) {
    e.setChannel(fn.CHANNEL_NAME, n);
  }
}
var as;
class gl {
  constructor() {
    this[as] = "LinkedMap", this._map = /* @__PURE__ */ new Map(), this._head = void 0, this._tail = void 0, this._size = 0, this._state = 0;
  }
  clear() {
    this._map.clear(), this._head = void 0, this._tail = void 0, this._size = 0, this._state++;
  }
  isEmpty() {
    return !this._head && !this._tail;
  }
  get size() {
    return this._size;
  }
  get first() {
    return this._head?.value;
  }
  get last() {
    return this._tail?.value;
  }
  has(e) {
    return this._map.has(e);
  }
  get(e, n = 0) {
    const i = this._map.get(e);
    if (i)
      return n !== 0 && this.touch(i, n), i.value;
  }
  set(e, n, i = 0) {
    let r = this._map.get(e);
    if (r)
      r.value = n, i !== 0 && this.touch(r, i);
    else {
      switch (r = { key: e, value: n, next: void 0, previous: void 0 }, i) {
        case 0:
          this.addItemLast(r);
          break;
        case 1:
          this.addItemFirst(r);
          break;
        case 2:
          this.addItemLast(r);
          break;
        default:
          this.addItemLast(r);
          break;
      }
      this._map.set(e, r), this._size++;
    }
    return this;
  }
  delete(e) {
    return !!this.remove(e);
  }
  remove(e) {
    const n = this._map.get(e);
    if (n)
      return this._map.delete(e), this.removeItem(n), this._size--, n.value;
  }
  shift() {
    if (!this._head && !this._tail)
      return;
    if (!this._head || !this._tail)
      throw new Error("Invalid list");
    const e = this._head;
    return this._map.delete(e.key), this.removeItem(e), this._size--, e.value;
  }
  forEach(e, n) {
    const i = this._state;
    let r = this._head;
    for (; r; ) {
      if (n ? e.bind(n)(r.value, r.key, this) : e(r.value, r.key, this), this._state !== i)
        throw new Error("LinkedMap got modified during iteration.");
      r = r.next;
    }
  }
  keys() {
    const e = this, n = this._state;
    let i = this._head;
    const r = {
      [Symbol.iterator]() {
        return r;
      },
      next() {
        if (e._state !== n)
          throw new Error("LinkedMap got modified during iteration.");
        if (i) {
          const s = { value: i.key, done: !1 };
          return i = i.next, s;
        } else
          return { value: void 0, done: !0 };
      }
    };
    return r;
  }
  values() {
    const e = this, n = this._state;
    let i = this._head;
    const r = {
      [Symbol.iterator]() {
        return r;
      },
      next() {
        if (e._state !== n)
          throw new Error("LinkedMap got modified during iteration.");
        if (i) {
          const s = { value: i.value, done: !1 };
          return i = i.next, s;
        } else
          return { value: void 0, done: !0 };
      }
    };
    return r;
  }
  entries() {
    const e = this, n = this._state;
    let i = this._head;
    const r = {
      [Symbol.iterator]() {
        return r;
      },
      next() {
        if (e._state !== n)
          throw new Error("LinkedMap got modified during iteration.");
        if (i) {
          const s = { value: [i.key, i.value], done: !1 };
          return i = i.next, s;
        } else
          return { value: void 0, done: !0 };
      }
    };
    return r;
  }
  [(as = Symbol.toStringTag, Symbol.iterator)]() {
    return this.entries();
  }
  trimOld(e) {
    if (e >= this.size)
      return;
    if (e === 0) {
      this.clear();
      return;
    }
    let n = this._head, i = this.size;
    for (; n && i > e; )
      this._map.delete(n.key), n = n.next, i--;
    this._head = n, this._size = i, n && (n.previous = void 0), this._state++;
  }
  trimNew(e) {
    if (e >= this.size)
      return;
    if (e === 0) {
      this.clear();
      return;
    }
    let n = this._tail, i = this.size;
    for (; n && i > e; )
      this._map.delete(n.key), n = n.previous, i--;
    this._tail = n, this._size = i, n && (n.next = void 0), this._state++;
  }
  addItemFirst(e) {
    if (!this._head && !this._tail)
      this._tail = e;
    else if (this._head)
      e.next = this._head, this._head.previous = e;
    else
      throw new Error("Invalid list");
    this._head = e, this._state++;
  }
  addItemLast(e) {
    if (!this._head && !this._tail)
      this._head = e;
    else if (this._tail)
      e.previous = this._tail, this._tail.next = e;
    else
      throw new Error("Invalid list");
    this._tail = e, this._state++;
  }
  removeItem(e) {
    if (e === this._head && e === this._tail)
      this._head = void 0, this._tail = void 0;
    else if (e === this._head) {
      if (!e.next)
        throw new Error("Invalid list");
      e.next.previous = void 0, this._head = e.next;
    } else if (e === this._tail) {
      if (!e.previous)
        throw new Error("Invalid list");
      e.previous.next = void 0, this._tail = e.previous;
    } else {
      const n = e.next, i = e.previous;
      if (!n || !i)
        throw new Error("Invalid list");
      n.previous = i, i.next = n;
    }
    e.next = void 0, e.previous = void 0, this._state++;
  }
  touch(e, n) {
    if (!this._head || !this._tail)
      throw new Error("Invalid list");
    if (!(n !== 1 && n !== 2)) {
      if (n === 1) {
        if (e === this._head)
          return;
        const i = e.next, r = e.previous;
        e === this._tail ? (r.next = void 0, this._tail = r) : (i.previous = r, r.next = i), e.previous = void 0, e.next = this._head, this._head.previous = e, this._head = e, this._state++;
      } else if (n === 2) {
        if (e === this._tail)
          return;
        const i = e.next, r = e.previous;
        e === this._head ? (i.previous = void 0, this._head = i) : (i.previous = r, r.next = i), e.next = void 0, e.previous = this._tail, this._tail.next = e, this._tail = e, this._state++;
      }
    }
  }
  toJSON() {
    const e = [];
    return this.forEach((n, i) => {
      e.push([i, n]);
    }), e;
  }
  fromJSON(e) {
    this.clear();
    for (const [n, i] of e)
      this.set(n, i);
  }
}
class pl extends gl {
  constructor(e, n = 1) {
    super(), this._limit = e, this._ratio = Math.min(Math.max(0, n), 1);
  }
  get limit() {
    return this._limit;
  }
  set limit(e) {
    this._limit = e, this.checkTrim();
  }
  get(e, n = 2) {
    return super.get(e, n);
  }
  peek(e) {
    return super.get(
      e,
      0
      /* Touch.None */
    );
  }
  set(e, n) {
    return super.set(
      e,
      n,
      2
      /* Touch.AsNew */
    ), this;
  }
  checkTrim() {
    this.size > this._limit && this.trim(Math.round(this._limit * this._ratio));
  }
}
class bl extends pl {
  constructor(e, n = 1) {
    super(e, n);
  }
  trim(e) {
    this.trimOld(e);
  }
  set(e, n) {
    return super.set(e, n), this.checkTrim(), this;
  }
}
class Dl {
  constructor() {
    this.map = /* @__PURE__ */ new Map();
  }
  add(e, n) {
    let i = this.map.get(e);
    i || (i = /* @__PURE__ */ new Set(), this.map.set(e, i)), i.add(n);
  }
  delete(e, n) {
    const i = this.map.get(e);
    i && (i.delete(n), i.size === 0 && this.map.delete(e));
  }
  forEach(e, n) {
    const i = this.map.get(e);
    i && i.forEach(n);
  }
  get(e) {
    const n = this.map.get(e);
    return n || /* @__PURE__ */ new Set();
  }
}
new bl(10);
function xl(t) {
  let e = [];
  for (; Object.prototype !== t; )
    e = e.concat(Object.getOwnPropertyNames(t)), t = Object.getPrototypeOf(t);
  return e;
}
function os(t) {
  const e = [];
  for (const n of xl(t))
    typeof t[n] == "function" && e.push(n);
  return e;
}
function Cl(t, e) {
  const n = (r) => function() {
    const s = Array.prototype.slice.call(arguments, 0);
    return e(r, s);
  }, i = {};
  for (const r of t)
    i[r] = n(r);
  return i;
}
var us;
(function(t) {
  t[t.Left = 1] = "Left", t[t.Center = 2] = "Center", t[t.Right = 4] = "Right", t[t.Full = 7] = "Full";
})(us || (us = {}));
var ls;
(function(t) {
  t[t.Left = 1] = "Left", t[t.Center = 2] = "Center", t[t.Right = 3] = "Right";
})(ls || (ls = {}));
var cs;
(function(t) {
  t[t.Both = 0] = "Both", t[t.Right = 1] = "Right", t[t.Left = 2] = "Left", t[t.None = 3] = "None";
})(cs || (cs = {}));
function El(t, e, n, i, r) {
  if (i === 0)
    return !0;
  const s = e.charCodeAt(i - 1);
  if (t.get(s) !== 0 || s === 13 || s === 10)
    return !0;
  if (r > 0) {
    const a = e.charCodeAt(i);
    if (t.get(a) !== 0)
      return !0;
  }
  return !1;
}
function Al(t, e, n, i, r) {
  if (i + r === n)
    return !0;
  const s = e.charCodeAt(i + r);
  if (t.get(s) !== 0 || s === 13 || s === 10)
    return !0;
  if (r > 0) {
    const a = e.charCodeAt(i + r - 1);
    if (t.get(a) !== 0)
      return !0;
  }
  return !1;
}
function wl(t, e, n, i, r) {
  return El(t, e, n, i, r) && Al(t, e, n, i, r);
}
class Ll {
  constructor(e, n) {
    this._wordSeparators = e, this._searchRegex = n, this._prevMatchStartIndex = -1, this._prevMatchLength = 0;
  }
  reset(e) {
    this._searchRegex.lastIndex = e, this._prevMatchStartIndex = -1, this._prevMatchLength = 0;
  }
  next(e) {
    const n = e.length;
    let i;
    do {
      if (this._prevMatchStartIndex + this._prevMatchLength === n || (i = this._searchRegex.exec(e), !i))
        return null;
      const r = i.index, s = i[0].length;
      if (r === this._prevMatchStartIndex && s === this._prevMatchLength) {
        if (s === 0) {
          pu(e, n, this._searchRegex.lastIndex) > 65535 ? this._searchRegex.lastIndex += 2 : this._searchRegex.lastIndex += 1;
          continue;
        }
        return null;
      }
      if (this._prevMatchStartIndex = r, this._prevMatchLength = s, !this._wordSeparators || wl(this._wordSeparators, e, n, r, s))
        return i;
    } while (i);
    return null;
  }
}
function vl(t, e = "Unreachable") {
  throw new Error(e);
}
function mn(t) {
  if (!t()) {
    debugger;
    t(), yt(new Ae("Assertion Failed"));
  }
}
function uo(t, e) {
  let n = 0;
  for (; n < t.length - 1; ) {
    const i = t[n], r = t[n + 1];
    if (!e(i, r))
      return !1;
    n++;
  }
  return !0;
}
const _l = "`~!@#$%^&*()-=+[{]}\\|;:'\",.<>/?";
function Fl(t = "") {
  let e = "(-?\\d*\\.\\d\\w*)|([^";
  for (const n of _l)
    t.indexOf(n) >= 0 || (e += "\\" + n);
  return e += "\\s]+)", new RegExp(e, "g");
}
const lo = Fl();
function co(t) {
  let e = lo;
  if (t && t instanceof RegExp)
    if (t.global)
      e = t;
    else {
      let n = "g";
      t.ignoreCase && (n += "i"), t.multiline && (n += "m"), t.unicode && (n += "u"), e = new RegExp(t.source, n);
    }
  return e.lastIndex = 0, e;
}
const ho = new Oo();
ho.unshift({
  maxLen: 1e3,
  windowSize: 15,
  timeBudget: 150
});
function Ui(t, e, n, i, r) {
  if (e = co(e), r || (r = tn.first(ho)), n.length > r.maxLen) {
    let c = t - r.maxLen / 2;
    return c < 0 ? c = 0 : i += c, n = n.substring(c, t + r.maxLen / 2), Ui(t, e, n, i, r);
  }
  const s = Date.now(), a = t - 1 - i;
  let o = -1, l = null;
  for (let c = 1; !(Date.now() - s >= r.timeBudget); c++) {
    const d = a - r.windowSize * c;
    e.lastIndex = Math.max(0, d);
    const h = yl(e, n, a, o);
    if (!h && l || (l = h, d <= 0))
      break;
    o = d;
  }
  if (l) {
    const c = {
      word: l[0],
      startColumn: i + 1 + l.index,
      endColumn: i + 1 + l.index + l[0].length
    };
    return e.lastIndex = 0, c;
  }
  return null;
}
function yl(t, e, n, i) {
  let r;
  for (; r = t.exec(e); ) {
    const s = r.index || 0;
    if (s <= n && t.lastIndex >= n)
      return r;
    if (i > 0 && s > i)
      return null;
  }
  return null;
}
class Sl {
  static computeUnicodeHighlights(e, n, i) {
    const r = i ? i.startLineNumber : 1, s = i ? i.endLineNumber : e.getLineCount(), a = new hs(n), o = a.getCandidateCodePoints();
    let l;
    o === "allNonBasicAscii" ? l = new RegExp("[^\\t\\n\\r\\x20-\\x7E]", "g") : l = new RegExp(`${Nl(Array.from(o))}`, "g");
    const c = new Ll(null, l), d = [];
    let h = !1, f, m = 0, b = 0, D = 0;
    e: for (let E = r, L = s; E <= L; E++) {
      const _ = e.getLineContent(E), v = _.length;
      c.reset(0);
      do
        if (f = c.next(_), f) {
          let C = f.index, x = f.index + f[0].length;
          if (C > 0) {
            const j = _.charCodeAt(C - 1);
            on(j) && C--;
          }
          if (x + 1 < v) {
            const j = _.charCodeAt(x - 1);
            on(j) && x++;
          }
          const w = _.substring(C, x);
          let N = Ui(C + 1, lo, _, 0);
          N && N.endColumn <= C + 1 && (N = null);
          const B = a.shouldHighlightNonBasicASCII(w, N ? N.word : null);
          if (B !== 0) {
            if (B === 3 ? m++ : B === 2 ? b++ : B === 1 ? D++ : vl(), d.length >= 1e3) {
              h = !0;
              break e;
            }
            d.push(new H(E, C + 1, E, x + 1));
          }
        }
      while (f);
    }
    return {
      ranges: d,
      hasMore: h,
      ambiguousCharacterCount: m,
      invisibleCharacterCount: b,
      nonBasicAsciiCharacterCount: D
    };
  }
  static computeUnicodeHighlightReason(e, n) {
    const i = new hs(n);
    switch (i.shouldHighlightNonBasicASCII(e, null)) {
      case 0:
        return null;
      case 2:
        return {
          kind: 1
          /* UnicodeHighlighterReasonKind.Invisible */
        };
      case 3: {
        const s = e.codePointAt(0), a = i.ambiguousCharacters.getPrimaryConfusable(s), o = Xe.getLocales().filter((l) => !Xe.getInstance(/* @__PURE__ */ new Set([...n.allowedLocales, l])).isAmbiguous(s));
        return { kind: 0, confusableWith: String.fromCodePoint(a), notAmbiguousInLocales: o };
      }
      case 1:
        return {
          kind: 2
          /* UnicodeHighlighterReasonKind.NonBasicAscii */
        };
    }
  }
}
function Nl(t, e) {
  return `[${du(t.map((i) => String.fromCodePoint(i)).join(""))}]`;
}
class hs {
  constructor(e) {
    this.options = e, this.allowedCodePoints = new Set(e.allowedCodePoints), this.ambiguousCharacters = Xe.getInstance(new Set(e.allowedLocales));
  }
  getCandidateCodePoints() {
    if (this.options.nonBasicASCII)
      return "allNonBasicAscii";
    const e = /* @__PURE__ */ new Set();
    if (this.options.invisibleCharacters)
      for (const n of et.codePoints)
        ds(String.fromCodePoint(n)) || e.add(n);
    if (this.options.ambiguousCharacters)
      for (const n of this.ambiguousCharacters.getConfusableCodePoints())
        e.add(n);
    for (const n of this.allowedCodePoints)
      e.delete(n);
    return e;
  }
  shouldHighlightNonBasicASCII(e, n) {
    const i = e.codePointAt(0);
    if (this.allowedCodePoints.has(i))
      return 0;
    if (this.options.nonBasicASCII)
      return 1;
    let r = !1, s = !1;
    if (n)
      for (const a of n) {
        const o = a.codePointAt(0), l = Du(a);
        r = r || l, !l && !this.ambiguousCharacters.isAmbiguous(o) && !et.isInvisibleCharacter(o) && (s = !0);
      }
    return (
      /* Don't allow mixing weird looking characters with ASCII */
      !r && /* Is there an obviously weird looking character? */
      s ? 0 : this.options.invisibleCharacters && !ds(e) && et.isInvisibleCharacter(i) ? 2 : this.options.ambiguousCharacters && this.ambiguousCharacters.isAmbiguous(i) ? 3 : 0
    );
  }
}
function ds(t) {
  return t === " " || t === `
` || t === "	";
}
class Jt {
  constructor(e, n, i) {
    this.changes = e, this.moves = n, this.hitTimeout = i;
  }
}
class kl {
  constructor(e, n) {
    this.lineRangeMapping = e, this.changes = n;
  }
}
class O {
  static addRange(e, n) {
    let i = 0;
    for (; i < n.length && n[i].endExclusive < e.start; )
      i++;
    let r = i;
    for (; r < n.length && n[r].start <= e.endExclusive; )
      r++;
    if (i === r)
      n.splice(i, 0, e);
    else {
      const s = Math.min(e.start, n[i].start), a = Math.max(e.endExclusive, n[r - 1].endExclusive);
      n.splice(i, r - i, new O(s, a));
    }
  }
  static tryCreate(e, n) {
    if (!(e > n))
      return new O(e, n);
  }
  static ofLength(e) {
    return new O(0, e);
  }
  static ofStartAndLength(e, n) {
    return new O(e, e + n);
  }
  constructor(e, n) {
    if (this.start = e, this.endExclusive = n, e > n)
      throw new Ae(`Invalid range: ${this.toString()}`);
  }
  get isEmpty() {
    return this.start === this.endExclusive;
  }
  delta(e) {
    return new O(this.start + e, this.endExclusive + e);
  }
  deltaStart(e) {
    return new O(this.start + e, this.endExclusive);
  }
  deltaEnd(e) {
    return new O(this.start, this.endExclusive + e);
  }
  get length() {
    return this.endExclusive - this.start;
  }
  toString() {
    return `[${this.start}, ${this.endExclusive})`;
  }
  contains(e) {
    return this.start <= e && e < this.endExclusive;
  }
  /**
   * for all numbers n: range1.contains(n) or range2.contains(n) => range1.join(range2).contains(n)
   * The joined range is the smallest range that contains both ranges.
   */
  join(e) {
    return new O(Math.min(this.start, e.start), Math.max(this.endExclusive, e.endExclusive));
  }
  /**
   * for all numbers n: range1.contains(n) and range2.contains(n) <=> range1.intersect(range2).contains(n)
   *
   * The resulting range is empty if the ranges do not intersect, but touch.
   * If the ranges don't even touch, the result is undefined.
   */
  intersect(e) {
    const n = Math.max(this.start, e.start), i = Math.min(this.endExclusive, e.endExclusive);
    if (n <= i)
      return new O(n, i);
  }
  intersects(e) {
    const n = Math.max(this.start, e.start), i = Math.min(this.endExclusive, e.endExclusive);
    return n < i;
  }
  isBefore(e) {
    return this.endExclusive <= e.start;
  }
  isAfter(e) {
    return this.start >= e.endExclusive;
  }
  slice(e) {
    return e.slice(this.start, this.endExclusive);
  }
  substring(e) {
    return e.substring(this.start, this.endExclusive);
  }
  /**
   * Returns the given value if it is contained in this instance, otherwise the closest value that is contained.
   * The range must not be empty.
   */
  clip(e) {
    if (this.isEmpty)
      throw new Ae(`Invalid clipping range: ${this.toString()}`);
    return Math.max(this.start, Math.min(this.endExclusive - 1, e));
  }
  /**
   * Returns `r := value + k * length` such that `r` is contained in this range.
   * The range must not be empty.
   *
   * E.g. `[5, 10).clipCyclic(10) === 5`, `[5, 10).clipCyclic(11) === 6` and `[5, 10).clipCyclic(4) === 9`.
   */
  clipCyclic(e) {
    if (this.isEmpty)
      throw new Ae(`Invalid clipping range: ${this.toString()}`);
    return e < this.start ? this.endExclusive - (this.start - e) % this.length : e >= this.endExclusive ? this.start + (e - this.start) % this.length : e;
  }
  forEach(e) {
    for (let n = this.start; n < this.endExclusive; n++)
      e(n);
  }
}
function Dt(t, e) {
  const n = It(t, e);
  return n === -1 ? void 0 : t[n];
}
function It(t, e, n = 0, i = t.length) {
  let r = n, s = i;
  for (; r < s; ) {
    const a = Math.floor((r + s) / 2);
    e(t[a]) ? r = a + 1 : s = a;
  }
  return r - 1;
}
function Bl(t, e) {
  const n = si(t, e);
  return n === t.length ? void 0 : t[n];
}
function si(t, e, n = 0, i = t.length) {
  let r = n, s = i;
  for (; r < s; ) {
    const a = Math.floor((r + s) / 2);
    e(t[a]) ? s = a : r = a + 1;
  }
  return r;
}
class Nn {
  static {
    this.assertInvariants = !1;
  }
  constructor(e) {
    this._array = e, this._findLastMonotonousLastIdx = 0;
  }
  /**
   * The predicate must be monotonous, i.e. `arr.map(predicate)` must be like `[true, ..., true, false, ..., false]`!
   * For subsequent calls, current predicate must be weaker than (or equal to) the previous predicate, i.e. more entries must be `true`.
   */
  findLastMonotonous(e) {
    if (Nn.assertInvariants) {
      if (this._prevFindLastPredicate) {
        for (const i of this._array)
          if (this._prevFindLastPredicate(i) && !e(i))
            throw new Error("MonotonousArray: current predicate must be weaker than (or equal to) the previous predicate.");
      }
      this._prevFindLastPredicate = e;
    }
    const n = It(this._array, e, this._findLastMonotonousLastIdx);
    return this._findLastMonotonousLastIdx = n + 1, n === -1 ? void 0 : this._array[n];
  }
}
class $ {
  static fromRangeInclusive(e) {
    return new $(e.startLineNumber, e.endLineNumber + 1);
  }
  /**
   * @param lineRanges An array of sorted line ranges.
   */
  static joinMany(e) {
    if (e.length === 0)
      return [];
    let n = new Be(e[0].slice());
    for (let i = 1; i < e.length; i++)
      n = n.getUnion(new Be(e[i].slice()));
    return n.ranges;
  }
  static join(e) {
    if (e.length === 0)
      throw new Ae("lineRanges cannot be empty");
    let n = e[0].startLineNumber, i = e[0].endLineNumberExclusive;
    for (let r = 1; r < e.length; r++)
      n = Math.min(n, e[r].startLineNumber), i = Math.max(i, e[r].endLineNumberExclusive);
    return new $(n, i);
  }
  static ofLength(e, n) {
    return new $(e, e + n);
  }
  /**
   * @internal
   */
  static deserialize(e) {
    return new $(e[0], e[1]);
  }
  constructor(e, n) {
    if (e > n)
      throw new Ae(`startLineNumber ${e} cannot be after endLineNumberExclusive ${n}`);
    this.startLineNumber = e, this.endLineNumberExclusive = n;
  }
  /**
   * Indicates if this line range contains the given line number.
   */
  contains(e) {
    return this.startLineNumber <= e && e < this.endLineNumberExclusive;
  }
  /**
   * Indicates if this line range is empty.
   */
  get isEmpty() {
    return this.startLineNumber === this.endLineNumberExclusive;
  }
  /**
   * Moves this line range by the given offset of line numbers.
   */
  delta(e) {
    return new $(this.startLineNumber + e, this.endLineNumberExclusive + e);
  }
  deltaLength(e) {
    return new $(this.startLineNumber, this.endLineNumberExclusive + e);
  }
  /**
   * The number of lines this line range spans.
   */
  get length() {
    return this.endLineNumberExclusive - this.startLineNumber;
  }
  /**
   * Creates a line range that combines this and the given line range.
   */
  join(e) {
    return new $(Math.min(this.startLineNumber, e.startLineNumber), Math.max(this.endLineNumberExclusive, e.endLineNumberExclusive));
  }
  toString() {
    return `[${this.startLineNumber},${this.endLineNumberExclusive})`;
  }
  /**
   * The resulting range is empty if the ranges do not intersect, but touch.
   * If the ranges don't even touch, the result is undefined.
   */
  intersect(e) {
    const n = Math.max(this.startLineNumber, e.startLineNumber), i = Math.min(this.endLineNumberExclusive, e.endLineNumberExclusive);
    if (n <= i)
      return new $(n, i);
  }
  intersectsStrict(e) {
    return this.startLineNumber < e.endLineNumberExclusive && e.startLineNumber < this.endLineNumberExclusive;
  }
  overlapOrTouch(e) {
    return this.startLineNumber <= e.endLineNumberExclusive && e.startLineNumber <= this.endLineNumberExclusive;
  }
  equals(e) {
    return this.startLineNumber === e.startLineNumber && this.endLineNumberExclusive === e.endLineNumberExclusive;
  }
  toInclusiveRange() {
    return this.isEmpty ? null : new H(this.startLineNumber, 1, this.endLineNumberExclusive - 1, Number.MAX_SAFE_INTEGER);
  }
  /**
   * @deprecated Using this function is discouraged because it might lead to bugs: The end position is not guaranteed to be a valid position!
  */
  toExclusiveRange() {
    return new H(this.startLineNumber, 1, this.endLineNumberExclusive, 1);
  }
  mapToLineArray(e) {
    const n = [];
    for (let i = this.startLineNumber; i < this.endLineNumberExclusive; i++)
      n.push(e(i));
    return n;
  }
  forEach(e) {
    for (let n = this.startLineNumber; n < this.endLineNumberExclusive; n++)
      e(n);
  }
  /**
   * @internal
   */
  serialize() {
    return [this.startLineNumber, this.endLineNumberExclusive];
  }
  includes(e) {
    return this.startLineNumber <= e && e < this.endLineNumberExclusive;
  }
  /**
   * Converts this 1-based line range to a 0-based offset range (subtracts 1!).
   * @internal
   */
  toOffsetRange() {
    return new O(this.startLineNumber - 1, this.endLineNumberExclusive - 1);
  }
}
class Be {
  constructor(e = []) {
    this._normalizedRanges = e;
  }
  get ranges() {
    return this._normalizedRanges;
  }
  addRange(e) {
    if (e.length === 0)
      return;
    const n = si(this._normalizedRanges, (r) => r.endLineNumberExclusive >= e.startLineNumber), i = It(this._normalizedRanges, (r) => r.startLineNumber <= e.endLineNumberExclusive) + 1;
    if (n === i)
      this._normalizedRanges.splice(n, 0, e);
    else if (n === i - 1) {
      const r = this._normalizedRanges[n];
      this._normalizedRanges[n] = r.join(e);
    } else {
      const r = this._normalizedRanges[n].join(this._normalizedRanges[i - 1]).join(e);
      this._normalizedRanges.splice(n, i - n, r);
    }
  }
  contains(e) {
    const n = Dt(this._normalizedRanges, (i) => i.startLineNumber <= e);
    return !!n && n.endLineNumberExclusive > e;
  }
  intersects(e) {
    const n = Dt(this._normalizedRanges, (i) => i.startLineNumber < e.endLineNumberExclusive);
    return !!n && n.endLineNumberExclusive > e.startLineNumber;
  }
  getUnion(e) {
    if (this._normalizedRanges.length === 0)
      return e;
    if (e._normalizedRanges.length === 0)
      return this;
    const n = [];
    let i = 0, r = 0, s = null;
    for (; i < this._normalizedRanges.length || r < e._normalizedRanges.length; ) {
      let a = null;
      if (i < this._normalizedRanges.length && r < e._normalizedRanges.length) {
        const o = this._normalizedRanges[i], l = e._normalizedRanges[r];
        o.startLineNumber < l.startLineNumber ? (a = o, i++) : (a = l, r++);
      } else i < this._normalizedRanges.length ? (a = this._normalizedRanges[i], i++) : (a = e._normalizedRanges[r], r++);
      s === null ? s = a : s.endLineNumberExclusive >= a.startLineNumber ? s = new $(s.startLineNumber, Math.max(s.endLineNumberExclusive, a.endLineNumberExclusive)) : (n.push(s), s = a);
    }
    return s !== null && n.push(s), new Be(n);
  }
  /**
   * Subtracts all ranges in this set from `range` and returns the result.
   */
  subtractFrom(e) {
    const n = si(this._normalizedRanges, (a) => a.endLineNumberExclusive >= e.startLineNumber), i = It(this._normalizedRanges, (a) => a.startLineNumber <= e.endLineNumberExclusive) + 1;
    if (n === i)
      return new Be([e]);
    const r = [];
    let s = e.startLineNumber;
    for (let a = n; a < i; a++) {
      const o = this._normalizedRanges[a];
      o.startLineNumber > s && r.push(new $(s, o.startLineNumber)), s = o.endLineNumberExclusive;
    }
    return s < e.endLineNumberExclusive && r.push(new $(s, e.endLineNumberExclusive)), new Be(r);
  }
  toString() {
    return this._normalizedRanges.map((e) => e.toString()).join(", ");
  }
  getIntersection(e) {
    const n = [];
    let i = 0, r = 0;
    for (; i < this._normalizedRanges.length && r < e._normalizedRanges.length; ) {
      const s = this._normalizedRanges[i], a = e._normalizedRanges[r], o = s.intersect(a);
      o && !o.isEmpty && n.push(o), s.endLineNumberExclusive < a.endLineNumberExclusive ? i++ : r++;
    }
    return new Be(n);
  }
  getWithDelta(e) {
    return new Be(this._normalizedRanges.map((n) => n.delta(e)));
  }
}
class dt {
  static {
    this.zero = new dt(0, 0);
  }
  static betweenPositions(e, n) {
    return e.lineNumber === n.lineNumber ? new dt(0, n.column - e.column) : new dt(n.lineNumber - e.lineNumber, n.column - 1);
  }
  static ofRange(e) {
    return dt.betweenPositions(e.getStartPosition(), e.getEndPosition());
  }
  static ofText(e) {
    let n = 0, i = 0;
    for (const r of e)
      r === `
` ? (n++, i = 0) : i++;
    return new dt(n, i);
  }
  constructor(e, n) {
    this.lineCount = e, this.columnCount = n;
  }
  isGreaterThanOrEqualTo(e) {
    return this.lineCount !== e.lineCount ? this.lineCount > e.lineCount : this.columnCount >= e.columnCount;
  }
  createRange(e) {
    return this.lineCount === 0 ? new H(e.lineNumber, e.column, e.lineNumber, e.column + this.columnCount) : new H(e.lineNumber, e.column, e.lineNumber + this.lineCount, this.columnCount + 1);
  }
  addToPosition(e) {
    return this.lineCount === 0 ? new ne(e.lineNumber, e.column + this.columnCount) : new ne(e.lineNumber + this.lineCount, this.columnCount + 1);
  }
  toString() {
    return `${this.lineCount},${this.columnCount}`;
  }
}
class Il {
  constructor(e, n) {
    this.range = e, this.text = n;
  }
  toSingleEditOperation() {
    return {
      range: this.range,
      text: this.text
    };
  }
}
class ve {
  static inverse(e, n, i) {
    const r = [];
    let s = 1, a = 1;
    for (const l of e) {
      const c = new ve(new $(s, l.original.startLineNumber), new $(a, l.modified.startLineNumber));
      c.modified.isEmpty || r.push(c), s = l.original.endLineNumberExclusive, a = l.modified.endLineNumberExclusive;
    }
    const o = new ve(new $(s, n + 1), new $(a, i + 1));
    return o.modified.isEmpty || r.push(o), r;
  }
  static clip(e, n, i) {
    const r = [];
    for (const s of e) {
      const a = s.original.intersect(n), o = s.modified.intersect(i);
      a && !a.isEmpty && o && !o.isEmpty && r.push(new ve(a, o));
    }
    return r;
  }
  constructor(e, n) {
    this.original = e, this.modified = n;
  }
  toString() {
    return `{${this.original.toString()}->${this.modified.toString()}}`;
  }
  flip() {
    return new ve(this.modified, this.original);
  }
  join(e) {
    return new ve(this.original.join(e.original), this.modified.join(e.modified));
  }
  /**
   * This method assumes that the LineRangeMapping describes a valid diff!
   * I.e. if one range is empty, the other range cannot be the entire document.
   * It avoids various problems when the line range points to non-existing line-numbers.
  */
  toRangeMapping() {
    const e = this.original.toInclusiveRange(), n = this.modified.toInclusiveRange();
    if (e && n)
      return new Fe(e, n);
    if (this.original.startLineNumber === 1 || this.modified.startLineNumber === 1) {
      if (!(this.modified.startLineNumber === 1 && this.original.startLineNumber === 1))
        throw new Ae("not a valid diff");
      return new Fe(new H(this.original.startLineNumber, 1, this.original.endLineNumberExclusive, 1), new H(this.modified.startLineNumber, 1, this.modified.endLineNumberExclusive, 1));
    } else
      return new Fe(new H(this.original.startLineNumber - 1, Number.MAX_SAFE_INTEGER, this.original.endLineNumberExclusive - 1, Number.MAX_SAFE_INTEGER), new H(this.modified.startLineNumber - 1, Number.MAX_SAFE_INTEGER, this.modified.endLineNumberExclusive - 1, Number.MAX_SAFE_INTEGER));
  }
  /**
   * This method assumes that the LineRangeMapping describes a valid diff!
   * I.e. if one range is empty, the other range cannot be the entire document.
   * It avoids various problems when the line range points to non-existing line-numbers.
  */
  toRangeMapping2(e, n) {
    if (fs(this.original.endLineNumberExclusive, e) && fs(this.modified.endLineNumberExclusive, n))
      return new Fe(new H(this.original.startLineNumber, 1, this.original.endLineNumberExclusive, 1), new H(this.modified.startLineNumber, 1, this.modified.endLineNumberExclusive, 1));
    if (!this.original.isEmpty && !this.modified.isEmpty)
      return new Fe(H.fromPositions(new ne(this.original.startLineNumber, 1), lt(new ne(this.original.endLineNumberExclusive - 1, Number.MAX_SAFE_INTEGER), e)), H.fromPositions(new ne(this.modified.startLineNumber, 1), lt(new ne(this.modified.endLineNumberExclusive - 1, Number.MAX_SAFE_INTEGER), n)));
    if (this.original.startLineNumber > 1 && this.modified.startLineNumber > 1)
      return new Fe(H.fromPositions(lt(new ne(this.original.startLineNumber - 1, Number.MAX_SAFE_INTEGER), e), lt(new ne(this.original.endLineNumberExclusive - 1, Number.MAX_SAFE_INTEGER), e)), H.fromPositions(lt(new ne(this.modified.startLineNumber - 1, Number.MAX_SAFE_INTEGER), n), lt(new ne(this.modified.endLineNumberExclusive - 1, Number.MAX_SAFE_INTEGER), n)));
    throw new Ae();
  }
}
function lt(t, e) {
  if (t.lineNumber < 1)
    return new ne(1, 1);
  if (t.lineNumber > e.length)
    return new ne(e.length, e[e.length - 1].length + 1);
  const n = e[t.lineNumber - 1];
  return t.column > n.length + 1 ? new ne(t.lineNumber, n.length + 1) : t;
}
function fs(t, e) {
  return t >= 1 && t <= e.length;
}
class Te extends ve {
  static fromRangeMappings(e) {
    const n = $.join(e.map((r) => $.fromRangeInclusive(r.originalRange))), i = $.join(e.map((r) => $.fromRangeInclusive(r.modifiedRange)));
    return new Te(n, i, e);
  }
  constructor(e, n, i) {
    super(e, n), this.innerChanges = i;
  }
  flip() {
    return new Te(this.modified, this.original, this.innerChanges?.map((e) => e.flip()));
  }
  withInnerChangesFromLineRanges() {
    return new Te(this.original, this.modified, [this.toRangeMapping()]);
  }
}
class Fe {
  static assertSorted(e) {
    for (let n = 1; n < e.length; n++) {
      const i = e[n - 1], r = e[n];
      if (!(i.originalRange.getEndPosition().isBeforeOrEqual(r.originalRange.getStartPosition()) && i.modifiedRange.getEndPosition().isBeforeOrEqual(r.modifiedRange.getStartPosition())))
        throw new Ae("Range mappings must be sorted");
    }
  }
  constructor(e, n) {
    this.originalRange = e, this.modifiedRange = n;
  }
  toString() {
    return `{${this.originalRange.toString()}->${this.modifiedRange.toString()}}`;
  }
  flip() {
    return new Fe(this.modifiedRange, this.originalRange);
  }
  /**
   * Creates a single text edit that describes the change from the original to the modified text.
  */
  toTextEdit(e) {
    const n = e.getValueOfRange(this.modifiedRange);
    return new Il(this.originalRange, n);
  }
}
const Rl = 3;
class Ml {
  computeDiff(e, n, i) {
    const s = new Ul(e, n, {
      maxComputationTime: i.maxComputationTimeMs,
      shouldIgnoreTrimWhitespace: i.ignoreTrimWhitespace,
      shouldComputeCharChanges: !0,
      shouldMakePrettyDiff: !0,
      shouldPostProcessCharChanges: !0
    }).computeDiff(), a = [];
    let o = null;
    for (const l of s.changes) {
      let c;
      l.originalEndLineNumber === 0 ? c = new $(l.originalStartLineNumber + 1, l.originalStartLineNumber + 1) : c = new $(l.originalStartLineNumber, l.originalEndLineNumber + 1);
      let d;
      l.modifiedEndLineNumber === 0 ? d = new $(l.modifiedStartLineNumber + 1, l.modifiedStartLineNumber + 1) : d = new $(l.modifiedStartLineNumber, l.modifiedEndLineNumber + 1);
      let h = new Te(c, d, l.charChanges?.map((f) => new Fe(new H(f.originalStartLineNumber, f.originalStartColumn, f.originalEndLineNumber, f.originalEndColumn), new H(f.modifiedStartLineNumber, f.modifiedStartColumn, f.modifiedEndLineNumber, f.modifiedEndColumn))));
      o && (o.modified.endLineNumberExclusive === h.modified.startLineNumber || o.original.endLineNumberExclusive === h.original.startLineNumber) && (h = new Te(o.original.join(h.original), o.modified.join(h.modified), o.innerChanges && h.innerChanges ? o.innerChanges.concat(h.innerChanges) : void 0), a.pop()), a.push(h), o = h;
    }
    return mn(() => uo(a, (l, c) => c.original.startLineNumber - l.original.endLineNumberExclusive === c.modified.startLineNumber - l.modified.endLineNumberExclusive && // There has to be an unchanged line in between (otherwise both diffs should have been joined)
    l.original.endLineNumberExclusive < c.original.startLineNumber && l.modified.endLineNumberExclusive < c.modified.startLineNumber)), new Jt(a, [], s.quitEarly);
  }
}
function fo(t, e, n, i) {
  return new Ge(t, e, n).ComputeDiff(i);
}
let ms = class {
  constructor(e) {
    const n = [], i = [];
    for (let r = 0, s = e.length; r < s; r++)
      n[r] = ai(e[r], 1), i[r] = oi(e[r], 1);
    this.lines = e, this._startColumns = n, this._endColumns = i;
  }
  getElements() {
    const e = [];
    for (let n = 0, i = this.lines.length; n < i; n++)
      e[n] = this.lines[n].substring(this._startColumns[n] - 1, this._endColumns[n] - 1);
    return e;
  }
  getStrictElement(e) {
    return this.lines[e];
  }
  getStartLineNumber(e) {
    return e + 1;
  }
  getEndLineNumber(e) {
    return e + 1;
  }
  createCharSequence(e, n, i) {
    const r = [], s = [], a = [];
    let o = 0;
    for (let l = n; l <= i; l++) {
      const c = this.lines[l], d = e ? this._startColumns[l] : 1, h = e ? this._endColumns[l] : c.length + 1;
      for (let f = d; f < h; f++)
        r[o] = c.charCodeAt(f - 1), s[o] = l + 1, a[o] = f, o++;
      !e && l < i && (r[o] = 10, s[o] = l + 1, a[o] = c.length + 1, o++);
    }
    return new Pl(r, s, a);
  }
};
class Pl {
  constructor(e, n, i) {
    this._charCodes = e, this._lineNumbers = n, this._columns = i;
  }
  toString() {
    return "[" + this._charCodes.map((e, n) => (e === 10 ? "\\n" : String.fromCharCode(e)) + `-(${this._lineNumbers[n]},${this._columns[n]})`).join(", ") + "]";
  }
  _assertIndex(e, n) {
    if (e < 0 || e >= n.length)
      throw new Error("Illegal index");
  }
  getElements() {
    return this._charCodes;
  }
  getStartLineNumber(e) {
    return e > 0 && e === this._lineNumbers.length ? this.getEndLineNumber(e - 1) : (this._assertIndex(e, this._lineNumbers), this._lineNumbers[e]);
  }
  getEndLineNumber(e) {
    return e === -1 ? this.getStartLineNumber(e + 1) : (this._assertIndex(e, this._lineNumbers), this._charCodes[e] === 10 ? this._lineNumbers[e] + 1 : this._lineNumbers[e]);
  }
  getStartColumn(e) {
    return e > 0 && e === this._columns.length ? this.getEndColumn(e - 1) : (this._assertIndex(e, this._columns), this._columns[e]);
  }
  getEndColumn(e) {
    return e === -1 ? this.getStartColumn(e + 1) : (this._assertIndex(e, this._columns), this._charCodes[e] === 10 ? 1 : this._columns[e] + 1);
  }
}
class pt {
  constructor(e, n, i, r, s, a, o, l) {
    this.originalStartLineNumber = e, this.originalStartColumn = n, this.originalEndLineNumber = i, this.originalEndColumn = r, this.modifiedStartLineNumber = s, this.modifiedStartColumn = a, this.modifiedEndLineNumber = o, this.modifiedEndColumn = l;
  }
  static createFromDiffChange(e, n, i) {
    const r = n.getStartLineNumber(e.originalStart), s = n.getStartColumn(e.originalStart), a = n.getEndLineNumber(e.originalStart + e.originalLength - 1), o = n.getEndColumn(e.originalStart + e.originalLength - 1), l = i.getStartLineNumber(e.modifiedStart), c = i.getStartColumn(e.modifiedStart), d = i.getEndLineNumber(e.modifiedStart + e.modifiedLength - 1), h = i.getEndColumn(e.modifiedStart + e.modifiedLength - 1);
    return new pt(r, s, a, o, l, c, d, h);
  }
}
function Tl(t) {
  if (t.length <= 1)
    return t;
  const e = [t[0]];
  let n = e[0];
  for (let i = 1, r = t.length; i < r; i++) {
    const s = t[i], a = s.originalStart - (n.originalStart + n.originalLength), o = s.modifiedStart - (n.modifiedStart + n.modifiedLength);
    Math.min(a, o) < Rl ? (n.originalLength = s.originalStart + s.originalLength - n.originalStart, n.modifiedLength = s.modifiedStart + s.modifiedLength - n.modifiedStart) : (e.push(s), n = s);
  }
  return e;
}
class St {
  constructor(e, n, i, r, s) {
    this.originalStartLineNumber = e, this.originalEndLineNumber = n, this.modifiedStartLineNumber = i, this.modifiedEndLineNumber = r, this.charChanges = s;
  }
  static createFromDiffResult(e, n, i, r, s, a, o) {
    let l, c, d, h, f;
    if (n.originalLength === 0 ? (l = i.getStartLineNumber(n.originalStart) - 1, c = 0) : (l = i.getStartLineNumber(n.originalStart), c = i.getEndLineNumber(n.originalStart + n.originalLength - 1)), n.modifiedLength === 0 ? (d = r.getStartLineNumber(n.modifiedStart) - 1, h = 0) : (d = r.getStartLineNumber(n.modifiedStart), h = r.getEndLineNumber(n.modifiedStart + n.modifiedLength - 1)), a && n.originalLength > 0 && n.originalLength < 20 && n.modifiedLength > 0 && n.modifiedLength < 20 && s()) {
      const m = i.createCharSequence(e, n.originalStart, n.originalStart + n.originalLength - 1), b = r.createCharSequence(e, n.modifiedStart, n.modifiedStart + n.modifiedLength - 1);
      if (m.getElements().length > 0 && b.getElements().length > 0) {
        let D = fo(m, b, s, !0).changes;
        o && (D = Tl(D)), f = [];
        for (let E = 0, L = D.length; E < L; E++)
          f.push(pt.createFromDiffChange(D[E], m, b));
      }
    }
    return new St(l, c, d, h, f);
  }
}
class Ul {
  constructor(e, n, i) {
    this.shouldComputeCharChanges = i.shouldComputeCharChanges, this.shouldPostProcessCharChanges = i.shouldPostProcessCharChanges, this.shouldIgnoreTrimWhitespace = i.shouldIgnoreTrimWhitespace, this.shouldMakePrettyDiff = i.shouldMakePrettyDiff, this.originalLines = e, this.modifiedLines = n, this.original = new ms(e), this.modified = new ms(n), this.continueLineDiff = gs(i.maxComputationTime), this.continueCharDiff = gs(i.maxComputationTime === 0 ? 0 : Math.min(i.maxComputationTime, 5e3));
  }
  computeDiff() {
    if (this.original.lines.length === 1 && this.original.lines[0].length === 0)
      return this.modified.lines.length === 1 && this.modified.lines[0].length === 0 ? {
        quitEarly: !1,
        changes: []
      } : {
        quitEarly: !1,
        changes: [{
          originalStartLineNumber: 1,
          originalEndLineNumber: 1,
          modifiedStartLineNumber: 1,
          modifiedEndLineNumber: this.modified.lines.length,
          charChanges: void 0
        }]
      };
    if (this.modified.lines.length === 1 && this.modified.lines[0].length === 0)
      return {
        quitEarly: !1,
        changes: [{
          originalStartLineNumber: 1,
          originalEndLineNumber: this.original.lines.length,
          modifiedStartLineNumber: 1,
          modifiedEndLineNumber: 1,
          charChanges: void 0
        }]
      };
    const e = fo(this.original, this.modified, this.continueLineDiff, this.shouldMakePrettyDiff), n = e.changes, i = e.quitEarly;
    if (this.shouldIgnoreTrimWhitespace) {
      const o = [];
      for (let l = 0, c = n.length; l < c; l++)
        o.push(St.createFromDiffResult(this.shouldIgnoreTrimWhitespace, n[l], this.original, this.modified, this.continueCharDiff, this.shouldComputeCharChanges, this.shouldPostProcessCharChanges));
      return {
        quitEarly: i,
        changes: o
      };
    }
    const r = [];
    let s = 0, a = 0;
    for (let o = -1, l = n.length; o < l; o++) {
      const c = o + 1 < l ? n[o + 1] : null, d = c ? c.originalStart : this.originalLines.length, h = c ? c.modifiedStart : this.modifiedLines.length;
      for (; s < d && a < h; ) {
        const f = this.originalLines[s], m = this.modifiedLines[a];
        if (f !== m) {
          {
            let b = ai(f, 1), D = ai(m, 1);
            for (; b > 1 && D > 1; ) {
              const E = f.charCodeAt(b - 2), L = m.charCodeAt(D - 2);
              if (E !== L)
                break;
              b--, D--;
            }
            (b > 1 || D > 1) && this._pushTrimWhitespaceCharChange(r, s + 1, 1, b, a + 1, 1, D);
          }
          {
            let b = oi(f, 1), D = oi(m, 1);
            const E = f.length + 1, L = m.length + 1;
            for (; b < E && D < L; ) {
              const _ = f.charCodeAt(b - 1), v = f.charCodeAt(D - 1);
              if (_ !== v)
                break;
              b++, D++;
            }
            (b < E || D < L) && this._pushTrimWhitespaceCharChange(r, s + 1, b, E, a + 1, D, L);
          }
        }
        s++, a++;
      }
      c && (r.push(St.createFromDiffResult(this.shouldIgnoreTrimWhitespace, c, this.original, this.modified, this.continueCharDiff, this.shouldComputeCharChanges, this.shouldPostProcessCharChanges)), s += c.originalLength, a += c.modifiedLength);
    }
    return {
      quitEarly: i,
      changes: r
    };
  }
  _pushTrimWhitespaceCharChange(e, n, i, r, s, a, o) {
    if (this._mergeTrimWhitespaceCharChange(e, n, i, r, s, a, o))
      return;
    let l;
    this.shouldComputeCharChanges && (l = [new pt(n, i, n, r, s, a, s, o)]), e.push(new St(n, n, s, s, l));
  }
  _mergeTrimWhitespaceCharChange(e, n, i, r, s, a, o) {
    const l = e.length;
    if (l === 0)
      return !1;
    const c = e[l - 1];
    return c.originalEndLineNumber === 0 || c.modifiedEndLineNumber === 0 ? !1 : c.originalEndLineNumber === n && c.modifiedEndLineNumber === s ? (this.shouldComputeCharChanges && c.charChanges && c.charChanges.push(new pt(n, i, n, r, s, a, s, o)), !0) : c.originalEndLineNumber + 1 === n && c.modifiedEndLineNumber + 1 === s ? (c.originalEndLineNumber = n, c.modifiedEndLineNumber = s, this.shouldComputeCharChanges && c.charChanges && c.charChanges.push(new pt(n, i, n, r, s, a, s, o)), !0) : !1;
  }
}
function ai(t, e) {
  const n = mu(t);
  return n === -1 ? e : n + 1;
}
function oi(t, e) {
  const n = gu(t);
  return n === -1 ? e : n + 2;
}
function gs(t) {
  if (t === 0)
    return () => !0;
  const e = Date.now();
  return () => Date.now() - e < t;
}
function Vl(t, e, n = (i, r) => i === r) {
  if (t === e)
    return !0;
  if (!t || !e || t.length !== e.length)
    return !1;
  for (let i = 0, r = t.length; i < r; i++)
    if (!n(t[i], e[i]))
      return !1;
  return !0;
}
function* $l(t, e) {
  let n, i;
  for (const r of t)
    i !== void 0 && e(i, r) ? n.push(r) : (n && (yield n), n = [r]), i = r;
  n && (yield n);
}
function ql(t, e) {
  for (let n = 0; n <= t.length; n++)
    e(n === 0 ? void 0 : t[n - 1], n === t.length ? void 0 : t[n]);
}
function zl(t, e) {
  for (let n = 0; n < t.length; n++)
    e(n === 0 ? void 0 : t[n - 1], t[n], n + 1 === t.length ? void 0 : t[n + 1]);
}
function Wl(t, e) {
  for (const n of e)
    t.push(n);
}
var ui;
(function(t) {
  function e(s) {
    return s < 0;
  }
  t.isLessThan = e;
  function n(s) {
    return s <= 0;
  }
  t.isLessThanOrEqual = n;
  function i(s) {
    return s > 0;
  }
  t.isGreaterThan = i;
  function r(s) {
    return s === 0;
  }
  t.isNeitherLessOrGreaterThan = r, t.greaterThan = 1, t.lessThan = -1, t.neitherLessOrGreaterThan = 0;
})(ui || (ui = {}));
function Qt(t, e) {
  return (n, i) => e(t(n), t(i));
}
const Yt = (t, e) => t - e;
function Ol(t) {
  return (e, n) => -t(e, n);
}
class Zt {
  static {
    this.empty = new Zt((e) => {
    });
  }
  constructor(e) {
    this.iterate = e;
  }
  toArray() {
    const e = [];
    return this.iterate((n) => (e.push(n), !0)), e;
  }
  filter(e) {
    return new Zt((n) => this.iterate((i) => e(i) ? n(i) : !0));
  }
  map(e) {
    return new Zt((n) => this.iterate((i) => n(e(i))));
  }
  findLast(e) {
    let n;
    return this.iterate((i) => (e(i) && (n = i), !0)), n;
  }
  findLastMaxBy(e) {
    let n, i = !0;
    return this.iterate((r) => ((i || ui.isGreaterThan(e(r, n))) && (i = !1, n = r), !0)), n;
  }
}
class Ue {
  static trivial(e, n) {
    return new Ue([new K(O.ofLength(e.length), O.ofLength(n.length))], !1);
  }
  static trivialTimedOut(e, n) {
    return new Ue([new K(O.ofLength(e.length), O.ofLength(n.length))], !0);
  }
  constructor(e, n) {
    this.diffs = e, this.hitTimeout = n;
  }
}
class K {
  static invert(e, n) {
    const i = [];
    return ql(e, (r, s) => {
      i.push(K.fromOffsetPairs(r ? r.getEndExclusives() : Se.zero, s ? s.getStarts() : new Se(n, (r ? r.seq2Range.endExclusive - r.seq1Range.endExclusive : 0) + n)));
    }), i;
  }
  static fromOffsetPairs(e, n) {
    return new K(new O(e.offset1, n.offset1), new O(e.offset2, n.offset2));
  }
  static assertSorted(e) {
    let n;
    for (const i of e) {
      if (n && !(n.seq1Range.endExclusive <= i.seq1Range.start && n.seq2Range.endExclusive <= i.seq2Range.start))
        throw new Ae("Sequence diffs must be sorted");
      n = i;
    }
  }
  constructor(e, n) {
    this.seq1Range = e, this.seq2Range = n;
  }
  swap() {
    return new K(this.seq2Range, this.seq1Range);
  }
  toString() {
    return `${this.seq1Range} <-> ${this.seq2Range}`;
  }
  join(e) {
    return new K(this.seq1Range.join(e.seq1Range), this.seq2Range.join(e.seq2Range));
  }
  delta(e) {
    return e === 0 ? this : new K(this.seq1Range.delta(e), this.seq2Range.delta(e));
  }
  deltaStart(e) {
    return e === 0 ? this : new K(this.seq1Range.deltaStart(e), this.seq2Range.deltaStart(e));
  }
  deltaEnd(e) {
    return e === 0 ? this : new K(this.seq1Range.deltaEnd(e), this.seq2Range.deltaEnd(e));
  }
  intersect(e) {
    const n = this.seq1Range.intersect(e.seq1Range), i = this.seq2Range.intersect(e.seq2Range);
    if (!(!n || !i))
      return new K(n, i);
  }
  getStarts() {
    return new Se(this.seq1Range.start, this.seq2Range.start);
  }
  getEndExclusives() {
    return new Se(this.seq1Range.endExclusive, this.seq2Range.endExclusive);
  }
}
class Se {
  static {
    this.zero = new Se(0, 0);
  }
  static {
    this.max = new Se(Number.MAX_SAFE_INTEGER, Number.MAX_SAFE_INTEGER);
  }
  constructor(e, n) {
    this.offset1 = e, this.offset2 = n;
  }
  toString() {
    return `${this.offset1} <-> ${this.offset2}`;
  }
  delta(e) {
    return e === 0 ? this : new Se(this.offset1 + e, this.offset2 + e);
  }
  equals(e) {
    return this.offset1 === e.offset1 && this.offset2 === e.offset2;
  }
}
class Vt {
  static {
    this.instance = new Vt();
  }
  isValid() {
    return !0;
  }
}
class Hl {
  constructor(e) {
    if (this.timeout = e, this.startTime = Date.now(), this.valid = !0, e <= 0)
      throw new Ae("timeout must be positive");
  }
  // Recommendation: Set a log-point `{this.disable()}` in the body
  isValid() {
    if (!(Date.now() - this.startTime < this.timeout) && this.valid) {
      this.valid = !1;
      debugger;
    }
    return this.valid;
  }
}
class Vn {
  constructor(e, n) {
    this.width = e, this.height = n, this.array = [], this.array = new Array(e * n);
  }
  get(e, n) {
    return this.array[e + n * this.width];
  }
  set(e, n, i) {
    this.array[e + n * this.width] = i;
  }
}
function li(t) {
  return t === 32 || t === 9;
}
class Rt {
  static {
    this.chrKeys = /* @__PURE__ */ new Map();
  }
  static getKey(e) {
    let n = this.chrKeys.get(e);
    return n === void 0 && (n = this.chrKeys.size, this.chrKeys.set(e, n)), n;
  }
  constructor(e, n, i) {
    this.range = e, this.lines = n, this.source = i, this.histogram = [];
    let r = 0;
    for (let s = e.startLineNumber - 1; s < e.endLineNumberExclusive - 1; s++) {
      const a = n[s];
      for (let l = 0; l < a.length; l++) {
        r++;
        const c = a[l], d = Rt.getKey(c);
        this.histogram[d] = (this.histogram[d] || 0) + 1;
      }
      r++;
      const o = Rt.getKey(`
`);
      this.histogram[o] = (this.histogram[o] || 0) + 1;
    }
    this.totalCount = r;
  }
  computeSimilarity(e) {
    let n = 0;
    const i = Math.max(this.histogram.length, e.histogram.length);
    for (let r = 0; r < i; r++)
      n += Math.abs((this.histogram[r] ?? 0) - (e.histogram[r] ?? 0));
    return 1 - n / (this.totalCount + e.totalCount);
  }
}
class jl {
  compute(e, n, i = Vt.instance, r) {
    if (e.length === 0 || n.length === 0)
      return Ue.trivial(e, n);
    const s = new Vn(e.length, n.length), a = new Vn(e.length, n.length), o = new Vn(e.length, n.length);
    for (let b = 0; b < e.length; b++)
      for (let D = 0; D < n.length; D++) {
        if (!i.isValid())
          return Ue.trivialTimedOut(e, n);
        const E = b === 0 ? 0 : s.get(b - 1, D), L = D === 0 ? 0 : s.get(b, D - 1);
        let _;
        e.getElement(b) === n.getElement(D) ? (b === 0 || D === 0 ? _ = 0 : _ = s.get(b - 1, D - 1), b > 0 && D > 0 && a.get(b - 1, D - 1) === 3 && (_ += o.get(b - 1, D - 1)), _ += r ? r(b, D) : 1) : _ = -1;
        const v = Math.max(E, L, _);
        if (v === _) {
          const C = b > 0 && D > 0 ? o.get(b - 1, D - 1) : 0;
          o.set(b, D, C + 1), a.set(b, D, 3);
        } else v === E ? (o.set(b, D, 0), a.set(b, D, 1)) : v === L && (o.set(b, D, 0), a.set(b, D, 2));
        s.set(b, D, v);
      }
    const l = [];
    let c = e.length, d = n.length;
    function h(b, D) {
      (b + 1 !== c || D + 1 !== d) && l.push(new K(new O(b + 1, c), new O(D + 1, d))), c = b, d = D;
    }
    let f = e.length - 1, m = n.length - 1;
    for (; f >= 0 && m >= 0; )
      a.get(f, m) === 3 ? (h(f, m), f--, m--) : a.get(f, m) === 1 ? f-- : m--;
    return h(-1, -1), l.reverse(), new Ue(l, !1);
  }
}
class mo {
  compute(e, n, i = Vt.instance) {
    if (e.length === 0 || n.length === 0)
      return Ue.trivial(e, n);
    const r = e, s = n;
    function a(D, E) {
      for (; D < r.length && E < s.length && r.getElement(D) === s.getElement(E); )
        D++, E++;
      return D;
    }
    let o = 0;
    const l = new Gl();
    l.set(0, a(0, 0));
    const c = new Xl();
    c.set(0, l.get(0) === 0 ? null : new ps(null, 0, 0, l.get(0)));
    let d = 0;
    e: for (; ; ) {
      if (o++, !i.isValid())
        return Ue.trivialTimedOut(r, s);
      const D = -Math.min(o, s.length + o % 2), E = Math.min(o, r.length + o % 2);
      for (d = D; d <= E; d += 2) {
        const L = d === E ? -1 : l.get(d + 1), _ = d === D ? -1 : l.get(d - 1) + 1, v = Math.min(Math.max(L, _), r.length), C = v - d;
        if (v > r.length || C > s.length)
          continue;
        const x = a(v, C);
        l.set(d, x);
        const w = v === L ? c.get(d + 1) : c.get(d - 1);
        if (c.set(d, x !== v ? new ps(w, v, C, x - v) : w), l.get(d) === r.length && l.get(d) - d === s.length)
          break e;
      }
    }
    let h = c.get(d);
    const f = [];
    let m = r.length, b = s.length;
    for (; ; ) {
      const D = h ? h.x + h.length : 0, E = h ? h.y + h.length : 0;
      if ((D !== m || E !== b) && f.push(new K(new O(D, m), new O(E, b))), !h)
        break;
      m = h.x, b = h.y, h = h.prev;
    }
    return f.reverse(), new Ue(f, !1);
  }
}
class ps {
  constructor(e, n, i, r) {
    this.prev = e, this.x = n, this.y = i, this.length = r;
  }
}
class Gl {
  constructor() {
    this.positiveArr = new Int32Array(10), this.negativeArr = new Int32Array(10);
  }
  get(e) {
    return e < 0 ? (e = -e - 1, this.negativeArr[e]) : this.positiveArr[e];
  }
  set(e, n) {
    if (e < 0) {
      if (e = -e - 1, e >= this.negativeArr.length) {
        const i = this.negativeArr;
        this.negativeArr = new Int32Array(i.length * 2), this.negativeArr.set(i);
      }
      this.negativeArr[e] = n;
    } else {
      if (e >= this.positiveArr.length) {
        const i = this.positiveArr;
        this.positiveArr = new Int32Array(i.length * 2), this.positiveArr.set(i);
      }
      this.positiveArr[e] = n;
    }
  }
}
class Xl {
  constructor() {
    this.positiveArr = [], this.negativeArr = [];
  }
  get(e) {
    return e < 0 ? (e = -e - 1, this.negativeArr[e]) : this.positiveArr[e];
  }
  set(e, n) {
    e < 0 ? (e = -e - 1, this.negativeArr[e] = n) : this.positiveArr[e] = n;
  }
}
class gn {
  constructor(e, n, i) {
    this.lines = e, this.range = n, this.considerWhitespaceChanges = i, this.elements = [], this.firstElementOffsetByLineIdx = [], this.lineStartOffsets = [], this.trimmedWsLengthsByLineIdx = [], this.firstElementOffsetByLineIdx.push(0);
    for (let r = this.range.startLineNumber; r <= this.range.endLineNumber; r++) {
      let s = e[r - 1], a = 0;
      r === this.range.startLineNumber && this.range.startColumn > 1 && (a = this.range.startColumn - 1, s = s.substring(a)), this.lineStartOffsets.push(a);
      let o = 0;
      if (!i) {
        const c = s.trimStart();
        o = s.length - c.length, s = c.trimEnd();
      }
      this.trimmedWsLengthsByLineIdx.push(o);
      const l = r === this.range.endLineNumber ? Math.min(this.range.endColumn - 1 - a - o, s.length) : s.length;
      for (let c = 0; c < l; c++)
        this.elements.push(s.charCodeAt(c));
      r < this.range.endLineNumber && (this.elements.push(10), this.firstElementOffsetByLineIdx.push(this.elements.length));
    }
  }
  toString() {
    return `Slice: "${this.text}"`;
  }
  get text() {
    return this.getText(new O(0, this.length));
  }
  getText(e) {
    return this.elements.slice(e.start, e.endExclusive).map((n) => String.fromCharCode(n)).join("");
  }
  getElement(e) {
    return this.elements[e];
  }
  get length() {
    return this.elements.length;
  }
  getBoundaryScore(e) {
    const n = Ds(e > 0 ? this.elements[e - 1] : -1), i = Ds(e < this.elements.length ? this.elements[e] : -1);
    if (n === 7 && i === 8)
      return 0;
    if (n === 8)
      return 150;
    let r = 0;
    return n !== i && (r += 10, n === 0 && i === 1 && (r += 1)), r += bs(n), r += bs(i), r;
  }
  translateOffset(e, n = "right") {
    const i = It(this.firstElementOffsetByLineIdx, (s) => s <= e), r = e - this.firstElementOffsetByLineIdx[i];
    return new ne(this.range.startLineNumber + i, 1 + this.lineStartOffsets[i] + r + (r === 0 && n === "left" ? 0 : this.trimmedWsLengthsByLineIdx[i]));
  }
  translateRange(e) {
    const n = this.translateOffset(e.start, "right"), i = this.translateOffset(e.endExclusive, "left");
    return i.isBefore(n) ? H.fromPositions(i, i) : H.fromPositions(n, i);
  }
  /**
   * Finds the word that contains the character at the given offset
   */
  findWordContaining(e) {
    if (e < 0 || e >= this.elements.length || !$n(this.elements[e]))
      return;
    let n = e;
    for (; n > 0 && $n(this.elements[n - 1]); )
      n--;
    let i = e;
    for (; i < this.elements.length && $n(this.elements[i]); )
      i++;
    return new O(n, i);
  }
  countLinesIn(e) {
    return this.translateOffset(e.endExclusive).lineNumber - this.translateOffset(e.start).lineNumber;
  }
  isStronglyEqual(e, n) {
    return this.elements[e] === this.elements[n];
  }
  extendToFullLines(e) {
    const n = Dt(this.firstElementOffsetByLineIdx, (r) => r <= e.start) ?? 0, i = Bl(this.firstElementOffsetByLineIdx, (r) => e.endExclusive <= r) ?? this.elements.length;
    return new O(n, i);
  }
}
function $n(t) {
  return t >= 97 && t <= 122 || t >= 65 && t <= 90 || t >= 48 && t <= 57;
}
const Jl = {
  0: 0,
  1: 0,
  2: 0,
  3: 10,
  4: 2,
  5: 30,
  6: 3,
  7: 10,
  8: 10
};
function bs(t) {
  return Jl[t];
}
function Ds(t) {
  return t === 10 ? 8 : t === 13 ? 7 : li(t) ? 6 : t >= 97 && t <= 122 ? 0 : t >= 65 && t <= 90 ? 1 : t >= 48 && t <= 57 ? 2 : t === -1 ? 3 : t === 44 || t === 59 ? 5 : 4;
}
function Ql(t, e, n, i, r, s) {
  let { moves: a, excludedChanges: o } = Zl(t, e, n, s);
  if (!s.isValid())
    return [];
  const l = t.filter((d) => !o.has(d)), c = Kl(l, i, r, e, n, s);
  return Wl(a, c), a = ec(a), a = a.filter((d) => {
    const h = d.original.toOffsetRange().slice(e).map((m) => m.trim());
    return h.join(`
`).length >= 15 && Yl(h, (m) => m.length >= 2) >= 2;
  }), a = tc(t, a), a;
}
function Yl(t, e) {
  let n = 0;
  for (const i of t)
    e(i) && n++;
  return n;
}
function Zl(t, e, n, i) {
  const r = [], s = t.filter((l) => l.modified.isEmpty && l.original.length >= 3).map((l) => new Rt(l.original, e, l)), a = new Set(t.filter((l) => l.original.isEmpty && l.modified.length >= 3).map((l) => new Rt(l.modified, n, l))), o = /* @__PURE__ */ new Set();
  for (const l of s) {
    let c = -1, d;
    for (const h of a) {
      const f = l.computeSimilarity(h);
      f > c && (c = f, d = h);
    }
    if (c > 0.9 && d && (a.delete(d), r.push(new ve(l.range, d.range)), o.add(l.source), o.add(d.source)), !i.isValid())
      return { moves: r, excludedChanges: o };
  }
  return { moves: r, excludedChanges: o };
}
function Kl(t, e, n, i, r, s) {
  const a = [], o = new Dl();
  for (const f of t)
    for (let m = f.original.startLineNumber; m < f.original.endLineNumberExclusive - 2; m++) {
      const b = `${e[m - 1]}:${e[m + 1 - 1]}:${e[m + 2 - 1]}`;
      o.add(b, { range: new $(m, m + 3) });
    }
  const l = [];
  t.sort(Qt((f) => f.modified.startLineNumber, Yt));
  for (const f of t) {
    let m = [];
    for (let b = f.modified.startLineNumber; b < f.modified.endLineNumberExclusive - 2; b++) {
      const D = `${n[b - 1]}:${n[b + 1 - 1]}:${n[b + 2 - 1]}`, E = new $(b, b + 3), L = [];
      o.forEach(D, ({ range: _ }) => {
        for (const C of m)
          if (C.originalLineRange.endLineNumberExclusive + 1 === _.endLineNumberExclusive && C.modifiedLineRange.endLineNumberExclusive + 1 === E.endLineNumberExclusive) {
            C.originalLineRange = new $(C.originalLineRange.startLineNumber, _.endLineNumberExclusive), C.modifiedLineRange = new $(C.modifiedLineRange.startLineNumber, E.endLineNumberExclusive), L.push(C);
            return;
          }
        const v = {
          modifiedLineRange: E,
          originalLineRange: _
        };
        l.push(v), L.push(v);
      }), m = L;
    }
    if (!s.isValid())
      return [];
  }
  l.sort(Ol(Qt((f) => f.modifiedLineRange.length, Yt)));
  const c = new Be(), d = new Be();
  for (const f of l) {
    const m = f.modifiedLineRange.startLineNumber - f.originalLineRange.startLineNumber, b = c.subtractFrom(f.modifiedLineRange), D = d.subtractFrom(f.originalLineRange).getWithDelta(m), E = b.getIntersection(D);
    for (const L of E.ranges) {
      if (L.length < 3)
        continue;
      const _ = L, v = L.delta(-m);
      a.push(new ve(v, _)), c.addRange(_), d.addRange(v);
    }
  }
  a.sort(Qt((f) => f.original.startLineNumber, Yt));
  const h = new Nn(t);
  for (let f = 0; f < a.length; f++) {
    const m = a[f], b = h.findLastMonotonous((w) => w.original.startLineNumber <= m.original.startLineNumber), D = Dt(t, (w) => w.modified.startLineNumber <= m.modified.startLineNumber), E = Math.max(m.original.startLineNumber - b.original.startLineNumber, m.modified.startLineNumber - D.modified.startLineNumber), L = h.findLastMonotonous((w) => w.original.startLineNumber < m.original.endLineNumberExclusive), _ = Dt(t, (w) => w.modified.startLineNumber < m.modified.endLineNumberExclusive), v = Math.max(L.original.endLineNumberExclusive - m.original.endLineNumberExclusive, _.modified.endLineNumberExclusive - m.modified.endLineNumberExclusive);
    let C;
    for (C = 0; C < E; C++) {
      const w = m.original.startLineNumber - C - 1, N = m.modified.startLineNumber - C - 1;
      if (w > i.length || N > r.length || c.contains(N) || d.contains(w) || !xs(i[w - 1], r[N - 1], s))
        break;
    }
    C > 0 && (d.addRange(new $(m.original.startLineNumber - C, m.original.startLineNumber)), c.addRange(new $(m.modified.startLineNumber - C, m.modified.startLineNumber)));
    let x;
    for (x = 0; x < v; x++) {
      const w = m.original.endLineNumberExclusive + x, N = m.modified.endLineNumberExclusive + x;
      if (w > i.length || N > r.length || c.contains(N) || d.contains(w) || !xs(i[w - 1], r[N - 1], s))
        break;
    }
    x > 0 && (d.addRange(new $(m.original.endLineNumberExclusive, m.original.endLineNumberExclusive + x)), c.addRange(new $(m.modified.endLineNumberExclusive, m.modified.endLineNumberExclusive + x))), (C > 0 || x > 0) && (a[f] = new ve(new $(m.original.startLineNumber - C, m.original.endLineNumberExclusive + x), new $(m.modified.startLineNumber - C, m.modified.endLineNumberExclusive + x)));
  }
  return a;
}
function xs(t, e, n) {
  if (t.trim() === e.trim())
    return !0;
  if (t.length > 300 && e.length > 300)
    return !1;
  const r = new mo().compute(new gn([t], new H(1, 1, 1, t.length), !1), new gn([e], new H(1, 1, 1, e.length), !1), n);
  let s = 0;
  const a = K.invert(r.diffs, t.length);
  for (const d of a)
    d.seq1Range.forEach((h) => {
      li(t.charCodeAt(h)) || s++;
    });
  function o(d) {
    let h = 0;
    for (let f = 0; f < t.length; f++)
      li(d.charCodeAt(f)) || h++;
    return h;
  }
  const l = o(t.length > e.length ? t : e);
  return s / l > 0.6 && l > 10;
}
function ec(t) {
  if (t.length === 0)
    return t;
  t.sort(Qt((n) => n.original.startLineNumber, Yt));
  const e = [t[0]];
  for (let n = 1; n < t.length; n++) {
    const i = e[e.length - 1], r = t[n], s = r.original.startLineNumber - i.original.endLineNumberExclusive, a = r.modified.startLineNumber - i.modified.endLineNumberExclusive;
    if (s >= 0 && a >= 0 && s + a <= 2) {
      e[e.length - 1] = i.join(r);
      continue;
    }
    e.push(r);
  }
  return e;
}
function tc(t, e) {
  const n = new Nn(t);
  return e = e.filter((i) => {
    const r = n.findLastMonotonous((o) => o.original.startLineNumber < i.original.endLineNumberExclusive) || new ve(new $(1, 1), new $(1, 1)), s = Dt(t, (o) => o.modified.startLineNumber < i.modified.endLineNumberExclusive);
    return r !== s;
  }), e;
}
function Cs(t, e, n) {
  let i = n;
  return i = Es(t, e, i), i = Es(t, e, i), i = nc(t, e, i), i;
}
function Es(t, e, n) {
  if (n.length === 0)
    return n;
  const i = [];
  i.push(n[0]);
  for (let s = 1; s < n.length; s++) {
    const a = i[i.length - 1];
    let o = n[s];
    if (o.seq1Range.isEmpty || o.seq2Range.isEmpty) {
      const l = o.seq1Range.start - a.seq1Range.endExclusive;
      let c;
      for (c = 1; c <= l && !(t.getElement(o.seq1Range.start - c) !== t.getElement(o.seq1Range.endExclusive - c) || e.getElement(o.seq2Range.start - c) !== e.getElement(o.seq2Range.endExclusive - c)); c++)
        ;
      if (c--, c === l) {
        i[i.length - 1] = new K(new O(a.seq1Range.start, o.seq1Range.endExclusive - l), new O(a.seq2Range.start, o.seq2Range.endExclusive - l));
        continue;
      }
      o = o.delta(-c);
    }
    i.push(o);
  }
  const r = [];
  for (let s = 0; s < i.length - 1; s++) {
    const a = i[s + 1];
    let o = i[s];
    if (o.seq1Range.isEmpty || o.seq2Range.isEmpty) {
      const l = a.seq1Range.start - o.seq1Range.endExclusive;
      let c;
      for (c = 0; c < l && !(!t.isStronglyEqual(o.seq1Range.start + c, o.seq1Range.endExclusive + c) || !e.isStronglyEqual(o.seq2Range.start + c, o.seq2Range.endExclusive + c)); c++)
        ;
      if (c === l) {
        i[s + 1] = new K(new O(o.seq1Range.start + l, a.seq1Range.endExclusive), new O(o.seq2Range.start + l, a.seq2Range.endExclusive));
        continue;
      }
      c > 0 && (o = o.delta(c));
    }
    r.push(o);
  }
  return i.length > 0 && r.push(i[i.length - 1]), r;
}
function nc(t, e, n) {
  if (!t.getBoundaryScore || !e.getBoundaryScore)
    return n;
  for (let i = 0; i < n.length; i++) {
    const r = i > 0 ? n[i - 1] : void 0, s = n[i], a = i + 1 < n.length ? n[i + 1] : void 0, o = new O(r ? r.seq1Range.endExclusive + 1 : 0, a ? a.seq1Range.start - 1 : t.length), l = new O(r ? r.seq2Range.endExclusive + 1 : 0, a ? a.seq2Range.start - 1 : e.length);
    s.seq1Range.isEmpty ? n[i] = As(s, t, e, o, l) : s.seq2Range.isEmpty && (n[i] = As(s.swap(), e, t, l, o).swap());
  }
  return n;
}
function As(t, e, n, i, r) {
  let a = 1;
  for (; t.seq1Range.start - a >= i.start && t.seq2Range.start - a >= r.start && n.isStronglyEqual(t.seq2Range.start - a, t.seq2Range.endExclusive - a) && a < 100; )
    a++;
  a--;
  let o = 0;
  for (; t.seq1Range.start + o < i.endExclusive && t.seq2Range.endExclusive + o < r.endExclusive && n.isStronglyEqual(t.seq2Range.start + o, t.seq2Range.endExclusive + o) && o < 100; )
    o++;
  if (a === 0 && o === 0)
    return t;
  let l = 0, c = -1;
  for (let d = -a; d <= o; d++) {
    const h = t.seq2Range.start + d, f = t.seq2Range.endExclusive + d, m = t.seq1Range.start + d, b = e.getBoundaryScore(m) + n.getBoundaryScore(h) + n.getBoundaryScore(f);
    b > c && (c = b, l = d);
  }
  return t.delta(l);
}
function ic(t, e, n) {
  const i = [];
  for (const r of n) {
    const s = i[i.length - 1];
    if (!s) {
      i.push(r);
      continue;
    }
    r.seq1Range.start - s.seq1Range.endExclusive <= 2 || r.seq2Range.start - s.seq2Range.endExclusive <= 2 ? i[i.length - 1] = new K(s.seq1Range.join(r.seq1Range), s.seq2Range.join(r.seq2Range)) : i.push(r);
  }
  return i;
}
function rc(t, e, n) {
  const i = K.invert(n, t.length), r = [];
  let s = new Se(0, 0);
  function a(l, c) {
    if (l.offset1 < s.offset1 || l.offset2 < s.offset2)
      return;
    const d = t.findWordContaining(l.offset1), h = e.findWordContaining(l.offset2);
    if (!d || !h)
      return;
    let f = new K(d, h);
    const m = f.intersect(c);
    let b = m.seq1Range.length, D = m.seq2Range.length;
    for (; i.length > 0; ) {
      const E = i[0];
      if (!(E.seq1Range.intersects(f.seq1Range) || E.seq2Range.intersects(f.seq2Range)))
        break;
      const _ = t.findWordContaining(E.seq1Range.start), v = e.findWordContaining(E.seq2Range.start), C = new K(_, v), x = C.intersect(E);
      if (b += x.seq1Range.length, D += x.seq2Range.length, f = f.join(C), f.seq1Range.endExclusive >= E.seq1Range.endExclusive)
        i.shift();
      else
        break;
    }
    b + D < (f.seq1Range.length + f.seq2Range.length) * 2 / 3 && r.push(f), s = f.getEndExclusives();
  }
  for (; i.length > 0; ) {
    const l = i.shift();
    l.seq1Range.isEmpty || (a(l.getStarts(), l), a(l.getEndExclusives().delta(-1), l));
  }
  return sc(n, r);
}
function sc(t, e) {
  const n = [];
  for (; t.length > 0 || e.length > 0; ) {
    const i = t[0], r = e[0];
    let s;
    i && (!r || i.seq1Range.start < r.seq1Range.start) ? s = t.shift() : s = e.shift(), n.length > 0 && n[n.length - 1].seq1Range.endExclusive >= s.seq1Range.start ? n[n.length - 1] = n[n.length - 1].join(s) : n.push(s);
  }
  return n;
}
function ac(t, e, n) {
  let i = n;
  if (i.length === 0)
    return i;
  let r = 0, s;
  do {
    s = !1;
    const o = [
      i[0]
    ];
    for (let l = 1; l < i.length; l++) {
      let h = function(m, b) {
        const D = new O(d.seq1Range.endExclusive, c.seq1Range.start);
        return t.getText(D).replace(/\s/g, "").length <= 4 && (m.seq1Range.length + m.seq2Range.length > 5 || b.seq1Range.length + b.seq2Range.length > 5);
      };
      var a = h;
      const c = i[l], d = o[o.length - 1];
      h(d, c) ? (s = !0, o[o.length - 1] = o[o.length - 1].join(c)) : o.push(c);
    }
    i = o;
  } while (r++ < 10 && s);
  return i;
}
function oc(t, e, n) {
  let i = n;
  if (i.length === 0)
    return i;
  let r = 0, s;
  do {
    s = !1;
    const l = [
      i[0]
    ];
    for (let c = 1; c < i.length; c++) {
      let f = function(b, D) {
        const E = new O(h.seq1Range.endExclusive, d.seq1Range.start);
        if (t.countLinesIn(E) > 5 || E.length > 500)
          return !1;
        const _ = t.getText(E).trim();
        if (_.length > 20 || _.split(/\r\n|\r|\n/).length > 1)
          return !1;
        const v = t.countLinesIn(b.seq1Range), C = b.seq1Range.length, x = e.countLinesIn(b.seq2Range), w = b.seq2Range.length, N = t.countLinesIn(D.seq1Range), B = D.seq1Range.length, j = e.countLinesIn(D.seq2Range), ue = D.seq2Range.length, G = 2 * 40 + 50;
        function U(y) {
          return Math.min(y, G);
        }
        return Math.pow(Math.pow(U(v * 40 + C), 1.5) + Math.pow(U(x * 40 + w), 1.5), 1.5) + Math.pow(Math.pow(U(N * 40 + B), 1.5) + Math.pow(U(j * 40 + ue), 1.5), 1.5) > (G ** 1.5) ** 1.5 * 1.3;
      };
      var o = f;
      const d = i[c], h = l[l.length - 1];
      f(h, d) ? (s = !0, l[l.length - 1] = l[l.length - 1].join(d)) : l.push(d);
    }
    i = l;
  } while (r++ < 10 && s);
  const a = [];
  return zl(i, (l, c, d) => {
    let h = c;
    function f(_) {
      return _.length > 0 && _.trim().length <= 3 && c.seq1Range.length + c.seq2Range.length > 100;
    }
    const m = t.extendToFullLines(c.seq1Range), b = t.getText(new O(m.start, c.seq1Range.start));
    f(b) && (h = h.deltaStart(-b.length));
    const D = t.getText(new O(c.seq1Range.endExclusive, m.endExclusive));
    f(D) && (h = h.deltaEnd(D.length));
    const E = K.fromOffsetPairs(l ? l.getEndExclusives() : Se.zero, d ? d.getStarts() : Se.max), L = h.intersect(E);
    a.length > 0 && L.getStarts().equals(a[a.length - 1].getEndExclusives()) ? a[a.length - 1] = a[a.length - 1].join(L) : a.push(L);
  }), a;
}
class ws {
  constructor(e, n) {
    this.trimmedHash = e, this.lines = n;
  }
  getElement(e) {
    return this.trimmedHash[e];
  }
  get length() {
    return this.trimmedHash.length;
  }
  getBoundaryScore(e) {
    const n = e === 0 ? 0 : Ls(this.lines[e - 1]), i = e === this.lines.length ? 0 : Ls(this.lines[e]);
    return 1e3 - (n + i);
  }
  getText(e) {
    return this.lines.slice(e.start, e.endExclusive).join(`
`);
  }
  isStronglyEqual(e, n) {
    return this.lines[e] === this.lines[n];
  }
}
function Ls(t) {
  let e = 0;
  for (; e < t.length && (t.charCodeAt(e) === 32 || t.charCodeAt(e) === 9); )
    e++;
  return e;
}
class uc {
  constructor() {
    this.dynamicProgrammingDiffing = new jl(), this.myersDiffingAlgorithm = new mo();
  }
  computeDiff(e, n, i) {
    if (e.length <= 1 && Vl(e, n, (x, w) => x === w))
      return new Jt([], [], !1);
    if (e.length === 1 && e[0].length === 0 || n.length === 1 && n[0].length === 0)
      return new Jt([
        new Te(new $(1, e.length + 1), new $(1, n.length + 1), [
          new Fe(new H(1, 1, e.length, e[e.length - 1].length + 1), new H(1, 1, n.length, n[n.length - 1].length + 1))
        ])
      ], [], !1);
    const r = i.maxComputationTimeMs === 0 ? Vt.instance : new Hl(i.maxComputationTimeMs), s = !i.ignoreTrimWhitespace, a = /* @__PURE__ */ new Map();
    function o(x) {
      let w = a.get(x);
      return w === void 0 && (w = a.size, a.set(x, w)), w;
    }
    const l = e.map((x) => o(x.trim())), c = n.map((x) => o(x.trim())), d = new ws(l, e), h = new ws(c, n), f = d.length + h.length < 1700 ? this.dynamicProgrammingDiffing.compute(d, h, r, (x, w) => e[x] === n[w] ? n[w].length === 0 ? 0.1 : 1 + Math.log(1 + n[w].length) : 0.99) : this.myersDiffingAlgorithm.compute(d, h, r);
    let m = f.diffs, b = f.hitTimeout;
    m = Cs(d, h, m), m = ac(d, h, m);
    const D = [], E = (x) => {
      if (s)
        for (let w = 0; w < x; w++) {
          const N = L + w, B = _ + w;
          if (e[N] !== n[B]) {
            const j = this.refineDiff(e, n, new K(new O(N, N + 1), new O(B, B + 1)), r, s);
            for (const ue of j.mappings)
              D.push(ue);
            j.hitTimeout && (b = !0);
          }
        }
    };
    let L = 0, _ = 0;
    for (const x of m) {
      mn(() => x.seq1Range.start - L === x.seq2Range.start - _);
      const w = x.seq1Range.start - L;
      E(w), L = x.seq1Range.endExclusive, _ = x.seq2Range.endExclusive;
      const N = this.refineDiff(e, n, x, r, s);
      N.hitTimeout && (b = !0);
      for (const B of N.mappings)
        D.push(B);
    }
    E(e.length - L);
    const v = vs(D, e, n);
    let C = [];
    return i.computeMoves && (C = this.computeMoves(v, e, n, l, c, r, s)), mn(() => {
      function x(N, B) {
        if (N.lineNumber < 1 || N.lineNumber > B.length)
          return !1;
        const j = B[N.lineNumber - 1];
        return !(N.column < 1 || N.column > j.length + 1);
      }
      function w(N, B) {
        return !(N.startLineNumber < 1 || N.startLineNumber > B.length + 1 || N.endLineNumberExclusive < 1 || N.endLineNumberExclusive > B.length + 1);
      }
      for (const N of v) {
        if (!N.innerChanges)
          return !1;
        for (const B of N.innerChanges)
          if (!(x(B.modifiedRange.getStartPosition(), n) && x(B.modifiedRange.getEndPosition(), n) && x(B.originalRange.getStartPosition(), e) && x(B.originalRange.getEndPosition(), e)))
            return !1;
        if (!w(N.modified, n) || !w(N.original, e))
          return !1;
      }
      return !0;
    }), new Jt(v, C, b);
  }
  computeMoves(e, n, i, r, s, a, o) {
    return Ql(e, n, i, r, s, a).map((d) => {
      const h = this.refineDiff(n, i, new K(d.original.toOffsetRange(), d.modified.toOffsetRange()), a, o), f = vs(h.mappings, n, i, !0);
      return new kl(d, f);
    });
  }
  refineDiff(e, n, i, r, s) {
    const o = cc(i).toRangeMapping2(e, n), l = new gn(e, o.originalRange, s), c = new gn(n, o.modifiedRange, s), d = l.length + c.length < 500 ? this.dynamicProgrammingDiffing.compute(l, c, r) : this.myersDiffingAlgorithm.compute(l, c, r);
    let h = d.diffs;
    return h = Cs(l, c, h), h = rc(l, c, h), h = ic(l, c, h), h = oc(l, c, h), {
      mappings: h.map((m) => new Fe(l.translateRange(m.seq1Range), c.translateRange(m.seq2Range))),
      hitTimeout: d.hitTimeout
    };
  }
}
function vs(t, e, n, i = !1) {
  const r = [];
  for (const s of $l(t.map((a) => lc(a, e, n)), (a, o) => a.original.overlapOrTouch(o.original) || a.modified.overlapOrTouch(o.modified))) {
    const a = s[0], o = s[s.length - 1];
    r.push(new Te(a.original.join(o.original), a.modified.join(o.modified), s.map((l) => l.innerChanges[0])));
  }
  return mn(() => !i && r.length > 0 && (r[0].modified.startLineNumber !== r[0].original.startLineNumber || n.length - r[r.length - 1].modified.endLineNumberExclusive !== e.length - r[r.length - 1].original.endLineNumberExclusive) ? !1 : uo(r, (s, a) => a.original.startLineNumber - s.original.endLineNumberExclusive === a.modified.startLineNumber - s.modified.endLineNumberExclusive && // There has to be an unchanged line in between (otherwise both diffs should have been joined)
  s.original.endLineNumberExclusive < a.original.startLineNumber && s.modified.endLineNumberExclusive < a.modified.startLineNumber)), r;
}
function lc(t, e, n) {
  let i = 0, r = 0;
  t.modifiedRange.endColumn === 1 && t.originalRange.endColumn === 1 && t.originalRange.startLineNumber + i <= t.originalRange.endLineNumber && t.modifiedRange.startLineNumber + i <= t.modifiedRange.endLineNumber && (r = -1), t.modifiedRange.startColumn - 1 >= n[t.modifiedRange.startLineNumber - 1].length && t.originalRange.startColumn - 1 >= e[t.originalRange.startLineNumber - 1].length && t.originalRange.startLineNumber <= t.originalRange.endLineNumber + r && t.modifiedRange.startLineNumber <= t.modifiedRange.endLineNumber + r && (i = 1);
  const s = new $(t.originalRange.startLineNumber + i, t.originalRange.endLineNumber + 1 + r), a = new $(t.modifiedRange.startLineNumber + i, t.modifiedRange.endLineNumber + 1 + r);
  return new Te(s, a, [t]);
}
function cc(t) {
  return new ve(new $(t.seq1Range.start + 1, t.seq1Range.endExclusive + 1), new $(t.seq2Range.start + 1, t.seq2Range.endExclusive + 1));
}
const _s = {
  getLegacy: () => new Ml(),
  getDefault: () => new uc()
};
function Ye(t, e) {
  const n = Math.pow(10, e);
  return Math.round(t * n) / n;
}
class oe {
  constructor(e, n, i, r = 1) {
    this._rgbaBrand = void 0, this.r = Math.min(255, Math.max(0, e)) | 0, this.g = Math.min(255, Math.max(0, n)) | 0, this.b = Math.min(255, Math.max(0, i)) | 0, this.a = Ye(Math.max(Math.min(1, r), 0), 3);
  }
  static equals(e, n) {
    return e.r === n.r && e.g === n.g && e.b === n.b && e.a === n.a;
  }
}
class Le {
  constructor(e, n, i, r) {
    this._hslaBrand = void 0, this.h = Math.max(Math.min(360, e), 0) | 0, this.s = Ye(Math.max(Math.min(1, n), 0), 3), this.l = Ye(Math.max(Math.min(1, i), 0), 3), this.a = Ye(Math.max(Math.min(1, r), 0), 3);
  }
  static equals(e, n) {
    return e.h === n.h && e.s === n.s && e.l === n.l && e.a === n.a;
  }
  /**
   * Converts an RGB color value to HSL. Conversion formula
   * adapted from http://en.wikipedia.org/wiki/HSL_color_space.
   * Assumes r, g, and b are contained in the set [0, 255] and
   * returns h in the set [0, 360], s, and l in the set [0, 1].
   */
  static fromRGBA(e) {
    const n = e.r / 255, i = e.g / 255, r = e.b / 255, s = e.a, a = Math.max(n, i, r), o = Math.min(n, i, r);
    let l = 0, c = 0;
    const d = (o + a) / 2, h = a - o;
    if (h > 0) {
      switch (c = Math.min(d <= 0.5 ? h / (2 * d) : h / (2 - 2 * d), 1), a) {
        case n:
          l = (i - r) / h + (i < r ? 6 : 0);
          break;
        case i:
          l = (r - n) / h + 2;
          break;
        case r:
          l = (n - i) / h + 4;
          break;
      }
      l *= 60, l = Math.round(l);
    }
    return new Le(l, c, d, s);
  }
  static _hue2rgb(e, n, i) {
    return i < 0 && (i += 1), i > 1 && (i -= 1), i < 1 / 6 ? e + (n - e) * 6 * i : i < 1 / 2 ? n : i < 2 / 3 ? e + (n - e) * (2 / 3 - i) * 6 : e;
  }
  /**
   * Converts an HSL color value to RGB. Conversion formula
   * adapted from http://en.wikipedia.org/wiki/HSL_color_space.
   * Assumes h in the set [0, 360] s, and l are contained in the set [0, 1] and
   * returns r, g, and b in the set [0, 255].
   */
  static toRGBA(e) {
    const n = e.h / 360, { s: i, l: r, a: s } = e;
    let a, o, l;
    if (i === 0)
      a = o = l = r;
    else {
      const c = r < 0.5 ? r * (1 + i) : r + i - r * i, d = 2 * r - c;
      a = Le._hue2rgb(d, c, n + 1 / 3), o = Le._hue2rgb(d, c, n), l = Le._hue2rgb(d, c, n - 1 / 3);
    }
    return new oe(Math.round(a * 255), Math.round(o * 255), Math.round(l * 255), s);
  }
}
class mt {
  constructor(e, n, i, r) {
    this._hsvaBrand = void 0, this.h = Math.max(Math.min(360, e), 0) | 0, this.s = Ye(Math.max(Math.min(1, n), 0), 3), this.v = Ye(Math.max(Math.min(1, i), 0), 3), this.a = Ye(Math.max(Math.min(1, r), 0), 3);
  }
  static equals(e, n) {
    return e.h === n.h && e.s === n.s && e.v === n.v && e.a === n.a;
  }
  // from http://www.rapidtables.com/convert/color/rgb-to-hsv.htm
  static fromRGBA(e) {
    const n = e.r / 255, i = e.g / 255, r = e.b / 255, s = Math.max(n, i, r), a = Math.min(n, i, r), o = s - a, l = s === 0 ? 0 : o / s;
    let c;
    return o === 0 ? c = 0 : s === n ? c = ((i - r) / o % 6 + 6) % 6 : s === i ? c = (r - n) / o + 2 : c = (n - i) / o + 4, new mt(Math.round(c * 60), l, s, e.a);
  }
  // from http://www.rapidtables.com/convert/color/hsv-to-rgb.htm
  static toRGBA(e) {
    const { h: n, s: i, v: r, a: s } = e, a = r * i, o = a * (1 - Math.abs(n / 60 % 2 - 1)), l = r - a;
    let [c, d, h] = [0, 0, 0];
    return n < 60 ? (c = a, d = o) : n < 120 ? (c = o, d = a) : n < 180 ? (d = a, h = o) : n < 240 ? (d = o, h = a) : n < 300 ? (c = o, h = a) : n <= 360 && (c = a, h = o), c = Math.round((c + l) * 255), d = Math.round((d + l) * 255), h = Math.round((h + l) * 255), new oe(c, d, h, s);
  }
}
let pn = class ae {
  static fromHex(e) {
    return ae.Format.CSS.parseHex(e) || ae.red;
  }
  static equals(e, n) {
    return !e && !n ? !0 : !e || !n ? !1 : e.equals(n);
  }
  get hsla() {
    return this._hsla ? this._hsla : Le.fromRGBA(this.rgba);
  }
  get hsva() {
    return this._hsva ? this._hsva : mt.fromRGBA(this.rgba);
  }
  constructor(e) {
    if (e)
      if (e instanceof oe)
        this.rgba = e;
      else if (e instanceof Le)
        this._hsla = e, this.rgba = Le.toRGBA(e);
      else if (e instanceof mt)
        this._hsva = e, this.rgba = mt.toRGBA(e);
      else
        throw new Error("Invalid color ctor argument");
    else throw new Error("Color needs a value");
  }
  equals(e) {
    return !!e && oe.equals(this.rgba, e.rgba) && Le.equals(this.hsla, e.hsla) && mt.equals(this.hsva, e.hsva);
  }
  /**
   * http://www.w3.org/TR/WCAG20/#relativeluminancedef
   * Returns the number in the set [0, 1]. O => Darkest Black. 1 => Lightest white.
   */
  getRelativeLuminance() {
    const e = ae._relativeLuminanceForComponent(this.rgba.r), n = ae._relativeLuminanceForComponent(this.rgba.g), i = ae._relativeLuminanceForComponent(this.rgba.b), r = 0.2126 * e + 0.7152 * n + 0.0722 * i;
    return Ye(r, 4);
  }
  static _relativeLuminanceForComponent(e) {
    const n = e / 255;
    return n <= 0.03928 ? n / 12.92 : Math.pow((n + 0.055) / 1.055, 2.4);
  }
  /**
   *	http://24ways.org/2010/calculating-color-contrast
   *  Return 'true' if lighter color otherwise 'false'
   */
  isLighter() {
    return (this.rgba.r * 299 + this.rgba.g * 587 + this.rgba.b * 114) / 1e3 >= 128;
  }
  isLighterThan(e) {
    const n = this.getRelativeLuminance(), i = e.getRelativeLuminance();
    return n > i;
  }
  isDarkerThan(e) {
    const n = this.getRelativeLuminance(), i = e.getRelativeLuminance();
    return n < i;
  }
  lighten(e) {
    return new ae(new Le(this.hsla.h, this.hsla.s, this.hsla.l + this.hsla.l * e, this.hsla.a));
  }
  darken(e) {
    return new ae(new Le(this.hsla.h, this.hsla.s, this.hsla.l - this.hsla.l * e, this.hsla.a));
  }
  transparent(e) {
    const { r: n, g: i, b: r, a: s } = this.rgba;
    return new ae(new oe(n, i, r, s * e));
  }
  isTransparent() {
    return this.rgba.a === 0;
  }
  isOpaque() {
    return this.rgba.a === 1;
  }
  opposite() {
    return new ae(new oe(255 - this.rgba.r, 255 - this.rgba.g, 255 - this.rgba.b, this.rgba.a));
  }
  makeOpaque(e) {
    if (this.isOpaque() || e.rgba.a !== 1)
      return this;
    const { r: n, g: i, b: r, a: s } = this.rgba;
    return new ae(new oe(e.rgba.r - s * (e.rgba.r - n), e.rgba.g - s * (e.rgba.g - i), e.rgba.b - s * (e.rgba.b - r), 1));
  }
  toString() {
    return this._toString || (this._toString = ae.Format.CSS.format(this)), this._toString;
  }
  static getLighterColor(e, n, i) {
    if (e.isLighterThan(n))
      return e;
    i = i || 0.5;
    const r = e.getRelativeLuminance(), s = n.getRelativeLuminance();
    return i = i * (s - r) / s, e.lighten(i);
  }
  static getDarkerColor(e, n, i) {
    if (e.isDarkerThan(n))
      return e;
    i = i || 0.5;
    const r = e.getRelativeLuminance(), s = n.getRelativeLuminance();
    return i = i * (r - s) / r, e.darken(i);
  }
  static {
    this.white = new ae(new oe(255, 255, 255, 1));
  }
  static {
    this.black = new ae(new oe(0, 0, 0, 1));
  }
  static {
    this.red = new ae(new oe(255, 0, 0, 1));
  }
  static {
    this.blue = new ae(new oe(0, 0, 255, 1));
  }
  static {
    this.green = new ae(new oe(0, 255, 0, 1));
  }
  static {
    this.cyan = new ae(new oe(0, 255, 255, 1));
  }
  static {
    this.lightgrey = new ae(new oe(211, 211, 211, 1));
  }
  static {
    this.transparent = new ae(new oe(0, 0, 0, 0));
  }
};
(function(t) {
  (function(e) {
    (function(n) {
      function i(m) {
        return m.rgba.a === 1 ? `rgb(${m.rgba.r}, ${m.rgba.g}, ${m.rgba.b})` : t.Format.CSS.formatRGBA(m);
      }
      n.formatRGB = i;
      function r(m) {
        return `rgba(${m.rgba.r}, ${m.rgba.g}, ${m.rgba.b}, ${+m.rgba.a.toFixed(2)})`;
      }
      n.formatRGBA = r;
      function s(m) {
        return m.hsla.a === 1 ? `hsl(${m.hsla.h}, ${(m.hsla.s * 100).toFixed(2)}%, ${(m.hsla.l * 100).toFixed(2)}%)` : t.Format.CSS.formatHSLA(m);
      }
      n.formatHSL = s;
      function a(m) {
        return `hsla(${m.hsla.h}, ${(m.hsla.s * 100).toFixed(2)}%, ${(m.hsla.l * 100).toFixed(2)}%, ${m.hsla.a.toFixed(2)})`;
      }
      n.formatHSLA = a;
      function o(m) {
        const b = m.toString(16);
        return b.length !== 2 ? "0" + b : b;
      }
      function l(m) {
        return `#${o(m.rgba.r)}${o(m.rgba.g)}${o(m.rgba.b)}`;
      }
      n.formatHex = l;
      function c(m, b = !1) {
        return b && m.rgba.a === 1 ? t.Format.CSS.formatHex(m) : `#${o(m.rgba.r)}${o(m.rgba.g)}${o(m.rgba.b)}${o(Math.round(m.rgba.a * 255))}`;
      }
      n.formatHexA = c;
      function d(m) {
        return m.isOpaque() ? t.Format.CSS.formatHex(m) : t.Format.CSS.formatRGBA(m);
      }
      n.format = d;
      function h(m) {
        const b = m.length;
        if (b === 0 || m.charCodeAt(0) !== 35)
          return null;
        if (b === 7) {
          const D = 16 * f(m.charCodeAt(1)) + f(m.charCodeAt(2)), E = 16 * f(m.charCodeAt(3)) + f(m.charCodeAt(4)), L = 16 * f(m.charCodeAt(5)) + f(m.charCodeAt(6));
          return new t(new oe(D, E, L, 1));
        }
        if (b === 9) {
          const D = 16 * f(m.charCodeAt(1)) + f(m.charCodeAt(2)), E = 16 * f(m.charCodeAt(3)) + f(m.charCodeAt(4)), L = 16 * f(m.charCodeAt(5)) + f(m.charCodeAt(6)), _ = 16 * f(m.charCodeAt(7)) + f(m.charCodeAt(8));
          return new t(new oe(D, E, L, _ / 255));
        }
        if (b === 4) {
          const D = f(m.charCodeAt(1)), E = f(m.charCodeAt(2)), L = f(m.charCodeAt(3));
          return new t(new oe(16 * D + D, 16 * E + E, 16 * L + L));
        }
        if (b === 5) {
          const D = f(m.charCodeAt(1)), E = f(m.charCodeAt(2)), L = f(m.charCodeAt(3)), _ = f(m.charCodeAt(4));
          return new t(new oe(16 * D + D, 16 * E + E, 16 * L + L, (16 * _ + _) / 255));
        }
        return null;
      }
      n.parseHex = h;
      function f(m) {
        switch (m) {
          case 48:
            return 0;
          case 49:
            return 1;
          case 50:
            return 2;
          case 51:
            return 3;
          case 52:
            return 4;
          case 53:
            return 5;
          case 54:
            return 6;
          case 55:
            return 7;
          case 56:
            return 8;
          case 57:
            return 9;
          case 97:
            return 10;
          case 65:
            return 10;
          case 98:
            return 11;
          case 66:
            return 11;
          case 99:
            return 12;
          case 67:
            return 12;
          case 100:
            return 13;
          case 68:
            return 13;
          case 101:
            return 14;
          case 69:
            return 14;
          case 102:
            return 15;
          case 70:
            return 15;
        }
        return 0;
      }
    })(e.CSS || (e.CSS = {}));
  })(t.Format || (t.Format = {}));
})(pn || (pn = {}));
function go(t) {
  const e = [];
  for (const n of t) {
    const i = Number(n);
    (i || i === 0 && n.replace(/\s/g, "") !== "") && e.push(i);
  }
  return e;
}
function Vi(t, e, n, i) {
  return {
    red: t / 255,
    blue: n / 255,
    green: e / 255,
    alpha: i
  };
}
function _t(t, e) {
  const n = e.index, i = e[0].length;
  if (!n)
    return;
  const r = t.positionAt(n);
  return {
    startLineNumber: r.lineNumber,
    startColumn: r.column,
    endLineNumber: r.lineNumber,
    endColumn: r.column + i
  };
}
function hc(t, e) {
  if (!t)
    return;
  const n = pn.Format.CSS.parseHex(e);
  if (n)
    return {
      range: t,
      color: Vi(n.rgba.r, n.rgba.g, n.rgba.b, n.rgba.a)
    };
}
function Fs(t, e, n) {
  if (!t || e.length !== 1)
    return;
  const r = e[0].values(), s = go(r);
  return {
    range: t,
    color: Vi(s[0], s[1], s[2], n ? s[3] : 1)
  };
}
function ys(t, e, n) {
  if (!t || e.length !== 1)
    return;
  const r = e[0].values(), s = go(r), a = new pn(new Le(s[0], s[1] / 100, s[2] / 100, n ? s[3] : 1));
  return {
    range: t,
    color: Vi(a.rgba.r, a.rgba.g, a.rgba.b, a.rgba.a)
  };
}
function Ft(t, e) {
  return typeof t == "string" ? [...t.matchAll(e)] : t.findMatches(e);
}
function dc(t) {
  const e = [], i = Ft(t, /\b(rgb|rgba|hsl|hsla)(\([0-9\s,.\%]*\))|(#)([A-Fa-f0-9]{3})\b|(#)([A-Fa-f0-9]{4})\b|(#)([A-Fa-f0-9]{6})\b|(#)([A-Fa-f0-9]{8})\b/gm);
  if (i.length > 0)
    for (const r of i) {
      const s = r.filter((c) => c !== void 0), a = s[1], o = s[2];
      if (!o)
        continue;
      let l;
      if (a === "rgb") {
        const c = /^\(\s*(25[0-5]|2[0-4][0-9]|1[0-9]{2}|[1-9][0-9]|[0-9])\s*,\s*(25[0-5]|2[0-4][0-9]|1[0-9]{2}|[1-9][0-9]|[0-9])\s*,\s*(25[0-5]|2[0-4][0-9]|1[0-9]{2}|[1-9][0-9]|[0-9])\s*\)$/gm;
        l = Fs(_t(t, r), Ft(o, c), !1);
      } else if (a === "rgba") {
        const c = /^\(\s*(25[0-5]|2[0-4][0-9]|1[0-9]{2}|[1-9][0-9]|[0-9])\s*,\s*(25[0-5]|2[0-4][0-9]|1[0-9]{2}|[1-9][0-9]|[0-9])\s*,\s*(25[0-5]|2[0-4][0-9]|1[0-9]{2}|[1-9][0-9]|[0-9])\s*,\s*(0[.][0-9]+|[.][0-9]+|[01][.]|[01])\s*\)$/gm;
        l = Fs(_t(t, r), Ft(o, c), !0);
      } else if (a === "hsl") {
        const c = /^\(\s*(36[0]|3[0-5][0-9]|[12][0-9][0-9]|[1-9]?[0-9])\s*,\s*(100|\d{1,2}[.]\d*|\d{1,2})%\s*,\s*(100|\d{1,2}[.]\d*|\d{1,2})%\s*\)$/gm;
        l = ys(_t(t, r), Ft(o, c), !1);
      } else if (a === "hsla") {
        const c = /^\(\s*(36[0]|3[0-5][0-9]|[12][0-9][0-9]|[1-9]?[0-9])\s*,\s*(100|\d{1,2}[.]\d*|\d{1,2})%\s*,\s*(100|\d{1,2}[.]\d*|\d{1,2})%\s*,\s*(0[.][0-9]+|[.][0-9]+|[01][.]|[01])\s*\)$/gm;
        l = ys(_t(t, r), Ft(o, c), !0);
      } else a === "#" && (l = hc(_t(t, r), a + o));
      l && e.push(l);
    }
  return e;
}
function fc(t) {
  return !t || typeof t.getValue != "function" || typeof t.positionAt != "function" ? [] : dc(t);
}
const Ss = new RegExp("\\bMARK:\\s*(.*)$", "d"), mc = /^-+|-+$/g;
function gc(t, e) {
  let n = [];
  if (e.findRegionSectionHeaders && e.foldingRules?.markers) {
    const i = pc(t, e);
    n = n.concat(i);
  }
  if (e.findMarkSectionHeaders) {
    const i = bc(t);
    n = n.concat(i);
  }
  return n;
}
function pc(t, e) {
  const n = [], i = t.getLineCount();
  for (let r = 1; r <= i; r++) {
    const s = t.getLineContent(r), a = s.match(e.foldingRules.markers.start);
    if (a) {
      const o = { startLineNumber: r, startColumn: a[0].length + 1, endLineNumber: r, endColumn: s.length + 1 };
      if (o.endColumn > o.startColumn) {
        const l = {
          range: o,
          ...po(s.substring(a[0].length)),
          shouldBeInComments: !1
        };
        (l.text || l.hasSeparatorLine) && n.push(l);
      }
    }
  }
  return n;
}
function bc(t) {
  const e = [], n = t.getLineCount();
  for (let i = 1; i <= n; i++) {
    const r = t.getLineContent(i);
    Dc(r, i, e);
  }
  return e;
}
function Dc(t, e, n) {
  Ss.lastIndex = 0;
  const i = Ss.exec(t);
  if (i) {
    const r = i.indices[1][0] + 1, s = i.indices[1][1] + 1, a = { startLineNumber: e, startColumn: r, endLineNumber: e, endColumn: s };
    if (a.endColumn > a.startColumn) {
      const o = {
        range: a,
        ...po(i[1]),
        shouldBeInComments: !0
      };
      (o.text || o.hasSeparatorLine) && n.push(o);
    }
  }
}
function po(t) {
  t = t.trim();
  const e = t.startsWith("-");
  return t = t.replace(mc, ""), { text: t, hasSeparatorLine: e };
}
var Ns;
(function(t) {
  async function e(i) {
    let r;
    const s = await Promise.all(i.map((a) => a.then((o) => o, (o) => {
      r || (r = o);
    })));
    if (typeof r < "u")
      throw r;
    return s;
  }
  t.settled = e;
  function n(i) {
    return new Promise(async (r, s) => {
      try {
        await i(r, s);
      } catch (a) {
        s(a);
      }
    });
  }
  t.withAsyncBody = n;
})(Ns || (Ns = {}));
class xe {
  static fromArray(e) {
    return new xe((n) => {
      n.emitMany(e);
    });
  }
  static fromPromise(e) {
    return new xe(async (n) => {
      n.emitMany(await e);
    });
  }
  static fromPromises(e) {
    return new xe(async (n) => {
      await Promise.all(e.map(async (i) => n.emitOne(await i)));
    });
  }
  static merge(e) {
    return new xe(async (n) => {
      await Promise.all(e.map(async (i) => {
        for await (const r of i)
          n.emitOne(r);
      }));
    });
  }
  static {
    this.EMPTY = xe.fromArray([]);
  }
  constructor(e, n) {
    this._state = 0, this._results = [], this._error = null, this._onReturn = n, this._onStateChanged = new we(), queueMicrotask(async () => {
      const i = {
        emitOne: (r) => this.emitOne(r),
        emitMany: (r) => this.emitMany(r),
        reject: (r) => this.reject(r)
      };
      try {
        await Promise.resolve(e(i)), this.resolve();
      } catch (r) {
        this.reject(r);
      } finally {
        i.emitOne = void 0, i.emitMany = void 0, i.reject = void 0;
      }
    });
  }
  [Symbol.asyncIterator]() {
    let e = 0;
    return {
      next: async () => {
        do {
          if (this._state === 2)
            throw this._error;
          if (e < this._results.length)
            return { done: !1, value: this._results[e++] };
          if (this._state === 1)
            return { done: !0, value: void 0 };
          await sn.toPromise(this._onStateChanged.event);
        } while (!0);
      },
      return: async () => (this._onReturn?.(), { done: !0, value: void 0 })
    };
  }
  static map(e, n) {
    return new xe(async (i) => {
      for await (const r of e)
        i.emitOne(n(r));
    });
  }
  map(e) {
    return xe.map(this, e);
  }
  static filter(e, n) {
    return new xe(async (i) => {
      for await (const r of e)
        n(r) && i.emitOne(r);
    });
  }
  filter(e) {
    return xe.filter(this, e);
  }
  static coalesce(e) {
    return xe.filter(e, (n) => !!n);
  }
  coalesce() {
    return xe.coalesce(this);
  }
  static async toPromise(e) {
    const n = [];
    for await (const i of e)
      n.push(i);
    return n;
  }
  toPromise() {
    return xe.toPromise(this);
  }
  /**
   * The value will be appended at the end.
   *
   * **NOTE** If `resolve()` or `reject()` have already been called, this method has no effect.
   */
  emitOne(e) {
    this._state === 0 && (this._results.push(e), this._onStateChanged.fire());
  }
  /**
   * The values will be appended at the end.
   *
   * **NOTE** If `resolve()` or `reject()` have already been called, this method has no effect.
   */
  emitMany(e) {
    this._state === 0 && (this._results = this._results.concat(e), this._onStateChanged.fire());
  }
  /**
   * Calling `resolve()` will mark the result array as complete.
   *
   * **NOTE** `resolve()` must be called, otherwise all consumers of this iterable will hang indefinitely, similar to a non-resolved promise.
   * **NOTE** If `resolve()` or `reject()` have already been called, this method has no effect.
   */
  resolve() {
    this._state === 0 && (this._state = 1, this._onStateChanged.fire());
  }
  /**
   * Writing an error will permanently invalidate this iterable.
   * The current users will receive an error thrown, as will all future users.
   *
   * **NOTE** If `resolve()` or `reject()` have already been called, this method has no effect.
   */
  reject(e) {
    this._state === 0 && (this._state = 2, this._error = e, this._onStateChanged.fire());
  }
}
class xc {
  constructor(e) {
    this.values = e, this.prefixSum = new Uint32Array(e.length), this.prefixSumValidIndex = new Int32Array(1), this.prefixSumValidIndex[0] = -1;
  }
  insertValues(e, n) {
    e = ut(e);
    const i = this.values, r = this.prefixSum, s = n.length;
    return s === 0 ? !1 : (this.values = new Uint32Array(i.length + s), this.values.set(i.subarray(0, e), 0), this.values.set(i.subarray(e), e + s), this.values.set(n, e), e - 1 < this.prefixSumValidIndex[0] && (this.prefixSumValidIndex[0] = e - 1), this.prefixSum = new Uint32Array(this.values.length), this.prefixSumValidIndex[0] >= 0 && this.prefixSum.set(r.subarray(0, this.prefixSumValidIndex[0] + 1)), !0);
  }
  setValue(e, n) {
    return e = ut(e), n = ut(n), this.values[e] === n ? !1 : (this.values[e] = n, e - 1 < this.prefixSumValidIndex[0] && (this.prefixSumValidIndex[0] = e - 1), !0);
  }
  removeValues(e, n) {
    e = ut(e), n = ut(n);
    const i = this.values, r = this.prefixSum;
    if (e >= i.length)
      return !1;
    const s = i.length - e;
    return n >= s && (n = s), n === 0 ? !1 : (this.values = new Uint32Array(i.length - n), this.values.set(i.subarray(0, e), 0), this.values.set(i.subarray(e + n), e), this.prefixSum = new Uint32Array(this.values.length), e - 1 < this.prefixSumValidIndex[0] && (this.prefixSumValidIndex[0] = e - 1), this.prefixSumValidIndex[0] >= 0 && this.prefixSum.set(r.subarray(0, this.prefixSumValidIndex[0] + 1)), !0);
  }
  getTotalSum() {
    return this.values.length === 0 ? 0 : this._getPrefixSum(this.values.length - 1);
  }
  /**
   * Returns the sum of the first `index + 1` many items.
   * @returns `SUM(0 <= j <= index, values[j])`.
   */
  getPrefixSum(e) {
    return e < 0 ? 0 : (e = ut(e), this._getPrefixSum(e));
  }
  _getPrefixSum(e) {
    if (e <= this.prefixSumValidIndex[0])
      return this.prefixSum[e];
    let n = this.prefixSumValidIndex[0] + 1;
    n === 0 && (this.prefixSum[0] = this.values[0], n++), e >= this.values.length && (e = this.values.length - 1);
    for (let i = n; i <= e; i++)
      this.prefixSum[i] = this.prefixSum[i - 1] + this.values[i];
    return this.prefixSumValidIndex[0] = Math.max(this.prefixSumValidIndex[0], e), this.prefixSum[e];
  }
  getIndexOf(e) {
    e = Math.floor(e), this.getTotalSum();
    let n = 0, i = this.values.length - 1, r = 0, s = 0, a = 0;
    for (; n <= i; )
      if (r = n + (i - n) / 2 | 0, s = this.prefixSum[r], a = s - this.values[r], e < a)
        i = r - 1;
      else if (e >= s)
        n = r + 1;
      else
        break;
    return new Cc(r, e - a);
  }
}
class Cc {
  constructor(e, n) {
    this.index = e, this.remainder = n, this._prefixSumIndexOfResultBrand = void 0, this.index = e, this.remainder = n;
  }
}
class Ec {
  constructor(e, n, i, r) {
    this._uri = e, this._lines = n, this._eol = i, this._versionId = r, this._lineStarts = null, this._cachedTextValue = null;
  }
  dispose() {
    this._lines.length = 0;
  }
  get version() {
    return this._versionId;
  }
  getText() {
    return this._cachedTextValue === null && (this._cachedTextValue = this._lines.join(this._eol)), this._cachedTextValue;
  }
  onEvents(e) {
    e.eol && e.eol !== this._eol && (this._eol = e.eol, this._lineStarts = null);
    const n = e.changes;
    for (const i of n)
      this._acceptDeleteRange(i.range), this._acceptInsertText(new ne(i.range.startLineNumber, i.range.startColumn), i.text);
    this._versionId = e.versionId, this._cachedTextValue = null;
  }
  _ensureLineStarts() {
    if (!this._lineStarts) {
      const e = this._eol.length, n = this._lines.length, i = new Uint32Array(n);
      for (let r = 0; r < n; r++)
        i[r] = this._lines[r].length + e;
      this._lineStarts = new xc(i);
    }
  }
  /**
   * All changes to a line's text go through this method
   */
  _setLineText(e, n) {
    this._lines[e] = n, this._lineStarts && this._lineStarts.setValue(e, this._lines[e].length + this._eol.length);
  }
  _acceptDeleteRange(e) {
    if (e.startLineNumber === e.endLineNumber) {
      if (e.startColumn === e.endColumn)
        return;
      this._setLineText(e.startLineNumber - 1, this._lines[e.startLineNumber - 1].substring(0, e.startColumn - 1) + this._lines[e.startLineNumber - 1].substring(e.endColumn - 1));
      return;
    }
    this._setLineText(e.startLineNumber - 1, this._lines[e.startLineNumber - 1].substring(0, e.startColumn - 1) + this._lines[e.endLineNumber - 1].substring(e.endColumn - 1)), this._lines.splice(e.startLineNumber, e.endLineNumber - e.startLineNumber), this._lineStarts && this._lineStarts.removeValues(e.startLineNumber, e.endLineNumber - e.startLineNumber);
  }
  _acceptInsertText(e, n) {
    if (n.length === 0)
      return;
    const i = fu(n);
    if (i.length === 1) {
      this._setLineText(e.lineNumber - 1, this._lines[e.lineNumber - 1].substring(0, e.column - 1) + i[0] + this._lines[e.lineNumber - 1].substring(e.column - 1));
      return;
    }
    i[i.length - 1] += this._lines[e.lineNumber - 1].substring(e.column - 1), this._setLineText(e.lineNumber - 1, this._lines[e.lineNumber - 1].substring(0, e.column - 1) + i[0]);
    const r = new Uint32Array(i.length - 1);
    for (let s = 1; s < i.length; s++)
      this._lines.splice(e.lineNumber + s - 1, 0, i[s]), r[s - 1] = i[s].length + this._eol.length;
    this._lineStarts && this._lineStarts.insertValues(e.lineNumber, r);
  }
}
class Ac {
  constructor() {
    this._models = /* @__PURE__ */ Object.create(null);
  }
  getModel(e) {
    return this._models[e];
  }
  getModels() {
    const e = [];
    return Object.keys(this._models).forEach((n) => e.push(this._models[n])), e;
  }
  $acceptNewModel(e) {
    this._models[e.url] = new wc(ke.parse(e.url), e.lines, e.EOL, e.versionId);
  }
  $acceptModelChanged(e, n) {
    if (!this._models[e])
      return;
    this._models[e].onEvents(n);
  }
  $acceptRemovedModel(e) {
    this._models[e] && delete this._models[e];
  }
}
class wc extends Ec {
  get uri() {
    return this._uri;
  }
  get eol() {
    return this._eol;
  }
  getValue() {
    return this.getText();
  }
  findMatches(e) {
    const n = [];
    for (let i = 0; i < this._lines.length; i++) {
      const r = this._lines[i], s = this.offsetAt(new ne(i + 1, 1)), a = r.matchAll(e);
      for (const o of a)
        (o.index || o.index === 0) && (o.index = o.index + s), n.push(o);
    }
    return n;
  }
  getLinesContent() {
    return this._lines.slice(0);
  }
  getLineCount() {
    return this._lines.length;
  }
  getLineContent(e) {
    return this._lines[e - 1];
  }
  getWordAtPosition(e, n) {
    const i = Ui(e.column, co(n), this._lines[e.lineNumber - 1], 0);
    return i ? new H(e.lineNumber, i.startColumn, e.lineNumber, i.endColumn) : null;
  }
  words(e) {
    const n = this._lines, i = this._wordenize.bind(this);
    let r = 0, s = "", a = 0, o = [];
    return {
      *[Symbol.iterator]() {
        for (; ; )
          if (a < o.length) {
            const l = s.substring(o[a].start, o[a].end);
            a += 1, yield l;
          } else if (r < n.length)
            s = n[r], o = i(s, e), a = 0, r += 1;
          else
            break;
      }
    };
  }
  getLineWords(e, n) {
    const i = this._lines[e - 1], r = this._wordenize(i, n), s = [];
    for (const a of r)
      s.push({
        word: i.substring(a.start, a.end),
        startColumn: a.start + 1,
        endColumn: a.end + 1
      });
    return s;
  }
  _wordenize(e, n) {
    const i = [];
    let r;
    for (n.lastIndex = 0; (r = n.exec(e)) && r[0].length !== 0; )
      i.push({ start: r.index, end: r.index + r[0].length });
    return i;
  }
  getValueInRange(e) {
    if (e = this._validateRange(e), e.startLineNumber === e.endLineNumber)
      return this._lines[e.startLineNumber - 1].substring(e.startColumn - 1, e.endColumn - 1);
    const n = this._eol, i = e.startLineNumber - 1, r = e.endLineNumber - 1, s = [];
    s.push(this._lines[i].substring(e.startColumn - 1));
    for (let a = i + 1; a < r; a++)
      s.push(this._lines[a]);
    return s.push(this._lines[r].substring(0, e.endColumn - 1)), s.join(n);
  }
  offsetAt(e) {
    return e = this._validatePosition(e), this._ensureLineStarts(), this._lineStarts.getPrefixSum(e.lineNumber - 2) + (e.column - 1);
  }
  positionAt(e) {
    e = Math.floor(e), e = Math.max(0, e), this._ensureLineStarts();
    const n = this._lineStarts.getIndexOf(e), i = this._lines[n.index].length;
    return {
      lineNumber: 1 + n.index,
      column: 1 + Math.min(n.remainder, i)
    };
  }
  _validateRange(e) {
    const n = this._validatePosition({ lineNumber: e.startLineNumber, column: e.startColumn }), i = this._validatePosition({ lineNumber: e.endLineNumber, column: e.endColumn });
    return n.lineNumber !== e.startLineNumber || n.column !== e.startColumn || i.lineNumber !== e.endLineNumber || i.column !== e.endColumn ? {
      startLineNumber: n.lineNumber,
      startColumn: n.column,
      endLineNumber: i.lineNumber,
      endColumn: i.column
    } : e;
  }
  _validatePosition(e) {
    if (!ne.isIPosition(e))
      throw new Error("bad position");
    let { lineNumber: n, column: i } = e, r = !1;
    if (n < 1)
      n = 1, i = 1, r = !0;
    else if (n > this._lines.length)
      n = this._lines.length, i = this._lines[n - 1].length + 1, r = !0;
    else {
      const s = this._lines[n - 1].length + 1;
      i < 1 ? (i = 1, r = !0) : i > s && (i = s, r = !0);
    }
    return r ? { lineNumber: n, column: i } : e;
  }
}
class Lc {
  constructor() {
    this._workerTextModelSyncServer = new Ac();
  }
  dispose() {
  }
  _getModel(e) {
    return this._workerTextModelSyncServer.getModel(e);
  }
  _getModels() {
    return this._workerTextModelSyncServer.getModels();
  }
  $acceptNewModel(e) {
    this._workerTextModelSyncServer.$acceptNewModel(e);
  }
  $acceptModelChanged(e, n) {
    this._workerTextModelSyncServer.$acceptModelChanged(e, n);
  }
  $acceptRemovedModel(e) {
    this._workerTextModelSyncServer.$acceptRemovedModel(e);
  }
  async $computeUnicodeHighlights(e, n, i) {
    const r = this._getModel(e);
    return r ? Sl.computeUnicodeHighlights(r, n, i) : { ranges: [], hasMore: !1, ambiguousCharacterCount: 0, invisibleCharacterCount: 0, nonBasicAsciiCharacterCount: 0 };
  }
  async $findSectionHeaders(e, n) {
    const i = this._getModel(e);
    return i ? gc(i, n) : [];
  }
  // ---- BEGIN diff --------------------------------------------------------------------------
  async $computeDiff(e, n, i, r) {
    const s = this._getModel(e), a = this._getModel(n);
    return !s || !a ? null : Kt.computeDiff(s, a, i, r);
  }
  static computeDiff(e, n, i, r) {
    const s = r === "advanced" ? _s.getDefault() : _s.getLegacy(), a = e.getLinesContent(), o = n.getLinesContent(), l = s.computeDiff(a, o, i), c = l.changes.length > 0 ? !1 : this._modelsAreIdentical(e, n);
    function d(h) {
      return h.map((f) => [f.original.startLineNumber, f.original.endLineNumberExclusive, f.modified.startLineNumber, f.modified.endLineNumberExclusive, f.innerChanges?.map((m) => [
        m.originalRange.startLineNumber,
        m.originalRange.startColumn,
        m.originalRange.endLineNumber,
        m.originalRange.endColumn,
        m.modifiedRange.startLineNumber,
        m.modifiedRange.startColumn,
        m.modifiedRange.endLineNumber,
        m.modifiedRange.endColumn
      ])]);
    }
    return {
      identical: c,
      quitEarly: l.hitTimeout,
      changes: d(l.changes),
      moves: l.moves.map((h) => [
        h.lineRangeMapping.original.startLineNumber,
        h.lineRangeMapping.original.endLineNumberExclusive,
        h.lineRangeMapping.modified.startLineNumber,
        h.lineRangeMapping.modified.endLineNumberExclusive,
        d(h.changes)
      ])
    };
  }
  static _modelsAreIdentical(e, n) {
    const i = e.getLineCount(), r = n.getLineCount();
    if (i !== r)
      return !1;
    for (let s = 1; s <= i; s++) {
      const a = e.getLineContent(s), o = n.getLineContent(s);
      if (a !== o)
        return !1;
    }
    return !0;
  }
  static {
    this._diffLimit = 1e5;
  }
  async $computeMoreMinimalEdits(e, n, i) {
    const r = this._getModel(e);
    if (!r)
      return n;
    const s = [];
    let a;
    n = n.slice(0).sort((l, c) => {
      if (l.range && c.range)
        return H.compareRangesUsingStarts(l.range, c.range);
      const d = l.range ? 0 : 1, h = c.range ? 0 : 1;
      return d - h;
    });
    let o = 0;
    for (let l = 1; l < n.length; l++)
      H.getEndPosition(n[o].range).equals(H.getStartPosition(n[l].range)) ? (n[o].range = H.fromPositions(H.getStartPosition(n[o].range), H.getEndPosition(n[l].range)), n[o].text += n[l].text) : (o++, n[o] = n[l]);
    n.length = o + 1;
    for (let { range: l, text: c, eol: d } of n) {
      if (typeof d == "number" && (a = d), H.isEmpty(l) && !c)
        continue;
      const h = r.getValueInRange(l);
      if (c = c.replace(/\r\n|\n|\r/g, r.eol), h === c)
        continue;
      if (Math.max(c.length, h.length) > Kt._diffLimit) {
        s.push({ range: l, text: c });
        continue;
      }
      const f = Yu(h, c, i), m = r.offsetAt(H.lift(l).getStartPosition());
      for (const b of f) {
        const D = r.positionAt(m + b.originalStart), E = r.positionAt(m + b.originalStart + b.originalLength), L = {
          text: c.substr(b.modifiedStart, b.modifiedLength),
          range: { startLineNumber: D.lineNumber, startColumn: D.column, endLineNumber: E.lineNumber, endColumn: E.column }
        };
        r.getValueInRange(L.range) !== L.text && s.push(L);
      }
    }
    return typeof a == "number" && s.push({ eol: a, text: "", range: { startLineNumber: 0, startColumn: 0, endLineNumber: 0, endColumn: 0 } }), s;
  }
  // ---- END minimal edits ---------------------------------------------------------------
  async $computeLinks(e) {
    const n = this._getModel(e);
    return n ? nl(n) : null;
  }
  // --- BEGIN default document colors -----------------------------------------------------------
  async $computeDefaultDocumentColors(e) {
    const n = this._getModel(e);
    return n ? fc(n) : null;
  }
  static {
    this._suggestionsLimit = 1e4;
  }
  async $textualSuggest(e, n, i, r) {
    const s = new Sn(), a = new RegExp(i, r), o = /* @__PURE__ */ new Set();
    e: for (const l of e) {
      const c = this._getModel(l);
      if (c) {
        for (const d of c.words(a))
          if (!(d === n || !isNaN(Number(d))) && (o.add(d), o.size > Kt._suggestionsLimit))
            break e;
      }
    }
    return { words: Array.from(o), duration: s.elapsed() };
  }
  // ---- END suggest --------------------------------------------------------------------------
  //#region -- word ranges --
  async $computeWordRanges(e, n, i, r) {
    const s = this._getModel(e);
    if (!s)
      return /* @__PURE__ */ Object.create(null);
    const a = new RegExp(i, r), o = /* @__PURE__ */ Object.create(null);
    for (let l = n.startLineNumber; l < n.endLineNumber; l++) {
      const c = s.getLineWords(l, a);
      for (const d of c) {
        if (!isNaN(Number(d.word)))
          continue;
        let h = o[d.word];
        h || (h = [], o[d.word] = h), h.push({
          startLineNumber: l,
          startColumn: d.startColumn,
          endLineNumber: l,
          endColumn: d.endColumn
        });
      }
    }
    return o;
  }
  //#endregion
  async $navigateValueSet(e, n, i, r, s) {
    const a = this._getModel(e);
    if (!a)
      return null;
    const o = new RegExp(r, s);
    n.startColumn === n.endColumn && (n = {
      startLineNumber: n.startLineNumber,
      startColumn: n.startColumn,
      endLineNumber: n.endLineNumber,
      endColumn: n.endColumn + 1
    });
    const l = a.getValueInRange(n), c = a.getWordAtPosition({ lineNumber: n.startLineNumber, column: n.startColumn }, o);
    if (!c)
      return null;
    const d = a.getValueInRange(c);
    return Pi.INSTANCE.navigateValueSet(n, l, c, d, i);
  }
}
class Kt extends Lc {
  constructor(e, n) {
    super(), this._host = e, this._foreignModuleFactory = n, this._foreignModule = null;
  }
  async $ping() {
    return "pong";
  }
  // ---- BEGIN foreign module support --------------------------------------------------------------------------
  $loadForeignModule(e, n, i) {
    const a = {
      host: Cl(i, (o, l) => this._host.$fhr(o, l)),
      getMirrorModels: () => this._getModels()
    };
    return this._foreignModuleFactory ? (this._foreignModule = this._foreignModuleFactory(a, n), Promise.resolve(os(this._foreignModule))) : new Promise((o, l) => {
      const c = (d) => {
        this._foreignModule = d.create(a, n), o(os(this._foreignModule));
      };
      import(`${no.asBrowserUri(`${e}.js`).toString(!0)}`).then(c).catch(l);
    });
  }
  // foreign method request
  $fmr(e, n) {
    if (!this._foreignModule || typeof this._foreignModule[e] != "function")
      return Promise.reject(new Error("Missing requestHandler or method: " + e));
    try {
      return Promise.resolve(this._foreignModule[e].apply(this._foreignModule, n));
    } catch (i) {
      return Promise.reject(i);
    }
  }
}
typeof importScripts == "function" && (globalThis.monaco = ml());
let ci = !1;
function bo(t) {
  if (ci)
    return;
  ci = !0;
  const e = new Xu((n) => {
    globalThis.postMessage(n);
  }, (n) => new Kt(fn.getChannel(n), t));
  globalThis.onmessage = (n) => {
    e.onmessage(n.data);
  };
}
globalThis.onmessage = (t) => {
  ci || bo(null);
};
var ks;
(function(t) {
  function e(n) {
    return typeof n == "string";
  }
  t.is = e;
})(ks || (ks = {}));
var hi;
(function(t) {
  function e(n) {
    return typeof n == "string";
  }
  t.is = e;
})(hi || (hi = {}));
var Bs;
(function(t) {
  t.MIN_VALUE = -2147483648, t.MAX_VALUE = 2147483647;
  function e(n) {
    return typeof n == "number" && t.MIN_VALUE <= n && n <= t.MAX_VALUE;
  }
  t.is = e;
})(Bs || (Bs = {}));
var bn;
(function(t) {
  t.MIN_VALUE = 0, t.MAX_VALUE = 2147483647;
  function e(n) {
    return typeof n == "number" && t.MIN_VALUE <= n && n <= t.MAX_VALUE;
  }
  t.is = e;
})(bn || (bn = {}));
var ye;
(function(t) {
  function e(i, r) {
    return i === Number.MAX_VALUE && (i = bn.MAX_VALUE), r === Number.MAX_VALUE && (r = bn.MAX_VALUE), { line: i, character: r };
  }
  t.create = e;
  function n(i) {
    let r = i;
    return p.objectLiteral(r) && p.uinteger(r.line) && p.uinteger(r.character);
  }
  t.is = n;
})(ye || (ye = {}));
var se;
(function(t) {
  function e(i, r, s, a) {
    if (p.uinteger(i) && p.uinteger(r) && p.uinteger(s) && p.uinteger(a))
      return { start: ye.create(i, r), end: ye.create(s, a) };
    if (ye.is(i) && ye.is(r))
      return { start: i, end: r };
    throw new Error(`Range#create called with invalid arguments[${i}, ${r}, ${s}, ${a}]`);
  }
  t.create = e;
  function n(i) {
    let r = i;
    return p.objectLiteral(r) && ye.is(r.start) && ye.is(r.end);
  }
  t.is = n;
})(se || (se = {}));
var Dn;
(function(t) {
  function e(i, r) {
    return { uri: i, range: r };
  }
  t.create = e;
  function n(i) {
    let r = i;
    return p.objectLiteral(r) && se.is(r.range) && (p.string(r.uri) || p.undefined(r.uri));
  }
  t.is = n;
})(Dn || (Dn = {}));
var Is;
(function(t) {
  function e(i, r, s, a) {
    return { targetUri: i, targetRange: r, targetSelectionRange: s, originSelectionRange: a };
  }
  t.create = e;
  function n(i) {
    let r = i;
    return p.objectLiteral(r) && se.is(r.targetRange) && p.string(r.targetUri) && se.is(r.targetSelectionRange) && (se.is(r.originSelectionRange) || p.undefined(r.originSelectionRange));
  }
  t.is = n;
})(Is || (Is = {}));
var di;
(function(t) {
  function e(i, r, s, a) {
    return {
      red: i,
      green: r,
      blue: s,
      alpha: a
    };
  }
  t.create = e;
  function n(i) {
    const r = i;
    return p.objectLiteral(r) && p.numberRange(r.red, 0, 1) && p.numberRange(r.green, 0, 1) && p.numberRange(r.blue, 0, 1) && p.numberRange(r.alpha, 0, 1);
  }
  t.is = n;
})(di || (di = {}));
var Rs;
(function(t) {
  function e(i, r) {
    return {
      range: i,
      color: r
    };
  }
  t.create = e;
  function n(i) {
    const r = i;
    return p.objectLiteral(r) && se.is(r.range) && di.is(r.color);
  }
  t.is = n;
})(Rs || (Rs = {}));
var Ms;
(function(t) {
  function e(i, r, s) {
    return {
      label: i,
      textEdit: r,
      additionalTextEdits: s
    };
  }
  t.create = e;
  function n(i) {
    const r = i;
    return p.objectLiteral(r) && p.string(r.label) && (p.undefined(r.textEdit) || Ct.is(r)) && (p.undefined(r.additionalTextEdits) || p.typedArray(r.additionalTextEdits, Ct.is));
  }
  t.is = n;
})(Ms || (Ms = {}));
var Ps;
(function(t) {
  t.Comment = "comment", t.Imports = "imports", t.Region = "region";
})(Ps || (Ps = {}));
var Ts;
(function(t) {
  function e(i, r, s, a, o, l) {
    const c = {
      startLine: i,
      endLine: r
    };
    return p.defined(s) && (c.startCharacter = s), p.defined(a) && (c.endCharacter = a), p.defined(o) && (c.kind = o), p.defined(l) && (c.collapsedText = l), c;
  }
  t.create = e;
  function n(i) {
    const r = i;
    return p.objectLiteral(r) && p.uinteger(r.startLine) && p.uinteger(r.startLine) && (p.undefined(r.startCharacter) || p.uinteger(r.startCharacter)) && (p.undefined(r.endCharacter) || p.uinteger(r.endCharacter)) && (p.undefined(r.kind) || p.string(r.kind));
  }
  t.is = n;
})(Ts || (Ts = {}));
var fi;
(function(t) {
  function e(i, r) {
    return {
      location: i,
      message: r
    };
  }
  t.create = e;
  function n(i) {
    let r = i;
    return p.defined(r) && Dn.is(r.location) && p.string(r.message);
  }
  t.is = n;
})(fi || (fi = {}));
var ce;
(function(t) {
  t.Error = 1, t.Warning = 2, t.Information = 3, t.Hint = 4;
})(ce || (ce = {}));
var Us;
(function(t) {
  t.Unnecessary = 1, t.Deprecated = 2;
})(Us || (Us = {}));
var Vs;
(function(t) {
  function e(n) {
    const i = n;
    return p.objectLiteral(i) && p.string(i.href);
  }
  t.is = e;
})(Vs || (Vs = {}));
var xn;
(function(t) {
  function e(i, r, s, a, o, l) {
    let c = { range: i, message: r };
    return p.defined(s) && (c.severity = s), p.defined(a) && (c.code = a), p.defined(o) && (c.source = o), p.defined(l) && (c.relatedInformation = l), c;
  }
  t.create = e;
  function n(i) {
    var r;
    let s = i;
    return p.defined(s) && se.is(s.range) && p.string(s.message) && (p.number(s.severity) || p.undefined(s.severity)) && (p.integer(s.code) || p.string(s.code) || p.undefined(s.code)) && (p.undefined(s.codeDescription) || p.string((r = s.codeDescription) === null || r === void 0 ? void 0 : r.href)) && (p.string(s.source) || p.undefined(s.source)) && (p.undefined(s.relatedInformation) || p.typedArray(s.relatedInformation, fi.is));
  }
  t.is = n;
})(xn || (xn = {}));
var xt;
(function(t) {
  function e(i, r, ...s) {
    let a = { title: i, command: r };
    return p.defined(s) && s.length > 0 && (a.arguments = s), a;
  }
  t.create = e;
  function n(i) {
    let r = i;
    return p.defined(r) && p.string(r.title) && p.string(r.command);
  }
  t.is = n;
})(xt || (xt = {}));
var Ct;
(function(t) {
  function e(s, a) {
    return { range: s, newText: a };
  }
  t.replace = e;
  function n(s, a) {
    return { range: { start: s, end: s }, newText: a };
  }
  t.insert = n;
  function i(s) {
    return { range: s, newText: "" };
  }
  t.del = i;
  function r(s) {
    const a = s;
    return p.objectLiteral(a) && p.string(a.newText) && se.is(a.range);
  }
  t.is = r;
})(Ct || (Ct = {}));
var mi;
(function(t) {
  function e(i, r, s) {
    const a = { label: i };
    return r !== void 0 && (a.needsConfirmation = r), s !== void 0 && (a.description = s), a;
  }
  t.create = e;
  function n(i) {
    const r = i;
    return p.objectLiteral(r) && p.string(r.label) && (p.boolean(r.needsConfirmation) || r.needsConfirmation === void 0) && (p.string(r.description) || r.description === void 0);
  }
  t.is = n;
})(mi || (mi = {}));
var Et;
(function(t) {
  function e(n) {
    const i = n;
    return p.string(i);
  }
  t.is = e;
})(Et || (Et = {}));
var $s;
(function(t) {
  function e(s, a, o) {
    return { range: s, newText: a, annotationId: o };
  }
  t.replace = e;
  function n(s, a, o) {
    return { range: { start: s, end: s }, newText: a, annotationId: o };
  }
  t.insert = n;
  function i(s, a) {
    return { range: s, newText: "", annotationId: a };
  }
  t.del = i;
  function r(s) {
    const a = s;
    return Ct.is(a) && (mi.is(a.annotationId) || Et.is(a.annotationId));
  }
  t.is = r;
})($s || ($s = {}));
var gi;
(function(t) {
  function e(i, r) {
    return { textDocument: i, edits: r };
  }
  t.create = e;
  function n(i) {
    let r = i;
    return p.defined(r) && Ci.is(r.textDocument) && Array.isArray(r.edits);
  }
  t.is = n;
})(gi || (gi = {}));
var pi;
(function(t) {
  function e(i, r, s) {
    let a = {
      kind: "create",
      uri: i
    };
    return r !== void 0 && (r.overwrite !== void 0 || r.ignoreIfExists !== void 0) && (a.options = r), s !== void 0 && (a.annotationId = s), a;
  }
  t.create = e;
  function n(i) {
    let r = i;
    return r && r.kind === "create" && p.string(r.uri) && (r.options === void 0 || (r.options.overwrite === void 0 || p.boolean(r.options.overwrite)) && (r.options.ignoreIfExists === void 0 || p.boolean(r.options.ignoreIfExists))) && (r.annotationId === void 0 || Et.is(r.annotationId));
  }
  t.is = n;
})(pi || (pi = {}));
var bi;
(function(t) {
  function e(i, r, s, a) {
    let o = {
      kind: "rename",
      oldUri: i,
      newUri: r
    };
    return s !== void 0 && (s.overwrite !== void 0 || s.ignoreIfExists !== void 0) && (o.options = s), a !== void 0 && (o.annotationId = a), o;
  }
  t.create = e;
  function n(i) {
    let r = i;
    return r && r.kind === "rename" && p.string(r.oldUri) && p.string(r.newUri) && (r.options === void 0 || (r.options.overwrite === void 0 || p.boolean(r.options.overwrite)) && (r.options.ignoreIfExists === void 0 || p.boolean(r.options.ignoreIfExists))) && (r.annotationId === void 0 || Et.is(r.annotationId));
  }
  t.is = n;
})(bi || (bi = {}));
var Di;
(function(t) {
  function e(i, r, s) {
    let a = {
      kind: "delete",
      uri: i
    };
    return r !== void 0 && (r.recursive !== void 0 || r.ignoreIfNotExists !== void 0) && (a.options = r), s !== void 0 && (a.annotationId = s), a;
  }
  t.create = e;
  function n(i) {
    let r = i;
    return r && r.kind === "delete" && p.string(r.uri) && (r.options === void 0 || (r.options.recursive === void 0 || p.boolean(r.options.recursive)) && (r.options.ignoreIfNotExists === void 0 || p.boolean(r.options.ignoreIfNotExists))) && (r.annotationId === void 0 || Et.is(r.annotationId));
  }
  t.is = n;
})(Di || (Di = {}));
var xi;
(function(t) {
  function e(n) {
    let i = n;
    return i && (i.changes !== void 0 || i.documentChanges !== void 0) && (i.documentChanges === void 0 || i.documentChanges.every((r) => p.string(r.kind) ? pi.is(r) || bi.is(r) || Di.is(r) : gi.is(r)));
  }
  t.is = e;
})(xi || (xi = {}));
var qs;
(function(t) {
  function e(i) {
    return { uri: i };
  }
  t.create = e;
  function n(i) {
    let r = i;
    return p.defined(r) && p.string(r.uri);
  }
  t.is = n;
})(qs || (qs = {}));
var zs;
(function(t) {
  function e(i, r) {
    return { uri: i, version: r };
  }
  t.create = e;
  function n(i) {
    let r = i;
    return p.defined(r) && p.string(r.uri) && p.integer(r.version);
  }
  t.is = n;
})(zs || (zs = {}));
var Ci;
(function(t) {
  function e(i, r) {
    return { uri: i, version: r };
  }
  t.create = e;
  function n(i) {
    let r = i;
    return p.defined(r) && p.string(r.uri) && (r.version === null || p.integer(r.version));
  }
  t.is = n;
})(Ci || (Ci = {}));
var Ws;
(function(t) {
  function e(i, r, s, a) {
    return { uri: i, languageId: r, version: s, text: a };
  }
  t.create = e;
  function n(i) {
    let r = i;
    return p.defined(r) && p.string(r.uri) && p.string(r.languageId) && p.integer(r.version) && p.string(r.text);
  }
  t.is = n;
})(Ws || (Ws = {}));
var Cn;
(function(t) {
  t.PlainText = "plaintext", t.Markdown = "markdown";
  function e(n) {
    const i = n;
    return i === t.PlainText || i === t.Markdown;
  }
  t.is = e;
})(Cn || (Cn = {}));
var Mt;
(function(t) {
  function e(n) {
    const i = n;
    return p.objectLiteral(n) && Cn.is(i.kind) && p.string(i.value);
  }
  t.is = e;
})(Mt || (Mt = {}));
var re;
(function(t) {
  t.Text = 1, t.Method = 2, t.Function = 3, t.Constructor = 4, t.Field = 5, t.Variable = 6, t.Class = 7, t.Interface = 8, t.Module = 9, t.Property = 10, t.Unit = 11, t.Value = 12, t.Enum = 13, t.Keyword = 14, t.Snippet = 15, t.Color = 16, t.File = 17, t.Reference = 18, t.Folder = 19, t.EnumMember = 20, t.Constant = 21, t.Struct = 22, t.Event = 23, t.Operator = 24, t.TypeParameter = 25;
})(re || (re = {}));
var me;
(function(t) {
  t.PlainText = 1, t.Snippet = 2;
})(me || (me = {}));
var Os;
(function(t) {
  t.Deprecated = 1;
})(Os || (Os = {}));
var Hs;
(function(t) {
  function e(i, r, s) {
    return { newText: i, insert: r, replace: s };
  }
  t.create = e;
  function n(i) {
    const r = i;
    return r && p.string(r.newText) && se.is(r.insert) && se.is(r.replace);
  }
  t.is = n;
})(Hs || (Hs = {}));
var ge;
(function(t) {
  t.asIs = 1, t.adjustIndentation = 2;
})(ge || (ge = {}));
var js;
(function(t) {
  function e(n) {
    const i = n;
    return i && (p.string(i.detail) || i.detail === void 0) && (p.string(i.description) || i.description === void 0);
  }
  t.is = e;
})(js || (js = {}));
var Gs;
(function(t) {
  function e(n) {
    return { label: n };
  }
  t.create = e;
})(Gs || (Gs = {}));
var Xs;
(function(t) {
  function e(n, i) {
    return { items: n || [], isIncomplete: !!i };
  }
  t.create = e;
})(Xs || (Xs = {}));
var En;
(function(t) {
  function e(i) {
    return i.replace(/[\\`*_{}[\]()#+\-.!]/g, "\\$&");
  }
  t.fromPlainText = e;
  function n(i) {
    const r = i;
    return p.string(r) || p.objectLiteral(r) && p.string(r.language) && p.string(r.value);
  }
  t.is = n;
})(En || (En = {}));
var Js;
(function(t) {
  function e(n) {
    let i = n;
    return !!i && p.objectLiteral(i) && (Mt.is(i.contents) || En.is(i.contents) || p.typedArray(i.contents, En.is)) && (n.range === void 0 || se.is(n.range));
  }
  t.is = e;
})(Js || (Js = {}));
var Qs;
(function(t) {
  function e(n, i) {
    return i ? { label: n, documentation: i } : { label: n };
  }
  t.create = e;
})(Qs || (Qs = {}));
var Ys;
(function(t) {
  function e(n, i, ...r) {
    let s = { label: n };
    return p.defined(i) && (s.documentation = i), p.defined(r) ? s.parameters = r : s.parameters = [], s;
  }
  t.create = e;
})(Ys || (Ys = {}));
var Zs;
(function(t) {
  t.Text = 1, t.Read = 2, t.Write = 3;
})(Zs || (Zs = {}));
var Ks;
(function(t) {
  function e(n, i) {
    let r = { range: n };
    return p.number(i) && (r.kind = i), r;
  }
  t.create = e;
})(Ks || (Ks = {}));
var ea;
(function(t) {
  t.File = 1, t.Module = 2, t.Namespace = 3, t.Package = 4, t.Class = 5, t.Method = 6, t.Property = 7, t.Field = 8, t.Constructor = 9, t.Enum = 10, t.Interface = 11, t.Function = 12, t.Variable = 13, t.Constant = 14, t.String = 15, t.Number = 16, t.Boolean = 17, t.Array = 18, t.Object = 19, t.Key = 20, t.Null = 21, t.EnumMember = 22, t.Struct = 23, t.Event = 24, t.Operator = 25, t.TypeParameter = 26;
})(ea || (ea = {}));
var ta;
(function(t) {
  t.Deprecated = 1;
})(ta || (ta = {}));
var na;
(function(t) {
  function e(n, i, r, s, a) {
    let o = {
      name: n,
      kind: i,
      location: { uri: s, range: r }
    };
    return a && (o.containerName = a), o;
  }
  t.create = e;
})(na || (na = {}));
var ia;
(function(t) {
  function e(n, i, r, s) {
    return s !== void 0 ? { name: n, kind: i, location: { uri: r, range: s } } : { name: n, kind: i, location: { uri: r } };
  }
  t.create = e;
})(ia || (ia = {}));
var ra;
(function(t) {
  function e(i, r, s, a, o, l) {
    let c = {
      name: i,
      detail: r,
      kind: s,
      range: a,
      selectionRange: o
    };
    return l !== void 0 && (c.children = l), c;
  }
  t.create = e;
  function n(i) {
    let r = i;
    return r && p.string(r.name) && p.number(r.kind) && se.is(r.range) && se.is(r.selectionRange) && (r.detail === void 0 || p.string(r.detail)) && (r.deprecated === void 0 || p.boolean(r.deprecated)) && (r.children === void 0 || Array.isArray(r.children)) && (r.tags === void 0 || Array.isArray(r.tags));
  }
  t.is = n;
})(ra || (ra = {}));
var sa;
(function(t) {
  t.Empty = "", t.QuickFix = "quickfix", t.Refactor = "refactor", t.RefactorExtract = "refactor.extract", t.RefactorInline = "refactor.inline", t.RefactorRewrite = "refactor.rewrite", t.Source = "source", t.SourceOrganizeImports = "source.organizeImports", t.SourceFixAll = "source.fixAll";
})(sa || (sa = {}));
var An;
(function(t) {
  t.Invoked = 1, t.Automatic = 2;
})(An || (An = {}));
var aa;
(function(t) {
  function e(i, r, s) {
    let a = { diagnostics: i };
    return r != null && (a.only = r), s != null && (a.triggerKind = s), a;
  }
  t.create = e;
  function n(i) {
    let r = i;
    return p.defined(r) && p.typedArray(r.diagnostics, xn.is) && (r.only === void 0 || p.typedArray(r.only, p.string)) && (r.triggerKind === void 0 || r.triggerKind === An.Invoked || r.triggerKind === An.Automatic);
  }
  t.is = n;
})(aa || (aa = {}));
var oa;
(function(t) {
  function e(i, r, s) {
    let a = { title: i }, o = !0;
    return typeof r == "string" ? (o = !1, a.kind = r) : xt.is(r) ? a.command = r : a.edit = r, o && s !== void 0 && (a.kind = s), a;
  }
  t.create = e;
  function n(i) {
    let r = i;
    return r && p.string(r.title) && (r.diagnostics === void 0 || p.typedArray(r.diagnostics, xn.is)) && (r.kind === void 0 || p.string(r.kind)) && (r.edit !== void 0 || r.command !== void 0) && (r.command === void 0 || xt.is(r.command)) && (r.isPreferred === void 0 || p.boolean(r.isPreferred)) && (r.edit === void 0 || xi.is(r.edit));
  }
  t.is = n;
})(oa || (oa = {}));
var ua;
(function(t) {
  function e(i, r) {
    let s = { range: i };
    return p.defined(r) && (s.data = r), s;
  }
  t.create = e;
  function n(i) {
    let r = i;
    return p.defined(r) && se.is(r.range) && (p.undefined(r.command) || xt.is(r.command));
  }
  t.is = n;
})(ua || (ua = {}));
var la;
(function(t) {
  function e(i, r) {
    return { tabSize: i, insertSpaces: r };
  }
  t.create = e;
  function n(i) {
    let r = i;
    return p.defined(r) && p.uinteger(r.tabSize) && p.boolean(r.insertSpaces);
  }
  t.is = n;
})(la || (la = {}));
var ca;
(function(t) {
  function e(i, r, s) {
    return { range: i, target: r, data: s };
  }
  t.create = e;
  function n(i) {
    let r = i;
    return p.defined(r) && se.is(r.range) && (p.undefined(r.target) || p.string(r.target));
  }
  t.is = n;
})(ca || (ca = {}));
var ha;
(function(t) {
  function e(i, r) {
    return { range: i, parent: r };
  }
  t.create = e;
  function n(i) {
    let r = i;
    return p.objectLiteral(r) && se.is(r.range) && (r.parent === void 0 || t.is(r.parent));
  }
  t.is = n;
})(ha || (ha = {}));
var da;
(function(t) {
  t.namespace = "namespace", t.type = "type", t.class = "class", t.enum = "enum", t.interface = "interface", t.struct = "struct", t.typeParameter = "typeParameter", t.parameter = "parameter", t.variable = "variable", t.property = "property", t.enumMember = "enumMember", t.event = "event", t.function = "function", t.method = "method", t.macro = "macro", t.keyword = "keyword", t.modifier = "modifier", t.comment = "comment", t.string = "string", t.number = "number", t.regexp = "regexp", t.operator = "operator", t.decorator = "decorator";
})(da || (da = {}));
var fa;
(function(t) {
  t.declaration = "declaration", t.definition = "definition", t.readonly = "readonly", t.static = "static", t.deprecated = "deprecated", t.abstract = "abstract", t.async = "async", t.modification = "modification", t.documentation = "documentation", t.defaultLibrary = "defaultLibrary";
})(fa || (fa = {}));
var ma;
(function(t) {
  function e(n) {
    const i = n;
    return p.objectLiteral(i) && (i.resultId === void 0 || typeof i.resultId == "string") && Array.isArray(i.data) && (i.data.length === 0 || typeof i.data[0] == "number");
  }
  t.is = e;
})(ma || (ma = {}));
var ga;
(function(t) {
  function e(i, r) {
    return { range: i, text: r };
  }
  t.create = e;
  function n(i) {
    const r = i;
    return r != null && se.is(r.range) && p.string(r.text);
  }
  t.is = n;
})(ga || (ga = {}));
var pa;
(function(t) {
  function e(i, r, s) {
    return { range: i, variableName: r, caseSensitiveLookup: s };
  }
  t.create = e;
  function n(i) {
    const r = i;
    return r != null && se.is(r.range) && p.boolean(r.caseSensitiveLookup) && (p.string(r.variableName) || r.variableName === void 0);
  }
  t.is = n;
})(pa || (pa = {}));
var ba;
(function(t) {
  function e(i, r) {
    return { range: i, expression: r };
  }
  t.create = e;
  function n(i) {
    const r = i;
    return r != null && se.is(r.range) && (p.string(r.expression) || r.expression === void 0);
  }
  t.is = n;
})(ba || (ba = {}));
var Da;
(function(t) {
  function e(i, r) {
    return { frameId: i, stoppedLocation: r };
  }
  t.create = e;
  function n(i) {
    const r = i;
    return p.defined(r) && se.is(i.stoppedLocation);
  }
  t.is = n;
})(Da || (Da = {}));
var Ei;
(function(t) {
  t.Type = 1, t.Parameter = 2;
  function e(n) {
    return n === 1 || n === 2;
  }
  t.is = e;
})(Ei || (Ei = {}));
var Ai;
(function(t) {
  function e(i) {
    return { value: i };
  }
  t.create = e;
  function n(i) {
    const r = i;
    return p.objectLiteral(r) && (r.tooltip === void 0 || p.string(r.tooltip) || Mt.is(r.tooltip)) && (r.location === void 0 || Dn.is(r.location)) && (r.command === void 0 || xt.is(r.command));
  }
  t.is = n;
})(Ai || (Ai = {}));
var xa;
(function(t) {
  function e(i, r, s) {
    const a = { position: i, label: r };
    return s !== void 0 && (a.kind = s), a;
  }
  t.create = e;
  function n(i) {
    const r = i;
    return p.objectLiteral(r) && ye.is(r.position) && (p.string(r.label) || p.typedArray(r.label, Ai.is)) && (r.kind === void 0 || Ei.is(r.kind)) && r.textEdits === void 0 || p.typedArray(r.textEdits, Ct.is) && (r.tooltip === void 0 || p.string(r.tooltip) || Mt.is(r.tooltip)) && (r.paddingLeft === void 0 || p.boolean(r.paddingLeft)) && (r.paddingRight === void 0 || p.boolean(r.paddingRight));
  }
  t.is = n;
})(xa || (xa = {}));
var Ca;
(function(t) {
  function e(n) {
    return { kind: "snippet", value: n };
  }
  t.createSnippet = e;
})(Ca || (Ca = {}));
var Ea;
(function(t) {
  function e(n, i, r, s) {
    return { insertText: n, filterText: i, range: r, command: s };
  }
  t.create = e;
})(Ea || (Ea = {}));
var Aa;
(function(t) {
  function e(n) {
    return { items: n };
  }
  t.create = e;
})(Aa || (Aa = {}));
var wa;
(function(t) {
  t.Invoked = 0, t.Automatic = 1;
})(wa || (wa = {}));
var La;
(function(t) {
  function e(n, i) {
    return { range: n, text: i };
  }
  t.create = e;
})(La || (La = {}));
var va;
(function(t) {
  function e(n, i) {
    return { triggerKind: n, selectedCompletionInfo: i };
  }
  t.create = e;
})(va || (va = {}));
var _a;
(function(t) {
  function e(n) {
    const i = n;
    return p.objectLiteral(i) && hi.is(i.uri) && p.string(i.name);
  }
  t.is = e;
})(_a || (_a = {}));
var Fa;
(function(t) {
  function e(s, a, o, l) {
    return new vc(s, a, o, l);
  }
  t.create = e;
  function n(s) {
    let a = s;
    return !!(p.defined(a) && p.string(a.uri) && (p.undefined(a.languageId) || p.string(a.languageId)) && p.uinteger(a.lineCount) && p.func(a.getText) && p.func(a.positionAt) && p.func(a.offsetAt));
  }
  t.is = n;
  function i(s, a) {
    let o = s.getText(), l = r(a, (d, h) => {
      let f = d.range.start.line - h.range.start.line;
      return f === 0 ? d.range.start.character - h.range.start.character : f;
    }), c = o.length;
    for (let d = l.length - 1; d >= 0; d--) {
      let h = l[d], f = s.offsetAt(h.range.start), m = s.offsetAt(h.range.end);
      if (m <= c)
        o = o.substring(0, f) + h.newText + o.substring(m, o.length);
      else
        throw new Error("Overlapping edit");
      c = f;
    }
    return o;
  }
  t.applyEdits = i;
  function r(s, a) {
    if (s.length <= 1)
      return s;
    const o = s.length / 2 | 0, l = s.slice(0, o), c = s.slice(o);
    r(l, a), r(c, a);
    let d = 0, h = 0, f = 0;
    for (; d < l.length && h < c.length; )
      a(l[d], c[h]) <= 0 ? s[f++] = l[d++] : s[f++] = c[h++];
    for (; d < l.length; )
      s[f++] = l[d++];
    for (; h < c.length; )
      s[f++] = c[h++];
    return s;
  }
})(Fa || (Fa = {}));
let vc = class {
  constructor(e, n, i, r) {
    this._uri = e, this._languageId = n, this._version = i, this._content = r, this._lineOffsets = void 0;
  }
  get uri() {
    return this._uri;
  }
  get languageId() {
    return this._languageId;
  }
  get version() {
    return this._version;
  }
  getText(e) {
    if (e) {
      let n = this.offsetAt(e.start), i = this.offsetAt(e.end);
      return this._content.substring(n, i);
    }
    return this._content;
  }
  update(e, n) {
    this._content = e.text, this._version = n, this._lineOffsets = void 0;
  }
  getLineOffsets() {
    if (this._lineOffsets === void 0) {
      let e = [], n = this._content, i = !0;
      for (let r = 0; r < n.length; r++) {
        i && (e.push(r), i = !1);
        let s = n.charAt(r);
        i = s === "\r" || s === `
`, s === "\r" && r + 1 < n.length && n.charAt(r + 1) === `
` && r++;
      }
      i && n.length > 0 && e.push(n.length), this._lineOffsets = e;
    }
    return this._lineOffsets;
  }
  positionAt(e) {
    e = Math.max(Math.min(e, this._content.length), 0);
    let n = this.getLineOffsets(), i = 0, r = n.length;
    if (r === 0)
      return ye.create(0, e);
    for (; i < r; ) {
      let a = Math.floor((i + r) / 2);
      n[a] > e ? r = a : i = a + 1;
    }
    let s = i - 1;
    return ye.create(s, e - n[s]);
  }
  offsetAt(e) {
    let n = this.getLineOffsets();
    if (e.line >= n.length)
      return this._content.length;
    if (e.line < 0)
      return 0;
    let i = n[e.line], r = e.line + 1 < n.length ? n[e.line + 1] : this._content.length;
    return Math.max(Math.min(i + e.character, r), i);
  }
  get lineCount() {
    return this.getLineOffsets().length;
  }
};
var p;
(function(t) {
  const e = Object.prototype.toString;
  function n(m) {
    return typeof m < "u";
  }
  t.defined = n;
  function i(m) {
    return typeof m > "u";
  }
  t.undefined = i;
  function r(m) {
    return m === !0 || m === !1;
  }
  t.boolean = r;
  function s(m) {
    return e.call(m) === "[object String]";
  }
  t.string = s;
  function a(m) {
    return e.call(m) === "[object Number]";
  }
  t.number = a;
  function o(m, b, D) {
    return e.call(m) === "[object Number]" && b <= m && m <= D;
  }
  t.numberRange = o;
  function l(m) {
    return e.call(m) === "[object Number]" && -2147483648 <= m && m <= 2147483647;
  }
  t.integer = l;
  function c(m) {
    return e.call(m) === "[object Number]" && 0 <= m && m <= 2147483647;
  }
  t.uinteger = c;
  function d(m) {
    return e.call(m) === "[object Function]";
  }
  t.func = d;
  function h(m) {
    return m !== null && typeof m == "object";
  }
  t.objectLiteral = h;
  function f(m, b) {
    return Array.isArray(m) && m.every(b);
  }
  t.typedArray = f;
})(p || (p = {}));
async function _c(t, e) {
  try {
    const n = await t, i = /* @__PURE__ */ new Map(), r = /* @__PURE__ */ new Map(), s = [], a = Fc(e);
    return n.forEach((o) => {
      const l = [];
      o.items.forEach(
        (c) => yc(l, r, i, a, c)
      ), l.length && s.push({ ...o, items: l });
    }), { categories: s, functionDefinitions: i, constantDefinitions: r };
  } catch (n) {
    return console.error(n), { categories: [], functionDefinitions: /* @__PURE__ */ new Map(), constantDefinitions: /* @__PURE__ */ new Map() };
  }
}
function Fc(t) {
  const { profile: { apiVersion: e, bundles: n, hiddenApiItems: i = [] } = {} } = t, r = Do(e), s = Array.isArray(n) && n.length > 0 ? /* @__PURE__ */ new Set(["core", ...n]) : void 0;
  return (a) => Nc(r, a.sinceVersion) && (!s || s.has(a.bundle)) && !i.includes(a.name);
}
function yc(t, e, n, i, r) {
  if (Array.isArray(r)) {
    r.forEach(
      (s) => ya(t, n, i, s)
    );
    return;
  }
  r.type === "constant" ? Sc(t, e, i, r) : ya(t, n, i, r);
}
function ya(t, e, n, i) {
  if (!n(i))
    return;
  i.disableDocumentation || t.push(i);
  const {
    completion: { label: r }
  } = i, s = r.toLowerCase();
  let a = e.get(s);
  a || (a = {
    type: "functionDefinition",
    key: s,
    overloads: []
  }, e.set(s, a)), a.overloads.push(i);
}
function Sc(t, e, n, i) {
  if (!n(i))
    return;
  t.push(i);
  const {
    completion: { label: r }
  } = i, s = r.toLowerCase();
  e.set(s, i);
  const [a, o] = i.completion.label.split(".");
  if (!o)
    return;
  const l = a.toLowerCase();
  let c = e.get(l);
  c || (c = {
    type: "namespace",
    key: l,
    members: [],
    completion: {
      label: a,
      detail: a,
      insertText: a,
      insertTextMode: ge.adjustIndentation,
      insertTextFormat: me.PlainText,
      kind: re.Enum
    }
  }, e.set(l, c));
  const d = structuredClone(i);
  d.name = o, d.completion.label = o, d.completion.insertText = o, d.completion.kind = re.Constant, c.members.push(d), c.completion.documentation = c.members.reduce(
    (h, f) => (h.value = `${h.value}${h.value ? `

` : ""}**${f.completion.label}**: ${f.description}`, h),
    { kind: Cn.Markdown, value: "" }
  );
}
function Do(t) {
  if (!t || typeof t != "string")
    return null;
  const e = t.split(".").map((r) => Number.parseInt(r));
  if (e.some(Number.isNaN))
    return console.error("Invalid API version string", t), null;
  const [n, i] = e.slice(0, 2);
  return { major: n, minor: i };
}
function Nc(t, e) {
  if (!t)
    return !0;
  const n = Do(e);
  return n ? t.major > n.major ? !1 : t.minor === void 0 || n.minor === void 0 ? !0 : n.minor <= t.minor : !0;
}
function Sa(t) {
  return !!t && t.type !== "dictionary";
}
function kc(t) {
  return t?.type === "dictionary";
}
let Bc = class {
  constructor(e) {
    this._settings = e, this.localeToApiLibraryPromiseMap = /* @__PURE__ */ new Map();
  }
  /**
   * Returns the API definitions for the given settings: definitions, constant definitions, and function definitions
   */
  async getApiDatabase(e) {
    const { locale: n = "en" } = e;
    let i = this.localeToApiLibraryPromiseMap.get(n);
    return i || (i = this._settings.getApiLibrary(n), this.localeToApiLibraryPromiseMap.set(n, i)), await _c(i, e);
  }
  /**
   * Returns the API definitions
   */
  async getApiLibrary(e) {
    const { categories: n } = await this.getApiDatabase(e);
    return n;
  }
};
const Nt = {
  False: "false",
  Null: "null",
  True: "true"
}, W = {
  Break: "break",
  Continue: "continue",
  Else: "else",
  For: "for",
  Function: "function",
  If: "if",
  Import: "import",
  Export: "export",
  In: "in",
  Return: "return",
  Var: "var",
  While: "while"
}, qn = {
  From: "from",
  Of: "of"
}, g = {
  AssignmentExpression: "AssignmentExpression",
  ArrayExpression: "ArrayExpression",
  BlockComment: "BlockComment",
  BlockStatement: "BlockStatement",
  BinaryExpression: "BinaryExpression",
  BreakStatement: "BreakStatement",
  CallExpression: "CallExpression",
  ContinueStatement: "ContinueStatement",
  EmptyStatement: "EmptyStatement",
  ExpressionStatement: "ExpressionStatement",
  ExportNamedDeclaration: "ExportNamedDeclaration",
  ForStatement: "ForStatement",
  ForInStatement: "ForInStatement",
  ForOfStatement: "ForOfStatement",
  FunctionDeclaration: "FunctionDeclaration",
  Identifier: "Identifier",
  IfStatement: "IfStatement",
  ImportDeclaration: "ImportDeclaration",
  ImportDefaultSpecifier: "ImportDefaultSpecifier",
  LineComment: "LineComment",
  Literal: "Literal",
  LogicalExpression: "LogicalExpression",
  MemberExpression: "MemberExpression",
  ObjectExpression: "ObjectExpression",
  Program: "Program",
  Property: "Property",
  ReturnStatement: "ReturnStatement",
  TemplateElement: "TemplateElement",
  TemplateLiteral: "TemplateLiteral",
  UnaryExpression: "UnaryExpression",
  UpdateExpression: "UpdateExpression",
  VariableDeclaration: "VariableDeclaration",
  VariableDeclarator: "VariableDeclarator",
  WhileStatement: "WhileStatement"
}, wi = ["++", "--"], xo = ["-", "+", "!", "~"], Co = ["=", "/=", "*=", "%=", "+=", "-="], Eo = ["||", "&&"], Ic = [
  "|",
  "&",
  ">>",
  "<<",
  ">>>",
  "^",
  "==",
  "!=",
  "<",
  "<=",
  ">",
  ">=",
  "+",
  "-",
  "*",
  "/",
  "%"
], wn = {
  "||": 1,
  "&&": 2,
  "|": 3,
  "^": 4,
  "&": 5,
  "==": 6,
  "!=": 6,
  "<": 7,
  ">": 7,
  "<=": 7,
  ">=": 7,
  "<<": 8,
  ">>": 8,
  ">>>": 8,
  "+": 9,
  "-": 9,
  "*": 10,
  "/": 10,
  "%": 10
}, S = {
  BooleanLiteral: 1,
  EOF: 2,
  Identifier: 3,
  Keyword: 4,
  NullLiteral: 5,
  NumericLiteral: 6,
  Punctuator: 7,
  StringLiteral: 8,
  Template: 10
}, Ao = [
  "Unknown",
  "Boolean",
  "<end>",
  "Identifier",
  "Keyword",
  "Null",
  "Numeric",
  "Punctuator",
  "String",
  "RegularExpression",
  "Template"
], F = {
  InvalidModuleUri: "InvalidModuleUri",
  ForInOfLoopInitializer: "ForInOfLoopInitializer",
  IdentifierExpected: "IdentifierExpected",
  InvalidEscapedReservedWord: "InvalidEscapedReservedWord",
  InvalidExpression: "InvalidExpression",
  InvalidFunctionIdentifier: "InvalidFunctionIdentifier",
  InvalidHexEscapeSequence: "InvalidHexEscapeSequence",
  InvalidLeftHandSideInAssignment: "InvalidLeftHandSideInAssignment",
  InvalidLeftHandSideInForIn: "InvalidLeftHandSideInForIn",
  InvalidTemplateHead: "InvalidTemplateHead",
  InvalidVariableAssignment: "InvalidVariableAssignment",
  KeyMustBeString: "KeyMustBeString",
  NoFunctionInsideBlock: "NoFunctionInsideBlock",
  NoFunctionInsideFunction: "NoFunctionInsideFunction",
  ModuleExportRootOnly: "ModuleExportRootOnly",
  ModuleImportRootOnly: "ModuleImportRootOnly",
  PunctuatorExpected: "PunctuatorExpected",
  TemplateOctalLiteral: "TemplateOctalLiteral",
  UnexpectedBoolean: "UnexpectedBoolean",
  UnexpectedEndOfScript: "UnexpectedEndOfScript",
  UnexpectedIdentifier: "UnexpectedIdentifier",
  UnexpectedKeyword: "UnexpectedKeyword",
  UnexpectedNull: "UnexpectedNull",
  UnexpectedNumber: "UnexpectedNumber",
  UnexpectedPunctuator: "UnexpectedPunctuator",
  UnexpectedString: "UnexpectedString",
  UnexpectedTemplate: "UnexpectedTemplate",
  UnexpectedToken: "UnexpectedToken"
}, wo = {
  [F.InvalidModuleUri]: "Module uri must be a text literal.",
  [F.ForInOfLoopInitializer]: "for-in loop variable declaration may not have an initializer.",
  [F.IdentifierExpected]: "'${value}' is an invalid identifier.",
  [F.InvalidEscapedReservedWord]: "Keyword cannot contain escaped characters.",
  [F.InvalidExpression]: "Invalid expression.",
  [F.InvalidFunctionIdentifier]: "'${value}' is an invalid function identifier.",
  [F.InvalidHexEscapeSequence]: "Invalid hexadecimal escape sequence.",
  [F.InvalidLeftHandSideInAssignment]: "Invalid left-hand side in assignment.",
  [F.InvalidLeftHandSideInForIn]: "Invalid left-hand side in for-in.",
  [F.InvalidTemplateHead]: "Invalid template structure.",
  [F.InvalidVariableAssignment]: "Invalid variable assignment.",
  [F.KeyMustBeString]: "Object property keys must be a word starting with a letter.",
  [F.NoFunctionInsideBlock]: "Functions cannot be declared inside of code blocks.",
  [F.NoFunctionInsideFunction]: "Functions cannot be declared inside another function.",
  [F.ModuleExportRootOnly]: "Module exports cannot be declared inside of code blocks.",
  [F.ModuleImportRootOnly]: "Module import cannot be declared inside of code blocks.",
  [F.PunctuatorExpected]: "'${value}' expected.",
  [F.TemplateOctalLiteral]: "Octal literals are not allowed in template literals.",
  [F.UnexpectedBoolean]: "Unexpected boolean literal.",
  [F.UnexpectedEndOfScript]: "Unexpected end of Arcade expression.",
  [F.UnexpectedIdentifier]: "Unexpected identifier.",
  [F.UnexpectedKeyword]: "Unexpected keyword.",
  [F.UnexpectedNull]: "Unexpected null literal.",
  [F.UnexpectedNumber]: "Unexpected number.",
  [F.UnexpectedPunctuator]: "Unexpected punctuator.",
  [F.UnexpectedString]: "Unexpected text literal.",
  [F.UnexpectedTemplate]: "Unexpected quasi '${value}'.",
  [F.UnexpectedToken]: "Unexpected token '${value}'."
};
class At extends Error {
  constructor({ code: e, index: n, line: i, column: r, len: s = 0, description: a, data: o }) {
    super(a ?? e), this.declaredRootClass = "esri.arcade.lib.diagnostic", this.name = "ParsingError", this.code = e, this.index = n, this.line = i, this.column = r, this.len = s, this.data = o, this.description = a, this.range = {
      start: { line: i, column: r - 1 },
      end: { line: i, column: r + s }
    }, Error.captureStackTrace?.(
      this,
      At
    );
  }
}
function Rc(t) {
  return !!t && typeof t == "object" && "type" in t && t.type === g.Program;
}
function Ie(t) {
  return !!t && typeof t == "object" && "type" in t && t.type === g.BlockStatement;
}
function Mc(t) {
  return !!t && typeof t == "object" && "type" in t && t.type === g.BlockComment;
}
function $i(t) {
  return !!t && typeof t == "object" && "type" in t && t.type === g.EmptyStatement;
}
function Pc(t) {
  return !!t && typeof t == "object" && "type" in t && t.type === g.ExpressionStatement;
}
function Na(t) {
  return !!t && typeof t == "object" && "type" in t && t.type === g.FunctionDeclaration;
}
function Li(t) {
  return !!t && typeof t == "object" && "type" in t && t.type === g.IfStatement;
}
function Ln(t) {
  return !!t && typeof t == "object" && "type" in t && t.type === g.VariableDeclaration;
}
function vn(t) {
  return !!t && typeof t == "object" && "type" in t && t.type === g.ArrayExpression;
}
function vi(t) {
  return !!t && typeof t == "object" && "type" in t && t.type === g.BinaryExpression;
}
function Ne(t) {
  return !!t && typeof t == "object" && "type" in t && t.type === g.Identifier;
}
function Lo(t) {
  return !!t && typeof t == "object" && "type" in t && t.type === g.Literal;
}
function _i(t) {
  return !!t && typeof t == "object" && "type" in t && t.type === g.LogicalExpression;
}
function ka(t) {
  return !!t && typeof t == "object" && "type" in t && t.type === g.ObjectExpression;
}
function Ba(t) {
  return !!t && typeof t == "object" && "type" in t && t.type === g.MemberExpression;
}
function Tc(t) {
  return !!t && typeof t == "object" && "type" in t && t.type === g.UnaryExpression;
}
function Uc(t) {
  return !!t && typeof t == "object" && "type" in t && t.type === g.UpdateExpression;
}
function vo(t) {
  return !!t && typeof t == "object" && "type" in t && t.type === g.VariableDeclarator;
}
function Vc(t) {
  return !!t && typeof t == "object" && "type" in t && t.type === g.Property;
}
function zn(t, e) {
  return e.loc.end.line === t.loc.start.line && e.loc.end.column <= t.loc.start.column;
}
function Ia(t, e) {
  return t.range[0] >= e.range[0] && t.range[1] <= e.range[1];
}
class $c {
  constructor() {
    this.comments = [], this._nodeStack = [], this._newComments = [];
  }
  insertInnerComments(e) {
    if (!Ie(e) || e.body.length !== 0)
      return;
    const n = [];
    for (let i = this._newComments.length - 1; i >= 0; i--) {
      const r = this._newComments[i];
      e.range[1] >= r.range[0] && (n.unshift(r), this._newComments.splice(i, 1));
    }
    n.length && (e.innerComments = n);
  }
  attachTrailingComments(e) {
    const n = this._nodeStack.at(-1);
    if (!n)
      return;
    if (Ie(e) && Ia(n, e))
      for (let r = this._newComments.length - 1; r >= 0; r--) {
        const s = this._newComments[r];
        Ia(s, e) && (n.trailingComments = [...n.trailingComments ?? [], s], this._newComments.splice(r, 1));
      }
    let i = [];
    if (this._newComments.length > 0)
      for (let r = this._newComments.length - 1; r >= 0; r--) {
        const s = this._newComments[r];
        zn(s, n) ? (n.trailingComments = [...n.trailingComments ?? [], s], this._newComments.splice(r, 1)) : zn(s, e) && (i.unshift(s), this._newComments.splice(r, 1));
      }
    if (n.trailingComments) {
      const r = n.trailingComments[0];
      zn(r, e) && (i = [...i, ...n.trailingComments], delete n.trailingComments);
    }
    i.length > 0 && (e.trailingComments = i);
  }
  attachLeadingComments(e) {
    let n;
    for (; this._nodeStack.length > 0; ) {
      const s = this._nodeStack[this._nodeStack.length - 1];
      if (e.range[0] <= s.range[0]) {
        n = s, this._nodeStack.pop();
        continue;
      }
      break;
    }
    const i = [], r = [];
    if (n != null) {
      if (!n.leadingComments)
        return;
      for (let s = n.leadingComments.length - 1; s >= 0; s--) {
        const a = n.leadingComments[s];
        if (e.range[0] >= a.range[1]) {
          i.unshift(a), n.leadingComments.splice(s, 1);
          continue;
        }
        vo(e) && !Mc(a) && (r.unshift(a), n.leadingComments.splice(s, 1));
      }
      n.leadingComments.length === 0 && delete n.leadingComments, i.length && (e.leadingComments = i), r.length && (e.trailingComments = [...r, ...e.trailingComments ?? []]);
      return;
    }
    for (let s = this._newComments.length - 1; s >= 0; s--) {
      const a = this._newComments[s];
      e.range[0] >= a.range[0] && (i.unshift(a), this._newComments.splice(s, 1));
    }
    i.length && (e.leadingComments = i);
  }
  attachComments(e) {
    if (Rc(e) && e.body.length > 0) {
      const n = this._nodeStack.at(-1);
      if (n) {
        n.trailingComments = [...n.trailingComments ?? [], ...this._newComments], this._newComments.length = 0, this._nodeStack.pop();
        return;
      }
      e.trailingComments = [...this._newComments], this._newComments.length = 0;
      return;
    }
    this.attachTrailingComments(e), this.attachLeadingComments(e), this.insertInnerComments(e), this._nodeStack.push(e);
  }
  collectComment(e) {
    this.comments.push(e), this._newComments.push(e);
  }
}
const qc = /\$\{(.*?)\}/gu;
function Fi(t, e) {
  const n = wo[t];
  return e ? n.replace(qc, (i, r) => e[r]?.toString() ?? "") : n;
}
class _o {
  constructor(e = !1) {
    this.tolerant = e, this.errors = [];
  }
  recordError(e) {
    this.errors.push(e);
  }
  tolerate(e) {
    if (this.tolerant)
      this.recordError(e);
    else
      throw e;
  }
  throwError(e) {
    throw e.description ??= Fi(e.code, e.data), new At(e);
  }
  tolerateError(e) {
    e.description ??= Fi(e.code, e.data);
    const n = new At(e);
    if (this.tolerant)
      this.recordError(n);
    else
      throw n;
  }
}
function Ra(t, e) {
  if (!t)
    throw new Error(`ASSERT: ${e}`);
}
const Ma = {
  // Unicode v12.1.0 NonAsciiIdentifierStart:
  NonAsciiIdentifierStart: /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0560-\u0588\u05D0-\u05EA\u05EF-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u08A0-\u08B4\u08B6-\u08BD\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E86-\u0E8A\u0E8C-\u0EA3\u0EA5\u0EA7-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1878\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1C90-\u1CBA\u1CBD-\u1CBF\u1CE9-\u1CEC\u1CEE-\u1CF3\u1CF5\u1CF6\u1CFA\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309B-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312F\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FEF\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7BF\uA7C2-\uA7C6\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA8FE\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB67\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF2D-\uDF4A\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE35\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2\uDD00-\uDD23\uDF00-\uDF1C\uDF27\uDF30-\uDF45\uDFE0-\uDFF6]|\uD804[\uDC03-\uDC37\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD44\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE2B\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF50\uDF5D-\uDF61]|\uD805[\uDC00-\uDC34\uDC47-\uDC4A\uDC5F\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDDD8-\uDDDB\uDE00-\uDE2F\uDE44\uDE80-\uDEAA\uDEB8\uDF00-\uDF1A]|\uD806[\uDC00-\uDC2B\uDCA0-\uDCDF\uDCFF\uDDA0-\uDDA7\uDDAA-\uDDD0\uDDE1\uDDE3\uDE00\uDE0B-\uDE32\uDE3A\uDE50\uDE5C-\uDE89\uDE9D\uDEC0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC2E\uDC40\uDC72-\uDC8F\uDD00-\uDD06\uDD08\uDD09\uDD0B-\uDD30\uDD46\uDD60-\uDD65\uDD67\uDD68\uDD6A-\uDD89\uDD98\uDEE0-\uDEF2]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD81C-\uD820\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872\uD874-\uD879][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDE40-\uDE7F\uDF00-\uDF4A\uDF50\uDF93-\uDF9F\uDFE0\uDFE1\uDFE3]|\uD821[\uDC00-\uDFF7]|\uD822[\uDC00-\uDEF2]|\uD82C[\uDC00-\uDD1E\uDD50-\uDD52\uDD64-\uDD67\uDD70-\uDEFB]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD838[\uDD00-\uDD2C\uDD37-\uDD3D\uDD4E\uDEC0-\uDEEB]|\uD83A[\uDC00-\uDCC4\uDD00-\uDD43\uDD4B]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1\uDEB0-\uDFFF]|\uD87A[\uDC00-\uDFE0]|\uD87E[\uDC00-\uDE1D]/u,
  // Unicode v12.1.0 NonAsciiIdentifierPart:
  NonAsciiIdentifierPart: (
    // eslint-disable-next-line no-misleading-character-class
    /[\xAA\xB5\xB7\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u052F\u0531-\u0556\u0559\u0560-\u0588\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05EF-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u07FD\u0800-\u082D\u0840-\u085B\u0860-\u086A\u08A0-\u08B4\u08B6-\u08BD\u08D3-\u08E1\u08E3-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u09FC\u09FE\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0AF9-\u0AFF\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C00-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58-\u0C5A\u0C60-\u0C63\u0C66-\u0C6F\u0C80-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D00-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D54-\u0D57\u0D5F-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E86-\u0E8A\u0E8C-\u0EA3\u0EA5\u0EA7-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1369-\u1371\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1878\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19DA\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABD\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1C80-\u1C88\u1C90-\u1CBA\u1CBD-\u1CBF\u1CD0-\u1CD2\u1CD4-\u1CFA\u1D00-\u1DF9\u1DFB-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u200C\u200D\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312F\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FEF\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA7BF\uA7C2-\uA7C6\uA7F7-\uA827\uA840-\uA873\uA880-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA8FD-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB67\uAB70-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDDFD\uDE80-\uDE9C\uDEA0-\uDED0\uDEE0\uDF00-\uDF1F\uDF2D-\uDF4A\uDF50-\uDF7A\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCA0-\uDCA9\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00-\uDE03\uDE05\uDE06\uDE0C-\uDE13\uDE15-\uDE17\uDE19-\uDE35\uDE38-\uDE3A\uDE3F\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE6\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2\uDD00-\uDD27\uDD30-\uDD39\uDF00-\uDF1C\uDF27\uDF30-\uDF50\uDFE0-\uDFF6]|\uD804[\uDC00-\uDC46\uDC66-\uDC6F\uDC7F-\uDCBA\uDCD0-\uDCE8\uDCF0-\uDCF9\uDD00-\uDD34\uDD36-\uDD3F\uDD44-\uDD46\uDD50-\uDD73\uDD76\uDD80-\uDDC4\uDDC9-\uDDCC\uDDD0-\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE37\uDE3E\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEEA\uDEF0-\uDEF9\uDF00-\uDF03\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3B-\uDF44\uDF47\uDF48\uDF4B-\uDF4D\uDF50\uDF57\uDF5D-\uDF63\uDF66-\uDF6C\uDF70-\uDF74]|\uD805[\uDC00-\uDC4A\uDC50-\uDC59\uDC5E\uDC5F\uDC80-\uDCC5\uDCC7\uDCD0-\uDCD9\uDD80-\uDDB5\uDDB8-\uDDC0\uDDD8-\uDDDD\uDE00-\uDE40\uDE44\uDE50-\uDE59\uDE80-\uDEB8\uDEC0-\uDEC9\uDF00-\uDF1A\uDF1D-\uDF2B\uDF30-\uDF39]|\uD806[\uDC00-\uDC3A\uDCA0-\uDCE9\uDCFF\uDDA0-\uDDA7\uDDAA-\uDDD7\uDDDA-\uDDE1\uDDE3\uDDE4\uDE00-\uDE3E\uDE47\uDE50-\uDE99\uDE9D\uDEC0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC36\uDC38-\uDC40\uDC50-\uDC59\uDC72-\uDC8F\uDC92-\uDCA7\uDCA9-\uDCB6\uDD00-\uDD06\uDD08\uDD09\uDD0B-\uDD36\uDD3A\uDD3C\uDD3D\uDD3F-\uDD47\uDD50-\uDD59\uDD60-\uDD65\uDD67\uDD68\uDD6A-\uDD8E\uDD90\uDD91\uDD93-\uDD98\uDDA0-\uDDA9\uDEE0-\uDEF6]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD81C-\uD820\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872\uD874-\uD879][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDE60-\uDE69\uDED0-\uDEED\uDEF0-\uDEF4\uDF00-\uDF36\uDF40-\uDF43\uDF50-\uDF59\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDE40-\uDE7F\uDF00-\uDF4A\uDF4F-\uDF87\uDF8F-\uDF9F\uDFE0\uDFE1\uDFE3]|\uD821[\uDC00-\uDFF7]|\uD822[\uDC00-\uDEF2]|\uD82C[\uDC00-\uDD1E\uDD50-\uDD52\uDD64-\uDD67\uDD70-\uDEFB]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99\uDC9D\uDC9E]|\uD834[\uDD65-\uDD69\uDD6D-\uDD72\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB\uDFCE-\uDFFF]|\uD836[\uDE00-\uDE36\uDE3B-\uDE6C\uDE75\uDE84\uDE9B-\uDE9F\uDEA1-\uDEAF]|\uD838[\uDC00-\uDC06\uDC08-\uDC18\uDC1B-\uDC21\uDC23\uDC24\uDC26-\uDC2A\uDD00-\uDD2C\uDD30-\uDD3D\uDD40-\uDD49\uDD4E\uDEC0-\uDEF9]|\uD83A[\uDC00-\uDCC4\uDCD0-\uDCD6\uDD00-\uDD4B\uDD50-\uDD59]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1\uDEB0-\uDFFF]|\uD87A[\uDC00-\uDFE0]|\uD87E[\uDC00-\uDE1D]|\uDB40[\uDD00-\uDDEF]/u
  )
}, V = {
  fromCodePoint(t) {
    return t < 65536 ? String.fromCharCode(t) : String.fromCharCode(55296 + (t - 65536 >> 10)) + String.fromCharCode(56320 + (t - 65536 & 1023));
  },
  // https://tc39.github.io/ecma262/#sec-white-space
  isWhiteSpace(t) {
    return t === 32 || t === 9 || t === 11 || t === 12 || t === 160 || t >= 5760 && [
      5760,
      8192,
      8193,
      8194,
      8195,
      8196,
      8197,
      8198,
      8199,
      8200,
      8201,
      8202,
      8239,
      8287,
      12288,
      65279
    ].includes(t);
  },
  // https://tc39.github.io/ecma262/#sec-line-terminators
  isLineTerminator(t) {
    return t === 10 || t === 13 || t === 8232 || t === 8233;
  },
  // https://tc39.github.io/ecma262/#sec-names-and-keywords
  isIdentifierStart(t) {
    return t === 36 || t === 95 || // $ (dollar) and _ (underscore)
    t >= 65 && t <= 90 || // A..Z
    t >= 97 && t <= 122 || // a..z
    t === 92 || // \ (backslash)
    t >= 128 && Ma.NonAsciiIdentifierStart.test(V.fromCodePoint(t));
  },
  isIdentifierPart(t) {
    return t === 36 || t === 95 || // $ (dollar) and _ (underscore)
    t >= 65 && t <= 90 || // A..Z
    t >= 97 && t <= 122 || // a..z
    t >= 48 && t <= 57 || // 0..9
    t === 92 || // \ (backslash)
    t >= 128 && Ma.NonAsciiIdentifierPart.test(V.fromCodePoint(t));
  },
  // https://tc39.github.io/ecma262/#sec-literals-numeric-literals
  isDecimalDigit(t) {
    return t >= 48 && t <= 57;
  },
  isHexDigit(t) {
    return t >= 48 && t <= 57 || // 0..9
    t >= 65 && t <= 70 || // A..F
    t >= 97 && t <= 102;
  },
  isOctalDigit(t) {
    return t >= 48 && t <= 55;
  }
};
function Pa(t) {
  return "0123456789abcdef".indexOf(t.toLowerCase());
}
function Wn(t) {
  return "01234567".indexOf(t);
}
const tt = [[], [], []];
wi.forEach((t) => tt[t.length - 1]?.push(t));
xo.forEach((t) => tt[t.length - 1]?.push(t));
Eo.forEach((t) => tt[t.length - 1]?.push(t));
Co.forEach((t) => tt[t.length - 1]?.push(t));
Ic.forEach((t) => tt[t.length - 1]?.push(t));
class Fo {
  constructor(e, n) {
    this.source = e, this.errorHandler = n, this._length = e.length, this.index = 0, this.lineNumber = 1, this.lineStart = 0, this.curlyStack = [];
  }
  saveState() {
    return {
      index: this.index,
      lineNumber: this.lineNumber,
      lineStart: this.lineStart,
      curlyStack: this.curlyStack.slice()
    };
  }
  restoreState(e) {
    this.index = e.index, this.lineNumber = e.lineNumber, this.lineStart = e.lineStart, this.curlyStack = e.curlyStack;
  }
  eof() {
    return this.index >= this._length;
  }
  throwUnexpectedToken(e = F.UnexpectedToken) {
    this.errorHandler.throwError({
      code: e,
      index: this.index,
      line: this.lineNumber,
      column: this.index - this.lineStart + 1,
      data: { value: this.source.charAt(this.index) }
    });
  }
  tolerateUnexpectedToken(e = F.UnexpectedToken) {
    this.errorHandler.tolerateError({
      code: e,
      index: this.index,
      line: this.lineNumber,
      column: this.index - this.lineStart + 1
    });
  }
  skipSingleLineComment(e) {
    const n = [], i = this.index - e, r = {
      start: {
        line: this.lineNumber,
        column: this.index - this.lineStart - e
      },
      end: { line: 0, column: 0 }
      // Fake for now
    };
    for (; !this.eof(); ) {
      const a = this.source.charCodeAt(this.index);
      if (this.index += 1, V.isLineTerminator(a)) {
        r.end = {
          line: this.lineNumber,
          column: this.index - this.lineStart - 1
        };
        const o = {
          multiLine: !1,
          start: i + e,
          end: this.index - 1,
          range: [i, this.index - 1],
          loc: r
        };
        return n.push(o), a === 13 && this.source.charCodeAt(this.index) === 10 && (this.index += 1), this.lineNumber += 1, this.lineStart = this.index, n;
      }
    }
    r.end = {
      line: this.lineNumber,
      column: this.index - this.lineStart
    };
    const s = {
      multiLine: !1,
      start: i + e,
      end: this.index,
      range: [i, this.index],
      loc: r
    };
    return n.push(s), n;
  }
  skipMultiLineComment() {
    const e = [], n = this.index - 2, i = {
      start: {
        line: this.lineNumber,
        column: this.index - this.lineStart - 2
      },
      end: { line: 0, column: 0 }
      // Fake for now
    };
    for (; !this.eof(); ) {
      const s = this.source.charCodeAt(this.index);
      if (V.isLineTerminator(s))
        s === 13 && this.source.charCodeAt(this.index + 1) === 10 && (this.index += 1), this.lineNumber += 1, this.index += 1, this.lineStart = this.index;
      else if (s === 42) {
        if (this.source.charCodeAt(this.index + 1) === 47) {
          this.index += 2, i.end = {
            line: this.lineNumber,
            column: this.index - this.lineStart
          };
          const a = {
            multiLine: !0,
            start: n + 2,
            end: this.index - 2,
            range: [n, this.index],
            loc: i
          };
          return e.push(a), e;
        }
        this.index += 1;
      } else
        this.index += 1;
    }
    i.end = {
      line: this.lineNumber,
      column: this.index - this.lineStart
    };
    const r = {
      multiLine: !0,
      start: n + 2,
      end: this.index,
      range: [n, this.index],
      loc: i
    };
    return e.push(r), this.tolerateUnexpectedToken(), e;
  }
  scanComments() {
    let e = [];
    for (; !this.eof(); ) {
      let n = this.source.charCodeAt(this.index);
      if (V.isWhiteSpace(n))
        this.index += 1;
      else if (V.isLineTerminator(n))
        this.index += 1, n === 13 && this.source.charCodeAt(this.index) === 10 && (this.index += 1), this.lineNumber += 1, this.lineStart = this.index;
      else if (n === 47)
        if (n = this.source.charCodeAt(this.index + 1), n === 47) {
          this.index += 2;
          const i = this.skipSingleLineComment(2);
          e = [...e, ...i];
        } else if (n === 42) {
          this.index += 2;
          const i = this.skipMultiLineComment();
          e = [...e, ...i];
        } else
          break;
      else
        break;
    }
    return e;
  }
  isKeyword(e) {
    switch (e = e.toLowerCase(), e.length) {
      case 2:
        return e === W.If || e === W.In;
      case 3:
        return e === W.Var || e === W.For;
      case 4:
        return e === W.Else;
      case 5:
        return e === W.Break || e === W.While;
      case 6:
        return e === W.Return || e === W.Import || e === W.Export;
      case 8:
        return e === W.Function || e === W.Continue;
      default:
        return !1;
    }
  }
  codePointAt(e) {
    let n = this.source.charCodeAt(e);
    if (n >= 55296 && n <= 56319) {
      const i = this.source.charCodeAt(e + 1);
      i >= 56320 && i <= 57343 && (n = (n - 55296) * 1024 + i - 56320 + 65536);
    }
    return n;
  }
  scanHexEscape(e) {
    const n = e === "u" ? 4 : 2;
    let i = 0;
    for (let r = 0; r < n; r++)
      if (!this.eof() && V.isHexDigit(this.source.charCodeAt(this.index)))
        i = i * 16 + Pa(this.source[this.index] ?? ""), this.index += 1;
      else
        return null;
    return String.fromCharCode(i);
  }
  scanUnicodeCodePointEscape() {
    let e = this.source[this.index], n = 0;
    for (e === "}" && this.throwUnexpectedToken(); !this.eof() && (e = this.source[this.index] ?? "", this.index += 1, !!V.isHexDigit(e.charCodeAt(0))); )
      n = n * 16 + Pa(e);
    return (n > 1114111 || e !== "}") && this.throwUnexpectedToken(), V.fromCodePoint(n);
  }
  getIdentifier() {
    const e = this.index;
    for (this.index += 1; !this.eof(); ) {
      const n = this.source.charCodeAt(this.index);
      if (n === 92)
        return this.index = e, this.getComplexIdentifier();
      if (n >= 55296 && n < 57343)
        return this.index = e, this.getComplexIdentifier();
      if (V.isIdentifierPart(n))
        this.index += 1;
      else
        break;
    }
    return this.source.slice(e, this.index);
  }
  getComplexIdentifier() {
    let e = this.codePointAt(this.index), n = V.fromCodePoint(e);
    this.index += n.length;
    let i;
    for (e === 92 && (this.source.charCodeAt(this.index) !== 117 && this.throwUnexpectedToken(), this.index += 1, this.source[this.index] === "{" ? (this.index += 1, i = this.scanUnicodeCodePointEscape()) : (i = this.scanHexEscape("u"), (i === null || i === "\\" || !V.isIdentifierStart(i.charCodeAt(0))) && this.throwUnexpectedToken()), n = i); !this.eof() && (e = this.codePointAt(this.index), !!V.isIdentifierPart(e)); )
      i = V.fromCodePoint(e), n += i, this.index += i.length, e === 92 && (n = n.substring(0, n.length - 1), this.source.charCodeAt(this.index) !== 117 && this.throwUnexpectedToken(), this.index += 1, this.source[this.index] === "{" ? (this.index += 1, i = this.scanUnicodeCodePointEscape()) : (i = this.scanHexEscape("u"), (i === null || i === "\\" || !V.isIdentifierPart(i.charCodeAt(0))) && this.throwUnexpectedToken()), n += i);
    return n;
  }
  octalToDecimal(e) {
    let n = e !== "0", i = Wn(e);
    return !this.eof() && V.isOctalDigit(this.source.charCodeAt(this.index)) && (n = !0, i = i * 8 + Wn(this.source[this.index] ?? ""), this.index += 1, "0123".includes(e) && !this.eof() && V.isOctalDigit(this.source.charCodeAt(this.index)) && (i = i * 8 + Wn(this.source[this.index] ?? ""), this.index += 1)), { code: i, octal: n };
  }
  // https://tc39.github.io/ecma262/#sec-names-and-keywords
  scanIdentifier() {
    let e;
    const n = this.index, i = this.source.charCodeAt(n) === 92 ? this.getComplexIdentifier() : this.getIdentifier();
    if (i.length === 1 ? e = S.Identifier : this.isKeyword(i) ? e = S.Keyword : i.toLowerCase() === Nt.Null ? e = S.NullLiteral : i.toLowerCase() === Nt.True || i.toLowerCase() === Nt.False ? e = S.BooleanLiteral : e = S.Identifier, e !== S.Identifier && n + i.length !== this.index) {
      const r = this.index;
      this.index = n, this.tolerateUnexpectedToken(F.InvalidEscapedReservedWord), this.index = r;
    }
    return {
      type: e,
      value: i,
      lineNumber: this.lineNumber,
      lineStart: this.lineStart,
      start: n,
      end: this.index
    };
  }
  // https://tc39.github.io/ecma262/#sec-punctuators
  scanPunctuator() {
    const e = this.index;
    let n = this.source[this.index] ?? "";
    switch (n) {
      case "(":
      case "{":
        n === "{" && this.curlyStack.push("{"), this.index += 1;
        break;
      case ".":
        this.index += 1;
        break;
      case "}":
        this.index += 1, this.curlyStack.pop();
        break;
      case ")":
      case ";":
      case ",":
      case "[":
      case "]":
      case ":":
      case "?":
      case "~":
        this.index += 1;
        break;
      default:
        for (let i = tt.length; i > 0; i--)
          if (n = this.source.substring(this.index, this.index + i), tt[i - 1]?.includes(n)) {
            this.index += i;
            break;
          }
    }
    return this.index === e && this.throwUnexpectedToken(), {
      type: S.Punctuator,
      value: n,
      lineNumber: this.lineNumber,
      lineStart: this.lineStart,
      start: e,
      end: this.index
    };
  }
  // https://tc39.github.io/ecma262/#sec-literals-numeric-literals
  scanHexLiteral(e) {
    let n = "";
    for (; !this.eof() && V.isHexDigit(this.source.charCodeAt(this.index)); )
      n += this.source[this.index], this.index += 1;
    return n.length === 0 && this.throwUnexpectedToken(), V.isIdentifierStart(this.source.charCodeAt(this.index)) && this.throwUnexpectedToken(), {
      type: S.NumericLiteral,
      value: Number.parseInt(`0x${n}`, 16),
      lineNumber: this.lineNumber,
      lineStart: this.lineStart,
      start: e,
      end: this.index
    };
  }
  scanBinaryLiteral(e) {
    let n = "";
    for (; !this.eof(); ) {
      const i = this.source[this.index];
      if (i !== "0" && i !== "1")
        break;
      n += this.source[this.index], this.index += 1;
    }
    if (n.length === 0 && this.throwUnexpectedToken(), !this.eof()) {
      const i = this.source.charCodeAt(this.index);
      (V.isIdentifierStart(i) || V.isDecimalDigit(i)) && this.throwUnexpectedToken();
    }
    return {
      type: S.NumericLiteral,
      value: Number.parseInt(n, 2),
      lineNumber: this.lineNumber,
      lineStart: this.lineStart,
      start: e,
      end: this.index
    };
  }
  scanOctalLiteral(e, n) {
    let i = "", r = !1;
    for (V.isOctalDigit(e.charCodeAt(0)) && (r = !0, i = `0${this.source[this.index]}`), this.index += 1; !this.eof() && V.isOctalDigit(this.source.charCodeAt(this.index)); )
      i += this.source[this.index], this.index += 1;
    return !r && i.length === 0 && this.throwUnexpectedToken(), (V.isIdentifierStart(this.source.charCodeAt(this.index)) || V.isDecimalDigit(this.source.charCodeAt(this.index))) && this.throwUnexpectedToken(), {
      type: S.NumericLiteral,
      value: Number.parseInt(i, 8),
      lineNumber: this.lineNumber,
      lineStart: this.lineStart,
      start: n,
      end: this.index
    };
  }
  scanNumericLiteral() {
    const e = this.index;
    let n = this.source[e] ?? "";
    Ra(
      V.isDecimalDigit(n.charCodeAt(0)) || n === ".",
      "Numeric literal must start with a decimal digit or a decimal point"
    );
    let i = "";
    if (n !== ".") {
      if (i = this.source[this.index] ?? "", this.index += 1, n = this.source[this.index] ?? "", i === "0") {
        if (n === "x" || n === "X")
          return this.index += 1, this.scanHexLiteral(e);
        if (n === "b" || n === "B")
          return this.index += 1, this.scanBinaryLiteral(e);
        if (n === "o" || n === "O")
          return this.scanOctalLiteral(n, e);
      }
      for (; V.isDecimalDigit(this.source.charCodeAt(this.index)); )
        i += this.source[this.index], this.index += 1;
      n = this.source[this.index] ?? "";
    }
    if (n === ".") {
      for (i += this.source[this.index], this.index += 1; V.isDecimalDigit(this.source.charCodeAt(this.index)); )
        i += this.source[this.index], this.index += 1;
      n = this.source[this.index] ?? "";
    }
    if (n === "e" || n === "E")
      if (i += this.source[this.index], this.index += 1, n = this.source[this.index] ?? "", (n === "+" || n === "-") && (i += this.source[this.index], this.index += 1), V.isDecimalDigit(this.source.charCodeAt(this.index)))
        for (; V.isDecimalDigit(this.source.charCodeAt(this.index)); )
          i += this.source[this.index], this.index += 1;
      else
        this.throwUnexpectedToken();
    return V.isIdentifierStart(this.source.charCodeAt(this.index)) && this.throwUnexpectedToken(), {
      type: S.NumericLiteral,
      value: Number.parseFloat(i),
      lineNumber: this.lineNumber,
      lineStart: this.lineStart,
      start: e,
      end: this.index
    };
  }
  scanStringLiteral() {
    const e = this.index;
    let n = this.source[e];
    Ra(n === "'" || n === '"', "String literal must starts with a quote"), this.index += 1;
    let i = !1, r = "";
    for (; !this.eof(); ) {
      let s = this.source[this.index] ?? "";
      if (this.index += 1, s === n) {
        n = "";
        break;
      }
      if (s === "\\")
        if (s = this.source[this.index] ?? "", this.index += 1, !s || !V.isLineTerminator(s.charCodeAt(0)))
          switch (s) {
            case "u":
              if (this.source[this.index] === "{")
                this.index += 1, r += this.scanUnicodeCodePointEscape();
              else {
                const a = this.scanHexEscape(s);
                a === null && this.throwUnexpectedToken(), r += a;
              }
              break;
            case "x": {
              const a = this.scanHexEscape(s);
              a === null && this.throwUnexpectedToken(F.InvalidHexEscapeSequence), r += a;
              break;
            }
            case "n":
              r += `
`;
              break;
            case "r":
              r += "\r";
              break;
            case "t":
              r += "	";
              break;
            case "b":
              r += "\b";
              break;
            case "f":
              r += "\f";
              break;
            case "v":
              r += "\v";
              break;
            case "8":
            case "9":
              r += s, this.tolerateUnexpectedToken();
              break;
            default:
              if (s && V.isOctalDigit(s.charCodeAt(0))) {
                const a = this.octalToDecimal(s);
                i = a.octal || i, r += String.fromCharCode(a.code);
              } else
                r += s;
              break;
          }
        else
          this.lineNumber += 1, s === "\r" && this.source[this.index] === `
` && (this.index += 1), this.lineStart = this.index;
      else {
        if (V.isLineTerminator(s.charCodeAt(0)))
          break;
        r += s;
      }
    }
    return n !== "" && (this.index = e, this.throwUnexpectedToken()), {
      type: S.StringLiteral,
      value: r,
      lineNumber: this.lineNumber,
      lineStart: this.lineStart,
      start: e,
      end: this.index
    };
  }
  scanTemplate() {
    let e = "", n = !1;
    const i = this.index, r = this.source[i] === "`";
    let s = !1, a = 2;
    for (this.index += 1; !this.eof(); ) {
      let o = this.source[this.index] ?? "";
      if (this.index += 1, o === "`") {
        a = 1, s = !0, n = !0;
        break;
      }
      if (o === "$") {
        if (this.source[this.index] === "{") {
          this.curlyStack.push("${"), this.index += 1, n = !0;
          break;
        }
        e += o;
        continue;
      }
      if (o === "\\") {
        if (o = this.source[this.index] ?? "", this.index += 1, V.isLineTerminator(o.charCodeAt(0)))
          this.lineNumber += 1, o === "\r" && this.source[this.index] === `
` && (this.index += 1), this.lineStart = this.index;
        else
          switch (o) {
            case "n":
              e += `
`;
              break;
            case "r":
              e += "\r";
              break;
            case "t":
              e += "	";
              break;
            case "u":
              if (this.source[this.index] === "{")
                this.index += 1, e += this.scanUnicodeCodePointEscape();
              else {
                const l = this.index, c = this.scanHexEscape(o);
                c !== null ? e += c : (this.index = l, e += o);
              }
              break;
            case "x": {
              const l = this.scanHexEscape(o);
              l === null && this.throwUnexpectedToken(F.InvalidHexEscapeSequence), e += l;
              break;
            }
            case "b":
              e += "\b";
              break;
            case "f":
              e += "\f";
              break;
            case "v":
              e += "\v";
              break;
            default:
              o === "0" ? (V.isDecimalDigit(this.source.charCodeAt(this.index)) && this.throwUnexpectedToken(F.TemplateOctalLiteral), e += "\0") : V.isOctalDigit(o.charCodeAt(0)) ? this.throwUnexpectedToken(F.TemplateOctalLiteral) : e += o;
              break;
          }
        continue;
      }
      if (V.isLineTerminator(o.charCodeAt(0))) {
        this.lineNumber += 1, o === "\r" && this.source[this.index] === `
` && (this.index += 1), this.lineStart = this.index, e += `
`;
        continue;
      }
      e += o;
    }
    return n || this.throwUnexpectedToken(), r || this.curlyStack.pop(), {
      type: S.Template,
      value: this.source.slice(i + 1, this.index - a),
      cooked: e,
      head: r,
      tail: s,
      lineNumber: this.lineNumber,
      lineStart: this.lineStart,
      start: i,
      end: this.index
    };
  }
  lex() {
    if (this.eof())
      return {
        type: S.EOF,
        value: "",
        lineNumber: this.lineNumber,
        lineStart: this.lineStart,
        start: this.index,
        end: this.index
      };
    const e = this.source.charCodeAt(this.index);
    return V.isIdentifierStart(e) ? this.scanIdentifier() : e === 40 || e === 41 || e === 59 ? this.scanPunctuator() : e === 39 || e === 34 ? this.scanStringLiteral() : e === 46 ? V.isDecimalDigit(this.source.charCodeAt(this.index + 1)) ? this.scanNumericLiteral() : this.scanPunctuator() : V.isDecimalDigit(e) ? this.scanNumericLiteral() : e === 96 || e === 125 && this.curlyStack[this.curlyStack.length - 1] === "${" ? this.scanTemplate() : e >= 55296 && e < 57343 && V.isIdentifierStart(this.codePointAt(this.index)) ? this.scanIdentifier() : this.scanPunctuator();
  }
}
const fe = {
  None: 0,
  Function: 1,
  IfClause: 2,
  ForLoop: 4,
  ForOfLoop: 8,
  WhileLoop: 16
}, On = {
  AsObject: 0,
  Automatic: 1
};
function Ta(t, e = 0) {
  let n = t.start - t.lineStart, i = t.lineNumber;
  return n < 0 && (n += e, i -= 1), { index: t.start, line: i, column: n };
}
function Ua(t) {
  return [
    { index: t.range[0], ...t.loc.start },
    { index: t.range[1], ...t.loc.end }
  ];
}
function Va(t) {
  return t in wn ? wn[t] : 0;
}
class zc {
  constructor(e, n = {}, i) {
    this.delegate = i, this.hasLineTerminator = !1, this.options = {
      tokens: typeof n.tokens == "boolean" && n.tokens,
      comments: typeof n.comments == "boolean" && n.comments,
      tolerant: typeof n.tolerant == "boolean" && n.tolerant
    }, this.options.comments && (this.commentHandler = new $c()), this.errorHandler = new _o(this.options.tolerant), this.scanner = new Fo(e, this.errorHandler), this.context = {
      isAssignmentTarget: !1,
      blockContext: fe.None,
      curlyParsingType: On.AsObject
    }, this.rawToken = {
      type: S.EOF,
      value: "",
      lineNumber: this.scanner.lineNumber,
      lineStart: 0,
      start: 0,
      end: 0
    }, this.tokens = [], this.startMarker = {
      index: 0,
      line: this.scanner.lineNumber,
      column: 0
    }, this.endMarker = {
      index: 0,
      line: this.scanner.lineNumber,
      column: 0
    }, this.readNextRawToken(), this.endMarker = {
      index: this.scanner.index,
      line: this.scanner.lineNumber,
      column: this.scanner.index - this.scanner.lineStart
    };
  }
  throwIfInvalidType(e, n, {
    validTypes: i,
    invalidTypes: r
  }) {
    i?.some((s) => e.type === s) || r?.some((s) => e.type === s) && this.throwError(F.InvalidExpression, n);
  }
  throwError(e, n, i = this.endMarker) {
    const { index: r, line: s, column: a } = n, o = i.index - r - 1;
    this.errorHandler.throwError({ code: e, index: r, line: s, column: a + 1, len: o });
  }
  tolerateError(e, n) {
    throw new Error("######################################### !!!");
  }
  // Throw an exception because of the token.
  unexpectedTokenError(e = {}) {
    const { rawToken: n } = e;
    let { code: i, data: r } = e, s;
    if (n) {
      if (!i)
        switch (n.type) {
          case S.EOF:
            i = F.UnexpectedEndOfScript;
            break;
          case S.Identifier:
            i = F.UnexpectedIdentifier;
            break;
          case S.NumericLiteral:
            i = F.UnexpectedNumber;
            break;
          case S.StringLiteral:
            i = F.UnexpectedString;
            break;
          case S.Template:
            i = F.UnexpectedTemplate;
            break;
        }
      s = n.value.toString();
    } else
      s = "ILLEGAL";
    i ??= F.UnexpectedToken, r ??= { value: s };
    const a = Fi(i, r);
    if (n) {
      const c = n.start, d = n.lineNumber, h = n.start - n.lineStart + 1;
      return new At({
        code: i,
        index: c,
        line: d,
        column: h,
        len: n.end - n.start - 1,
        data: r,
        description: a
      });
    }
    const { index: o, line: l } = this.endMarker;
    return new At({ code: i, index: o, line: l, column: this.endMarker.column + 1, data: r, description: a });
  }
  throwUnexpectedToken(e = {}) {
    throw e.rawToken ??= this.rawToken, this.unexpectedTokenError(e);
  }
  collectComments(e) {
    const { commentHandler: n } = this;
    !n || !e.length || e.forEach((i) => {
      const r = {
        type: i.multiLine ? g.BlockComment : g.LineComment,
        value: this.getSourceValue(i),
        range: i.range,
        loc: i.loc
      };
      n.collectComment(r);
    });
  }
  peekAhead(e) {
    const n = () => (this.scanner.scanComments(), this.scanner.lex()), i = this.scanner.saveState(), r = e.call(this, n);
    return this.scanner.restoreState(i), r;
  }
  getSourceValue(e) {
    return this.scanner.source.slice(e.start, e.end);
  }
  convertToToken(e) {
    return {
      type: Ao[e.type],
      value: this.getSourceValue(e),
      range: [e.start, e.end],
      loc: {
        start: {
          line: this.startMarker.line,
          column: this.startMarker.column
        },
        end: {
          line: this.scanner.lineNumber,
          column: this.scanner.index - this.scanner.lineStart
        }
      }
    };
  }
  readNextRawToken() {
    this.endMarker.index = this.scanner.index, this.endMarker.line = this.scanner.lineNumber, this.endMarker.column = this.scanner.index - this.scanner.lineStart;
    const e = this.rawToken;
    this.collectComments(this.scanner.scanComments()), this.scanner.index !== this.startMarker.index && (this.startMarker.index = this.scanner.index, this.startMarker.line = this.scanner.lineNumber, this.startMarker.column = this.scanner.index - this.scanner.lineStart), this.rawToken = this.scanner.lex(), this.hasLineTerminator = e.lineNumber !== this.rawToken.lineNumber, this.options.tokens && this.rawToken.type !== S.EOF && this.tokens.push(this.convertToToken(this.rawToken));
  }
  captureStartMarker() {
    return {
      index: this.startMarker.index,
      line: this.startMarker.line,
      column: this.startMarker.column
    };
  }
  getItemLocation(e) {
    return {
      range: [e.index, this.endMarker.index],
      loc: {
        start: {
          line: e.line,
          column: e.column
        },
        end: {
          line: this.endMarker.line,
          column: this.endMarker.column
        }
      }
    };
  }
  finalize(e) {
    return (this.delegate ?? this.commentHandler) && (this.commentHandler?.attachComments(e), this.delegate?.(e)), e;
  }
  expectPunctuator(e) {
    const n = this.rawToken;
    if (this.matchPunctuator(e)) {
      this.readNextRawToken();
      return;
    }
    this.throwUnexpectedToken({ rawToken: n, code: F.PunctuatorExpected, data: { value: e } });
  }
  expectKeyword(e) {
    if (this.rawToken.type === S.Keyword && this.rawToken.value.toLowerCase() === e.toString()) {
      this.readNextRawToken();
      return;
    }
    this.throwUnexpectedToken({ rawToken: this.rawToken });
  }
  expectContextualKeyword(e) {
    if (this.rawToken.type === S.Identifier && this.rawToken.value.toLowerCase() === e) {
      this.readNextRawToken();
      return;
    }
    this.throwUnexpectedToken({ rawToken: this.rawToken });
  }
  matchKeyword(e) {
    return this.rawToken.type === S.Keyword && this.rawToken.value.toLowerCase() === e;
  }
  matchContextualKeyword(e) {
    return this.rawToken.type === S.Identifier && this.rawToken.value === e;
  }
  matchPunctuator(e) {
    return this.rawToken.type === S.Punctuator && this.rawToken.value === e;
  }
  getMatchingPunctuator(e) {
    if (typeof e == "string" && (e = e.split("")), !(this.rawToken.type !== S.Punctuator || !e.length))
      return e.find(this.matchPunctuator.bind(this));
  }
  // Cover grammar support.
  //
  // When an assignment expression position starts with an left parenthesis, the determination of the type
  // of the syntax is to be deferred arbitrarily long until the end of the parentheses pair (plus a lookahead)
  // or the first comma. This situation also defers the determination of all the expressions nested in the pair.
  //
  // There are two productions that can be parsed in a parentheses pair that needs to be determined
  // after the outermost pair is closed. They are:
  //
  //   1. AssignmentExpression
  //   2. AssignmentTargets
  //
  // In order to avoid exponential backtracking, we use two flags to denote if the production can be
  // assignment target.
  //
  // The two productions have the relationship:
  //
  //   AssignmentTargets ⊆ AssignmentExpression
  //
  // with a single exception that CoverInitializedName when used directly in an Expression, generates
  // an early error.
  //
  // isolateCoverGrammar function runs the given parser function with a new cover grammar context, and it does not
  // effect the current flags. This means the production the parser parses is only used as an expression. Therefore
  // the CoverInitializedName check is conducted.
  //
  // inheritCoverGrammar function runs the given parse function with a new cover grammar context, and it propagates
  // the flags outside of the parser. This means the production the parser parses is used as a part of a potential
  // pattern. The CoverInitializedName check is deferred.
  isolateCoverGrammar(e) {
    const n = this.context.isAssignmentTarget;
    this.context.isAssignmentTarget = !0;
    const i = e.call(this);
    return this.context.isAssignmentTarget = n, i;
  }
  inheritCoverGrammar(e) {
    const n = this.context.isAssignmentTarget;
    this.context.isAssignmentTarget = !0;
    const i = e.call(this);
    return this.context.isAssignmentTarget &&= n, i;
  }
  withBlockContext(e, n) {
    const i = this.context.blockContext;
    this.context.blockContext |= e;
    const r = this.context.curlyParsingType;
    this.context.curlyParsingType = On.Automatic;
    const s = n.call(this);
    return this.context.blockContext = i, this.context.curlyParsingType = r, s;
  }
  consumeSemicolon() {
    if (this.matchPunctuator(";")) {
      this.readNextRawToken();
      return;
    }
    if (!this.hasLineTerminator) {
      if (this.rawToken.type === S.EOF || this.matchPunctuator("}")) {
        this.endMarker.index = this.startMarker.index, this.endMarker.line = this.startMarker.line, this.endMarker.column = this.startMarker.column;
        return;
      }
      this.throwUnexpectedToken({ rawToken: this.rawToken });
    }
  }
  parsePrimaryExpression() {
    const e = this.captureStartMarker(), n = this.rawToken;
    switch (n.type) {
      case S.Identifier:
        return this.readNextRawToken(), this.finalize({
          type: g.Identifier,
          name: n.value,
          ...this.getItemLocation(e)
        });
      case S.NumericLiteral:
      case S.StringLiteral:
        return this.context.isAssignmentTarget = !1, this.readNextRawToken(), this.finalize({
          type: g.Literal,
          value: n.value,
          raw: this.getSourceValue(n),
          isString: typeof n.value == "string",
          ...this.getItemLocation(e)
        });
      case S.BooleanLiteral:
        return this.context.isAssignmentTarget = !1, this.readNextRawToken(), this.finalize({
          type: g.Literal,
          value: n.value.toLowerCase() === Nt.True,
          raw: this.getSourceValue(n),
          isString: !1,
          ...this.getItemLocation(e)
        });
      case S.NullLiteral:
        return this.context.isAssignmentTarget = !1, this.readNextRawToken(), this.finalize({
          type: g.Literal,
          value: null,
          raw: this.getSourceValue(n),
          isString: !1,
          ...this.getItemLocation(e)
        });
      case S.Template:
        return this.parseTemplateLiteral();
      case S.Punctuator:
        switch (n.value) {
          case "(":
            return this.inheritCoverGrammar(this.parseGroupExpression.bind(this));
          case "[":
            return this.inheritCoverGrammar(this.parseArrayInitializer.bind(this));
          case "{":
            return this.inheritCoverGrammar(this.parseObjectExpression.bind(this));
          default:
            return this.throwUnexpectedToken({ rawToken: this.rawToken });
        }
      case S.Keyword:
        return this.context.isAssignmentTarget = !1, this.throwUnexpectedToken({ rawToken: this.rawToken });
      default:
        return this.throwUnexpectedToken({ rawToken: this.rawToken });
    }
  }
  parseArrayInitializer() {
    const e = this.captureStartMarker();
    this.expectPunctuator("[");
    const n = [];
    for (; !this.matchPunctuator("]"); ) {
      const i = this.captureStartMarker();
      this.matchPunctuator(",") ? (this.readNextRawToken(), this.throwError(F.InvalidExpression, i)) : (n.push(this.inheritCoverGrammar(this.parseAssignmentExpression.bind(this))), this.matchPunctuator("]") || this.expectPunctuator(","));
    }
    return this.expectPunctuator("]"), this.finalize({ type: g.ArrayExpression, elements: n, ...this.getItemLocation(e) });
  }
  parseObjectPropertyKey() {
    const e = this.captureStartMarker(), n = this.rawToken;
    switch (n.type) {
      case S.StringLiteral:
        return this.readNextRawToken(), this.finalize({
          type: g.Literal,
          value: n.value,
          raw: this.getSourceValue(n),
          isString: !0,
          ...this.getItemLocation(e)
        });
      case S.Identifier:
      case S.BooleanLiteral:
      case S.NullLiteral:
      case S.Keyword:
        return this.readNextRawToken(), this.finalize({
          type: g.Identifier,
          name: n.value,
          ...this.getItemLocation(e)
        });
      default:
        this.throwError(F.KeyMustBeString, e);
    }
  }
  parseObjectProperty() {
    const e = this.rawToken, n = this.captureStartMarker(), i = this.parseObjectPropertyKey();
    let r = !1, s = null;
    return this.matchPunctuator(":") ? (this.readNextRawToken(), s = this.inheritCoverGrammar(this.parseAssignmentExpression.bind(this))) : e.type === S.Identifier ? (r = !0, s = this.finalize({
      type: g.Identifier,
      name: e.value,
      ...this.getItemLocation(n)
    })) : this.throwUnexpectedToken({ rawToken: this.rawToken }), this.finalize({
      type: g.Property,
      kind: "init",
      key: i,
      value: s,
      shorthand: r,
      ...this.getItemLocation(n)
    });
  }
  parseObjectExpression() {
    const e = this.captureStartMarker();
    this.expectPunctuator("{");
    const n = [];
    for (; !this.matchPunctuator("}"); )
      n.push(this.parseObjectProperty()), this.matchPunctuator("}") || this.expectPunctuator(",");
    return this.expectPunctuator("}"), this.finalize({ type: g.ObjectExpression, properties: n, ...this.getItemLocation(e) });
  }
  parseTemplateElement(e = !1) {
    const n = this.rawToken;
    n.type !== S.Template && this.throwUnexpectedToken({ rawToken: n }), e && !n.head && this.throwUnexpectedToken({ code: F.InvalidTemplateHead, rawToken: n });
    const i = this.captureStartMarker();
    this.readNextRawToken();
    const { value: r, cooked: s, tail: a } = n, o = this.finalize({
      type: g.TemplateElement,
      value: { raw: r, cooked: s },
      tail: a,
      ...this.getItemLocation(i)
    });
    return o.loc.start.column += 1, o.loc.end.column -= a ? 1 : 2, o;
  }
  parseTemplateLiteral() {
    const e = this.captureStartMarker(), n = [], i = [];
    let r = this.parseTemplateElement(!0);
    for (i.push(r); !r.tail; )
      n.push(this.parseExpression()), r = this.parseTemplateElement(), i.push(r);
    return this.finalize({
      type: g.TemplateLiteral,
      quasis: i,
      expressions: n,
      ...this.getItemLocation(e)
    });
  }
  parseGroupExpression() {
    this.expectPunctuator("(");
    const e = this.inheritCoverGrammar(this.parseAssignmentExpression.bind(this));
    return this.expectPunctuator(")"), e;
  }
  parseArguments() {
    this.expectPunctuator("(");
    const e = [];
    if (!this.matchPunctuator(")"))
      for (; ; ) {
        const n = this.isolateCoverGrammar(this.parseAssignmentExpression.bind(this));
        if (e.push(n), this.matchPunctuator(")") || (this.expectPunctuator(","), this.matchPunctuator(")")))
          break;
      }
    return this.expectPunctuator(")"), e;
  }
  parseMemberName() {
    const e = this.rawToken, n = this.captureStartMarker();
    return this.readNextRawToken(), e.type !== S.NullLiteral && e.type !== S.Identifier && e.type !== S.Keyword && e.type !== S.BooleanLiteral && this.throwUnexpectedToken({ rawToken: e }), this.finalize({
      type: g.Identifier,
      name: e.value,
      ...this.getItemLocation(n)
    });
  }
  parseLeftHandSideExpression() {
    const e = this.captureStartMarker();
    let n = this.inheritCoverGrammar(this.parsePrimaryExpression.bind(this));
    const i = this.captureStartMarker();
    let r;
    for (; r = this.getMatchingPunctuator("([."); )
      switch (r) {
        case "(": {
          this.context.isAssignmentTarget = !1, n.type !== g.Identifier && n.type !== g.MemberExpression && this.throwError(F.IdentifierExpected, e, i);
          const s = this.parseArguments();
          n = this.finalize({
            type: g.CallExpression,
            callee: n,
            arguments: s,
            ...this.getItemLocation(e)
          });
          continue;
        }
        case "[": {
          this.context.isAssignmentTarget = !0, this.expectPunctuator("[");
          const s = this.isolateCoverGrammar(() => this.parseExpression());
          this.expectPunctuator("]"), n = this.finalize({
            type: g.MemberExpression,
            computed: !0,
            object: n,
            property: s,
            ...this.getItemLocation(e)
          });
          continue;
        }
        case ".": {
          this.context.isAssignmentTarget = !0, this.expectPunctuator(".");
          const s = this.parseMemberName();
          n = this.finalize({
            type: g.MemberExpression,
            computed: !1,
            object: n,
            property: s,
            ...this.getItemLocation(e)
          });
          continue;
        }
      }
    return n;
  }
  parseUpdateExpression() {
    const e = this.captureStartMarker();
    let n = this.getMatchingPunctuator(wi);
    if (n) {
      this.readNextRawToken();
      const a = this.captureStartMarker(), o = this.inheritCoverGrammar(this.parseUnaryExpression.bind(this));
      return o.type !== g.Identifier && o.type !== g.MemberExpression && o.type !== g.CallExpression && this.throwError(F.InvalidExpression, a), this.context.isAssignmentTarget || this.tolerateError(F.InvalidLeftHandSideInAssignment, e), this.context.isAssignmentTarget = !1, this.finalize({
        type: g.UpdateExpression,
        operator: n,
        argument: o,
        prefix: !0,
        ...this.getItemLocation(e)
      });
    }
    const i = this.captureStartMarker(), r = this.inheritCoverGrammar(this.parseLeftHandSideExpression.bind(this)), s = this.captureStartMarker();
    return this.hasLineTerminator || (n = this.getMatchingPunctuator(wi), !n) ? r : (r.type !== g.Identifier && r.type !== g.MemberExpression && this.throwError(F.InvalidExpression, i, s), this.context.isAssignmentTarget || this.tolerateError(F.InvalidLeftHandSideInAssignment, e), this.readNextRawToken(), this.context.isAssignmentTarget = !1, this.finalize({
      type: g.UpdateExpression,
      operator: n,
      argument: r,
      prefix: !1,
      ...this.getItemLocation(e)
    }));
  }
  parseUnaryExpression() {
    const e = this.getMatchingPunctuator(xo);
    if (e) {
      const n = this.captureStartMarker();
      this.readNextRawToken();
      const i = this.inheritCoverGrammar(this.parseUnaryExpression.bind(this));
      return this.context.isAssignmentTarget = !1, this.finalize({
        type: g.UnaryExpression,
        operator: e,
        argument: i,
        prefix: !0,
        ...this.getItemLocation(n)
      });
    }
    return this.parseUpdateExpression();
  }
  parseBinaryExpression() {
    const e = this.rawToken;
    let n = this.inheritCoverGrammar(this.parseUnaryExpression.bind(this));
    if (this.rawToken.type !== S.Punctuator)
      return n;
    const i = this.rawToken.value;
    let r = Va(i);
    if (r === 0)
      return n;
    this.readNextRawToken(), this.context.isAssignmentTarget = !1;
    const s = [e, this.rawToken];
    let a = n, o = this.inheritCoverGrammar(
      this.parseUnaryExpression.bind(this)
    );
    const l = [a, i, o], c = [r];
    for (; this.rawToken.type === S.Punctuator && (r = Va(this.rawToken.value)) > 0; ) {
      for (; l.length > 2 && r <= c[c.length - 1]; ) {
        o = l.pop();
        const f = l.pop();
        c.pop(), a = l.pop(), s.pop();
        const m = s[s.length - 1], b = Ta(m, m.lineStart);
        l.push(this.finalize(this.createBinaryOrLogicalExpression(b, f, a, o)));
      }
      l.push(this.rawToken.value), c.push(r), s.push(this.rawToken), this.readNextRawToken(), l.push(this.inheritCoverGrammar(this.parseUnaryExpression.bind(this)));
    }
    let d = l.length - 1;
    n = l[d];
    let h = s.pop();
    for (; d > 1; ) {
      const f = s.pop();
      if (!f)
        break;
      const m = h?.lineStart, b = Ta(f, m), D = l[d - 1];
      n = this.finalize(
        this.createBinaryOrLogicalExpression(b, D, l[d - 2], n)
      ), d -= 2, h = f;
    }
    return n;
  }
  createBinaryOrLogicalExpression(e, n, i, r) {
    const s = Eo.includes(n) ? g.LogicalExpression : g.BinaryExpression;
    return s === g.BinaryExpression ? { type: s, operator: n, left: i, right: r, ...this.getItemLocation(e) } : ((i.type === g.AssignmentExpression || i.type === g.UpdateExpression) && this.throwError(F.InvalidExpression, ...Ua(i)), (r.type === g.AssignmentExpression || r.type === g.UpdateExpression) && this.throwError(F.InvalidExpression, ...Ua(i)), { type: s, operator: n, left: i, right: r, ...this.getItemLocation(e) });
  }
  parseAssignmentExpression() {
    const e = this.captureStartMarker(), n = this.inheritCoverGrammar(this.parseBinaryExpression.bind(this)), i = this.captureStartMarker(), r = this.getMatchingPunctuator(Co);
    if (!r)
      return n;
    n.type !== g.Identifier && n.type !== g.MemberExpression && this.throwError(F.InvalidExpression, e, i), this.context.isAssignmentTarget || this.tolerateError(F.InvalidLeftHandSideInAssignment, e), this.matchPunctuator("=") || (this.context.isAssignmentTarget = !1), this.readNextRawToken();
    const s = this.isolateCoverGrammar(this.parseAssignmentExpression.bind(this));
    return this.finalize({
      type: g.AssignmentExpression,
      left: n,
      operator: r,
      right: s,
      ...this.getItemLocation(e)
    });
  }
  parseExpression() {
    return this.isolateCoverGrammar(this.parseAssignmentExpression.bind(this));
  }
  parseStatements(e) {
    const n = [];
    for (; this.rawToken.type !== S.EOF && !this.matchPunctuator(e); ) {
      const i = this.parseStatementListItem();
      $i(i) || n.push(i);
    }
    return n;
  }
  parseStatementListItem() {
    return this.context.isAssignmentTarget = !0, this.matchKeyword(W.Function) ? this.parseFunctionDeclaration() : this.matchKeyword(W.Export) ? this.parseExportDeclaration() : this.matchKeyword(W.Import) ? this.parseImportDeclaration() : this.parseStatement();
  }
  parseBlock() {
    const e = this.captureStartMarker();
    this.expectPunctuator("{");
    const n = this.parseStatements("}");
    return this.expectPunctuator("}"), this.finalize({ type: g.BlockStatement, body: n, ...this.getItemLocation(e) });
  }
  parseObjectStatement() {
    const e = this.captureStartMarker(), n = this.parseObjectExpression();
    return this.finalize({
      type: g.ExpressionStatement,
      expression: n,
      ...this.getItemLocation(e)
    });
  }
  parseBlockOrObjectStatement() {
    return this.context.curlyParsingType === On.AsObject ? this.parseObjectStatement() : this.peekAhead((e) => {
      let n = e();
      return !(n.type !== S.Identifier && n.type !== S.StringLiteral || (n = e(), n.type !== S.Punctuator || n.value !== ":"));
    }) ? this.parseObjectStatement() : this.parseBlock();
  }
  parseIdentifier() {
    const e = this.rawToken;
    if (e.type !== S.Identifier)
      return null;
    const n = this.captureStartMarker();
    return this.readNextRawToken(), this.finalize({
      type: g.Identifier,
      name: e.value,
      ...this.getItemLocation(n)
    });
  }
  parseVariableDeclarator() {
    const e = this.captureStartMarker(), n = this.parseIdentifier();
    n || this.throwUnexpectedToken({ code: F.IdentifierExpected });
    let i = null;
    if (this.matchPunctuator("=")) {
      this.readNextRawToken();
      const r = this.rawToken;
      try {
        i = this.isolateCoverGrammar(this.parseAssignmentExpression.bind(this));
      } catch {
        this.throwUnexpectedToken({ rawToken: r, code: F.InvalidVariableAssignment });
      }
    }
    return this.finalize({ type: g.VariableDeclarator, id: n, init: i, ...this.getItemLocation(e) });
  }
  parseVariableDeclarators() {
    const e = [this.parseVariableDeclarator()];
    for (; this.matchPunctuator(","); )
      this.readNextRawToken(), e.push(this.parseVariableDeclarator());
    return e;
  }
  parseVariableDeclaration() {
    const e = this.captureStartMarker();
    this.expectKeyword(W.Var);
    const n = this.parseVariableDeclarators();
    return this.consumeSemicolon(), this.finalize({
      type: g.VariableDeclaration,
      declarations: n,
      kind: "var",
      ...this.getItemLocation(e)
    });
  }
  parseEmptyStatement() {
    const e = this.captureStartMarker();
    return this.expectPunctuator(";"), this.finalize({ type: g.EmptyStatement, ...this.getItemLocation(e) });
  }
  parseExpressionStatement() {
    const e = this.captureStartMarker(), n = this.parseExpression();
    return this.consumeSemicolon(), this.finalize({
      type: g.ExpressionStatement,
      expression: n,
      ...this.getItemLocation(e)
    });
  }
  parseIfClause() {
    return this.withBlockContext(fe.IfClause, this.parseStatement.bind(this));
  }
  parseIfStatement() {
    const e = this.captureStartMarker();
    this.expectKeyword(W.If), this.expectPunctuator("(");
    const n = this.captureStartMarker(), i = this.parseExpression(), r = this.captureStartMarker();
    this.expectPunctuator(")"), (i.type === g.AssignmentExpression || i.type === g.UpdateExpression) && this.throwError(F.InvalidExpression, n, r);
    const s = this.parseIfClause();
    let a = null;
    return this.matchKeyword(W.Else) && (this.readNextRawToken(), a = this.parseIfClause()), this.finalize({
      type: g.IfStatement,
      test: i,
      consequent: s,
      alternate: a,
      ...this.getItemLocation(e)
    });
  }
  parseWhileStatement() {
    const e = this.captureStartMarker();
    this.expectKeyword(W.While), this.expectPunctuator("(");
    const n = this.captureStartMarker(), i = this.parseExpression(), r = this.captureStartMarker();
    this.expectPunctuator(")"), (i.type === g.AssignmentExpression || i.type === g.UpdateExpression) && this.throwError(F.InvalidExpression, n, r);
    const s = this.withBlockContext(fe.WhileLoop, this.parseStatement.bind(this));
    return this.finalize({
      type: g.WhileStatement,
      test: i,
      body: s,
      ...this.getItemLocation(e)
    });
  }
  parseForStatement() {
    let e = g.ForStatement, n = null, i = null, r = null, s = null, a = null;
    const o = this.captureStartMarker();
    if (this.expectKeyword(W.For), this.expectPunctuator("("), this.matchKeyword(W.Var)) {
      const c = this.captureStartMarker();
      this.readNextRawToken();
      const d = this.parseVariableDeclarators();
      n = this.finalize({
        type: g.VariableDeclaration,
        declarations: d,
        kind: "var",
        ...this.getItemLocation(c)
      });
      const h = this.matchKeyword(W.In), f = this.matchContextualKeyword(qn.Of);
      d.length === 1 && (h || f) && (d[0].init && this.throwError(F.ForInOfLoopInitializer, c), e = h ? g.ForInStatement : g.ForOfStatement, s = n);
    } else if (!this.matchPunctuator(";")) {
      const c = this.context.isAssignmentTarget, d = this.captureStartMarker();
      n = this.inheritCoverGrammar(this.parseAssignmentExpression.bind(this));
      const h = this.matchKeyword(W.In), f = this.matchContextualKeyword(qn.Of);
      h || f ? (this.context.isAssignmentTarget || this.tolerateError(F.InvalidLeftHandSideInForIn, d), n.type !== g.Identifier && this.throwError(F.InvalidLeftHandSideInForIn, d), e = h ? g.ForInStatement : g.ForOfStatement, s = n) : this.context.isAssignmentTarget = c;
    }
    e === g.ForStatement ? (this.expectPunctuator(";"), i = this.matchPunctuator(";") ? null : this.isolateCoverGrammar(this.parseExpression.bind(this)), this.expectPunctuator(";"), r = this.matchPunctuator(")") ? null : this.isolateCoverGrammar(this.parseExpression.bind(this))) : (this.readNextRawToken(), a = this.parseExpression()), this.expectPunctuator(")");
    const l = this.withBlockContext(
      e === g.ForOfStatement ? fe.ForOfLoop : fe.ForLoop,
      () => this.isolateCoverGrammar(this.parseStatement.bind(this))
    );
    return e === g.ForInStatement || e === g.ForOfStatement ? this.finalize({
      type: e,
      left: s,
      right: a,
      body: l,
      ...this.getItemLocation(o)
    }) : this.finalize({
      type: e,
      init: n,
      test: i,
      update: r,
      body: l,
      ...this.getItemLocation(o)
    });
  }
  parseContinueStatement() {
    const e = this.captureStartMarker();
    return this.expectKeyword(W.Continue), this.consumeSemicolon(), this.finalize({ type: g.ContinueStatement, ...this.getItemLocation(e) });
  }
  parseBreakStatement() {
    const e = this.captureStartMarker();
    return this.expectKeyword(W.Break), this.consumeSemicolon(), this.finalize({ type: g.BreakStatement, ...this.getItemLocation(e) });
  }
  parseReturnStatement() {
    const e = this.captureStartMarker();
    this.expectKeyword(W.Return);
    const n = !this.matchPunctuator(";") && !this.matchPunctuator("}") && !this.hasLineTerminator && this.rawToken.type !== S.EOF || this.rawToken.type === S.StringLiteral || this.rawToken.type === S.Template ? this.parseExpression() : null;
    return this.consumeSemicolon(), this.finalize({ type: g.ReturnStatement, argument: n, ...this.getItemLocation(e) });
  }
  parseStatement() {
    switch (this.rawToken.type) {
      case S.BooleanLiteral:
      case S.NullLiteral:
      case S.NumericLiteral:
      case S.StringLiteral:
      case S.Template:
      case S.Identifier:
        return this.parseExpressionStatement();
      case S.Punctuator:
        return this.rawToken.value === "{" ? this.parseBlockOrObjectStatement() : this.rawToken.value === "(" ? this.parseExpressionStatement() : this.rawToken.value === ";" ? this.parseEmptyStatement() : this.parseExpressionStatement();
      case S.Keyword:
        switch (this.rawToken.value.toLowerCase()) {
          case W.Break:
            return this.parseBreakStatement();
          case W.Continue:
            return this.parseContinueStatement();
          case W.For:
            return this.parseForStatement();
          case W.Function:
            return this.parseFunctionDeclaration();
          case W.If:
            return this.parseIfStatement();
          case W.Return:
            return this.parseReturnStatement();
          case W.Var:
            return this.parseVariableDeclaration();
          case W.While:
            return this.parseWhileStatement();
          default:
            return this.parseExpressionStatement();
        }
      default:
        return this.throwUnexpectedToken({ rawToken: this.rawToken });
    }
  }
  parseFormalParameters() {
    const e = [];
    if (this.expectPunctuator("("), !this.matchPunctuator(")"))
      for (; this.rawToken.type !== S.EOF; ) {
        const n = this.parseIdentifier();
        if (n || this.throwUnexpectedToken({ rawToken: this.rawToken, code: F.IdentifierExpected }), e.push(n), this.matchPunctuator(")") || (this.expectPunctuator(","), this.matchPunctuator(")")))
          break;
      }
    return this.expectPunctuator(")"), e;
  }
  parseFunctionDeclaration() {
    (this.context.blockContext & fe.Function) === fe.Function && this.throwUnexpectedToken({ code: F.NoFunctionInsideFunction }), ((this.context.blockContext & fe.WhileLoop) === fe.WhileLoop || (this.context.blockContext & fe.ForOfLoop) === fe.ForOfLoop || (this.context.blockContext & fe.IfClause) === fe.IfClause) && this.throwUnexpectedToken({ code: F.NoFunctionInsideBlock });
    const e = this.captureStartMarker();
    this.expectKeyword(W.Function);
    const n = this.parseIdentifier();
    n || this.throwUnexpectedToken({ code: F.InvalidFunctionIdentifier });
    const i = this.parseFormalParameters(), r = this.context.blockContext;
    this.context.blockContext |= fe.Function;
    const s = this.parseBlock();
    return this.context.blockContext = r, this.finalize({
      type: g.FunctionDeclaration,
      id: n,
      params: i,
      body: s,
      ...this.getItemLocation(e)
    });
  }
  parseScript() {
    const e = this.captureStartMarker(), n = this.parseStatements(), i = this.finalize({
      type: g.Program,
      body: n,
      ...this.getItemLocation(e)
    });
    return this.options.tokens && (i.tokens = this.tokens), this.options.tolerant && (i.errors = this.errorHandler.errors), i;
  }
  parseExportDeclaration() {
    this.context.blockContext !== fe.None && this.throwUnexpectedToken({ code: F.ModuleExportRootOnly });
    let e = null;
    const n = this.captureStartMarker();
    return this.expectKeyword(W.Export), this.matchKeyword(W.Var) ? e = this.parseVariableDeclaration() : this.matchKeyword("function") ? e = this.parseFunctionDeclaration() : this.throwUnexpectedToken({ code: F.InvalidExpression }), this.finalize({
      type: g.ExportNamedDeclaration,
      declaration: e,
      specifiers: [],
      source: null,
      ...this.getItemLocation(n)
    });
  }
  // The module specified part of a import XX from 'MODULESPECIFIER'
  parseModuleSpecifier() {
    const e = this.captureStartMarker(), n = this.rawToken;
    if (n.type === S.StringLiteral)
      return this.readNextRawToken(), this.finalize({
        type: g.Literal,
        value: n.value,
        raw: this.getSourceValue(n),
        isString: !0,
        ...this.getItemLocation(e)
      });
    this.throwError(F.InvalidModuleUri, e);
  }
  parseDefaultSpecifier() {
    const e = this.captureStartMarker(), n = this.parseIdentifier();
    return n || this.throwUnexpectedToken({ code: F.IdentifierExpected }), this.finalize({
      type: g.ImportDefaultSpecifier,
      local: n,
      ...this.getItemLocation(e)
    });
  }
  parseImportDeclaration() {
    this.context.blockContext !== fe.None && this.throwUnexpectedToken({ code: F.ModuleImportRootOnly });
    const e = this.captureStartMarker();
    this.expectKeyword(W.Import);
    const n = this.parseDefaultSpecifier();
    this.expectContextualKeyword(qn.From);
    const i = this.parseModuleSpecifier();
    return this.finalize({
      type: g.ImportDeclaration,
      specifiers: [n],
      source: i,
      ...this.getItemLocation(e)
    });
  }
}
class Wc {
  constructor(e, n) {
    this.errorHandler = new _o(), this.errorHandler.tolerant = n ? typeof n.tolerant == "boolean" && n.tolerant : !1, this.scanner = new Fo(e, this.errorHandler), this.trackComments = n ? typeof n.comment == "boolean" && n.comment : !1, this.buffer = [];
  }
  errors() {
    return this.errorHandler.errors;
  }
  /**
   * Used by the exposed method 'tokenize'
   */
  getNextToken() {
    if (this.buffer.length === 0) {
      const e = this.scanner.scanComments();
      if (this.trackComments && e.forEach((n) => {
        const i = this.scanner.source.slice(n.start, n.end), r = {
          type: n.multiLine ? g.BlockComment : g.LineComment,
          value: i,
          range: n.range,
          loc: n.loc
        };
        this.buffer.push(r);
      }), !this.scanner.eof()) {
        const n = {
          line: this.scanner.lineNumber,
          column: this.scanner.index - this.scanner.lineStart
        }, i = this.scanner.lex(), r = {
          line: this.scanner.lineNumber,
          column: this.scanner.index - this.scanner.lineStart
        }, s = {
          type: Ao[i.type],
          value: this.scanner.source.slice(i.start, i.end),
          range: [i.start, i.end],
          loc: { start: n, end: r }
        };
        this.buffer.push(s);
      }
    }
    return this.buffer.shift();
  }
}
function yo(t, e, n) {
  return new zc(t, e, n).parseScript();
}
function Oc(t, e, n) {
  const i = new Wc(t, e), r = [];
  let s;
  try {
    let a;
    for (; a = i.getNextToken(); )
      n && (a = n(a)), r.push(a);
  } catch (a) {
    a instanceof Error && i.errorHandler.tolerate(a);
  }
  return i.errorHandler.tolerant && (s = i.errors()), { tokens: r, errors: s };
}
const P = {
  AlreadyDefined: "AlreadyDefined",
  ApiConflict: "ApiConflict",
  AssignedNeverUsed: "AssignedNeverUsed",
  DefinedNeverAssigned: "DefinedNeverAssigned",
  DefinedNeverUsed: "DefinedNeverUsed",
  EmptyBlockStatement: "EmptyBlockStatement",
  ExecutionError: "ExecutionError",
  InvalidApiFunctionUsage: "InvalidApiFunctionUsage",
  InvalidConstantIdentifier: "InvalidConstantIdentifier",
  InvalidPropertyIdentifier: "InvalidPropertyIdentifier",
  NoArgumentExpected: "NoArgumentExpected",
  NotADictionary: "NotADictionary",
  NotDefined: "NotDefined",
  NotEnoughArguments: "NotEnoughArguments",
  ProfileVariablesAreImmutable: "ProfileVariablesAreImmutable",
  ProfileVariablesConflict: "ProfileVariablesConflict",
  ReservedKeyword: "ReservedKeyword",
  TooManyArguments: "TooManyArguments",
  UnexpectedEmptyFunction: "UnexpectedEmptyFunction",
  UnexpectedPropertyIdentifier: "UnexpectedPropertyIdentifier",
  UnknownPropertyIdentifier: "UnknownPropertyIdentifier"
}, Hc = {
  [P.AlreadyDefined]: "'${identifier}' is already defined.",
  [P.ApiConflict]: "'${identifier}' is already defined as an Arcade constant or function.",
  [P.AssignedNeverUsed]: "'${identifier}' is assigned but never used.",
  [P.DefinedNeverAssigned]: "'${identifier}' is defined but never assigned.",
  [P.DefinedNeverUsed]: "'${identifier}' is defined but never used.",
  [P.EmptyBlockStatement]: "Empty block statement.",
  [P.ExecutionError]: "Execution Error: '${stack}'",
  [P.InvalidApiFunctionUsage]: "Arcade function '${identifier}' not used in a call expression.",
  [P.InvalidConstantIdentifier]: "Invalid constant identifier, expecting ${list}.",
  [P.InvalidPropertyIdentifier]: "Invalid property identifier, expecting ${list}.",
  [P.NoArgumentExpected]: "Expecting no argument.",
  [P.NotADictionary]: "'${identifier}' doesn't have properties.",
  [P.NotDefined]: "'${identifier}' is not defined.",
  [P.NotEnoughArguments]: "Expecting at least ${min} argument(s).",
  [P.ProfileVariablesAreImmutable]: "Profile variables cannot be modified.",
  [P.ProfileVariablesConflict]: "'${identifier}' is already defined as a profile variable.",
  [P.ReservedKeyword]: "'${identifier}' is a reserved keyword.",
  [P.TooManyArguments]: "Too many arguments, expecting ${max}.",
  [P.UnexpectedEmptyFunction]: "Unexpected empty function '${identifier}'.",
  [P.UnexpectedPropertyIdentifier]: "Unexpected property identifier.",
  [P.UnknownPropertyIdentifier]: "Unknown property identifier '${identifier}'.",
  ...wo
};
function _n(t, e) {
  return t.line - e.line || t.column - e.column;
}
function jc(t, e) {
  const n = {
    start: t.loc.start,
    end: t.loc.end
  }, i = (r) => Gc(n, r.loc);
  return _n(n.start, n.end) < 0 && (n.start = { ...n.start }, e.skipSpaces(n.start), _n(n.start, n.end) < 0 && (n.end = { ...n.end }, e.skipSpaces(n.end, !0))), t.leadingComments?.forEach(i), t.trailingComments?.forEach(i), n;
}
function Gc(t, e) {
  _n(e.start, t.start) < 0 && (t.start = e.start), _n(t.end, e.end) < 0 && (t.end = e.end);
}
const Xc = /\S/u;
function Ot(t = "") {
  return !Xc.test(t);
}
const Hn = {
  indentWidth: 2,
  wrapColumn: 80,
  quote: null
};
function qi(t) {
  return {
    indentWidth: t?.indentWidth ?? Hn.indentWidth,
    wrapColumn: t?.wrapColumn ?? Hn.wrapColumn,
    quote: t?.quote ?? Hn.quote
  };
}
const Jc = /^\s*/u, Qc = /\u000D\u000A|\u000D(?!\u000A)|\u000A|\u2028|\u2029/u;
class Fn {
  // private cachedIndentWidth: number | void = void 0;
  constructor(e) {
    this.lineRecords = e, this.length = e.length;
  }
  // private static emptyLines = this.fromString("");
  static fromString(e, n) {
    if (typeof e != "string")
      return e;
    const i = n?.indentWidth;
    return new Fn(
      e.split(Qc).map((r) => {
        const s = Jc.exec(r)?.[0] ?? "";
        return {
          line: r,
          indentation: Yc(s, i),
          // Boolean indicating whether this line can be re-indented.
          locked: !1,
          sliceStart: s.length,
          sliceEnd: r.length
        };
      })
    );
  }
  toString() {
    return this.sliceString(this.firstPos(), this.lastPos());
  }
  charAt(e) {
    const { line: n, column: i } = e, r = this.lineRecords[n - 1];
    if (typeof r > "u" || i < 0)
      return "";
    const s = this.getIndentationAt(n);
    if (i < s)
      return " ";
    const a = i + r.sliceStart - s;
    return a === r.sliceEnd && n < this.length ? `
` : a >= r.sliceEnd ? "" : r.line.charAt(a);
  }
  getIndentationAt(e) {
    return Math.max(this.lineRecords[e - 1].indentation, 0);
  }
  getLineLength(e) {
    const n = this.lineRecords[e - 1];
    return this.getIndentationAt(e) + n.sliceEnd - n.sliceStart;
  }
  getStatementLineSeparators(e) {
    const n = this.slice(e, this.skipSpaces({ ...e }) ?? this.lastPos());
    return n.length === 1 || !Ot(n.lineRecords[1].line) ? [`
`] : [`
`, `
`];
  }
  getLeadingCommentSeparators(e) {
    const n = this.slice(e, this.skipSpaces({ ...e }) ?? this.lastPos());
    return n.length === 1 ? [" "] : Ot(n.lineRecords[1].line) ? [`
`, `
`] : [`
`];
  }
  nextPos(e, n = !1) {
    const i = Math.max(e.line, 0);
    return Math.max(e.column, 0) < this.getLineLength(i) ? (e.column += 1, n ? !!this.skipSpaces(e) : !0) : i < this.length ? (e.line += 1, e.column = 0, n ? !!this.skipSpaces(e) : !0) : !1;
  }
  prevPos(e, n = !1) {
    let i = e.line, r = e.column;
    if (r < 1) {
      if (i -= 1, i < 1)
        return !1;
      r = this.getLineLength(i);
    } else
      r = Math.min(r - 1, this.getLineLength(i));
    return e.line = i, e.column = r, n ? !!this.skipSpaces(e, !0) : !0;
  }
  firstPos() {
    return { line: 1, column: 0 };
  }
  lastPos() {
    return {
      line: this.length,
      column: this.getLineLength(this.length)
    };
  }
  skipSpaces(e, n = !1) {
    if (n) {
      for (; this.prevPos(e); )
        if (!Ot(this.charAt(e)) && this.nextPos(e))
          return e;
      return null;
    } else {
      for (; Ot(this.charAt(e)); )
        if (!this.nextPos(e))
          return null;
      return e;
    }
  }
  slice(e, n) {
    if (!n && !e)
      return this;
    if (n ??= this.lastPos(), !e)
      throw new Error("cannot slice with end but not start");
    const i = this.lineRecords.slice(e.line - 1, n.line);
    return e.line === n.line ? i[0] = ct(i[0], e.column, n.column) : (i[0] = ct(i[0], e.column), i.push(ct(i.pop() ?? i[0], 0, n.column))), new Fn(i);
  }
  sliceString(e = this.firstPos(), n = this.lastPos()) {
    const i = [];
    for (let r = e.line; r <= n.line; r++) {
      let s = this.lineRecords[r - 1];
      r === e.line ? r === n.line ? s = ct(s, e.column, n.column) : s = ct(s, e.column) : r === n.line && (s = ct(s, 0, n.column));
      let a = "";
      const o = Math.max(s.indentation, 0);
      o > 0 && (a += new Array(o + 1).join(" ")), a += s.line.slice(s.sliceStart, s.sliceEnd), i.push(a);
    }
    return i.join(`
`);
  }
}
function Yc(t, e = 2) {
  let n = 0;
  const i = t.length;
  for (let r = 0; r < i; r++)
    switch (t.charCodeAt(r)) {
      case 9: {
        const s = Math.ceil(n / e) * e;
        s === n ? n += e : n = s;
        break;
      }
      case 11:
      // '\v'
      case 12:
      // '\f'
      case 13:
      // '\r'
      case 65279:
        break;
      case 32:
      // ' '
      default:
        n += 1;
        break;
    }
  return n;
}
function ct(t, e, n) {
  let i = t.sliceStart, r = t.sliceEnd, s = Math.max(t.indentation, 0);
  const a = s + r - i;
  return n ??= a, e = Math.max(e, 0), n = Math.min(n, a), n = Math.max(n, e), n < s ? (s = n, r = i) : r -= a - n, e < s ? s -= e : (e -= s, s = 0, i += e), t.indentation === s && t.sliceStart === i && t.sliceEnd === r ? t : {
    line: t.line,
    indentation: s,
    sliceStart: i,
    sliceEnd: r
  };
}
function $a(t, e, n) {
  return !t && !n ? "" : t ? n ? `${t}${e}${n}` : t : n;
}
const Zc = /\u000D\u000A|\u000D(?!\u000A)|\u000A|\u2028|\u2029/u;
class I {
  constructor(e = []) {
    this.lines = e;
  }
  static fromString(e) {
    return new I(e.split(Zc));
  }
  /**
   * Append the elements lines together into a new FormattedLines.
   * [ [a, b], c, [ d, e]] => [a, b, c, d, e]
   * @param elements
   * @returns
   */
  static appendLines(e = []) {
    const n = new I();
    return e.forEach((i) => {
      i != null && (typeof i == "string" ? n.lines.push(i) : n.lines.push(...i.lines));
    }), n;
  }
  /**
   * Join the last line of each element to the first line of the next element.
   * [ [a, b], c, [ d, e]] => [a, bcd, e]
   * With separator:
   * [ [a, b], c, [ d, e]] => [a, b<sep>c<sep>d, e]
   * @param elements
   * @returns
   */
  static joinLines(e = [], n = "") {
    const i = new I();
    return e.forEach((r) => {
      if (r == null)
        return;
      const s = i.lines.pop() ?? "";
      typeof r == "string" ? i.lines.push($a(s, n, r)) : (i.lines.push($a(s, n, r.lines.slice(0)[0])), i.lines.push(...r.lines.slice(1)));
    }), i;
  }
  /**
   * Aggregates formatted lines coming from two expressions, statements, or comments.
   * Use the location of each to figure out if they are on the same line or different lines.
   * Also reduce the number of empty lines.
   * @param previousFormattedLines
   * @param previousLocation
   * @param formattedLines
   * @param location
   * @param indentation
   * @returns
   */
  static aggregateLines(e, n, i, r, s) {
    if (i.isEmpty)
      return e;
    if (!n || e.isEmpty)
      return i.indentFirstLine(s);
    const a = r.start.line - n.end.line;
    if (a === 0)
      return I.joinLines([e, " ", i]);
    const o = a === 1 ? void 0 : "";
    return I.appendLines([e, o, i.indentFirstLine(s)]);
  }
  get isEmpty() {
    return this.lines.length === 0 || this.lines.length === 1 && this.lines[0].length === 0;
  }
  get maxLineLength() {
    return this.lines.reduce((e, n) => Math.max(e, n.length), 0);
  }
  get firstLineLength() {
    return (this.lines[0] ?? "").length;
  }
  get lastLineLength() {
    return (this.lines[this.lines.length - 1] ?? "").length;
  }
  surroundWith(e = "", n = "") {
    return !e && !n ? this : this.isEmpty ? new I([e + n]) : this.lines.length === 1 ? new I([e + this.lines[0] + n]) : I.joinLines([e, this, n]);
  }
  indentFirstLine(e = "") {
    return this.isEmpty ? this : (this.lines[0] = e + this.lines[0], this);
  }
  suffixWith(e) {
    return this.surroundWith("", e);
  }
  toString(e = `
`) {
    return this.lines.join(e);
  }
}
function zi(t, e) {
  return t * (e.indentWidth ?? 2);
}
function nt(t = 0, e) {
  const { indentWidth: n = 2 } = qi(e);
  return new Array(t * n + 1).join(" ");
}
function Ht(t) {
  return t.replace(/['"]/gu, (e) => e === '"' ? "'" : '"');
}
function Kc(t, e) {
  switch (t.type) {
    case g.UnaryExpression:
      return Ba(e) && e.object === t;
    case g.BinaryExpression:
    case g.LogicalExpression:
      switch (e.type) {
        case g.UnaryExpression:
          return !0;
        case g.MemberExpression:
          return e.object === t;
        case g.BinaryExpression:
        case g.LogicalExpression:
          return wn[e.operator] > wn[t.operator];
        default:
          return !1;
      }
    case g.Literal:
      return Ba(e) && typeof t.value == "number" && e.object === t;
    case g.AssignmentExpression:
      switch (e.type) {
        case g.UnaryExpression:
        case g.BinaryExpression:
        case g.LogicalExpression:
        case g.ReturnStatement:
          return !0;
        case g.MemberExpression:
          return e.object === t;
        default:
          return !1;
      }
    default:
      return !1;
  }
}
function J(t, e, n) {
  switch (t?.type) {
    case g.BinaryExpression:
    case g.LogicalExpression:
      return e1(t, e, n);
    case g.AssignmentExpression:
      return new Wi(t, e, n);
    case g.MemberExpression:
      return new ko(t, e, n);
    case g.Identifier:
      return new yi(t, e, n);
    case g.CallExpression:
      return new n1(t, e, n);
    case g.ObjectExpression:
      return it(t, e, n);
    case g.ArrayExpression:
      return it(t, e, n);
    case g.Literal:
      return new yi(t, e, n);
    case g.UpdateExpression:
    case g.UnaryExpression:
      return new No(t, e, n);
    case g.TemplateLiteral:
      return new r1(t, e, n);
    case g.VariableDeclaration:
      return new Si(t, e, n);
    default:
      throw new Error(`unknown type: ${JSON.stringify(t)}`);
  }
}
function it(t, e, n) {
  const i = new kn(t, e, n);
  switch (t.type) {
    case g.ArrayExpression:
      return i.setupCollection(
        t.elements.map((r) => J(r, t, n)),
        "SquareBrackets"
      ), i;
    case g.ObjectExpression:
      return i.setupCollection(
        t.properties.map((r) => new i1(r, t, n)),
        "CurlyBrackets"
      ), i;
    case g.VariableDeclaration:
      return i.prefix = "var ", i.setupCollection(
        t.declarations.map((r) => So(r, t, n)),
        "None"
      ), i;
    case g.FunctionDeclaration:
      return i.prefix = `function ${t.id.name}`, i.setupCollection(
        t.params.map((r) => J(r, t, n)),
        "Parentheses"
      ), i;
    case g.ForStatement:
      return i.prefix = "for ", i.setupCollection(
        [
          J(t.init, t, n),
          J(t.test, t, n),
          J(t.update, t, n)
        ],
        "Parentheses",
        ";"
      ), i;
    case g.ForInStatement:
    case g.ForOfStatement:
      return i.prefix = "for ", i.setupCollection([new Wi(t, e, n)], "Parentheses", ""), i;
    case g.IfStatement:
      return i.prefix = "if ", i.setupCollection([J(t.test, t, n)], "Parentheses", ""), i;
    case g.WhileStatement:
      return i.prefix = "while ", i.setupCollection([J(t.test, t, n)], "Parentheses", ""), i;
    default:
      return i;
  }
}
function So(t, e, n) {
  return t.init ? new Wi(t, e, n) : new yi(t.id, e, n);
}
function e1(t, e, n) {
  const i = [
    ...yn(t.left, t.operator),
    ...yn(t.right, t.operator)
  ].map((s) => J(s, t, n)), r = new kn(t, e, n);
  return r.setupCollection(i, "None", ` ${t.operator}`), r;
}
function yn(t, e) {
  return t.type !== g.BinaryExpression && t.type !== g.LogicalExpression ? [t] : t.operator !== e ? [t] : [
    ...yn(t.left, e),
    ...yn(t.right, e)
  ];
}
class $e {
  constructor(e, n, i) {
    this.node = e, this.parent = n, this.options = i, this.prefix = "", this.suffix = "", this.groupingParentheses = !1, this.groupingParentheses = Kc(e, n);
  }
  get openingParenthesis() {
    return this.groupingParentheses ? "(" : "";
  }
  get closingParenthesis() {
    return this.groupingParentheses ? ")" : "";
  }
  get leadingString() {
    return [this.prefix, this.openingParenthesis].join("");
  }
  get trailingString() {
    return [this.closingParenthesis, this.suffix].join("");
  }
  finalize(e) {
    return typeof e == "string" && (e = I.fromString(e)), e.surroundWith(this.leadingString, this.trailingString);
  }
}
class kn extends $e {
  constructor(e, n, i) {
    super(e, n, i), this.node = e, this.parent = n, this.options = i, this.type = "CollectionPrinter", this.bracketsType = "None", this.separator = ",", this.printers = [];
  }
  setupCollection(e = [], n = "None", i) {
    return this.bracketsType = n, this.separator = i ?? this.separator, this.printers = e, this;
  }
  getOpeningBracket(e = !1, n = "singleLine") {
    if (this.bracketsType === "None")
      return "";
    if (this.bracketsType === "CurlyBrackets")
      return `{${e || n === "multiline" ? "" : " "}`;
    switch (this.bracketsType) {
      case "Parentheses":
        return "(";
      case "SquareBrackets":
        return "[";
      default:
        return "";
    }
  }
  getClosingBracket(e = !1, n = "singleLine") {
    if (this.bracketsType === "None")
      return "";
    if (this.bracketsType === "CurlyBrackets")
      return `${e || n === "multiline" ? "" : " "}}`;
    switch (this.bracketsType) {
      case "Parentheses":
        return ")";
      case "SquareBrackets":
        return "]";
      default:
        return "";
    }
  }
  getLinesLevel(e = 0) {
    return this.bracketsType !== "None" || Pc(this.parent) || vo(this.parent) || (_i(this.node) || vi(this.node)) && (_i(this.parent) || vi(this.parent)) ? e + 1 : e;
  }
  finalize(e, n = "singleLine", i = 0) {
    if (this.bracketsType === "None")
      return super.finalize(e);
    const r = this.getOpeningBracket(e.isEmpty, n), s = this.getClosingBracket(e.isEmpty, n);
    if (n === "singleLine")
      return super.finalize(e.surroundWith(r, s));
    const a = nt(i, this.options);
    return super.finalize(I.appendLines([r, e, a + s]));
  }
  singleLineFormat(e = 0) {
    const n = this.printers.length - 1;
    return I.joinLines(
      this.printers.map(
        (i, r) => i.format("singleLine", e).suffixWith(r < n ? this.separator : "")
      ),
      " "
    );
  }
  optimizedPrinterFormat(e, n, i = 0) {
    const r = this.getLinesLevel(i), s = nt(r, this.options), a = this.bracketsType === "None" && n === 0 ? "" : s, o = n < this.printers.length - 1 ? this.separator : "", l = e.format("singleLine", r).suffixWith(o);
    return l.maxLineLength + s.length <= this.options.wrapColumn ? l.indentFirstLine(a) : e.format("multiline", r).suffixWith(o).indentFirstLine(a);
  }
  multilineFormat(e = 0) {
    return I.appendLines(
      this.printers.map((n, i) => this.optimizedPrinterFormat(n, i, e))
    );
  }
  format(e = "singleLine", n = 0) {
    if (this.printers.length === 0) {
      const r = this.getOpeningBracket(!0, e), s = this.getClosingBracket(!0, e);
      return super.finalize(I.fromString(r + s));
    }
    if (e === "singleLine") {
      const r = this.singleLineFormat(n);
      return this.finalize(r, e, n);
    }
    const i = this.multilineFormat(n);
    return this.finalize(i, e, n);
  }
}
const t1 = /^[a-zA-Z_$][a-zA-Z_$0-9]*$/u;
class yi extends $e {
  constructor(e, n, i) {
    super(e, n, i), this.node = e, this.parent = n, this.options = i, this.type = "StringPrinter";
  }
  format() {
    if (Ne(this.node))
      return this.finalize(this.node.name);
    if (typeof this.node.value != "string")
      return this.finalize(this.node.raw);
    if (Vc(this.parent) && this.parent.key === this.node && Lo(this.node) && typeof this.node.value == "string" && t1.test(this.node.value))
      return this.finalize(this.node.value);
    switch (this.options.quote) {
      case "auto": {
        const e = JSON.stringify(this.node.value), n = Ht(JSON.stringify(Ht(this.node.value)));
        return this.finalize(e.length > n.length ? n : e);
      }
      case "single":
        return this.finalize(Ht(JSON.stringify(Ht(this.node.value))));
      default:
        return this.finalize(JSON.stringify(this.node.value));
    }
  }
}
class No extends $e {
  constructor(e, n, i) {
    super(e, n, i), this.node = e, this.parent = n, this.options = i, this.type = "SingleExpressionPrinter";
    const r = Tc(e), s = Uc(e);
    if (r || s) {
      this.prefix = r ? e.operator : "", this.suffix = s && !e.prefix ? e.operator : "", this.printer = J(e.argument, e, this.options);
      return;
    }
    this.printer = J(e, n, this.options);
  }
  format(e = "singleLine", n = 0) {
    return this.finalize(this.printer.format(e, n));
  }
}
class Si extends $e {
  constructor(e, n, i) {
    super(e, n, i), this.node = e, this.parent = n, this.options = i, this.type = "VariableDeclaratorsPrinter", e.declarations.length === 1 ? (this.printer = So(e.declarations[0], e, this.options), this.printer.prefix = "var ") : this.printer = it(e, n, this.options);
  }
  format(e = "singleLine", n = 0) {
    return this.finalize(this.printer.format(e, n));
  }
}
class n1 extends $e {
  constructor(e, n, i) {
    super(e, n, i), this.node = e, this.parent = n, this.options = i, this.type = "CallExpressionPrinter", this.argumentsPrinter = new kn(e, n, i), this.argumentsPrinter.setupCollection(
      e.arguments.map((r) => J(r, e, i)),
      "Parentheses"
    ), Ne(e.callee) ? this.argumentsPrinter.prefix = e.callee.name : this.memberExpressionPrinter = new ko(e.callee, n, i);
  }
  format(e = "singleLine", n = 0) {
    if (!this.memberExpressionPrinter)
      return this.finalize(this.argumentsPrinter.format(e, n));
    let i = this.memberExpressionPrinter.format("singleLine", n), r = this.argumentsPrinter.format("singleLine", n);
    if (e === "singleLine")
      return this.finalize(I.joinLines([i, r]));
    let s = zi(n, this.options) + this.leadingString.length + i.firstLineLength;
    return s + 1 < this.options.wrapColumn ? (r = this.argumentsPrinter.format("multiline", n), this.finalize(I.joinLines([i, r]))) : (i = this.memberExpressionPrinter.format("multiline", n), s = i.lastLineLength, s + r.maxLineLength > this.options.wrapColumn && (r = this.argumentsPrinter.format("multiline", n + 1)), this.finalize(I.joinLines([i, r])));
  }
}
class ko extends $e {
  constructor(e, n, i) {
    if (super(e, n, i), this.node = e, this.parent = n, this.options = i, this.type = "MemberExpressionPrinter", this.objectPrinter = J(e.object, e, this.options), e.computed) {
      const r = new kn(e.property, e, this.options);
      r.setupCollection([J(e.property, e, this.options)], "SquareBrackets"), this.propertyPrinter = r;
    } else {
      const r = new No(e.property, e, this.options);
      r.prefix = ".", this.propertyPrinter = r;
    }
  }
  format(e = "singleLine", n = 0) {
    let i = this.objectPrinter.format("singleLine", n), r = this.propertyPrinter.format("singleLine", n);
    if (e === "singleLine")
      return this.finalize(I.joinLines([i, r]));
    let s = zi(n, this.options) + this.leadingString.length + i.firstLineLength;
    s > this.options.wrapColumn && (i = this.objectPrinter.format("multiline", n), s = i.lastLineLength);
    let a = r.firstLineLength + this.trailingString.length;
    if (s + a < this.options.wrapColumn)
      return this.finalize(I.joinLines([i, r]));
    if (this.node.computed)
      return this.finalize(I.joinLines([i, this.propertyPrinter.format("multiline", n)]));
    const o = n + 1, l = nt(o, this.options);
    return r = this.propertyPrinter.format("singleLine", n), a = l.length + r.lastLineLength + this.trailingString.length, a > this.options.wrapColumn && (r = this.propertyPrinter.format("multiline", o)), this.finalize(I.appendLines([i, r.indentFirstLine(l)]));
  }
}
class i1 extends $e {
  constructor(e, n, i) {
    super(e, n, i), this.node = e, this.parent = n, this.options = i, this.type = "PropertyPrinter", this.key = J(e.key, e, this.options), e.shorthand || (this.key.suffix = ":", this.value = J(e.value, e, this.options));
  }
  format(e = "singleLine", n = 0) {
    if (this.node.shorthand || !this.value)
      return this.finalize(this.key.format(e, n));
    const i = this.key.format("singleLine", n);
    if (e === "singleLine") {
      const a = this.value.format("singleLine", n);
      return this.finalize(I.joinLines([i, a], " "));
    }
    if (vn(this.node.value) || vn(this.node.value)) {
      const a = this.value.format("multiline", n);
      return this.finalize(I.joinLines([i, a], " "));
    }
    const r = nt(n + 1, this.options);
    let s = this.value.format("singleLine", n + 1).indentFirstLine(r);
    return s.maxLineLength + this.trailingString.length + 1 <= this.options.wrapColumn ? this.finalize(I.appendLines([i, s])) : (s = this.value.format("multiline", n + 1).indentFirstLine(r), this.finalize(I.appendLines([i, s])));
  }
}
class Wi extends $e {
  constructor(e, n, i) {
    switch (super(e, n, i), this.node = e, this.parent = n, this.options = i, this.type = "OperationPrinter", this.operator = "", this.noNewLineWrapping = !1, e.type) {
      case g.AssignmentExpression:
        this.leftPrinter = J(e.left, e, this.options), this.operator = ` ${e.operator}`, this.rightPrinter = J(e.right, e, this.options), this.noNewLineWrapping = (Ne(e.left) || Lo(e.left)) && (vn(e.right) || ka(e.right));
        return;
      case g.VariableDeclarator:
        this.leftPrinter = J(e.id, e, this.options), e.init && (this.operator = " =", this.rightPrinter = J(e.init, e, this.options)), this.noNewLineWrapping = vn(e.init) || ka(e.init);
        return;
      case g.ForInStatement:
      case g.ForOfStatement:
        this.leftPrinter = J(e.left, e, this.options), this.operator = e.type === "ForInStatement" ? " in" : " of", this.rightPrinter = J(e.right, e, this.options);
        return;
      case g.BinaryExpression:
      case g.LogicalExpression:
        this.leftPrinter = J(e.left, e, this.options), this.operator = ` ${e.operator}`, this.rightPrinter = J(e.right, e, this.options);
        return;
    }
  }
  format(e = "singleLine", n = 0) {
    if (!this.rightPrinter)
      return this.finalize(this.leftPrinter.format(e, n));
    let i = this.leftPrinter.format("singleLine", n).suffixWith(this.operator), r = this.rightPrinter.format("singleLine", n);
    if (e === "singleLine")
      return this.finalize(I.joinLines([i, r], " "));
    let s = zi(n, this.options) + this.leadingString.length + i.maxLineLength + 1;
    s > this.options.wrapColumn && (i = this.leftPrinter.format("multiline", n).suffixWith(this.operator), s = i.lastLineLength + 1);
    const a = r.firstLineLength + this.trailingString.length + 1;
    if (s + a < this.options.wrapColumn)
      return this.finalize(I.joinLines([i, r], " "));
    const o = this.rightPrinter.format("multiline", n);
    return o.firstLineLength + this.trailingString.length + 1 + s < this.options.wrapColumn || this.noNewLineWrapping ? this.finalize(I.joinLines([i, o], " ")) : (a > this.options.wrapColumn && (r = this.rightPrinter.format("multiline", n + 1)), r = r.indentFirstLine(nt(n + 1)), this.finalize(I.appendLines([i, r])));
  }
}
class r1 extends $e {
  constructor(e, n, i) {
    super(e, n, i), this.node = e, this.parent = n, this.options = i, this.type = "TemplateLiteralPrinter", this.parts = [];
    const r = e.expressions.map(
      (s) => J(s, e, this.options)
    );
    this.parts.push("`"), e.quasis.forEach((s, a) => {
      this.parts.push(s.value.raw), a < r.length && (this.parts.push("${"), this.parts.push(r[a]), this.parts.push("}"));
    }), this.parts.push("`");
  }
  format(e = "singleLine", n = 0) {
    return this.finalize(
      I.joinLines(this.parts.map((i) => typeof i == "string" ? i : i.format(e, n)))
    );
  }
}
function s1(t) {
  const e = { ...t.leadingComments?.slice(0, 1)[0]?.loc.start ?? t.loc.start }, n = { ...t.trailingComments?.slice(-1)[0]?.loc.end ?? t.loc.end };
  return { start: e, end: n };
}
function a1(t) {
  return t.trailingComments?.slice(-1)[0]?.type === g.LineComment;
}
class qe {
  constructor(e, n, i) {
    this.node = e, this.parent = n, this.options = i, this.indentStatementFirstLine = !0, this.externalOffset = 0, this.options = qi(this.options);
  }
  createStatementPrinter(e) {
    switch (e.type) {
      case g.Program:
        return new Pt(e, this.node, this.options);
      case g.ImportDeclaration:
        return new d1(e, this.node, this.options);
      case g.ExpressionStatement:
        return new c1(e, this.node, this.options);
      case g.FunctionDeclaration:
        return new za(e, this.node, this.options);
      case g.ExportNamedDeclaration:
        return Ln(e) ? new qa(e, this.node, this.options) : new za(e, this.node, this.options);
      case g.BlockStatement:
        return new Pt(e, this.node, this.options);
      case g.ReturnStatement:
        return new h1(e, this.node, this.options);
      case g.VariableDeclaration:
        return new qa(e, this.node, this.options);
      case g.IfStatement:
        return new u1(e, this.node, this.options);
      case g.ForStatement:
      case g.ForInStatement:
      case g.ForOfStatement:
      case g.WhileStatement:
        return new l1(e, this.node, this.options);
      case g.EmptyStatement:
      case g.BreakStatement:
      case g.ContinueStatement:
        return new o1(e, this.node, this.options);
      default:
        throw new Error(`unknown type: ${JSON.stringify(e)}`);
    }
  }
  /**
   * We don't to reprint over and over the body that is usually stable for a given level.
   * Uses a cache to optimize the formatting.
   * @param bodyPrinter
   * @param level
   * @returns
   */
  getFormattedBody(e, n = 0) {
    if (this.cachedBody && this.cachedBody.level === n)
      return this.cachedBody.body;
    const i = e.format(n);
    return this.cachedBody = { body: i, level: n }, i;
  }
  getStatementIndentation(e = 0) {
    return this.indentStatementFirstLine ? nt(e, this.options) : "";
  }
  getStatementIndentationLength(e = 0) {
    return this.indentStatementFirstLine ? e * this.options.indentWidth : 0;
  }
  /**
   * Gets the indentation string for the corresponding level
   * @param level
   * @returns
   */
  getIndentation(e = 0) {
    return nt(e, this.options);
  }
  /**
   * Once the statement has been formatted, we need to wrap the leading and the
   * trailing comments.
   * @param formattedLines
   * @param level
   * @returns
   */
  addComments(e, n = 0) {
    const i = this.getStatementIndentation(n);
    if (!this.node.leadingComments?.length && !this.node.trailingComments?.length)
      return e.indentFirstLine(i);
    const r = (this.node.leadingComments ?? []).reduce(
      (a, o) => {
        const l = this.formatComment(o);
        return {
          formattedLines: I.aggregateLines(
            a.formattedLines,
            a.location,
            l,
            o.loc,
            i
          ),
          location: o.loc
        };
      },
      { formattedLines: new I() }
    ), s = I.aggregateLines(
      r.formattedLines,
      r.location,
      e,
      this.node.loc,
      i
    );
    return (this.node.trailingComments?.reduce(
      (a, o) => {
        const l = this.formatComment(o);
        return {
          formattedLines: I.aggregateLines(
            a.formattedLines,
            a.location,
            l,
            o.loc,
            i
          ),
          location: o.loc
        };
      },
      { formattedLines: s, location: this.node.loc }
    ) ?? { formattedLines: s }).formattedLines;
  }
  formatInnerComments(e = 0) {
    if (!Ie(this.node) || !Array.isArray(this.node.innerComments) || !this.node.innerComments.length)
      return new I();
    const n = this.getIndentation(e);
    return this.node.innerComments.reduce(
      (i, r) => {
        const s = this.formatComment(r);
        return {
          formattedLines: I.aggregateLines(
            i.formattedLines,
            i.location,
            s,
            r.loc,
            n
          ),
          location: r.loc
        };
      },
      { formattedLines: new I() }
    ).formattedLines;
  }
  formatComment(e) {
    switch (e.type) {
      case g.BlockComment:
        return I.fromString(e.value).surroundWith("/*", "*/");
      default:
        return I.fromString(e.value.trimEnd()).surroundWith("//");
    }
  }
  /**
   * Invoked for a single line format. Measure is the length of the statement would fit
   * the available space
   * @param formattedLines
   * @param level
   * @param offset
   * @returns
   */
  canFitSingleLine(e, n = 0, i = 0) {
    return this.externalOffset + i + this.getStatementIndentationLength(n) + e.lastLineLength <= this.options.wrapColumn;
  }
}
class Pt extends qe {
  constructor(e, n, i) {
    super(e, n, i), this.node = e, this.printers = [], this.printers = e.body.map((r) => this.createStatementPrinter(r));
  }
  format(e = 0) {
    if (this.printers.length === 0)
      return this.formatEmptyBlock(e);
    const n = [], i = Ie(this.node);
    i && n.push("{");
    const r = i ? e + 1 : e;
    let s;
    return this.printers.forEach((a) => {
      if ($i(a.node))
        return;
      const o = s1(a.node);
      s && o.start.line - s.end.line > 1 && n.push(""), s = o, n.push(a.format(r));
    }), i && n.push(`${this.getIndentation(e)}}`), this.addComments(I.appendLines(n), e);
  }
  formatEmptyBlock(e = 0) {
    if (!Ie(this.node))
      return this.addComments(I.fromString(""), e);
    const n = this.formatInnerComments(e + 1), i = "{", r = `${this.getIndentation(e)}}`;
    return n.isEmpty ? Li(this.parent) ? this.addComments(I.appendLines([i, r]), e) : this.addComments(I.fromString("{}"), e) : this.addComments(I.appendLines([i, n, r]), e);
  }
}
class o1 extends qe {
  constructor(e, n, i) {
    switch (super(e, n, i), this.node = e, this.keyword = "", this.node.type) {
      case g.ContinueStatement:
        this.keyword = "continue;";
        break;
      case g.BreakStatement:
        this.keyword = "break;";
        break;
      default:
        this.keyword = ";";
    }
  }
  format(e = 0) {
    return this.addComments(I.fromString(this.keyword), e);
  }
}
class qa extends qe {
  constructor(e, n, i) {
    if (super(e, n, i), this.node = e, Ln(e))
      this.printer = new Si(e, n, i);
    else if (Ln(e.declaration))
      this.printer = new Si(e.declaration, n, i), this.printer.prefix = "export ";
    else
      throw new Error(`invalid type: ${JSON.stringify(e)}`);
  }
  format(e = 0, n = "optimized") {
    if (n === "singleLine" || n === "optimized") {
      const i = this.printer.format("singleLine", e).suffixWith(";");
      if (n === "singleLine" || this.canFitSingleLine(i, e))
        return this.addComments(i, e);
    }
    return this.addComments(this.printer.format("multiline", e).suffixWith(";"), e);
  }
}
class za extends qe {
  constructor(e, n, i) {
    if (super(e, n, i), this.node = e, Na(e))
      this.header = it(e, n, i), this.body = new Pt(e.body, e, i);
    else if (Na(e.declaration))
      this.header = it(e.declaration, n, i), this.header.prefix = "export ", this.body = new Pt(e.declaration.body, e, i);
    else
      throw new Error(`invalid type: ${JSON.stringify(e)}`);
  }
  format(e = 0, n = "optimized") {
    this.body.indentStatementFirstLine = !1;
    const i = this.getFormattedBody(this.body, e);
    if (n === "singleLine" || n === "optimized") {
      const s = this.header.format("singleLine", e);
      if (n === "singleLine" || this.canFitSingleLine(s, e, i.firstLineLength + 1))
        return this.addComments(I.joinLines([s, i], " "), e);
    }
    const r = this.header.format("multiline", e);
    return this.addComments(I.joinLines([r, i], " "), e);
  }
}
class u1 extends qe {
  constructor(e, n, i) {
    super(e, n, i), this.node = e, this.header = it(e, n, i), this.consequent = this.createStatementPrinter(e.consequent), this.consequent.indentStatementFirstLine = !1, e.alternate && (this.alternate = this.createStatementPrinter(e.alternate), this.alternate.indentStatementFirstLine = !1);
  }
  format(e = 0, n = "optimized") {
    let i = !1, r;
    if (n === "singleLine" || n === "optimized") {
      const l = this.header.format("singleLine", e), c = Ie(this.node.consequent) ? 2 : 0;
      (n === "singleLine" || this.canFitSingleLine(l, e, c)) && (r = l);
    }
    r || (i = !0, r = this.header.format("multiline", e));
    let s;
    if (Ie(this.node.consequent)) {
      const l = this.consequent.format(e, "optimized");
      s = I.joinLines([r, " ", l]);
    } else if (i || Li(this.node.consequent)) {
      this.consequent.indentStatementFirstLine = !0;
      let l = this.consequent.format(e + 1, "singleLine");
      this.canFitSingleLine(l, e + 1) || (l = this.consequent.format(e + 1, "multiline")), s = I.appendLines([r, l]);
    } else {
      this.consequent.indentStatementFirstLine = !1;
      let l = this.consequent.format(e, "singleLine");
      this.canFitSingleLine(l, 0, r.lastLineLength + 1) ? s = I.joinLines([r, " ", l]) : (this.consequent.indentStatementFirstLine = !0, l = this.consequent.format(e + 1, "optimized"), s = I.appendLines([r, l]));
    }
    if (!this.alternate)
      return this.addComments(s, e);
    const a = a1(this.node.consequent) || !Ie(this.node.consequent);
    let o;
    if (this.alternate.externalOffset = 0, Ie(this.node.alternate) || Li(this.node.alternate))
      this.alternate.indentStatementFirstLine = !1, this.alternate.externalOffset = a ? 5 : s.lastLineLength + 6, o = this.alternate.format(e, "optimized"), o = I.joinLines(["else ", o]);
    else {
      const l = a ? 4 : s.lastLineLength + 4;
      this.alternate.indentStatementFirstLine = !1, o = this.alternate.format(e, "singleLine"), this.canFitSingleLine(o, e, l + 1) ? o = I.joinLines(["else ", o]) : (this.alternate.indentStatementFirstLine = !0, o = this.alternate.format(e + 1, "optimized"), o = I.appendLines(["else", o]));
    }
    return a ? s = I.appendLines([s, o.indentFirstLine(this.getIndentation(e))]) : s = I.joinLines([s, o], " "), this.addComments(s, e);
  }
}
class l1 extends qe {
  constructor(e, n, i) {
    super(e, n, i), this.node = e, this.header = it(e, n, i), this.body = this.createStatementPrinter(e.body);
  }
  format(e = 0, n = "optimized") {
    this.body.indentStatementFirstLine = !1;
    const i = this.getFormattedBody(this.body, e);
    if (n === "singleLine" || n === "optimized") {
      const s = this.header.format("singleLine", e);
      if (n === "singleLine" || this.canFitSingleLine(s, e, i.firstLineLength + 1))
        return this.addComments(I.joinLines([s, i], " "), e);
    }
    const r = this.header.format("multiline", e);
    return this.addComments(I.joinLines([r, i], " "), e);
  }
}
class c1 extends qe {
  constructor(e, n, i) {
    super(e, n, i), this.node = e, this.expression = J(e.expression, e, i);
  }
  format(e = 0, n = "optimized") {
    if (n === "singleLine" || n === "optimized") {
      const i = this.expression.format("singleLine", e).suffixWith(";");
      if (n === "singleLine" || this.canFitSingleLine(i, e))
        return this.addComments(i, e);
    }
    return this.addComments(this.expression.format("multiline", e).suffixWith(";"), e);
  }
}
class h1 extends qe {
  constructor(e, n, i) {
    super(e, n, i), this.node = e, this.argument = J(e.argument, e, i);
  }
  format(e = 0, n = "optimized") {
    if (n === "singleLine" || n === "optimized") {
      const a = this.argument.format("singleLine", e).surroundWith("return ", ";");
      if (n === "singleLine" || this.canFitSingleLine(a, e))
        return this.addComments(a, e);
    }
    if (!_i(this.node.argument) && !vi(this.node.argument)) {
      const a = this.argument.format("multiline", e).surroundWith("return ", ";");
      return this.addComments(a, e);
    }
    const i = this.getIndentation(e + 1), r = this.argument.format("multiline", e + 1).indentFirstLine(i), s = this.getIndentation(e);
    return this.addComments(I.appendLines(["return (", r, `${s});`]), e);
  }
}
class d1 extends qe {
  constructor(e, n, i) {
    super(e, n, i), this.node = e, this.libraryNamePrinter = J(e.specifiers[0].local, e, i), this.librarySourcePrinter = J(e.source, e, i);
  }
  format(e = 0) {
    return this.addComments(
      I.joinLines([
        "import",
        " ",
        this.libraryNamePrinter.format("singleLine", e),
        " from ",
        this.librarySourcePrinter.format("singleLine")
      ]).suffixWith(";"),
      e
    );
  }
}
const f1 = { quote: "auto" };
function m1(t, e = {}) {
  try {
    const n = t.getText(), i = t.positionAt(n.length), r = { start: { line: 0, character: 0 }, end: i }, s = { ...f1, ...e.formattingOptions ?? {} }, a = g1(n, s);
    return [{ range: r, newText: a }];
  } catch (n) {
    return console.error("Arcade Formatting Error:", n), [];
  }
}
function g1(t, e) {
  if (!t)
    return "";
  const n = qi(e), i = Fn.fromString(t, n), r = i.toString(), s = yo(r, {
    tolerant: !0,
    comments: !0
  }), a = jc(s, i);
  return s.loc.start = a.start, s.loc.end = a.end, new Pt(s, null, n).format().toString();
}
const p1 = Object.values(W), b1 = Object.values(Nt), D1 = ["case", "catch", "debugger", "switch", "try"], x1 = b1.map((t) => ({ label: t, kind: re.Constant })), C1 = p1.map((t) => ({ label: t, kind: re.Keyword })), E1 = [
  {
    label: "exportfunction",
    kind: re.Snippet,
    detail: "Export Function Statement",
    insertText: `export function \${1:functionName} ($2) {
	$0
}`,
    insertTextMode: ge.adjustIndentation,
    insertTextFormat: me.Snippet
  },
  {
    label: "exportvar",
    kind: re.Snippet,
    detail: "Export Variable Statement",
    insertText: "export var ${0:variableName}\n",
    insertTextMode: ge.adjustIndentation,
    insertTextFormat: me.Snippet
  },
  {
    label: "for",
    kind: re.Snippet,
    detail: "For Loop Statement",
    insertText: "for (var ${1:i} = 0; ${1:i} < ${2:array.length}; ${1:i}++) {\n	$0\n}",
    insertTextMode: ge.adjustIndentation,
    insertTextFormat: me.Snippet
  },
  {
    label: "forin",
    kind: re.Snippet,
    detail: "For-In Loop Statement",
    insertText: "for (var ${1:i} in ${2:arrayOrObject}) {\n	$0\n}",
    insertTextMode: ge.adjustIndentation,
    insertTextFormat: me.Snippet
  },
  {
    label: "forof",
    kind: re.Snippet,
    detail: "For-Of Loop Statement",
    insertText: "for (var ${1:i} of ${2:arrayOrObject}) {\n	$0\n}",
    insertTextMode: ge.adjustIndentation,
    insertTextFormat: me.Snippet
  },
  {
    label: "function",
    kind: re.Snippet,
    detail: "Function Statement",
    insertText: `function \${1:functionName} ($2) {
	$0
}`,
    insertTextMode: ge.adjustIndentation,
    insertTextFormat: me.Snippet
  },
  {
    label: "if",
    kind: re.Snippet,
    detail: "If Statement",
    insertText: `if (\${1:1==1}) {
	$0
}`,
    insertTextMode: ge.adjustIndentation,
    insertTextFormat: me.Snippet
  },
  {
    label: "ifelse",
    kind: re.Snippet,
    detail: "If-Else Statement",
    insertText: `if (\${1:1==1}) {
	$0
} else {
	
}`,
    insertTextMode: ge.adjustIndentation,
    insertTextFormat: me.Snippet
  },
  {
    label: "else",
    kind: re.Snippet,
    detail: "Else Statement",
    insertText: `else {
	$0
}`,
    insertTextMode: ge.adjustIndentation,
    insertTextFormat: me.Snippet
  },
  {
    label: "import",
    kind: re.Snippet,
    detail: "Import Statement",
    insertText: 'import ${1:namespace} from "${0:uri}"',
    insertTextMode: ge.adjustIndentation,
    insertTextFormat: me.Snippet
  },
  {
    label: "while",
    kind: re.Snippet,
    detail: "While Loop Statement",
    insertText: `while (\${1:false}) {
	$0
}`,
    insertTextMode: ge.adjustIndentation,
    insertTextFormat: me.Snippet
  }
], A1 = /\$\{(.*?)\}/gu;
function kt(t, e) {
  return e ? t.replace(A1, (n, i) => e[i].toString()) : t;
}
const Oi = /[-[\]/{}()*+?.\\^$|]/gu;
function w1(t, e) {
  return t.line > e.end.line;
}
function L1(t, e) {
  return t.line < e.start.line;
}
function Bo(t, e) {
  return !(L1(t, e) || w1(t, e) || t.line === e.start.line && t.column < e.start.column || t.line === e.end.line && t.column > e.end.column);
}
const ee = {
  None: 0,
  Keywords: 1,
  All: 255,
  NoKeywords: 254
}, Oe = {
  identifiers: "a",
  profileVariables: "aa",
  constants: "ab",
  literals: "ab",
  functions: "ac",
  snippets: "b",
  keywords: "c"
};
function v1(t, e, n, i = {}) {
  const r = t.getText({ start: { line: 0, character: 0 }, end: e }), { tokens: s, errors: a = [] } = Oc(r, { loc: !0, tolerant: !0 });
  if (a.length)
    return { isIncomplete: !1, items: [] };
  let o = s.at(s.length - 1), l = "";
  const c = U1(e);
  o?.type === "Identifier" && Bo(c, o.loc) && (l = o.value, s.pop(), o = s[s.length - 1]);
  const d = {
    variables: i.profile?.variables ?? [],
    additionalCompletionItems: (i.snippets ?? []).map((h) => ({
      kind: re.Snippet,
      insertTextMode: ge.adjustIndentation,
      insertTextFormat: me.Snippet,
      ...h
    })),
    apiDatabase: n
  };
  return o?.type === "Punctuator" && o.value === "." ? F1(s, l, d) : _1(s, l, c, d);
}
function _1(t, e, n, i) {
  const r = N1(t, n);
  if (r === ee.None)
    return { isIncomplete: !1, items: [] };
  const s = I1(t), a = [], o = new RegExp(e.replaceAll(Oi, "\\$&"), "i");
  return s.forEach((l, c) => {
    o.test(c) && a.push({ ...l, sortText: Oe.identifiers });
  }), i.variables.forEach((l) => {
    o.test(l.name) && l.completion && a.push({ ...l.completion, sortText: Oe.profileVariables });
  }), Wa(r) && E1.forEach((l) => {
    l.label.startsWith(e) && a.push({ ...l, sortText: Oe.snippets });
  }), i.additionalCompletionItems.forEach((l) => {
    o.test(l.label) && a.push({ ...l, sortText: Oe.snippets });
  }), Wa(r) && C1.forEach((l) => {
    o.test(l.label) && a.push({ ...l, sortText: Oe.keywords });
  }), x1.forEach((l) => {
    o.test(l.label) && a.push({ ...l, sortText: Oe.literals });
  }), i.apiDatabase.constantDefinitions.forEach((l, c) => {
    l.type === "constant" && l.disableDocumentation === !0 || !o.test(c) || a.push({ ...l.completion, sortText: Oe.constants });
  }), i.apiDatabase.functionDefinitions.forEach((l, c) => {
    o.test(c) && l.overloads.forEach((d) => {
      d.disableDocumentation || a.push({ ...d.completion, sortText: Oe.functions });
    });
  }), { isIncomplete: !1, items: a };
}
function F1(t, e, n) {
  const i = [...t];
  let r = i.pop();
  const s = r;
  let a = [];
  for (; r && !(r.type !== "Punctuator" || r.value !== "." || (r = i.pop(), r?.type !== "Identifier")); )
    a = [r.value.toLowerCase(), ...a], r = i.pop();
  if (a.length === 0 || !s)
    return { isIncomplete: !1, items: [] };
  let o = y1(a, e, n);
  return o || (o = S1(a, e, s, n), o) ? o : { isIncomplete: !1, items: [] };
}
function y1(t, e, n) {
  if (t.length > 1)
    return null;
  const i = n.apiDatabase.constantDefinitions.get(t[0]);
  if (!i)
    return null;
  if (i.type !== "namespace")
    return { isIncomplete: !1, items: [] };
  const r = [], s = new RegExp(e.replaceAll(Oi, "\\$&"), "i");
  return i.members.forEach((a) => {
    a.disableDocumentation === !0 || !s.test(a.name) || r.push(a.completion);
  }), { isIncomplete: !1, items: r };
}
function S1(t, e, n, i) {
  if (!i.variables.length || !t.length)
    return null;
  let r = t.shift(), s = i.variables;
  for (; r; ) {
    const c = s.find((d) => d.name.toLowerCase() === r);
    if (!kc(c))
      return null;
    s = c.properties ?? [], r = t.shift();
  }
  const a = [], o = new RegExp(e.replaceAll(Oi, "\\$&"), "i"), l = V1(n.loc.start);
  return s.forEach((c) => {
    o.test(c.name) && c.completion && a.push(T1(l, c.completion));
  }), { isIncomplete: !1, items: a };
}
function Wa(t) {
  return (t & ee.Keywords) === ee.Keywords;
}
function N1(t, e) {
  if (!t.length)
    return ee.All;
  const n = t[t.length - 1];
  switch (n.type) {
    case "Identifier":
      return ee.All;
    case "Keyword":
      return ["return", "in", "else"].includes(n.value) ? ee.NoKeywords : ee.None;
    case "Punctuator":
      return k1(t);
    case "Template":
      return n.value.endsWith("${") ? ee.NoKeywords : ee.All;
    default:
      return Bo(e, n.loc) ? ee.None : ee.All;
  }
}
function k1(t) {
  const e = [...t];
  let n = e.pop();
  if (!n)
    return ee.All;
  if (n.type !== "Punctuator")
    return ee.None;
  if (n.value !== "(" && n.value !== ",")
    return ee.All;
  if (n.value === "(")
    return Oa(e);
  let i = 0;
  for (n = e.pop(); n; ) {
    if (n.type === "Keyword")
      return ee.None;
    if (n.type !== "Punctuator") {
      n = e.pop();
      continue;
    }
    if (n.value === ")" || n.value === "]") {
      i -= 1, n = e.pop();
      continue;
    }
    if (n.value === "[") {
      if (i === 0)
        return ee.NoKeywords;
      i += 1, n = e.pop();
      continue;
    }
    if (n.value === "(") {
      if (i === 0)
        return Oa(e);
      i += 1, n = e.pop();
      continue;
    }
    n = e.pop();
  }
  return ee.None;
}
function Oa(t) {
  const e = [...t];
  let n = e.pop();
  return n ? n.type === "Keyword" ? n.value.toLowerCase() === "for" ? ee.All : ee.NoKeywords : n.type !== "Identifier" ? ee.All : (n = e.pop(), n?.type === "Keyword" && n.value.toLowerCase() === "function" ? ee.None : ee.NoKeywords) : ee.All;
}
class B1 {
  constructor(e) {
    this.tokens = e, this.currentIndex = 0;
  }
  increment() {
    if (!(this.currentIndex >= this.tokens.length))
      return this.currentIndex += 1, this.tokens[this.currentIndex];
  }
  get next() {
    return this.tokens[this.currentIndex + 1];
  }
  get previous() {
    return this.tokens[this.currentIndex - 1];
  }
  get current() {
    return this.tokens[this.currentIndex];
  }
}
const en = {
  parameterFormat: "(parameter) ${name}",
  variableFormat: "var ${name}",
  functionFormat: "function ${name} (${paramsDetail})"
};
function I1(t) {
  const e = /* @__PURE__ */ new Map();
  if (!t.length)
    return e;
  const n = new B1(t);
  for (; n.current; ) {
    if (n.current.type === "Keyword") {
      if (n.current.value.toLowerCase() === "var") {
        n.increment(), R1(n, e);
        continue;
      }
      if (n.current.value.toLowerCase() === "function") {
        n.increment(), M1(n, e);
        continue;
      }
    }
    n.increment();
  }
  return e;
}
function R1(t, e) {
  for (; t.current; ) {
    if (t.current.type !== "Identifier")
      return;
    const n = t.current.value, i = n.toLowerCase();
    e.set(i, {
      label: n,
      kind: re.Variable,
      detail: kt(en.variableFormat, { name: n })
    });
    const r = t.increment();
    if (r?.type !== "Punctuator")
      return;
    if (r.value === ",") {
      t.increment();
      continue;
    }
    if (r.value === "=") {
      t.increment(), P1(t);
      continue;
    }
  }
}
function M1(t, e) {
  for (; t.current; ) {
    if (t.current.type !== "Identifier")
      return;
    const n = t.current.value, i = n.toLowerCase(), r = {
      label: n,
      kind: re.Function,
      detail: kt(en.functionFormat, { name: n, paramsDetail: "" }),
      insertText: `${n}()`,
      insertTextMode: ge.adjustIndentation,
      insertTextFormat: me.Snippet
    };
    e.set(i, r);
    let s = t.increment();
    if (!Ke(s, "("))
      return;
    s = t.increment();
    const a = [];
    for (; s && !(s.type !== "Identifier" || (a.push(s.value), s = t.increment(), !Ke(s, ","))); )
      s = t.increment();
    if (a.length) {
      r.detail = kt(en.functionFormat, {
        name: r.label,
        paramsDetail: a.join(", ")
      });
      const c = a.map((d, h) => `\${${h + 1}:${d}}`).join(", ");
      r.insertText = `${r.label}(${c})`;
    }
    if (!Ke(s, ")") || (s = t.increment(), !Ke(s, "{")))
      return;
    s = t.increment();
    const o = t.currentIndex;
    let l = 1;
    for (; s && l > 0; )
      Ke(s, "{") ? l += 1 : Ke(s, "}") && (l -= 1), s = t.increment();
    if (l === 0)
      return;
    t.currentIndex = o, a.forEach((c) => {
      const d = c.toLowerCase();
      e.set(d, {
        label: c,
        kind: re.Variable,
        detail: kt(en.parameterFormat, { name: c })
      });
    });
  }
}
function Ke(t, e) {
  return t?.type === "Punctuator" && t.value === e;
}
function P1(t) {
  let e = 0;
  for (; t.current; ) {
    if (t.current.type === "Keyword") {
      if (Ke(t.previous, ".")) {
        t.increment();
        continue;
      }
      return;
    }
    if (t.current.type === "Punctuator" && t.current.value === ";")
      return;
    if (t.current.type === "Template" && t.current.value.startsWith("`")) {
      e += 1, t.increment();
      continue;
    }
    if (t.current.type === "Punctuator" && ["(", "[", "{"].includes(t.current.value)) {
      e += 1, t.increment();
      continue;
    }
    if (t.current.type === "Template" && t.current.value.endsWith("`")) {
      e -= 1, t.increment();
      continue;
    }
    if (t.current.type === "Punctuator" && [")", "]", "}"].includes(t.current.value)) {
      e -= 1, t.increment();
      continue;
    }
    if (!e && t.current.type === "Punctuator" && t.current.value === ",") {
      t.increment();
      return;
    }
    t.increment();
  }
}
function T1(t, e) {
  return e.insertText?.startsWith("[") && (e.additionalTextEdits = [
    {
      newText: "",
      range: {
        start: { ...t },
        end: {
          line: t.line,
          character: t.character + 1
        }
      }
    }
  ]), e;
}
function U1(t) {
  return { line: t.line + 1, column: t.character };
}
function V1(t) {
  return { line: t.line - 1, character: t.column };
}
class $1 {
  constructor(e, n = []) {
    this._apiDatabase = e, this._profileVariables = n, this._isInBlock = !1, this._isInCallExpression = !1, this._identifierBeingAssigned = void 0, this._assignmentValidationMode = "disabled", this._scriptScopeIdentifiers = /* @__PURE__ */ new Map(), this._diagnostics = [], this._undeclaredIdentifiersInFunctions = /* @__PURE__ */ new Map(), this.handleException = (i) => {
      if (q1(i)) {
        const { range: r, code: s, data: a } = i;
        this.logDiagnostic(r, { code: s, data: a });
      } else
        this.logDiagnostic(
          { start: { line: 1, column: 0 }, end: { line: 1, column: 0 } },
          { code: P.ExecutionError, data: { stack: i.stack ?? "" } }
        );
    }, this.validateStatement = (i) => {
      if (i)
        switch (i.type) {
          case g.BlockStatement:
            i.body.forEach(this.validateStatement);
            return;
          case g.VariableDeclaration:
            i.declarations.forEach((r) => this.validateVariableDeclarator(r));
            return;
          case g.FunctionDeclaration:
            this.validateFunctionDeclaration(i);
            return;
          case g.ExportNamedDeclaration:
            this.validateExportDeclaration(i);
            return;
          case g.ImportDeclaration:
            this.validateImportDeclaration(i);
            return;
          case g.WhileStatement:
            this.validateWhileStatement(i);
            return;
          case g.ForStatement:
            this.validateForStatement(i);
            return;
          case g.ForInStatement:
          case g.ForOfStatement:
            this.validateForInOfStatement(i);
            return;
          case g.IfStatement:
            this.validateIfStatement(i);
            return;
          case g.ReturnStatement:
            this.validateExpression(i.argument);
            return;
          case g.ExpressionStatement:
            this.validateExpression(i.expression);
            return;
          // No issue statement
          case g.BreakStatement:
          case g.ContinueStatement:
          case g.EmptyStatement:
            return;
        }
    }, this.validateExpression = (i) => {
      if (i)
        switch (i.type) {
          case g.AssignmentExpression:
            this.validateAssignmentExpression(i);
            return;
          case g.CallExpression:
            this.validateCallExpression(i);
            return;
          case g.Identifier:
            this.validateIdentifier(i);
            return;
          case g.Literal:
            this.validateLiteral(i);
            return;
          case g.ArrayExpression:
            i.elements.forEach(this.validateExpression);
            return;
          case g.ObjectExpression:
            this.validateObjectExpression(i);
            return;
          case g.UnaryExpression:
            this.validateUnaryExpression(i);
            return;
          case g.UpdateExpression:
            this.validateUpdateExpression(i);
            return;
          case g.BinaryExpression:
          case g.LogicalExpression:
            this.validateBinaryAndLogicalExpression(i);
            return;
          case g.MemberExpression:
            this.validateMemberExpression(i);
            return;
          case g.TemplateLiteral:
            i.expressions.forEach(this.validateExpression);
            return;
          default:
            return;
        }
    };
  }
  validateScript(e) {
    if (!e)
      return { diagnostics: [], program: null };
    this._isInBlock = !1, this._identifierBeingAssigned = void 0, this._assignmentValidationMode = "disabled", this._diagnostics = [], this._scriptScopeIdentifiers.clear(), this._undeclaredIdentifiersInFunctions.clear(), this._functionScopeIdentifiers = void 0;
    let n = null;
    try {
      n = yo(e, { tolerant: !0 }), this.handleErrors(n.errors), n.body.forEach(this.validateStatement), this.diagnoseIdentifiers(), this._undeclaredIdentifiersInFunctions.size > 0 && this._undeclaredIdentifiersInFunctions.forEach((i) => {
        for (const r of i)
          this.logDiagnostic(r.node.loc, {
            code: P.NotDefined,
            data: { identifier: r.node.name }
          });
      });
    } catch (i) {
      this.handleException(i);
    }
    return { diagnostics: this._diagnostics, program: n };
  }
  disableRecordIdentifierAssignment(e, n) {
    const i = this._assignmentValidationMode;
    this._assignmentValidationMode = "disabled", e.call(this, n), this._assignmentValidationMode = i;
  }
  inBlock(e, n) {
    const i = this._isInBlock;
    this._isInBlock = !0, e.call(this, n), this._isInBlock = i;
  }
  get _isInFunctionScope() {
    return !!this._functionScopeIdentifiers;
  }
  inFunctionScope(e) {
    this._functionScopeIdentifiers = /* @__PURE__ */ new Map(), e.call(this), this.diagnoseIdentifiers(), this._functionScopeIdentifiers = void 0;
  }
  logDiagnostic(e, n) {
    const i = {
      severity: ce.Error,
      ...n,
      message: kt(Hc[n.code], n.data),
      range: {
        start: { line: e.start.line - 1, character: e.start.column },
        end: { line: e.end.line - 1, character: e.end.column }
      }
    };
    this._diagnostics.push(i);
  }
  handleErrors(e) {
    (e ?? []).forEach(this.handleException);
  }
  getIdentifierInfo(e) {
    return this._functionScopeIdentifiers?.get(e) ?? this._scriptScopeIdentifiers.get(e);
  }
  setIdentifierInfo(e, n) {
    if (this._functionScopeIdentifiers) {
      this._functionScopeIdentifiers.set(e, n);
      return;
    }
    this._scriptScopeIdentifiers.set(e, n), this._undeclaredIdentifiersInFunctions.has(e) && (this._undeclaredIdentifiersInFunctions.delete(e), n.used = !0);
  }
  isProfileVariable(e) {
    return this._profileVariables.some((n) => n.name.toLowerCase() === e);
  }
  isApiConstant(e) {
    return !!this._apiDatabase?.constantDefinitions.get(e);
  }
  isApiFunction(e) {
    return !!this._apiDatabase?.functionDefinitions.get(e);
  }
  isApiItem(e) {
    return this.isApiConstant(e) || this.isApiFunction(e);
  }
  validateVariableDeclarator(e) {
    this.validateExpression(e.init), this.recordVariableIdentifier(e.id, { initialized: !!e.init });
  }
  validateFunctionDeclaration(e) {
    this.recordFunctionIdentifier(e), this.inFunctionScope(() => {
      e.params.forEach((n) => this.recordParamAsIdentifier(n)), ht(e.body) && this.logDiagnostic(e.body.loc, {
        code: P.UnexpectedEmptyFunction,
        data: { identifier: e.id.name },
        severity: ce.Warning
      }), this.validateStatement(e.body);
    });
  }
  validateExportDeclaration(e) {
    this.validateStatement(e.declaration);
  }
  validateImportDeclaration(e) {
    this.recordImportIdentifier(e);
  }
  validateForStatement(e) {
    Ln(e.init) ? this.inBlock(this.validateStatement, e.init) : this.validateExpression(e.init), this.validateExpression(e.update), this.validateExpression(e.test), ht(e.body) && this.logDiagnostic(e.body.loc, {
      code: P.EmptyBlockStatement,
      severity: ce.Warning
    }), this.inBlock(this.validateStatement, e.body);
  }
  validateWhileStatement(e) {
    this.validateExpression(e.test), ht(e.body) && this.logDiagnostic(e.body.loc, {
      code: P.EmptyBlockStatement,
      severity: ce.Warning
    }), this.inBlock(this.validateStatement, e.body);
  }
  validateForInOfStatement(e) {
    if (Ne(e.left)) {
      const n = this._assignmentValidationMode;
      this._assignmentValidationMode = "left", this._identifierBeingAssigned = e.left.name.toLowerCase(), this.validateExpression(e.left), this._assignmentValidationMode = n;
    } else
      this.recordVariableIdentifier(e.left.declarations[0].id, { initialized: !0, inBlock: !0 });
    this.validateExpression(e.right), ht(e.body) && this.logDiagnostic(e.body.loc, {
      code: P.EmptyBlockStatement,
      severity: ce.Warning
    }), this.validateStatement(e.body);
  }
  validateIfStatement(e) {
    this.validateExpression(e.test), ht(e.consequent) && this.logDiagnostic(e.consequent.loc, {
      code: P.EmptyBlockStatement,
      severity: ce.Warning
    }), e.alternate && ht(e.alternate) && this.logDiagnostic(e.alternate.loc, {
      code: P.EmptyBlockStatement,
      severity: ce.Warning
    }), this.inBlock(this.validateStatement, e.consequent), this.inBlock(this.validateStatement, e.alternate);
  }
  validateAssignmentExpression(e) {
    const n = this._identifierBeingAssigned, i = this._assignmentValidationMode;
    Ne(e.left) && (this._identifierBeingAssigned = e.left.name.toLowerCase(), this._assignmentValidationMode = "left"), this.validateExpression(e.left), Ne(e.left) && (this._assignmentValidationMode = "right"), this.validateExpression(e.right), this._identifierBeingAssigned = n, this._assignmentValidationMode = i;
  }
  validateCallExpression(e) {
    const n = this._isInCallExpression;
    if (this._isInCallExpression = !0, this.validateExpression(e.callee), Ne(e.callee)) {
      const i = e.callee.name.toLowerCase(), r = this.getIdentifierInfo(i), s = this._apiDatabase?.functionDefinitions.get(i);
      if (!r && s) {
        const a = z1(s, e.arguments.length);
        a && this.logDiagnostic(e.loc, a);
      }
    }
    e.arguments.forEach(this.validateExpression), this._isInCallExpression = n;
  }
  validateIdentifier(e) {
    const n = e.name.toLowerCase(), i = this.getIdentifierInfo(n);
    if (i) {
      if (this._assignmentValidationMode === "left" && this._identifierBeingAssigned === n) {
        i.initialized = !0;
        return;
      }
      if (this._assignmentValidationMode === "right" && this._identifierBeingAssigned === n)
        return;
      i.used = !0;
      return;
    }
    if (!(this.isProfileVariable(n) || this.isApiConstant(n))) {
      if (this.isApiFunction(n)) {
        if (this._isInCallExpression)
          return;
        this.logDiagnostic(e.loc, {
          code: P.InvalidApiFunctionUsage,
          data: { identifier: e.name }
        });
        return;
      }
      if (this._isInFunctionScope) {
        let r = this._undeclaredIdentifiersInFunctions.get(n);
        r || (r = [], this._undeclaredIdentifiersInFunctions.set(n, r)), r.push({ node: e, identifier: n });
        return;
      }
      this.logDiagnostic(e.loc, { code: P.NotDefined, data: { identifier: e.name } });
    }
  }
  validateLiteral(e) {
    O1(e.raw).forEach((n) => {
      const i = this.getIdentifierInfo(n.toLowerCase());
      i && (i.used = !0);
    });
  }
  logProfileOrApiConflict(e) {
    const n = e.name.toLowerCase(), i = this.isProfileVariable(n), r = this.isApiItem(n);
    !i && !r || this.logDiagnostic(e.loc, {
      code: i ? P.ProfileVariablesConflict : P.ApiConflict,
      severity: ce.Warning,
      data: {
        identifier: e.name
      }
    });
  }
  logReservedKeywordsConflict(e) {
    const n = e.name.toLowerCase();
    D1.includes(n) && this.logDiagnostic(e.loc, {
      code: P.ReservedKeyword,
      severity: ce.Warning,
      data: {
        identifier: e.name
      }
    });
  }
  validateObjectExpression(e) {
    e.properties.forEach((n) => {
      this.validateExpression(n.value);
    });
  }
  validateUnaryExpression(e) {
    this.validateExpression(e.argument);
  }
  validateUpdateExpression(e) {
    this.validateExpression(e.argument);
  }
  validateBinaryAndLogicalExpression(e) {
    this.validateExpression(e.left), this.validateExpression(e.right);
  }
  validateMemberExpression(e) {
    const n = this.flattenMemberExpressionAndValidate(e), i = n[0].object;
    this.disableRecordIdentifierAssignment(this.validateExpression, i), Ne(i) && (this.getIdentifierInfo(i.name.toLowerCase()) || this.validateMemberExpressionWithProfile(n) || this.validateConstantMemberExpression(n));
  }
  flattenMemberExpressionAndValidate(e) {
    switch (e.type) {
      case g.MemberExpression:
        return (!Ne(e.property) || e.computed) && this.validateExpression(e.property), [...this.flattenMemberExpressionAndValidate(e.object), e];
      default:
        return [];
    }
  }
  extractAndValidatePropertyName(e) {
    switch (e.type) {
      case g.Identifier:
        return e.name.toLowerCase();
      case g.Literal:
        return typeof e.value != "string" ? (this.logDiagnostic(e.loc, { code: P.UnexpectedPropertyIdentifier }), null) : e.value.toLowerCase();
      default:
        return this.logDiagnostic(e.loc, { code: P.UnexpectedPropertyIdentifier }), null;
    }
  }
  validateConstantMemberExpression(e) {
    const n = e[0];
    if (!Ne(n.object))
      return !1;
    const i = n.object.name.toLowerCase(), r = this._apiDatabase?.constantDefinitions.get(i);
    if (!r)
      return !1;
    if (r.type !== "namespace")
      return this.logDiagnostic(n.property.loc, {
        code: P.NotADictionary,
        data: { identifier: i }
      }), !0;
    const s = this.extractAndValidatePropertyName(n.property);
    if (!s)
      return !0;
    if (!r.members.some((a) => a.name.toLowerCase() === s)) {
      const a = r.members.reduce(
        (o, l) => `${o}${o ? " | " : ""}${l.completion.label.split(".").pop()}`,
        ""
      );
      this.logDiagnostic(n.property.loc, {
        code: P.InvalidConstantIdentifier,
        data: { list: a }
      });
    }
    return e.length > 1 && this.logDiagnostic(e[1].property.loc, { code: P.UnexpectedPropertyIdentifier }), !0;
  }
  validateMemberExpressionWithProfile(e) {
    const n = e[0];
    if (n.object.type !== g.Identifier)
      return !1;
    const i = n.object.name.toLowerCase(), r = this._profileVariables.find((a) => a.name.toLowerCase() === i);
    if (!r)
      return !1;
    if (Sa(r))
      return this.logDiagnostic(n.object.loc, {
        code: P.NotADictionary,
        data: { identifier: r.name }
      }), !0;
    if (this._identifierBeingAssigned === i)
      return this.logDiagnostic(n.loc, { code: P.ProfileVariablesAreImmutable }), !0;
    let s = r;
    for (let a = 0; a < e.length; a++) {
      if (e[a].computed)
        return !0;
      if (Sa(s))
        return this.logDiagnostic(e[a - 1]?.property.loc ?? e[a].object.loc, {
          code: P.NotADictionary,
          data: { identifier: s.name }
        }), !0;
      const o = this.extractAndValidatePropertyName(e[a].property);
      if (!o)
        return !0;
      if (!s.properties || s.properties.length === 0)
        return this.logDiagnostic(e[a].property.loc, {
          code: P.UnknownPropertyIdentifier,
          data: { identifier: o },
          severity: ce.Warning
        }), !0;
      const l = s.properties.find(
        (c) => c.name.toLowerCase() === o
      );
      if (!l) {
        const c = s.properties.reduce(
          (d, h) => `${d}${d ? " | " : ""}${h.name.split(".").pop()}`,
          ""
        );
        return this.logDiagnostic(e[a].property.loc, {
          code: P.InvalidPropertyIdentifier,
          data: { list: c }
        }), !0;
      }
      s = l;
    }
    return !0;
  }
  recordVariableIdentifier(e, n) {
    this.logReservedKeywordsConflict(e), this.logProfileOrApiConflict(e);
    const i = e.name.toLowerCase();
    let r = this.getIdentifierInfo(i);
    const s = this._isInFunctionScope && r?.scope === "function", a = !this._isInFunctionScope && r?.scope === "script";
    (s || a) && this.logDiagnostic(e.loc, {
      code: P.AlreadyDefined,
      data: { identifier: e.name },
      severity: ce.Warning
    });
    const o = n.inBlock ?? this._isInBlock, { initialized: l } = n;
    if (!r || this._isInFunctionScope && r.scope !== "function") {
      const c = this._isInFunctionScope ? "function" : o ? "block" : "script";
      r = {
        node: e,
        used: !1,
        initialized: l,
        scope: c
      };
    } else
      r.node = e, r.used = !1, r.initialized = l;
    return r.scope === "block" && !o && (r.scope = "script", this.logDiagnostic(e.loc, {
      code: P.AlreadyDefined,
      data: { identifier: e.name },
      severity: ce.Warning
    })), this.setIdentifierInfo(i, r), !1;
  }
  recordImportIdentifier(e) {
    const n = e.specifiers[0].local;
    this.logProfileOrApiConflict(n);
    const i = n.name.toLowerCase();
    let r = this.getIdentifierInfo(i);
    r?.scope && this.logDiagnostic(e.specifiers[0].local.loc, {
      code: P.AlreadyDefined,
      data: { identifier: e.specifiers[0].local.name },
      severity: ce.Warning
    }), r = {
      node: e.specifiers[0].local,
      used: !1,
      ...r,
      scope: "script",
      initialized: !0
    }, this.setIdentifierInfo(i, r);
  }
  recordFunctionIdentifier(e) {
    this.logProfileOrApiConflict(e.id);
    const n = e.id.name.toLowerCase();
    let i = this.getIdentifierInfo(n);
    i?.scope && this.logDiagnostic(e.id.loc, {
      code: P.AlreadyDefined,
      data: { identifier: e.id.name },
      severity: ce.Warning
    }), i = {
      node: e.id,
      used: !1,
      ...i,
      scope: "script",
      initialized: !0
    }, this.setIdentifierInfo(n, i);
  }
  recordParamAsIdentifier(e) {
    return this.recordVariableIdentifier(e, { initialized: !0 });
  }
  diagnoseIdentifiers() {
    (this._functionScopeIdentifiers ?? this._scriptScopeIdentifiers).forEach((e) => {
      e.used ? e.initialized || this.logDiagnostic(e.node.loc, {
        code: P.DefinedNeverAssigned,
        data: { identifier: e.node.name },
        severity: ce.Warning
      }) : this.logDiagnostic(e.node.loc, {
        code: e.initialized ? P.AssignedNeverUsed : P.DefinedNeverUsed,
        data: { identifier: e.node.name },
        severity: ce.Warning
      });
    });
  }
}
function q1(t) {
  return !!t && t.name === "ParsingError";
}
function ht(t) {
  return $i(t) || Ie(t) && !t.body.length;
}
function z1(t, e) {
  const { min: n, max: i } = t.overloads.reduce(
    (r, s) => {
      const { min: a, max: o } = s.parametersInfo;
      return r.min >= 0 && (r.min = Math.min(a, r.min)), r.max >= 0 && (r.max = o < 0 ? o : Math.max(o, r.max)), r;
    },
    { min: Number.POSITIVE_INFINITY, max: 0 }
  );
  return e < n ? n > 0 ? { code: P.NotEnoughArguments, data: { min: n } } : { code: P.NoArgumentExpected } : i >= 0 && e > i ? { code: P.TooManyArguments, data: { max: i } } : null;
}
const W1 = /\B@\w+/gu;
function O1(t = "") {
  return Array.from(t.matchAll(W1), (e) => e[0].slice(1));
}
class H1 {
  configure(e) {
    this.apiService = new Bc(e);
  }
  async doValidation(e, n) {
    if (!this.apiService)
      return [];
    const i = await this.apiService.getApiDatabase(n), { profile: { variables: r = [] } = {} } = n, { diagnostics: s } = new $1(i, r).validateScript(e.getText());
    return s;
  }
  async doComplete(e, n, i) {
    if (!this.apiService)
      return { isIncomplete: !1, items: [] };
    const r = await this.apiService.getApiDatabase(i);
    return v1(e, n, r, i);
  }
}
class Tt {
  constructor(e, n, i, r) {
    this._uri = e, this._languageId = n, this._version = i, this._content = r, this._lineOffsets = void 0;
  }
  get uri() {
    return this._uri;
  }
  get languageId() {
    return this._languageId;
  }
  get version() {
    return this._version;
  }
  getText(e) {
    if (e) {
      const n = this.offsetAt(e.start), i = this.offsetAt(e.end);
      return this._content.substring(n, i);
    }
    return this._content;
  }
  update(e, n) {
    for (const i of e)
      if (Tt.isIncremental(i)) {
        const r = Ro(i.range), s = this.offsetAt(r.start), a = this.offsetAt(r.end);
        this._content = this._content.substring(0, s) + i.text + this._content.substring(a, this._content.length);
        const o = Math.max(r.start.line, 0), l = Math.max(r.end.line, 0);
        let c = this._lineOffsets;
        const d = Ha(i.text, !1, s);
        if (l - o === d.length)
          for (let f = 0, m = d.length; f < m; f++)
            c[f + o + 1] = d[f];
        else
          d.length < 1e4 ? c.splice(o + 1, l - o, ...d) : this._lineOffsets = c = c.slice(0, o + 1).concat(d, c.slice(l + 1));
        const h = i.text.length - (a - s);
        if (h !== 0)
          for (let f = o + 1 + d.length, m = c.length; f < m; f++)
            c[f] = c[f] + h;
      } else if (Tt.isFull(i))
        this._content = i.text, this._lineOffsets = void 0;
      else
        throw new Error("Unknown change event received");
    this._version = n;
  }
  getLineOffsets() {
    return this._lineOffsets === void 0 && (this._lineOffsets = Ha(this._content, !0)), this._lineOffsets;
  }
  positionAt(e) {
    e = Math.max(Math.min(e, this._content.length), 0);
    const n = this.getLineOffsets();
    let i = 0, r = n.length;
    if (r === 0)
      return { line: 0, character: e };
    for (; i < r; ) {
      const a = Math.floor((i + r) / 2);
      n[a] > e ? r = a : i = a + 1;
    }
    const s = i - 1;
    return e = this.ensureBeforeEOL(e, n[s]), { line: s, character: e - n[s] };
  }
  offsetAt(e) {
    const n = this.getLineOffsets();
    if (e.line >= n.length)
      return this._content.length;
    if (e.line < 0)
      return 0;
    const i = n[e.line];
    if (e.character <= 0)
      return i;
    const r = e.line + 1 < n.length ? n[e.line + 1] : this._content.length, s = Math.min(i + e.character, r);
    return this.ensureBeforeEOL(s, i);
  }
  ensureBeforeEOL(e, n) {
    for (; e > n && Io(this._content.charCodeAt(e - 1)); )
      e--;
    return e;
  }
  get lineCount() {
    return this.getLineOffsets().length;
  }
  static isIncremental(e) {
    const n = e;
    return n != null && typeof n.text == "string" && n.range !== void 0 && (n.rangeLength === void 0 || typeof n.rangeLength == "number");
  }
  static isFull(e) {
    const n = e;
    return n != null && typeof n.text == "string" && n.range === void 0 && n.rangeLength === void 0;
  }
}
var Ni;
(function(t) {
  function e(r, s, a, o) {
    return new Tt(r, s, a, o);
  }
  t.create = e;
  function n(r, s, a) {
    if (r instanceof Tt)
      return r.update(s, a), r;
    throw new Error("TextDocument.update: document must be created by TextDocument.create");
  }
  t.update = n;
  function i(r, s) {
    const a = r.getText(), o = ki(s.map(j1), (d, h) => {
      const f = d.range.start.line - h.range.start.line;
      return f === 0 ? d.range.start.character - h.range.start.character : f;
    });
    let l = 0;
    const c = [];
    for (const d of o) {
      const h = r.offsetAt(d.range.start);
      if (h < l)
        throw new Error("Overlapping edit");
      h > l && c.push(a.substring(l, h)), d.newText.length && c.push(d.newText), l = r.offsetAt(d.range.end);
    }
    return c.push(a.substr(l)), c.join("");
  }
  t.applyEdits = i;
})(Ni || (Ni = {}));
function ki(t, e) {
  if (t.length <= 1)
    return t;
  const n = t.length / 2 | 0, i = t.slice(0, n), r = t.slice(n);
  ki(i, e), ki(r, e);
  let s = 0, a = 0, o = 0;
  for (; s < i.length && a < r.length; )
    e(i[s], r[a]) <= 0 ? t[o++] = i[s++] : t[o++] = r[a++];
  for (; s < i.length; )
    t[o++] = i[s++];
  for (; a < r.length; )
    t[o++] = r[a++];
  return t;
}
function Ha(t, e, n = 0) {
  const i = e ? [n] : [];
  for (let r = 0; r < t.length; r++) {
    const s = t.charCodeAt(r);
    Io(s) && (s === 13 && r + 1 < t.length && t.charCodeAt(r + 1) === 10 && r++, i.push(n + r + 1));
  }
  return i;
}
function Io(t) {
  return t === 13 || t === 10;
}
function Ro(t) {
  const e = t.start, n = t.end;
  return e.line > n.line || e.line === n.line && e.character > n.character ? { start: n, end: e } : t;
}
function j1(t) {
  const e = Ro(t.range);
  return e !== t.range ? { newText: t.newText, range: e } : t;
}
globalThis.onmessage = () => {
  bo(
    (t, e) => new G1(t, e)
  );
};
class G1 {
  // Our language service
  constructor(e, { languageId: n }) {
    this._ctx = e, this._languageId = n, this._languageService = new H1(), this._languageService.configure({ getApiLibrary: this._ctx.host.getApiLibrary });
  }
  async doValidation(e, n) {
    const i = this._getTextDocument(e);
    return i ? await this._languageService.doValidation(i, n) : await Promise.resolve([]);
  }
  async doComplete(e, n, i) {
    const r = this._getTextDocument(e);
    return r ? await this._languageService.doComplete(r, n, i) : await Promise.resolve({ isIncomplete: !1, items: [] });
  }
  async doFormat(e, n) {
    const i = this._getTextDocument(e);
    if (!i)
      return await Promise.resolve([]);
    const r = m1(i, n);
    return await Promise.resolve(r);
  }
  _getTextDocument(e) {
    const n = this._ctx.getMirrorModels();
    for (const i of n)
      if (i.uri.toString() === e)
        return Ni.create(e, this._languageId, i.version, i.getValue());
    return null;
  }
}
