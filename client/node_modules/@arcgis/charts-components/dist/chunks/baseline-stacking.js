import "@arcgis/charts-spec";
import "lodash-es";
import "d3-array";
import { af as o } from "./interfaces.js";
import "@arcgis/core/geometry/support/jsonUtils.js";
import "@arcgis/core/rest/support/AttributeBinsQuery.js";
import "@arcgis/core/rest/support/Query.js";
import "@arcgis/core/rest/support/StatisticDefinition.js";
import "@arcgis/core/time/TimeExtent.js";
import "@arcgis/core/core/promiseUtils.js";
import "@arcgis/core/request.js";
import { j as t, k as a } from "./index4.js";
import { s as l, b as m, g as S, a as k } from "./series.js";
/*! All material copyright Esri, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.33/esri/copyright.txt for details.
v4.33.19 */
const j = (s, e) => {
  if (t(e.series[s]) || a(e.series[s]))
    return S(e.series[s]);
}, A = (s, e, r) => {
  (t(r.series[e]) || a(r.series[e])) && l(s, r.series[e]);
}, B = (s, e) => {
  if (t(e.series[s]) || a(e.series[s]))
    return k(e.series[s]);
}, N = (s, e, r) => {
  (t(r.series[e]) || a(r.series[e])) && m(s, r.series[e]);
}, z = (s, e) => t(e.series[s]) || a(e.series[s]) ? e.series[s].markerSymbol?.color : void 0, W = (s, e, r) => {
  if (t(r.series[e]) || a(r.series[e])) {
    const i = r.series[e];
    i.markerSymbol === void 0 && (i.markerSymbol = o()), i.markerSymbol.color = s;
  }
}, O = (s, e) => t(e.series[s]) || a(e.series[s]) ? e.series?.[s]?.markerSymbol?.style : void 0, w = (s, e, r) => {
  if (t(r.series[e]) || a(r.series[e])) {
    const i = r.series[e];
    i.markerSymbol === void 0 && (i.markerSymbol = o()), i.markerSymbol.style = s;
  }
}, F = (s, e) => t(e.series[s]) || a(e.series[s]) ? e.series?.[s]?.markerSymbol?.size : void 0, q = (s, e, r) => {
  if (t(r.series[e]) || a(r.series[e])) {
    const i = r.series[e];
    i.markerSymbol === void 0 && (i.markerSymbol = o()), i.markerSymbol.size = s;
  }
}, D = (s, e) => t(e.series[s]) || a(e.series[s]) ? e.series?.[s]?.lineSmoothed ?? !1 : !1, R = (s) => {
  const { smoothed: e, seriesIndex: r, config: i } = s;
  (t(i.series[r]) || a(i.series[r])) && (i.series[r].lineSmoothed = e);
}, f = (s, e) => t(e.series[s]) || a(e.series[s]) ? e.series[s].showArea ?? !1 : !1, E = (s) => {
  const { visible: e, seriesIndex: r, config: i } = s;
  (t(i.series[r]) || a(i.series[r])) && (i.series[r].showArea = e);
}, G = (s, e) => t(e.series[s]) || a(e.series[s]) ? e.series[s].markerVisible ?? !0 : !1, H = (s) => {
  const { visible: e, seriesIndex: r, config: i } = s;
  (t(i.series[r]) || a(i.series[r])) && (i.series[r].markerVisible = e);
}, J = (s, e) => t(e.series[s]) || a(e.series[s]) ? e.series[s].areaColor : void 0, K = (s, e) => t(e.series[s]) || a(e.series[s]) ? e.series?.[s]?.connectLines : void 0, P = (s) => {
  const { connect: e, seriesIndex: r, config: i } = s;
  (t(i.series[r]) || a(i.series[r])) && (i.series[r].connectLines = e);
}, Q = (s, e) => t(e.series[s]) || a(e.series[s]) ? e.series[s].stackNegativeValuesToBaseline ?? !0 : !1, U = (s) => {
  const { stackNegativeValuesToBaseline: e, seriesIndex: r, config: i } = s;
  (t(i.series[r]) || a(i.series[r])) && (i.series[r].stackNegativeValuesToBaseline = e);
};
export {
  A as a,
  N as b,
  w as c,
  q as d,
  B as e,
  z as f,
  j as g,
  O as h,
  F as i,
  D as j,
  R as k,
  f as l,
  E as m,
  G as n,
  H as o,
  J as p,
  Q as q,
  U as r,
  W as s,
  K as t,
  P as u
};
