import { c as G } from "./chunks/index.js";
import { g as v } from "./chunks/interfaces.js";
import { aW as H, H as U, cs as j, p as z, C as Y, D as Z, aX as J, aU as X, ct as ee, c0 as ae, c1 as te, aV as se, bq as re, bn as ie, bQ as oe, aQ as le, aR as ne, bc as ue, cb as ce, c as fe, bt as ge, bT as ye, R as be, W as me, aS as de, Q as pe, T as Se, U as he, S as Ce, y as De, bJ as Fe, bL as Le, bM as Te, bK as xe, m as Pe, c6 as Be, s as $e, bf as Ie, be as Ae, L as Oe, bX as ve, bW as Ne, bY as Re, a_ as Ee, d as ke, ba as Me, f as Ve, bR as Qe, O as We, $ as we, j as qe, q as _e, A as Ge, x as Ke, aJ as He, k as Ue, aK as je, a as ze, c2 as Ye, G as Ze, F as Je, bU as Xe, aL as ea, al as aa, ac as ta, ay as sa, ar as ra, aq as ia, az as oa, ae as la, as as na, a4 as ua, ax as ca, a2 as fa, Z as ga, b$ as ya, _ as ba, a5 as ma, b_ as da, a0 as pa, aD as Sa, am as ha, aw as Ca, aI as Da, aF as Fa, aH as La, aG as Ta, aa as xa, aA as Pa, ag as Ba, af as $a, ao as Ia, a3 as Aa, aO as Oa, a6 as va, ab as Na, a8 as Ra, aC as Ea, av as ka, au as Ma, at as Va, aB as Qa, ap as Wa, aE as wa, ah as qa, ai as _a, aN as Ga, a7 as Ka, a1 as Ha, aM as Ua, ad as ja, aj as za, a9 as Ya, c9 as Za, b7 as Ja, a$ as Xa, ca as et, bd as at, an as tt, b4 as st, bN as rt, bO as it, b5 as ot, bP as lt, b6 as nt, bS as ut, bI as ct, bB as ft, bs as gt, b0 as yt, Y as bt, cm as mt, cn as dt, ch as pt, bh as St, bo as ht, bv as Ct, aZ as Dt, bu as Ft, b8 as Lt, aY as Tt, ak as xt, b as Pt, c4 as Bt, e as $t, h as It, c5 as At, cg as Ot, bV as vt, z as Nt, J as Rt, cp as Et, K as kt, i as Mt, c3 as Vt, b2 as Qt, E as Wt, cd as wt, bC as qt, bE as _t, bD as Gt, r as Kt, b3 as Ht, t as Ut, c8 as jt, b1 as zt, o as Yt, ce as Zt, br as Jt, cf as Xt, cq as es, l as as, co as ts, b9 as ss, bF as rs, bG as is, cc as os, bH as ls, ck as ns, bZ as us, bz as cs, by as fs, bA as gs, bx as ys, bw as bs, bb as ms, c7 as ds, n as ps, aT as Ss, aP as hs, V as Cs, bl as Ds, bg as Fs, bi as Ls, bp as Ts, N as xs, M as Ps, bj as Bs, bk as $s, bm as Is, X as As, P as Os, cj as vs, cr as Ns, I as Rs, u as Es, cl as ks, ci as Ms, B as Vs, v as Qs, w as Ws } from "./chunks/interfaces.js";
import { A as qs, c as _s, b as Gs, a as Ks, C as Hs, D as Us, E as js, e as zs, L as Ys, d as Zs, S as Js, V as Xs } from "./chunks/index2.js";
import { u as ar } from "./chunks/index3.js";
import { RESTSymbolType as C, RESTFieldType as d, RESTSimpleFillSymbolStyle as b, RESTSimpleLineSymbolStyle as p } from "@arcgis/charts-spec";
import { cloneDeep as N } from "lodash-es";
import { h as sr, l as rr, m as ir, g as or, p as lr, f as nr, j as ur, n as cr, q as fr, k as gr, o as yr, i as br, b as mr, c as dr, d as pr, a as Sr, u as hr, s as Cr, r as Dr, t as Fr, e as Lr } from "./chunks/index4.js";
import { g as xr, a as Pr } from "./chunks/chart-ui-utils.js";
import { P as $r, c as Ir, e as Ar, r as Or } from "./chunks/popover-ui-utils.js";
import { g as Nr } from "./chunks/series-types.js";
import { B as Er, a as kr, C as Mr, H as Vr, L as Qr, P as Wr, S as wr } from "./chunks/interfaces2.js";
import { g as _r, s as Gr } from "./chunks/runtime.js";
/*! All material copyright Esri, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.33/esri/copyright.txt for details.
v4.33.19 */
function R(a) {
  let o;
  switch (a.length) {
    case 4: {
      const e = a.match(/^#?([\da-f]{1})([\da-f]{1})([\da-f]{1})$/iu);
      e && (o = [
        Number.parseInt(`${e[1]}${e[1]}`, 16),
        Number.parseInt(`${e[2]}${e[2]}`, 16),
        Number.parseInt(`${e[3]}${e[3]}`, 16),
        255
      ]);
      break;
    }
    case 5: {
      const e = a.match(/^#?([\da-f]{1})([\da-f]{1})([\da-f]{1})([\da-f]{1})$/iu);
      e && (o = [
        Number.parseInt(`${e[1]}${e[1]}`, 16),
        Number.parseInt(`${e[2]}${e[2]}`, 16),
        Number.parseInt(`${e[3]}${e[3]}`, 16),
        Number.parseInt(`${e[4]}${e[4]}`, 16)
      ]);
      break;
    }
    case 7: {
      const e = a.match(/^#?([\da-f]{2})([\da-f]{2})([\da-f]{2})$/iu);
      e && (o = [
        Number.parseInt(e[1], 16),
        Number.parseInt(e[2], 16),
        Number.parseInt(e[3], 16),
        255
      ]);
      break;
    }
    case 9: {
      const e = a.match(/^#?([\da-f]{2})([\da-f]{2})([\da-f]{2})([\da-f]{2})$/iu);
      e && (o = [
        Number.parseInt(e[1], 16),
        Number.parseInt(e[2], 16),
        Number.parseInt(e[3], 16),
        Number.parseInt(e[4], 16)
      ]);
      break;
    }
  }
  return o;
}
function I(a) {
  let o;
  if (typeof a == "string" && a.startsWith("#")) {
    const e = R(a);
    e && (o = e);
  } else Array.isArray(a) && a.every((e) => typeof e == "number") && (a.length === 4 ? o = a : a.length === 3 && (o = [...a, 255]));
  return o;
}
function O(a) {
  return a === b.BackwardDiagonal || a === b.Cross || a === b.DiagonalCross || a === b.ForwardDiagonal || a === b.Horizontal || a === b.Null || a === b.Solid || a === b.Vertical;
}
function T(a) {
  return a === p.Dash || a === p.DashDot || a === p.DashDotDot || a === p.Dot || a === p.Null || a === p.Solid;
}
function E(a) {
  const { categoryField: o, numericFields: e, configFields: s, inlineData: n } = a;
  let f = {};
  return s && Object.keys(s).length > 0 && "dataItems" in n && (f = {
    type: "uniqueValue",
    field1: o,
    uniqueValueInfos: []
  }, n.dataItems.forEach((i) => {
    const l = i[o];
    if (l != null) {
      let t = { value: l };
      e.forEach((r) => {
        const u = I(i[`${s.fillColor}_${r}`]), g = i[`${s.fillOpacity}_${r}`], S = i[`${s.fillStyle}_${r}`], y = i[`${s.markerSize}_${r}`], D = I(i[`${s.outlineColor}_${r}`]), x = i[`${s.outlineOpacity}_${r}`], h = i[`${s.outlineWidth}_${r}`], P = i[`${s.outlineStyle}_${r}`], F = I(i[`${s.lineColor}_${r}`]), B = i[`${s.lineOpacity}_${r}`], m = i[`${s.lineWidth}_${r}`], $ = i[`${s.lineStyle}_${r}`], A = i[`${s.displayLabel}_${r}`];
        if (typeof A == "string" && (t = {
          ...t,
          label: A
        }), y != null) {
          const c = { type: C.SMS };
          y && typeof y == "number" && (c.size = y), t.symbol = c;
        }
        if (u || O(S)) {
          const c = t.symbol && t.symbol.type === C.SMS ? t.symbol : {
            type: C.SFS
          };
          if (u && (g && typeof g == "number" && (u[3] = g), c.color = u), O(S) && (c.style = S), t.symbol = c, D || h != null || T(P)) {
            const L = { type: C.SLS };
            D && (x && typeof x == "number" && (D[3] = x), L.color = D), T(P) && (L.style = P), h && typeof h == "number" && (L.width = h), t.symbol.outline = L;
          }
        } else if (F || m != null || T($)) {
          const c = { type: C.SLS };
          F && (B && typeof B == "number" && (F[3] = B), c.color = F), T($) && (c.style = $), m != null && typeof m == "number" && (c.width = m), t.symbol = c;
        }
      }), (t.label || t.symbol) && f.uniqueValueInfos.push(t);
    }
  })), f;
}
function k(a) {
  const { numericFields: o, configFields: e, inlineData: s } = a, n = s;
  return "dataItems" in s && Object.entries(e).forEach(([f, i]) => {
    o.forEach((l) => {
      const t = `${i}_${l}`;
      s.dataItems.forEach((r) => {
        t in r && delete r[t];
      });
    });
  }), n;
}
function M(a) {
  const { categoryField: o, categoryType: e, numericFields: s, inlineData: n } = a;
  let f;
  if ("dataItems" in n) {
    const { dataItems: i } = n, l = [];
    let t = "OBJECTID";
    const r = i.map((g, S) => {
      const y = { ...g };
      return "FID" in g ? t = "FID" : "ObjectId" in g && (t = "ObjectId"), y[t] || (y[t] = S), { attributes: y };
    });
    l.push({ type: "esriFieldTypeOID", name: t });
    let u;
    switch (e) {
      case "dateOnly":
        u = d.DateOnly;
        break;
      case "timeStampOffset":
        u = d.TimestampOffset;
        break;
      case "date":
        u = d.Date;
        break;
      case "number":
        u = d.Double;
        break;
      case "string":
      default:
        u = d.String;
        break;
    }
    l.push({ type: u, name: o }), s.forEach((g) => {
      l.push({ type: d.Double, name: g });
    }), f = {
      id: "",
      layerType: "ArcGISFeatureLayer",
      featureCollection: {
        layers: [{ layerDefinition: { fields: l }, featureSet: { features: r } }]
      }
    };
  }
  return f;
}
async function w(a) {
  const { categoryField: o, categoryType: e, numericFields: s, configFields: n, inlineData: f } = a;
  let i, l, t = N(f);
  n && (i = E({
    categoryField: o,
    numericFields: s,
    configFields: n,
    inlineData: t
  }), t = k({
    numericFields: s,
    configFields: n,
    inlineData: t
  }));
  const r = M({
    categoryField: o,
    categoryType: e,
    numericFields: s,
    inlineData: t
  });
  return r && (l = await v(r)), { chartRenderer: i, iLayer: r, layer: l };
}
export {
  qs as ActionModes,
  _s as ActionState,
  Gs as ActionToggle,
  H as ArcgisChartsError,
  Er as BarChartDataPopoverKinds,
  kr as BoxPlotDataPopoverKinds,
  U as BoxPlotYFieldKeys,
  Mr as ChartAuthoringPages,
  Ks as ChartComponentEvents,
  j as ChartSubType,
  z as ConfigErrorKeywords,
  Y as ConfigWarningKeywords,
  Hs as CursorRange,
  Z as DataWarningKeywords,
  Us as DefaultChartActions,
  J as ErrorKeywords,
  js as ErrorPolicy,
  Vr as HistogramDataPopoverKinds,
  zs as LayerFieldsChangePolicy,
  Ys as LayerFilterChangePolicy,
  Zs as LayerRendererChangePolicy,
  X as LimitBehavior,
  Qr as LineChartDataPopoverKinds,
  Wr as PieChartDataPopoverKinds,
  $r as PopoverType,
  wr as ScatterplotDataPopoverKinds,
  ee as SelectionSource,
  ae as SupportedLocales,
  te as SupportedLocalesForFormats,
  Js as SyncSelectionsBetweenChartAndLayerViewPolicy,
  se as TextElements,
  Xs as ViewTimeExtentChangePolicy,
  re as abortControllerMap,
  ie as abortPendingQueries,
  oe as addILayer,
  le as boxPlotOutliersSuffix,
  ne as boxPlotZScoreSuffix,
  ue as buildQueryConfig,
  ce as canShowLegend,
  fe as chartConfigVersions,
  ge as combineFilters,
  G as convertChartSpec,
  E as convertConfigFieldsToChartRenderer,
  w as convertInlineConfigToLayerConfig,
  M as convertInlineDataToLayerDefinition,
  ye as convertTimeZone,
  Ir as createPopover,
  be as defaultAxisLineColor,
  me as defaultBoxPlotCategory,
  de as defaultColorForBoxPlotWithMeanLines,
  pe as defaultGridLineOpacity,
  Se as defaultLineSymbolStyle,
  he as defaultLineSymbolWidth,
  Ce as defaultPieTickColor,
  De as doesBoxPlotItemHaveValidQuartiles,
  Fe as doesLayerSupportQueryWithDistance,
  Le as doesLayerSupportsCacheHintForQueryBins,
  Te as doesLayerSupportsQueryBinsForScatterplot,
  xe as doesLayerSupportsQueryBinsForTemporalData,
  Pe as doesSeriesSupportTemporalBinning,
  Ar as editPopover,
  Be as escapeSQLString,
  $e as extractChartDataFromFetchedData,
  Ie as extractFieldsFromConfigList,
  Ae as extractFieldsUsedInConfig,
  Oe as featuresExtentField,
  ve as fetchComponentLocaleCommonStrings,
  Ne as fetchComponentLocaleStrings,
  Re as fetchLanguageDirection,
  Ee as fetchLayerFieldsInfo,
  ke as findExpectedGuideSymbol,
  Me as findMatchingLayerFieldName,
  Ve as firstWebMapVersion,
  Qe as formatMessage,
  We as fullOpacity,
  we as generateRandomRestColor,
  _r as getAssetPath,
  qe as getBoxPlotChartSubType,
  _e as getBoxPlotStatisticFieldNames,
  Ge as getBoxPlotYList,
  Ke as getBoxPlotYValue,
  xr as getChartIcon,
  He as getChartLimits,
  Nr as getChartOrSeriesType,
  Ue as getChartSubType,
  je as getChartTechnicalLimits,
  Pr as getChartText,
  ze as getChartVersionInfo,
  Ye as getColorMatch,
  Ze as getDataMinMaxFromSeries,
  Je as getDataMinMaxFromStackedSeries,
  Xe as getDateStringInCalciteDatePickerFormat,
  ea as getDefaultAggregationTypeLabel,
  aa as getDefaultAxes,
  ta as getDefaultBackground,
  sa as getDefaultBarChart,
  ra as getDefaultBarChartSeries,
  ia as getDefaultBarChartSeriesSymbol,
  oa as getDefaultBoxPlot,
  la as getDefaultBoxPlotElementSymbol,
  na as getDefaultBoxPlotSeries,
  ua as getDefaultCategoryFormat,
  ca as getDefaultChartRotation,
  fa as getDefaultChartText,
  ga as getDefaultColor,
  ya as getDefaultCommonStrings,
  ba as getDefaultCursorCrosshair,
  ma as getDefaultDateFormat,
  da as getDefaultErrorsStrings,
  pa as getDefaultFont,
  Sa as getDefaultGauge,
  ha as getDefaultGaugeNeedle,
  Ca as getDefaultGaugeSeries,
  Da as getDefaultHistogram,
  Fa as getDefaultHistogramOverlays,
  La as getDefaultHistogramSeries,
  Ta as getDefaultHistogramSymbol,
  xa as getDefaultLegend,
  Pa as getDefaultLineChart,
  Ba as getDefaultLineChartLineSymbol,
  $a as getDefaultLineChartMarkerSymbol,
  Ia as getDefaultLineChartSeries,
  Aa as getDefaultLineSymbol,
  Oa as getDefaultNoR2Label,
  va as getDefaultNumberFormat,
  Na as getDefaultOverlay,
  Ra as getDefaultPercentNumberFormat,
  Ea as getDefaultPieChart,
  ka as getDefaultPieChartSeries,
  Ma as getDefaultPieChartSymbol,
  Va as getDefaultPieChartTick,
  Qa as getDefaultRadarChart,
  Wa as getDefaultRadarChartSeries,
  wa as getDefaultScatterplot,
  qa as getDefaultScatterplotMarkerSymbol,
  _a as getDefaultScatterplotSizePolicy,
  Ga as getDefaultStackedType,
  Ka as getDefaultStatNumberFormat,
  Ha as getDefaultTextSymbol,
  Ua as getDefaultTimeAggregationTypeLabel,
  ja as getDefaultTitle,
  za as getDefaultTrendLine,
  Ya as getDefaultValueAxis,
  v as getFeatureLayer,
  Za as getFieldAlias,
  Ja as getFieldDescription,
  Xa as getFieldFromName,
  et as getFieldNameFromFieldAlias,
  at as getFieldsUsedInCharts,
  tt as getGaugeAxes,
  st as getLayerDateFields,
  rt as getLayerFromLayerOrLayerView,
  it as getLayerFromQueryObject,
  ot as getLayerNumericFields,
  lt as getLayerSpatialAggregationStatisticsCapabilities,
  nt as getLayerSubtypeInfo,
  ut as getLocaleInfo,
  ct as getMainLayer,
  ft as getMaxRecordCountFactor,
  gt as getMaxRecords,
  yt as getObjectIdField,
  bt as getOneRampColor,
  mt as getOrderByComponents,
  dt as getOrderByFields,
  pt as getOverlayColorIndex,
  St as getQueryAttributeBinsForScatterplotFieldsAlias,
  ht as getQueryAttributeBinsForTemporalDataAliases,
  Ct as getQueryGeometry,
  Dt as getQueryObject,
  Ft as getQueryTimeExtent,
  Lt as getRendererFieldNames,
  Tt as getRendererInfo,
  xt as getScatterplotSeries,
  Pt as getSeriesReference,
  Bt as getSeriesTypes,
  $t as getSplitByField,
  It as getSplitByValue,
  At as getStackedType,
  Ot as getTimeIntervalUnitLabel,
  vt as getTimeStringInCalciteTimePickerFormat,
  Nt as getYList,
  Rt as groupByWhenCaseForMedianTimeBinning,
  sr as hasILayer,
  Et as hasSelectionChanged,
  kt as histogramBinCount,
  Mt as isAbsoluteTruthWhereClause,
  rr as isBarChartSeries,
  ir as isBarChartSeriesArray,
  or as isBoxPlotSeries,
  lr as isBoxPlotSeriesArray,
  Vt as isChartRotated,
  nr as isChartType,
  Qt as isDateField,
  Wt as isEmptyDataset,
  wt as isEmptyStringField,
  qt as isFeatureCollectionLayer,
  _t as isFeatureLayer,
  Gt as isFeatureLayerView,
  Kt as isGaugeByFeature,
  Ht as isIntegerField,
  ur as isLineChartSeries,
  cr as isLineChartSeriesArray,
  Ut as isMultiFieldsBoxPlot,
  fr as isNumberFormatOptions,
  jt as isNumberOfElementsUnderLimit,
  zt as isNumericField,
  Yt as isPartialConfig,
  Zt as isPropertyKeyInData,
  Jt as isQueryCacheable,
  Xt as isQueryCalculatedExprInItem,
  gr as isRadarChartSeries,
  yr as isRadarChartSeriesArray,
  br as isRotationSupported,
  mr as isSFS,
  dr as isSLS,
  pr as isSMS,
  es as isSelectionEmpty,
  as as isSeriesUsingTimeBinning,
  ts as isSplitByChart,
  Sr as isStackedTypeSupported,
  ss as isStandardLayer,
  rs as isSubtypeGroupLayer,
  is as isSubtypeSublayer,
  os as isSupportedChart,
  ls as isSupportedLayer,
  ns as isValidNumber,
  hr as isValueAxisDataItem,
  Cr as isWebChartGenericDataItemOrUndefined,
  Dr as isWebChartHistogramDataItemOrUndefined,
  Fr as isWebChartScatterplotDataItemOrUndefined,
  Lr as isWebChartTextSymbol,
  us as localeParseFloat,
  cs as mapAttributeBinsQueryForScatterplot,
  fs as mapAttributeBinsQueryForTemporalData,
  gs as mapQuery,
  ys as mapQueryGeometry,
  bs as mapQueryTimeExtent,
  ms as matchFieldsList,
  ds as normalizeString,
  ps as normalizeWhereClause,
  Ss as percentageSuffix,
  hs as pieChartInnerRadius,
  Cs as pieChartSpecialSlicesId,
  Ds as queryAllFeatures,
  Fs as queryAnalytic,
  Ls as queryAttributeBinsForScatterplot,
  Ts as queryAttributeBinsForTemporalData,
  xs as queryCalculatedExpr,
  Ps as queryDefaults,
  Bs as queryFeatureCount,
  $s as queryStatistics,
  Is as queryUniqueIDs,
  As as ramp,
  Os as reducedOpacity,
  Or as removePopover,
  vs as sanitizeHTMLOutput,
  Gr as setAssetPath,
  Ns as sortArrayAUsingArrayB,
  Rs as timeUnitHelper,
  ar as uniqueValues,
  Es as unrecognizedVersion,
  ks as updateRotation,
  Ms as updateSeriesVisibility,
  Vs as validateBarNLineChartDataItem,
  Qs as validateWebChart,
  Ws as webChartTypesSupportingTemporalBinning
};
