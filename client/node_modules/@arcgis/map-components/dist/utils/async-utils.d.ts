import { Nil } from '@arcgis/components-utils';
import { default as EsriError } from '@arcgis/core/core/Error.js';
export interface AbortError extends EsriError {
    name: "AbortError";
}
export interface AbortOptions {
    signal?: AbortSignal | null;
}
export declare function createAbortError(description?: string): AbortError;
export declare function throwIfAborted(params: AbortOptions | AbortSignal | Nil, description?: string): void;
export declare function signalFromSignalOrOptions(params: AbortOptions | AbortSignal | Nil): AbortSignal | undefined;
export declare function isAborted(params: AbortOptions | AbortSignal | Nil): boolean;
export declare function isAbortError(error: unknown): error is AbortError;
export declare function onAbort(params: AbortOptions | AbortSignal | Nil, callback: () => void): IHandle | Nil;
export interface Task<T> extends IHandle, Disposable {
    readonly value: Nil | T;
    readonly error: unknown;
    readonly finished: boolean;
    readonly promise: Promise<T>;
    abort: () => void;
}
type TaskFunction<T> = (signal: AbortSignal) => Promise<T>;
type TaskOptions = AbortOptions | AbortSignal | Nil;
/**
 * Wraps an async function (or function returning a promise) in order to create an abortable task.
 * This hides the complexity of creating and managing abort controllers, etc.
 *
 * 3D: Do not use this for anything else than wrapping trivial promises/promise chains. Do use a Scheduler task
 * to perform significant work:
 *
 * ```ts
 * this._queryTask = createTask((signal) => {
 *   const data = await view.resourceController.schedule(slowTask, signal);
 *   throwIfAborted(signal);
 *   // do things with data
 * });
 * ```
 *
 * Example:
 *
 *    ```ts
 *    const task = createTask((signal) => {
 *      return promiseUtils.whenOrAbort(doSomethingAsync(), signal);
 *    });
 *
 *    // Wait for the result
 *    task.promise.then((result) => console.log(result));
 *
 *    // Or abort it when not needed anymore.
 *    task.abort();
 *    ```
 *
 * @param task
 *    The task which is to be executed and made abortable. It receives a signal which can be passed to async operations
 *    in order for them to check whether the task has been aborted.
 *
 * @param options
 *    Abort the task
 *
 * @return
 *    An object which encapsulates the state of the task.
 *
 * @ignore
 */
export declare function createTask<T>(task: TaskFunction<T>, options?: TaskOptions): Task<T>;
export {};
