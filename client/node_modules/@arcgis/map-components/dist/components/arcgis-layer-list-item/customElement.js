import { c as T } from "../../chunks/runtime.js";
import { html as r } from "lit-html";
import { classes as y } from "@arcgis/components-utils";
import { isLayerFromCatalog as S } from "@arcgis/core/layers/catalog/catalogUtils.js";
import { LitElement as A, noShadowRoot as M, safeClassMap as h, nothing as o, safeStyleMap as w } from "@arcgis/lumina";
import { createRef as _, ref as v } from "lit-html/directives/ref.js";
import "lit/static-html.js";
import { s as L } from "../../chunks/component-utils.js";
import { s as E } from "../../chunks/layer-list.js";
import { u as x } from "../../chunks/useT9n.js";
/*! All material copyright Esri, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.33/esri/copyright.txt for details.
v4.33.19 */
const D = {
  hideChildren: "hide-children"
};
function O({
  exclusive: n,
  visible: e,
  visibilityAppearance: t
}) {
  const i = t === "checkbox";
  return e ? n ? "circle-f" : i ? "check-square-f" : "view-visible" : n ? "circle" : i ? "square" : "view-hide";
}
function R({
  connectionStatus: n,
  publishing: e
}) {
  return n ? n === "connected" ? "beacon" : "offline" : e ? "square" : "bullet-point";
}
function P(n) {
  return n?.listMode === D.hideChildren;
}
function F(n) {
  const e = (n?.layer && k(n.layer) ? n.layer.layer : void 0) ?? n?.layer;
  return e ? e.type === "catalog" ? !1 : U(e) ?? !0 : !1;
}
function k(n) {
  return n != null && "layer" in n && n.layer != null;
}
function U(n) {
  const e = V(n);
  return e != null && "supportsDynamicLayers" in e ? e.supportsDynamicLayers : void 0;
}
function V(n) {
  return n && "capabilities" in n && n.capabilities != null && "exportMap" in n.capabilities ? n.capabilities.exportMap : void 0;
}
function B(n) {
  return n?.getAttribute("data-item");
}
function G(n) {
  const { children: e, error: t } = n, i = "incompatible" in n ? n.incompatible : !1;
  return !!e?.filter((s) => !s.hidden).length && !t && !i;
}
function N(n) {
  for (const e of n)
    for (const t of e)
      if (t.type === "button" || t.type === "toggle")
        return t;
}
function I(n, e) {
  const t = n.parent, i = n.layer;
  if (i?.type !== "map-image" || !i.sourceJSON || !t)
    return !1;
  const s = i.sourceJSON.layers;
  if (!s)
    return !1;
  const a = s.find((l) => n.id === l.id), c = e === "footprints" ? "Feature Layer" : "Catalog Dynamic Group Layer";
  return a?.type !== c ? !1 : s.find((l) => l.id === t.id)?.type === "Catalog Layer";
}
function C(n) {
  if (n.icon)
    return n.icon;
  if (!("image" in n && n.image) && !n.className)
    return "question";
}
function H(n) {
  return n ? {
    backgroundImage: `url(${n})`
  } : {};
}
class J extends A {
  constructor() {
    super(...arguments), this._itemRef = _(), this._noticeRef = _(), this._messages = x({ name: "layer-list" }), this.hideCatalogLayerList = !1, this.showCloseButton = !1, this.showCollapseButton = !1, this.showErrors = !1, this.showFilter = !1, this.hideFlow = !1, this.showHeading = !1, this.hideStatusIndicators = !1, this.showTemporaryLayerIndicators = !1, this.showTemporaryTableIndicators = !1, this.dragEnabled = !1, this.listModeDisabled = !1, this.autoDestroyDisabled = !1;
  }
  static {
    this.properties = { _title: 16, _renderedItemStatus: 16, _renderedItemTemporaryIcon: 16, _renderedItemToggle: 16, _renderedPanel: 16, _renderedPanelAction: 16, _renderedActions: 16, _renderedActionMenu: 16, _renderedActionMenuContent: 16, _renderedCatalogFootprintIcon: 16, _renderedCatalogDynamicIcon: 16, _renderedCatalogSelectNode: 16, _renderedChildList: 16, _hasTables: 16, _renderedTablesItem: 16, _renderedItemMessage: 16, _singleAction: 16, _filteredSections: 16, _actionsCount: 16, activeItem: 0, canMove: 0, css: 0, displayMode: 1, hideCatalogLayerList: 5, showCloseButton: 5, showCollapseButton: 5, showErrors: 5, showFilter: 5, hideFlow: 5, showHeading: 5, hideStatusIndicators: 5, showTemporaryLayerIndicators: 5, showTemporaryTableIndicators: 5, dragEnabled: 5, item: 0, layerTablesEnabled: 0, listModeDisabled: 5, handleAction: 0, handlePanelOpen: 0, handleCatalogOpen: 0, handleTablesOpen: 0, handleSelectedDragItemLayerUidChange: 0, handleTooltipReferenceChange: 0, parent: 0, parentTitles: 0, rootGroupUid: 1, selectionMode: 1, selectedItems: 0, selectedDragItemLayerUid: 1, visibilityAppearance: 1, autoDestroyDisabled: 5 };
  }
  static {
    this.styles = E;
  }
  static {
    this.shadowRootOptions = M;
  }
  get _title() {
    const { _messages: e } = this;
    return this.item.title || ("untitledTable" in e ? e.untitledTable : e.untitledLayer);
  }
  get _renderedItemStatus() {
    const { item: e, parent: t, hideStatusIndicators: i, css: s } = this;
    if (!i)
      return null;
    const { publishing: a } = e, c = "updating" in e && e.updating && !t, l = "connectionStatus" in e ? e.connectionStatus : void 0, u = !!l;
    return r`<calcite-icon class=${h(y(s.statusIndicator, {
      [s.publishing]: a
    }, "updating" in s && {
      [s.updating]: c
    }, "connectionStatus" in s && {
      [s.connectionStatus]: u
    }, "connectionStatusConnected" in s && {
      [s.connectionStatusConnected]: u && l === "connected"
    }))} .icon=${R({ connectionStatus: l, publishing: a })} scale=s slot=content-end></calcite-icon>`;
  }
  get _renderedItemTemporaryIcon() {
    const { item: e, showTemporaryLayerIndicators: t, showTemporaryTableIndicators: i, css: s } = this, { layer: a } = e, c = a && "persistenceEnabled" in a && (S(a) || !a.persistenceEnabled);
    return (t || i) && c ? r`<calcite-icon class=${h(s.itemTemporaryIcon)} icon=temporary scale=s slot=content-start title=${this._messages.temporary ?? o}></calcite-icon>` : null;
  }
  get _renderedItemToggle() {
    const { item: e, parent: t, _messages: i, visibilityAppearance: s, css: a } = this;
    if (!("visible" in e) || !("layerVisibility" in i) || !("visibleToggle" in a) || !s)
      return null;
    const { visible: c } = e, l = this._getParentVisibilityMode(t);
    if (l === "inherited")
      return null;
    const u = O({
      visible: c,
      exclusive: l === "exclusive",
      visibilityAppearance: s
    }), d = s === "checkbox", g = i.layerVisibility;
    return r`<calcite-action appearance=transparent class=${h(a.visibleToggle)} .icon=${d ? u : void 0} @click=${() => this._toggleVisibility(e, t)} scale=s .slot=${d ? "actions-start" : "actions-end"} .text=${g ?? ""} title=${g ?? o}>${d ? null : r`<calcite-icon class=${h(y({
      [a.visibleIcon]: l !== "exclusive" && c
    }))} .icon=${u} scale=s></calcite-icon>`}</calcite-action>`;
  }
  get _renderedPanel() {
    const { panel: e } = this.item;
    return e?.open && !e.disabled && !e.flowEnabled ? r`<div class=${h(this.css.itemContentBottom)} slot=content-bottom>${/* TODO: [MIGRATION] Rewrite this widget to web component first, and then change it's usage to web component style */
    e.render()}</div>` : null;
  }
  get _renderedPanelAction() {
    const { panel: e } = this.item;
    if (!e?.visible)
      return null;
    const { open: t, title: i, disabled: s } = e, a = {
      icon: e.icon,
      image: e.image,
      indicator: !1
    };
    return r`<calcite-action .active=${t} appearance=transparent .disabled=${s} .icon=${C(a)} @click=${() => this._togglePanel(e)} scale=s slot=actions-end .text=${i ?? ""} title=${i ?? void 0 ?? o}>${this._renderFallbackIcon(e)}</calcite-action>`;
  }
  get _renderedActions() {
    switch (this._actionsCount) {
      case 0:
        return null;
      case 1:
        return this._singleAction;
      default:
        return this._renderedActionMenu;
    }
  }
  get _renderedActionMenu() {
    const { item: e, _messages: t } = this, i = t.options;
    return r`<calcite-action-menu appearance=transparent .label=${t.menu ?? ""} .open=${e.actionsOpen} overlay-positioning=fixed placement=bottom-end scale=s slot=actions-end @calciteActionMenuOpen=${this._onActionMenuOpen}><calcite-action appearance=transparent icon=ellipsis scale=s slot=trigger .text=${i ?? ""} title=${i ?? o}></calcite-action>${this._renderedActionMenuContent}</calcite-action-menu>`;
  }
  get _renderedActionMenuContent() {
    return this._filteredSections.toArray().map((e) => r`<calcite-action-group>${e.toArray().map((t) => this._renderAction({
      action: t,
      textEnabled: !0
    }))}</calcite-action-group>`);
  }
  get _renderedCatalogFootprintIcon() {
    const { css: e } = this, t = this.item.layer, i = t?.type === "catalog-footprint", s = t?.type === "sublayer" && I(t, "footprints");
    return "itemCatalogIcon" in e && (i || s) ? r`<calcite-icon class=${h(e.itemCatalogIcon)} icon=footprint scale=s slot=content-start></calcite-icon>` : null;
  }
  get _renderedCatalogDynamicIcon() {
    const { css: e } = this, t = this.item.layer, i = t?.type === "catalog-dynamic-group", s = t?.type === "sublayer" && I(t, "layers-in-view");
    return "itemCatalogIcon" in e && (i || s) ? r`<calcite-icon class=${h(e.itemCatalogIcon)} icon=catalog-dataset scale=s slot=content-start></calcite-icon>` : null;
  }
  get _renderedCatalogSelectNode() {
    const { _title: e, item: t, hideCatalogLayerList: i } = this;
    if (!("visible" in t))
      return;
    const { layer: s } = t, a = s?.type === "catalog-dynamic-group";
    return i && a ? r`<calcite-action appearance=transparent .disabled=${!s.visible} icon=chevron-right icon-flip-rtl @click=${() => this._triggerOnCatalogOpen(t)} scale=s slot=actions-end .text=${e}></calcite-action>` : null;
  }
  get _renderedChildList() {
    const { dragEnabled: e, item: t, rootGroupUid: i, listModeDisabled: s, selectionMode: a, displayMode: c } = this;
    if (!("children" in t))
      return;
    const l = [...this.parentTitles ?? [], t.title], { children: u, layer: d } = t, g = d?.type !== "catalog-dynamic-group" && G(t), f = s ? !1 : P(d), m = d?.type === "group", $ = !f && !g && e && m, b = e ? "childrenSortable" in t && t.childrenSortable && F(t) : !1;
    return g || $ ? r`<calcite-list .canPull=${(p) => this.canMove ? this.canMove(p, "pull") : !1} .canPut=${(p) => this.canMove ? this.canMove(p, "put") : !1} data-item=${t ?? o} data-layer-type=${i ?? o} .displayMode=${c} .dragEnabled=${b} .group=${m ? i : `${i}-${d?.uid}`} .label=${t.title} selection-appearance=border .selectionMode=${a}>${u?.filter((p) => !p.hidden && (this.showErrors || !p.error)).toArray().map((p) => this._renderItem(p, t, l))}${this._renderedTablesItem}</calcite-list>` : null;
  }
  get _hasTables() {
    const { layerTablesEnabled: e } = this, t = this.item.layer;
    if (!e || !t)
      return !1;
    switch (t.type) {
      case "knowledge-graph":
        return e.includes(t.type) && "tables" in t && !!t.tables?.length;
      case "map-image":
      case "tile":
        return e.includes(t.type) && "subtables" in t && !!t.subtables?.length;
      default:
        return !1;
    }
  }
  get _renderedTablesItem() {
    const { item: e, _messages: t, css: i } = this, { layer: s } = e;
    return "itemTableIcon" in i && "visible" in e && "tables" in t && this._hasTables ? r`<calcite-list-item class=${h(i.item)} data-layer-id=${s?.id ?? o} drag-disabled .label=${t.tables} title=${t.tables ?? o} @calciteListItemSelect=${() => this._triggerOnTablesOpen(e)}><calcite-icon class=${h(i.itemTableIcon)} icon=table scale=s slot=content-start></calcite-icon><calcite-icon flip-rtl icon=chevron-right scale=s slot=content-end></calcite-icon></calcite-list-item>` : null;
  }
  get _renderedItemMessage() {
    const { item: e, _messages: t, css: i } = this;
    return e.error ? r`<div class=${h(i.itemMessage)} slot=content-bottom><calcite-notice icon=exclamation-mark-triangle kind=warning open scale=s width=full><div slot=message>${"tableError" in t ? t.tableError : t.layerError}</div></calcite-notice></div>` : "incompatible" in e && e.incompatible && "layerIncompatible" in t ? r`<div class=${h(i.itemMessage)} slot=content-bottom><calcite-notice icon=exclamation-mark-triangle kind=warning open scale=s tabindex=0 width=full ${v(this._noticeRef)}><div slot=message>${t.layerIncompatible}</div></calcite-notice></div>` : null;
  }
  get _singleAction() {
    return this._renderAction({
      action: N(this._filteredSections),
      textEnabled: !1
    });
  }
  get _filteredSections() {
    return this.item.actionsSections.map((e) => e.filter((t) => t.visible));
  }
  get _actionsCount() {
    return this.item.actionsSections.reduce((e, t) => e + t.length, 0);
  }
  async destroy() {
    await this.manager.destroy();
  }
  willUpdate() {
    this._itemRef.value && this._focusSelectedDragEl(this._itemRef.value, this.item), this._noticeRef.value && this._setTooltipReference(this._noticeRef.value);
  }
  updated() {
    this._itemRef.value && this._focusSelectedDragEl(this._itemRef.value, this.item), this._noticeRef.value && this._removeTooltipReference();
  }
  _onActionMenuOpen(e) {
    this.item.actionsOpen = e.currentTarget.open;
  }
  _setTooltipReference(e) {
    this.handleTooltipReferenceChange?.(this.item.layer?.uid, e);
  }
  _removeTooltipReference() {
    this.handleTooltipReferenceChange?.(this.item.layer?.uid, null);
  }
  _triggerAction(e, t) {
    !t || !e || (t.type === "toggle" && (t.value = !t.value), this.handleAction(t, e));
  }
  _triggerOnTablesOpen(e) {
    !e || !this.handleTablesOpen || this.handleTablesOpen(e);
  }
  _triggerOnCatalogOpen(e) {
    e && this.handleCatalogOpen?.(e);
  }
  _focusSelectedDragEl(e, t) {
    this.selectedDragItemLayerUid === t.layer?.uid && (L(e), this.handleSelectedDragItemLayerUidChange?.(null));
  }
  _handleCalciteListItemToggle(e, t) {
    e.stopPropagation(), t.open = e.target.expanded;
  }
  _getParentVisibilityMode(e) {
    return e && "visibilityMode" in e ? e.visibilityMode : null;
  }
  _handleCalciteListItemSelect(e, t, i) {
    if (B(e.target) !== t)
      return;
    const s = this._getParentVisibilityMode(i);
    this.selectionMode !== "none" || s === "inherited" || this._toggleVisibility(t, i);
  }
  _togglePanel(e) {
    e.open = !e.open, e.open && this.handlePanelOpen();
  }
  _toggleVisibility(e, t) {
    if (!e || !("visible" in e))
      return;
    this._getParentVisibilityMode(t) === "exclusive" && e.visible || (e.visible = !e.visible);
  }
  render() {
    const e = this.parentTitles ?? [], { _title: t, item: i, activeItem: s, selectionMode: a, selectedItems: c, _messages: l, parent: u, css: d } = this, g = "visibleAtCurrentTimeExtent" in i && "layerInvisibleAtTime" in l && !i.visibleAtCurrentTimeExtent ? `${t} (${l.layerInvisibleAtTime})` : "visibleAtCurrentScale" in i && "layerInvisibleAtScale" in l && !i.visibleAtCurrentScale ? `${t} (${l.layerInvisibleAtScale})` : t, f = "parent" in i && i.parent?.layer?.type === "catalog", { layer: m } = i, $ = "visibleAtCurrentScale" in i && !i.visibleAtCurrentScale || "visibleAtCurrentTimeExtent" in i && !i.visibleAtCurrentTimeExtent;
    return r`<calcite-list-item class=${h(y(d.item, "itemActive" in d && { [d.itemActive]: s === i }))} data-item=${i ?? o} data-layer-id=${m?.id ?? o} .dragDisabled=${!("sortable" in i && i.sortable) || f} id=${m?.uid ?? o} .label=${t} .metadata=${{ parentTitles: e, _title: t }} .expanded=${"open" in i && i.open} .selected=${a !== "none" ? c.includes(i) : !1} title=${g ?? o} .unavailable=${$} .value=${m?.uid} @calciteListItemSelect=${(b) => "visible" in i && this._handleCalciteListItemSelect(b, i, u)} @calciteListItemToggle=${(b) => "open" in i && this._handleCalciteListItemToggle(b, i)} ${v(this._itemRef)}>${this._renderedCatalogFootprintIcon}${this._renderedCatalogDynamicIcon}${this._renderedItemStatus}${this._renderedItemToggle}${this._renderedCatalogSelectNode}${this._renderedItemTemporaryIcon}${this._renderedChildList}${this._renderedItemMessage}${this._renderedPanel}${this._renderedPanelAction}${this._renderedActions}</calcite-list-item>`;
  }
  _renderAction(e) {
    const { item: t } = this, { action: i, textEnabled: s } = e;
    if (!i)
      return null;
    const { active: a, disabled: c, title: l, type: u, indicator: d } = i;
    return r`<calcite-action .active=${u === "toggle" ? i.value : !1} appearance=transparent data-action-id=${i.id ?? o} .disabled=${c} .icon=${C(i)} .indicator=${d} .loading=${a} @click=${() => this._triggerAction(t, i)} scale=s slot=${(s ? void 0 : "actions-end") ?? o} .text=${l ?? ""} .textEnabled=${s} title=${l ?? void 0 ?? o}>${this._renderFallbackIcon(i)}</calcite-action>`;
  }
  _renderFallbackIcon(e) {
    const { css: t } = this, { icon: i } = e;
    if (i)
      return null;
    const s = "image" in e ? e.image : void 0, a = {
      [t.itemActionImage]: !!s
    };
    return s ? r`<span aria-hidden=true class=${h(y(t.itemActionIcon, a))} style=${w(H(s))}></span>` : null;
  }
  _renderItem(e, t, i = []) {
    return r`<arcgis-layer-list-item .activeItem=${this.activeItem} .canMove=${this.canMove} .css=${this.css} .displayMode=${this.displayMode} .dragEnabled=${this.dragEnabled} .item=${e} .layerTablesEnabled=${this.layerTablesEnabled} .listModeDisabled=${this.listModeDisabled} .parent=${t} .parentTitles=${i} .rootGroupUid=${this.rootGroupUid} .selectedDragItemLayerUid=${this.selectedDragItemLayerUid} .selectedItems=${this.selectedItems} .selectionMode=${this.selectionMode} .visibilityAppearance=${this.visibilityAppearance} .handleAction=${this.handleAction} .handleCatalogOpen=${this.handleCatalogOpen} .handlePanelOpen=${this.handlePanelOpen} .handleSelectedDragItemLayerUidChange=${this.handleSelectedDragItemLayerUidChange} .handleTablesOpen=${this.handleTablesOpen} .handleTooltipReferenceChange=${this.handleTooltipReferenceChange} .hideCatalogLayerList=${this.hideCatalogLayerList} .showCloseButton=${this.showCloseButton} .showCollapseButton=${this.showCollapseButton} .showErrors=${this.showErrors} .showFilter=${this.showFilter} .hideFlow=${this.hideFlow} .showHeading=${this.showHeading} .hideStatusIndicators=${this.hideStatusIndicators} .showTemporaryLayerIndicators=${this.showTemporaryLayerIndicators} .showTemporaryTableIndicators=${this.showTemporaryTableIndicators}></arcgis-layer-list-item>`;
  }
}
T("arcgis-layer-list-item", J);
export {
  J as ArcgisLayerListItem
};
