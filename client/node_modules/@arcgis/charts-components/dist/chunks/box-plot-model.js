import { WebChartTypes as x } from "@arcgis/charts-spec";
import "lodash-es";
import "d3-array";
import { az as O, as as I, Y as D, P as U, aS as g, T as d, U as c } from "./interfaces.js";
import "@arcgis/core/geometry/support/jsonUtils.js";
import "@arcgis/core/rest/support/AttributeBinsQuery.js";
import "@arcgis/core/rest/support/Query.js";
import "@arcgis/core/rest/support/StatisticDefinition.js";
import "@arcgis/core/time/TimeExtent.js";
import "@arcgis/core/core/promiseUtils.js";
import "@arcgis/core/request.js";
import { j as a } from "./index4.js";
import { C as W, M as E, a as N } from "./model-with-y-guides.js";
import { B as b } from "./common.js";
import { M as V, a as P, b as z, c as T } from "./model-with-data-labels.js";
import { f as j, i as k, j as A, h as K } from "./data.js";
import { M as Y } from "./model-with-rotation.js";
import { g as R, s as f, a as q, b as m } from "./series.js";
import { g as G, s as X, a as S, b as H, c as J, d as Q, e as Z, f as $, h as ee, i as te, j as ie, k as u, l as C, m as y, n as p, o as se, p as oe, q as re, r as ae, t as ne, u as he, v as L, w as le, x as M, y as ge, z as _, A as de, B as ce, C as fe, D as me, E as w } from "./box-plot-data.js";
/*! All material copyright Esri, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.33/esri/copyright.txt for details.
v4.33.19 */
class Se extends W {
  constructor() {
    super(...arguments), this._chartType = x.BoxPlotSeries;
  }
  async setup(e) {
    await this.loadConfigFromLayer(e), this.commonStrings = await j(), e.config !== void 0 && await this.updateSeriesFromLayerFilter(), this.resolveSetup();
  }
  // ---------------------------------------------------------------------------------------------
  // Data Props
  // ---------------------------------------------------------------------------------------------
  /**
   * Gets the category field for the box plot.
   * @returns {string}
   */
  getCategory() {
    return G(this._config);
  }
  /**
   * Sets the category field for the box plot.
   * @param {string} newCategory The new category field.
   * @async **This method is `async` and must be awaited for the changes to take effect.**
   */
  async setCategory(e) {
    await X(e, this._config, this.layerInfo), this.dispatchEvent(new CustomEvent("arcgisChartsModelDataChange")), this.emitConfigUpdate("setCategory");
  }
  /**
   * Gets the list of the category values for the chart.
   * @returns {string[]}
   */
  async getCustomSortValues() {
    return await S(this._config, this.layerInfo);
  }
  /**
   * Gets the numeric fields array for the box plot.
   * @returns {string[]}
   */
  getNumericFields() {
    return H(this._config);
  }
  /**
   * Sets the numeric field or numeric fields array for the box plot.
   * @param {string[] | string} newNumericFields The new numeric field or numeric fields array.
   * @async **This method is `async` and must be awaited for the changes to take effect.**
   */
  async setNumericFields(e) {
    const { layerFieldsInfo: t } = this.layerInfo;
    typeof e == "string" && (e = [e]), k(t, e) ? (await J(e, this._config, this.layerInfo), this.dispatchEvent(new CustomEvent("arcgisChartsModelDataChange")), this.emitConfigUpdate("setNumericFields")) : console.log("Invalid numericFields");
  }
  /**
   * Gets the split-by field for the box plot.
   * @returns {string}
   */
  getSplitByField() {
    return Q(this._config);
  }
  /**
   * Sets the split-by field for the box plot.
   * @param {string} newSplitByField The new split-by field.
   * @async **This method is `async` and must be awaited for the changes to take effect.**
   */
  async setSplitByField(e) {
    A(this.layerInfo.layerFieldsInfo, e) ? (await Z(e, this._config, this.layerInfo), this.dispatchEvent(new CustomEvent("arcgisChartsModelDataChange")), this.emitConfigUpdate("setSplitByField")) : console.log("Invalid splitByField");
  }
  /**
   * Gets whether outliers are shown.
   * @returns {boolean}
   */
  getShowOutliers() {
    return $(this._config);
  }
  /**
   * Sets whether outliers are shown.
   * @param {boolean} newShowOutliersState The new show outliers state.
   * @async **This method is `async` and must be awaited for the changes to take effect.**
   */
  async setShowOutliers(e) {
    await ee(e, this._config, this.layerInfo), this.dispatchEvent(new CustomEvent("arcgisChartsModelDataChange")), this.emitConfigUpdate("setShowOutliers");
  }
  /**
   * Gets whether values are standardized as z-scores.
   * @returns {boolean}
   */
  getStandardizeValues() {
    return te(this._config);
  }
  /**
   * Sets whether values are standardized as z-scores.
   * @param {boolean} newStandardizeValuesState The new standardize values state.
   * @async **This method is `async` and must be awaited for the changes to take effect.**
   */
  async setStandardizeValues(e) {
    await ie(e, this._config, this.layerInfo), this.dispatchEvent(new CustomEvent("arcgisChartsModelDataChange")), this.emitConfigUpdate("setStandardizeValues");
  }
  /**
   * Gets the sort order of the box plot data.
   * @returns {"xAxisAsc" | "xAxisDesc"| "meanAsc" | "meanDesc" | "medianAsc" | "medianDesc" | "customSort"}
   */
  getSortOrder() {
    return u(this._config);
  }
  /**
   * Sets the sort order of the box plot data.
   * @param {"xAxisAsc" | "xAxisDesc"| "meanAsc" | "meanDesc" | "medianAsc" | "medianDesc" | "customSort"} newSortOrder The new sort order.
   * @param {string[]} orderByList The new list of category's values for custom sort.
   */
  setSortOrder(e, t) {
    C(e, this._config, t), this.emitConfigUpdate("setSortOrder");
  }
  /**
   * Gets the list of category's values for custom sort
   * @returns {string[]}
   */
  getOrderByList() {
    return y(this._config);
  }
  /**
   * Sets the list of category's values for custom sort
   * @param {string[]} newOrderByList The new list of category's values
   */
  setOrderByList(e) {
    p(e, this._config), this.emitConfigUpdate("setOrderByList");
  }
  /**
   * Updates the series based on the layer filter.
   * @async **This method is `async` and must be awaited for the changes to take effect.*
   */
  async updateSeriesFromLayerFilter() {
    await se({
      splitByField: this.getSplitByField(),
      numericFields: this.getNumericFields(),
      category: this.getCategory(),
      config: this._config,
      layerInfo: this.layerInfo
    }), this.dispatchEvent(new CustomEvent("arcgisChartsModelDataChange")), this.emitConfigUpdate("updateSeriesFromLayerFilter");
  }
  /**
   * Gets the data filter for the bar chart.
   * @returns {WebChartDataFilters | undefined}
   */
  getDataFilter() {
    return oe(this._config);
  }
  /**
   * Sets the data filter for the bar chart.
   * @param {WebChartDataFilters | undefined} newDataFilter The new data filter.
   */
  async setDataFilter(e) {
    re(e, this._config);
    const t = u(this._config);
    if (t === b.customSort) {
      const i = await S(this._config, this.layerInfo);
      C(t, this._config, i);
    }
    this.dispatchEvent(new CustomEvent("arcgisChartsModelDataChange")), this.emitConfigUpdate("setDataFilter");
  }
  // ---------------------------------------------------------------------------------------------
  // Series Props
  // ---------------------------------------------------------------------------------------------
  /**
   * Gets whether mean lines are shown.
   * @returns {boolean | undefined}
   */
  getShowMeanLines() {
    return ae(this._config);
  }
  /**
   * Sets whether mean lines are shown.
   * @param {boolean | undefined} newShowMeanLines The new show mean lines state.
   */
  async setShowMeanLines(e) {
    const { previousMeanLinesBoxColor: t } = await ne(
      e,
      this._config,
      this.previousMeanLinesBoxColor
    );
    this.previousMeanLinesBoxColor = t, this.emitConfigUpdate("setShowMeanLines");
  }
  /**
   * Gets the color of the boxes when showing mean lines. Only applicable when mean lines are shown.
   * @returns {Color | undefined}
   */
  getMeanLinesBoxColor() {
    return he(this._config);
  }
  /**
   * Sets the color of the boxes when showing mean lines. Only applicable when mean lines are shown.
   * @param {Color | undefined} newColor The new color.
   */
  setMeanLinesBoxColor(e) {
    L(e, this._config), this.emitConfigUpdate("setMeanLinesBoxColor");
  }
  // ---------------------------------------------------------------------------------------------
  // Protected Methods
  // ---------------------------------------------------------------------------------------------
  async generateDefaultConfig() {
    const e = await O();
    return e.series = [await I()], e;
  }
  /**
   * Resets the config to the default config
   */
  async resetConfig() {
    const e = this._config.id;
    this._config = await this.generateDefaultConfig(), this._config.id = e, this.dispatchEvent(new CustomEvent("arcgisChartsModelDataChange")), this.emitConfigUpdate("resetConfig");
  }
  // ---------------------------------------------------------------------------------------------
  // Series Methods
  // ---------------------------------------------------------------------------------------------
  /**
   * Gets the name of the series based on the series index. If the index is out of bounds, it will return `undefined`.
   * @param {number} seriesIndex The index of the series.
   * @returns {string | undefined}
   */
  getSeriesName(e) {
    return le(e, this._config);
  }
  /**
   * Sets name of the series based on the series index.
   * @param {string} newName The new name for the series.
   * @param {number} seriesIndex The index of the series.
   */
  setSeriesName(e, t) {
    M(e, t, this._config), this.emitConfigUpdate("setSeriesName");
  }
  /**
   * Gets the color of the series based on the series index. If the index is out of bounds, it will return `undefined`.
   * @param {number} seriesIndex The index of the series.
   * @returns {Color | undefined}
   */
  getSeriesColor(e) {
    return ge(e, this._config);
  }
  /**
   * Sets the color of the series based on the series index.
   * @param {Color | undefined} newColor The new color for the series.
   * @param {number} seriesIndex The index of the series.
   */
  setSeriesColor(e, t) {
    _(e, t, this._config), this.emitConfigUpdate("setSeriesColor");
  }
  /**
   * Gets the line style of the series based on the series index. If the index is out of bounds, it will return `undefined`.
   *
   * **Only applicable when mean lines are shown.**
   *
   * @param {number} seriesIndex The index of the series.
   * @returns {RESTSimpleLineSymbolStyle | undefined}
   */
  getSeriesLineStyle(e) {
    const t = this._config.series[e];
    if (this.getShowMeanLines() === !0 && a(t))
      return R(t);
  }
  /**
   * Sets the line style of the series based on the series index.
   *
   * **Only applicable when mean lines are shown.**
   *
   * @param {RESTSimpleLineSymbolStyle | undefined} newStyle The new style for the series.
   * @param {number} seriesIndex The index of the series.
   */
  setSeriesLineStyle(e, t) {
    const i = this._config.series[t];
    this.getShowMeanLines() === !0 && a(i) && f(e, i), this.emitConfigUpdate("setSeriesLineStyle");
  }
  /**
   * Gets the line width of the series based on the series index. If the index is out of bounds, it will return `undefined`.
   *
   * **Only applicable when mean lines are shown.**
   *
   * @param {number} seriesIndex The index of the series.
   * @returns {number | undefined}
   */
  getSeriesLineWidth(e) {
    const t = this._config.series[e];
    if (this.getShowMeanLines() === !0 && a(t))
      return q(t);
  }
  /**
   * Sets the line width of the series based on the series index.
   *
   * **Only applicable when mean lines are shown.**
   *
   * @param {number | undefined} newWidth The new width for the series.
   * @param {number} seriesIndex The index of the series.
   */
  setSeriesLineWidth(e, t) {
    const i = this._config.series[t];
    this.getShowMeanLines() === !0 && a(i) && m(e, i), this.emitConfigUpdate("setSeriesLineWidth");
  }
  /**
   * Gets the order of the series array by returning an array of series ids.
   * @returns {string[]}
   */
  getOrderOfSeries() {
    return de(this._config);
  }
  /**
   * Sets the order of the series array by providing an array of series ids.
   * @param {string[]} newOrder The new order of the series array.
   */
  setOrderOfSeries(e) {
    ce(e, this._config), this.emitConfigUpdate("setOrderOfSeries");
  }
  /**
   * Moves a series from one index in the series array to another.
   * @param {number} fromIndex Index to move the series from.
   * @param {number} toIndex Index to move the series to.
   */
  moveSeries(e, t) {
    fe(e, t, this._config), this.emitConfigUpdate("moveSeries");
  }
  /**
   * Get the index of the box plot series in the series array in config object when show mean is true.
   *
   * **NOTE**: There is only one box plot series when show mean is true. The function returns '-1' if show mean is false.
   * @param config - config object
   */
  getBoxPlotSeriesIndexWhenMeanLinesShown() {
    return me(this._config);
  }
  /**
   * Move the custom sort values in-place for the order by list in the config.
   *
   * NOTE: This method should be only used when the sort order is set to `BoxPlotDataSortingKinds.customSort`.
   * @param {number} fromIndex The index to move the custom sort item from.
   * @param {number} toIndex The index to move the category item to.
   */
  moveCustomSortValuesInOrderByList(e, t) {
    const i = y(this._config), [o] = i.splice(e, 1);
    i.splice(t, 0, o), p(i, this._config), this.emitConfigUpdate("moveCustomSortValuesInOrderByList");
  }
  /**
   * Resets the series styling to the default styling.
   */
  resetSeriesStyling() {
    const e = this.getSeriesLength(), t = this.getShowMeanLines();
    for (let i = t === !0 ? 1 : 0; i < e; i += 1) {
      const o = this.getSeriesId(i), n = D({
        colorIndex: i,
        opacity: U
      }), r = this._config.series[i];
      _(n, i, this._config);
      const s = w({
        series: r,
        splitByField: this.getSplitByField(),
        layerInfo: this.layerInfo,
        commonStrings: this.commonStrings
      });
      M(s ?? o, i, this._config), t === !0 && a(r) && (f(d, r), m(c, r));
    }
    t === !0 && L(g, this._config), this._config.colorMatch = !0, this.emitConfigUpdate("resetSeriesStyling");
  }
  /**
   * Returns whether the series styling is able to be reset.
   * @returns {boolean}
   */
  resetAvailable() {
    const e = !this.getColorMatch(), t = this.getShowMeanLines(), i = t === !0 && this.getMeanLinesBoxColor() !== g;
    let o = !1, n = !1;
    if (!e) {
      const r = this.getSeriesLength();
      for (let s = t === !0 ? 1 : 0; s < r; s += 1) {
        const h = this._config.series[s], l = w({
          series: h,
          splitByField: this.getSplitByField(),
          layerInfo: this.layerInfo,
          commonStrings: this.commonStrings
        }), B = this.getSeriesName(s);
        if (l !== void 0 && l !== B) {
          o = !0;
          break;
        }
        if (t === !0 && a(h)) {
          const v = this.getSeriesLineStyle(s), F = this.getSeriesLineWidth(s);
          if (v !== d || F !== c) {
            n = !0;
            break;
          }
        }
      }
    }
    return e || i || o || n;
  }
}
K(Se, [
  E,
  V,
  P,
  z,
  Y,
  T,
  N
]);
export {
  Se as BoxPlotModel
};
