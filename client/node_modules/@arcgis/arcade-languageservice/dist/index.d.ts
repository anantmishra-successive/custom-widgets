import { ApiContext } from '@arcgis/languages-api-utils';
import { CompletionList } from 'vscode-languageserver-types';
import { DiagnosticSeverity } from 'vscode-languageserver-types';
import { LanguageServiceSettings } from '@arcgis/languages-api-utils';
import { Position as Position_2 } from 'vscode-languageserver-types';
import { Range as Range_2 } from 'vscode-languageserver-types';
import { TextDocument } from 'vscode-languageserver-textdocument';
import { TextEdit } from 'vscode-languageserver-types';

export declare interface ArcadeApiContext extends ApiContext {
    /**
     * Options to control how the script should be formatted
     */
    formattingOptions?: FormattingOptions;
}

export declare function arcadeFormat(document: TextDocument, context?: ArcadeApiContext): TextEdit[];

export declare const ArcadeKeywords: ("function" | "else" | "import" | "break" | "continue" | "for" | "if" | "export" | "in" | "return" | "var" | "while")[];

export declare class ArcadeLanguageService {
    private apiService;
    configure(settings: LanguageServiceSettings): void;
    doValidation(document: TextDocument, context: ArcadeApiContext): Promise<Diagnostic[]>;
    doComplete(document: TextDocument, position: Position_2, context: ArcadeApiContext): Promise<CompletionList>;
}

export declare const ArcadeLiterals: ("false" | "null" | "true")[];

export declare const ArcadeReservedKeywords: string[];

/**
 * Define an Arcade array expression.
 * Example: [1, 2, 3]
 */
declare interface ArrayExpression extends NodeBase<typeof NodeTypes.ArrayExpression> {
    /**
     * The elements of the array expression.
     */
    elements: Expression[];
}

/**
 * Define an Arcade assignment expression.
 * Example: a = 1;
 */
declare interface AssignmentExpression extends NodeBase<typeof NodeTypes.AssignmentExpression> {
    /**
     * The operator of the assignment expression.
     * Example: a = 1;
     *
     */
    operator: AssignmentOperators;
    /**
     * The left side of the assignment expression.
     * Example: a = 1;
     * The left side is a.
     */
    left: Identifier | MemberExpression;
    /**
     * The right side of the assignment expression.
     * Example: a = 1;
     * The right side is 1.
     */
    right: Expression;
}

/**
 * Arcade assignment operators.
 */
declare const AssignmentOperators: readonly string[];

/**
 * Arcade assignment operators.
 */
declare type AssignmentOperators = (typeof AssignmentOperators)[number];

/**
 * Define an Arcade binary expression.
 * Example: a << 1; or a + 1;
 */
declare interface BinaryExpression extends NodeBase<typeof NodeTypes.BinaryExpression> {
    /**
     * The operator of the binary expression.
     * Example: a << 1; or a + 1;
     * The operator is << or +.
     */
    operator: BinaryOperators;
    /**
     * The left side of the binary expression.
     * Example: a << 1; or a + 1;
     * The left side is a.
     */
    left: Expression;
    /**
     * The right side of the binary expression.
     * Example: a << 1; or a + 1;
     * The right side is 1.
     */
    right: Expression;
}

/**
 * Arcade binary operators.
 */
declare const BinaryOperators: readonly string[];

/**
 * Arcade binary operators.
 */
declare type BinaryOperators = (typeof BinaryOperators)[number];

/**
 * Define a block comment.
 */
declare interface BlockComment extends ItemLocation {
    readonly type: typeof NodeTypes.BlockComment;
    /**
     * The value of the comment.
     */
    value: string;
}

/**
 * Define an Arcade block statement.
 * Example: { return 1; }
 */
declare interface BlockStatement extends NodeBase<typeof NodeTypes.BlockStatement> {
    /**
     * The collection of statements in the block.
     */
    body: Statement[];
    /**
     * The collection of comments inside the block.
     */
    innerComments?: Comment_2[];
}

/**
 * Define an Arcade break statement.
 * Example: for (var i = 0; i < 10; i++) { break; }
 */
declare type BreakStatement = NodeBase<typeof NodeTypes.BreakStatement>;

/**
 * Define an Arcade call expression.
 * Example: foo(1, 2, 3)
 */
declare interface CallExpression extends NodeBase<typeof NodeTypes.CallExpression> {
    /**
     * The callee of the call expression.
     * Example: foo(1, 2, 3)
     * The callee is foo.
     */
    callee: Identifier | MemberExpression;
    /**
     * The arguments of the call expression.
     * Example: foo(1, 2, 3)
     * The arguments are 1, 2 and 3.
     */
    arguments: Expression[];
}

/**
 * Define a comment of type block or line.
 */
declare type Comment_2 = BlockComment | LineComment;

/**
 * Define an Arcade computed member expression.
 * Example: foo[1]
 */
declare interface ComputedMemberExpression extends NodeBase<typeof NodeTypes.MemberExpression> {
    readonly computed: true;
    /**
     * The object of the member expression.
     * Example: foo[1]
     * The object is foo.
     */
    object: Expression;
    /**
     * The property of the member expression.
     * Example: foo[1]
     * The property is 1.
     */
    property: Expression;
}

/**
 * Arcade contextual keywords.
 */
declare const ContextualKeywords: {
    From: string;
    Of: string;
};

/**
 * Define an Arcade continue statement.
 * Example: for (var i = 0; i < 10; i++) { continue; }
 */
declare type ContinueStatement = NodeBase<typeof NodeTypes.ContinueStatement>;

declare function convertProgramToJSON(program: Program): Record<string, unknown>;

/**
 * Define the types of Arcade Declaration.
 */
declare type Declaration = ExportNamedDeclaration | FunctionDeclaration | ImportDeclaration | VariableDeclaration;

/**
 * Define the delegate for the parser.
 */
declare type Delegate = (node: Node_2) => void;

/**
 * Represents a diagnostic, such as a parsing error or warning.
 */
export declare interface Diagnostic {
    /**
     * The range at which the message applies
     */
    range: Range_2;
    /**
     * The diagnostic's severity. Can be omitted. If omitted it is up to the
     * client to interpret diagnostics as error, warning, info or hint.
     */
    severity?: DiagnosticSeverity;
    /**
     * The diagnostic's code.
     */
    code: DiagnosticCodes;
    /**
     * The diagnostic's message. It usually appears in the user interface
     */
    message: string;
    /**
     * A data entry field that is preserved between a `textDocument/publishDiagnostics`
     * notification and `textDocument/codeAction` request.
     */
    data?: DiagnosticData_2 | null;
}

/**
 * The Arcade diagnostic class.
 */
declare class Diagnostic_2 extends Error implements DiagnosticApi {
    readonly declaredRootClass: string;
    code: DiagnosticCodes_2;
    index: number;
    line: number;
    column: number;
    len: number;
    range: SourceLocation;
    description?: string;
    data?: DiagnosticData_3 | null;
    constructor({ code, index, line, column, len, description, data }: DiagnosticApi);
}

/**
 * Define the properties of a diagnostic.
 */
declare interface DiagnosticApi extends Marker {
    /**
     * The diagnostic code.
     */
    code: DiagnosticCodes_2;
    /**
     * The diagnostic description.
     */
    description?: string;
    /**
     * The length of the token.
     */
    len?: number;
    /**
     * The associated diagnostic data.
     */
    data?: DiagnosticData_3 | null;
}

/**
 * The combined diagnostic codes
 */
export declare type DiagnosticCodes = Parser.DiagnosticCodes | ValidationDiagnosticCodes;

/**
 * Arcade diagnostic error codes.
 */
declare const DiagnosticCodes_2: {
    readonly InvalidModuleUri: "InvalidModuleUri";
    readonly ForInOfLoopInitializer: "ForInOfLoopInitializer";
    readonly IdentifierExpected: "IdentifierExpected";
    readonly InvalidEscapedReservedWord: "InvalidEscapedReservedWord";
    readonly InvalidExpression: "InvalidExpression";
    readonly InvalidFunctionIdentifier: "InvalidFunctionIdentifier";
    readonly InvalidHexEscapeSequence: "InvalidHexEscapeSequence";
    readonly InvalidLeftHandSideInAssignment: "InvalidLeftHandSideInAssignment";
    readonly InvalidLeftHandSideInForIn: "InvalidLeftHandSideInForIn";
    readonly InvalidTemplateHead: "InvalidTemplateHead";
    readonly InvalidVariableAssignment: "InvalidVariableAssignment";
    readonly KeyMustBeString: "KeyMustBeString";
    readonly NoFunctionInsideBlock: "NoFunctionInsideBlock";
    readonly NoFunctionInsideFunction: "NoFunctionInsideFunction";
    readonly ModuleExportRootOnly: "ModuleExportRootOnly";
    readonly ModuleImportRootOnly: "ModuleImportRootOnly";
    readonly PunctuatorExpected: "PunctuatorExpected";
    readonly TemplateOctalLiteral: "TemplateOctalLiteral";
    readonly UnexpectedBoolean: "UnexpectedBoolean";
    readonly UnexpectedEndOfScript: "UnexpectedEndOfScript";
    readonly UnexpectedIdentifier: "UnexpectedIdentifier";
    readonly UnexpectedKeyword: "UnexpectedKeyword";
    readonly UnexpectedNull: "UnexpectedNull";
    readonly UnexpectedNumber: "UnexpectedNumber";
    readonly UnexpectedPunctuator: "UnexpectedPunctuator";
    readonly UnexpectedString: "UnexpectedString";
    readonly UnexpectedTemplate: "UnexpectedTemplate";
    readonly UnexpectedToken: "UnexpectedToken";
};

/**
 * Arcade diagnostic error codes.
 */
declare type DiagnosticCodes_2 = (typeof DiagnosticCodes_2)[keyof typeof DiagnosticCodes_2];

/**
 * Represents the data associated with a diagnostic.
 * For example in case of an error associated to an identifier,
 * the DiagnosticData will contain a key 'identifier' and its value.
 */
declare type DiagnosticData_2 = Record<string, number | string>;
export { DiagnosticData_2 as DiagnosticData }

/**
 * Arcade diagnostic data.
 */
declare type DiagnosticData_3 = Record<string, number | string>;

export declare const DiagnosticMessages: {
    readonly InvalidModuleUri: string;
    readonly ForInOfLoopInitializer: string;
    readonly IdentifierExpected: string;
    readonly InvalidEscapedReservedWord: string;
    readonly InvalidExpression: string;
    readonly InvalidFunctionIdentifier: string;
    readonly InvalidHexEscapeSequence: string;
    readonly InvalidLeftHandSideInAssignment: string;
    readonly InvalidLeftHandSideInForIn: string;
    readonly InvalidTemplateHead: string;
    readonly InvalidVariableAssignment: string;
    readonly KeyMustBeString: string;
    readonly NoFunctionInsideBlock: string;
    readonly NoFunctionInsideFunction: string;
    readonly ModuleExportRootOnly: string;
    readonly ModuleImportRootOnly: string;
    readonly PunctuatorExpected: string;
    readonly TemplateOctalLiteral: string;
    readonly UnexpectedBoolean: string;
    readonly UnexpectedEndOfScript: string;
    readonly UnexpectedIdentifier: string;
    readonly UnexpectedKeyword: string;
    readonly UnexpectedNull: string;
    readonly UnexpectedNumber: string;
    readonly UnexpectedPunctuator: string;
    readonly UnexpectedString: string;
    readonly UnexpectedTemplate: string;
    readonly UnexpectedToken: string;
    readonly AlreadyDefined: "'${identifier}' is already defined.";
    readonly ApiConflict: "'${identifier}' is already defined as an Arcade constant or function.";
    readonly AssignedNeverUsed: "'${identifier}' is assigned but never used.";
    readonly DefinedNeverAssigned: "'${identifier}' is defined but never assigned.";
    readonly DefinedNeverUsed: "'${identifier}' is defined but never used.";
    readonly EmptyBlockStatement: "Empty block statement.";
    readonly ExecutionError: "Execution Error: '${stack}'";
    readonly InvalidApiFunctionUsage: "Arcade function '${identifier}' not used in a call expression.";
    readonly InvalidConstantIdentifier: "Invalid constant identifier, expecting ${list}.";
    readonly InvalidPropertyIdentifier: "Invalid property identifier, expecting ${list}.";
    readonly NoArgumentExpected: "Expecting no argument.";
    readonly NotADictionary: "'${identifier}' doesn't have properties.";
    readonly NotDefined: "'${identifier}' is not defined.";
    readonly NotEnoughArguments: "Expecting at least ${min} argument(s).";
    readonly ProfileVariablesAreImmutable: "Profile variables cannot be modified.";
    readonly ProfileVariablesConflict: "'${identifier}' is already defined as a profile variable.";
    readonly ReservedKeyword: "'${identifier}' is a reserved keyword.";
    readonly TooManyArguments: "Too many arguments, expecting ${max}.";
    readonly UnexpectedEmptyFunction: "Unexpected empty function '${identifier}'.";
    readonly UnexpectedPropertyIdentifier: "Unexpected property identifier.";
    readonly UnknownPropertyIdentifier: "Unknown property identifier '${identifier}'.";
};

/**
 * Arcade diagnostic messages.
 */
declare const DiagnosticMessages_2: Record<DiagnosticCodes_2, string>;

export { DiagnosticSeverity }

/**
 * Define an Arcade empty statement.
 */
declare type EmptyStatement = NodeBase<typeof NodeTypes.EmptyStatement>;

/**
 * Define an Arcade export declaration.
 * Example: export function foo() {}
 * The declaration is the function declaration: function foo() {}
 * The specifiers are foo and bar
 */
declare interface ExportNamedDeclaration extends NodeBase<typeof NodeTypes.ExportNamedDeclaration> {
    /**
     * The declaration of the export.
     * Example: export function foo() {}
     * The declaration is the function declaration: function foo() {}
     */
    declaration: FunctionDeclaration | VariableDeclaration;
    /**
     * The specifiers of the export.
     * Example: export { foo, bar }
     * The specifiers are foo and bar.
     */
    specifiers: ExportSpecifier[];
    /**
     * The source of the export.
     * Example: export { foo, bar } from "./my-module"
     * The source is "./my-module"
     */
    source: Literal | null;
}

/**
 * Define an Arcade export specifier.
 * Example: export { foo as bar }
 * The specifier is foo as bar.
 */
declare interface ExportSpecifier extends NodeBase<typeof NodeTypes.ExportSpecifier> {
    /**
     * The exported identifier.
     * Example: export { foo as bar }
     * The exported identifier is bar.
     */
    exported: Identifier;
    /**
     * The local identifier.
     * Example: export { foo as bar }
     * The local identifier is foo.
     */
    local: Identifier;
}

/**
 * Define the types of Arcade Expression.
 */
declare type Expression = ArrayExpression | AssignmentExpression | BinaryExpression | CallExpression | Identifier | Literal | LogicalExpression | MemberExpression | ObjectExpression | TemplateLiteral | UnaryExpression | UpdateExpression;

/**
 * Define an Arcade expression statement.
 * Example: a = 1;
 */
declare interface ExpressionStatement extends NodeBase<typeof NodeTypes.ExpressionStatement> {
    /**
     * The expression of the statement.
     */
    expression: Expression;
}

/**
 * Define an Arcade for-in statement.
 * Example:
 * ```
 * var arr = ['a', 'b'];
 * for (var i in arr) {
 *   Console(arr[i])
 * }
 * ```
 */
declare interface ForInStatement extends NodeBase<typeof NodeTypes.ForInStatement> {
    /**
     * The left: `var i`.
     */
    left: Identifier | VariableDeclaration;
    /**
     * The right: `arr`.
     */
    right: Expression;
    /**
     * The body: `Console(arr[i])`.
     */
    body: Statement;
}

/**
 * Format code using options.
 */
export declare function format(script: string, options?: FormattingOptions): string;

/**
 * Describes the formatting options
 */
declare interface FormattingOptions {
    /**
     * Number of spaces the formatter should use for indentation.
     * If you do not pass this option explicitly, it will be
     * (quite reliably!) inferred from the original code.
     * @default 2
     */
    indentWidth?: number;
    /**
     * Some of the formatter code (such as that for printing function
     * parameter lists) makes a valiant attempt to prevent really long
     * lines. You can adjust the limit by changing this option; however,
     * there is no guarantee that line length will fit inside this limit.
     * @default 80
     */
    wrapColumn?: number;
    /**
     * If you want to override the quotes used in string literals, specify
     * either "single", "double", or "auto" here ("auto" will select the one
     * which results in the shorter literal) Otherwise, use double quotes.
     * @default null
     */
    quote?: "auto" | "double" | "single" | null;
}

/**
 * Define an Arcade for-of statement.
 * Example:
 * ```
 * var arr = ['a', 'b'];
 * for (var v in arr) {
 *   Console(v)
 * }
 * ```
 */
declare interface ForOfStatement extends NodeBase<typeof NodeTypes.ForOfStatement> {
    /**
     * The left side: `var v`.
     */
    left: Identifier | VariableDeclaration;
    /**
     * The right side: `arr`.
     */
    right: Expression;
    /**
     * The body: `Console(v)`.
     */
    body: Statement;
}

/**
 * Define an Arcade for statement.
 * Example: for (var i = 0; i < 10; i++) { console(i); }
 */
declare interface ForStatement extends NodeBase<typeof NodeTypes.ForStatement> {
    /**
     * The init of the for statement.
     * Example: for (var i = 0; i < 10; i++) { console(i); }
     * The init is var i = 0.
     */
    init: Expression | VariableDeclaration | null;
    /**
     * The test of the for statement.
     * Example: for (var i = 0; i < 10; i++) { console(i); }
     * The test is i < 10.
     */
    test: Expression | null;
    /**
     * The update of the for statement.
     * Example: for (var i = 0; i < 10; i++) { console(i); }
     * The update is i++.
     */
    update: Expression | null;
    /**
     * The body of the for statement.
     */
    body: Statement;
}

/**
 * Define an Arcade function declaration.
 */
declare interface FunctionDeclaration extends NodeBase<typeof NodeTypes.FunctionDeclaration> {
    /**
     * The identifier of the function.
     * Example: function foo() {}
     * The identifier is foo.
     */
    id: Identifier;
    /**
     * The parameters of the function.
     * Example: function foo(bar, baz) {}
     * The parameters are bar and baz.
     */
    params: Identifier[];
    /**
     * The body of the function.
     * Example: function foo() { return 1; }
     * The body is { return 1; }
     */
    body: BlockStatement;
}

/**
 * Define an Arcade identifier.
 * Example: foo
 */
declare interface Identifier extends NodeBase<typeof NodeTypes.Identifier> {
    /**
     * The name of the identifier.
     * Example: foo
     * The name is foo.
     */
    name: string;
}

/**
 * Define an Arcade if statement.
 * Example: if (a < 10) { console(a++); } else { console(a--); }
 */
declare interface IfStatement extends NodeBase<typeof NodeTypes.IfStatement> {
    /**
     * The test of the if statement.
     * Example: if (a < 10) { console(a++); } else { console(a--); }
     * The test is a < 10.
     */
    test: Exclude<Expression, AssignmentExpression | UpdateExpression>;
    /**
     * The consequent of the if statement.
     * Example: if (a < 10) { console(a++); } else { console(a--); }
     * The consequent is console(a++).
     */
    consequent: Statement;
    /**
     * The alternate of the if statement.
     * Example: if (a < 10) { console(a++); } else { console(a--); }
     * The alternate is console(a--).
     */
    alternate: Statement | null;
}

/**
 * Define an Arcade import declaration.
 * Example: import { foo, bar } from "./my-module"
 * The specifiers are foo and bar.
 * The source is "./my-module"
 */
declare interface ImportDeclaration extends NodeBase<typeof NodeTypes.ImportDeclaration> {
    /**
     * The specifiers of the import.
     * Example: import { foo, bar } from "./my-module"
     * The specifiers are foo and bar.
     */
    specifiers: ImportDefaultSpecifier[];
    /**
     * The source of the import.
     * Example: import { foo, bar } from "./my-module"
     * The source is "./my-module"
     */
    source: Literal;
}

/**
 * Define an Arcade import default specifier.
 * Example: import "./my-module"
 * The local is "./my-module"
 */
declare interface ImportDefaultSpecifier extends NodeBase<typeof NodeTypes.ImportDefaultSpecifier> {
    /**
     * The local identifier.
     * Example: import "./my-module"
     * The local is "./my-module"
     */
    local: Identifier;
}

/**
 * Test if the item is an Arcade ArrayExpression.
 */
declare function isArrayExpression(item: unknown): item is ArrayExpression;

/**
 * Test if the item is an Arcade AssignmentExpression.
 */
declare function isAssignmentExpression(item: unknown): item is AssignmentExpression;

/**
 * Test if the item is an Arcade BinaryExpression.
 */
declare function isBinaryExpression(item: unknown): item is BinaryExpression;

/**
 * Test if the item is an Arcade BlockComment.
 */
declare function isBlockComment(item: unknown): item is BlockComment;

/**
 * Test if the item is an Arcade BlockStatement.
 */
declare function isBlockStatement(item: unknown): item is BlockStatement;

/**
 * Test if the item is an Arcade BreakStatement.
 */
declare function isBreakStatement(item: unknown): item is BreakStatement;

/**
 * Test if the item is an Arcade CallExpression.
 */
declare function isCallExpression(item: unknown): item is CallExpression;

/**
 * Test if the item is an Arcade ContinueStatement.
 */
declare function isContinueStatement(item: unknown): item is ContinueStatement;

/**
 * Test if the item is an Arcade EmptyStatement.
 */
declare function isEmptyStatement(item: unknown): item is EmptyStatement;

/**
 * Test if the item is an Arcade Expression.
 */
declare function isExpression(item: unknown): item is Expression;

/**
 * Test if the item is an Arcade ExpressionStatement.
 */
declare function isExpressionStatement(item: unknown): item is ExpressionStatement;

/**
 * Test if the item is an Arcade ForInStatement.
 */
declare function isForInStatement(item: unknown): item is ForInStatement;

/**
 * Test if the item is an Arcade ForOfStatement.
 */
declare function isForOfStatement(item: unknown): item is ForOfStatement;

/**
 * Test if the item is an Arcade ForStatement.
 */
declare function isForStatement(item: unknown): item is ForStatement;

/**
 * Test if the item is an Arcade FunctionDeclaration.
 */
declare function isFunctionDeclaration(item: unknown): item is FunctionDeclaration;

/**
 * Test if the item is an Arcade Identifier.
 */
declare function isIdentifier(item: unknown): item is Identifier;

/**
 * Test if the item is an Arcade IfStatement.
 */
declare function isIfStatement(item: unknown): item is IfStatement;

/**
 * Test if the item is an Arcade Literal.
 */
declare function isLiteral(item: unknown): item is Literal;

/**
 * Test if the item is an Arcade LogicalExpression.
 */
declare function isLogicalExpression(item: unknown): item is LogicalExpression;

/**
 * Test if the item is an Arcade MemberExpression.
 */
declare function isMemberExpression(item: unknown): item is MemberExpression;

/**
 * Test if the item is an Arcade ObjectExpression.
 */
declare function isObjectExpression(item: unknown): item is ObjectExpression;

/**
 * Test if the item is an Arcade Program.
 */
declare function isProgram(item: unknown): item is Program;

/**
 * Test if the item is an Arcade Property.
 */
declare function isProperty(item: unknown): item is Property;

/**
 * Test if the item is an Arcade ReturnStatement.
 */
declare function isReturnStatement(item: unknown): item is ReturnStatement;

/**
 * Test if the item is an Arcade Statement.
 */
declare function isStatement(item: unknown): item is Statement;

/**
 * Test if the item is an Arcade TemplateElement.
 */
declare function isTemplateElement(item: unknown): item is TemplateElement;

/**
 * Test if the item is an Arcade TemplateLiteral.
 */
declare function isTemplateLiteral(item: unknown): item is TemplateLiteral;

/**
 * Test if the item is an Arcade UnaryExpression.
 */
declare function isUnaryExpression(item: unknown): item is UnaryExpression;

/**
 * Test if the item is an Arcade UpdateExpression.
 */
declare function isUpdateExpression(item: unknown): item is UpdateExpression;

/**
 * Test if the item is an Arcade VariableDeclaration.
 */
declare function isVariableDeclaration(item: unknown): item is VariableDeclaration;

/**
 * Test if the item is an Arcade VariableDeclarator.
 */
declare function isVariableDeclarator(item: unknown): item is VariableDeclarator;

/**
 * Describe the location of a an item in the source code.
 * The range is [inclusive, exclusive].
 * The location is 1-based line number and 0-based column number.
 */
declare interface ItemLocation {
    /**
     * The location of the item in the source code as start and end positions.
     */
    loc: SourceLocation;
    /**
     * The range of the item in the source code as start and end indexes.
     * The range is [inclusive, exclusive].
     */
    range: [number, number];
}

/**
 * Arcade keywords.
 */
declare const Keywords: {
    readonly Break: "break";
    readonly Continue: "continue";
    readonly Else: "else";
    readonly For: "for";
    readonly Function: "function";
    readonly If: "if";
    readonly Import: "import";
    readonly Export: "export";
    readonly In: "in";
    readonly Return: "return";
    readonly Var: "var";
    readonly While: "while";
};

/**
 * Arcade keywords.
 */
declare type Keywords = (typeof Keywords)[keyof typeof Keywords];

/**
 * Define a line comment.
 */
declare interface LineComment extends ItemLocation {
    readonly type: typeof NodeTypes.LineComment;
    /**
     * The value of the comment.
     */
    value: string;
}

/**
 * Define an Arcade literal.
 * Example: 1 or "foo"
 * The value is 1 or "foo".
 */
declare interface Literal extends NodeBase<typeof NodeTypes.Literal> {
    /**
     * Indicate if the literal is a string.
     */
    isString: boolean;
    /**
     * The value of the literal.
     * Example: 1 or "foo"
     * The value is 1 or "foo".
     */
    value: boolean | number | string | null;
    /**
     * The raw value of the literal.
     * Example: 1 or "foo"
     * The raw value is "1" or "foo".
     */
    raw: string;
}

/**
 * Arcade literals.
 */
declare const Literals: {
    readonly False: "false";
    readonly Null: "null";
    readonly True: "true";
};

/**
 * Arcade literals.
 */
declare type Literals = (typeof Literals)[keyof typeof Literals];

/**
 * Define an Arcade logical expression.
 * Example: a || b
 */
declare interface LogicalExpression extends NodeBase<typeof NodeTypes.LogicalExpression> {
    /**
     * The operator of the logical expression.
     * Example: a || b
     * The operator is ||.
     */
    operator: LogicalOperators;
    /**
     * The left side of the logical expression.
     * Example: a || b
     * The left side is a.
     * Note that left can never be an AssignmentExpression or an UpdateExpression.
     */
    left: Expression;
    /**
     * The right side of the logical expression.
     * Example: a || b
     * The right side is b.
     * Note that right can never be an AssignmentExpression or an UpdateExpression.
     */
    right: Expression;
}

/**
 * Arcade logical operators.
 */
declare const LogicalOperators: readonly string[];

/**
 * Arcade logical operators.
 */
declare type LogicalOperators = (typeof LogicalOperators)[number];

/**
 * Describe the location of a character in the source code.
 */
declare interface Marker extends Position {
    /**
     * The zero based index of the character where the marker begins in the source code.
     */
    index: number;
}

/**
 * Define an Arcade member expression.
 * Example: foo.bar or foo[1]
 */
declare type MemberExpression = ComputedMemberExpression | NonComputedMemberExpression;

/**
 * Define the types of Arcade AST Node (excluding comments).
 */
declare type Node_2 = Expression | ImportDefaultSpecifier | Program | Property | Statement | TemplateElement | VariableDeclarator;

/**
 * Define the base properties of any Arcade AST Node.
 */
declare interface NodeBase<T extends NodeTypes> extends ItemLocation {
    /**
     * The type of the node.
     */
    type: T;
    /**
     * The leading comments of the node.
     */
    leadingComments?: Comment_2[];
    /**
     * The trailing comments of the node.
     */
    trailingComments?: Comment_2[];
}

declare const NodeTypes: {
    readonly AssignmentExpression: "AssignmentExpression";
    readonly ArrayExpression: "ArrayExpression";
    readonly BlockComment: "BlockComment";
    readonly BlockStatement: "BlockStatement";
    readonly BinaryExpression: "BinaryExpression";
    readonly BreakStatement: "BreakStatement";
    readonly CallExpression: "CallExpression";
    readonly ContinueStatement: "ContinueStatement";
    readonly EmptyStatement: "EmptyStatement";
    readonly ExpressionStatement: "ExpressionStatement";
    readonly ExportNamedDeclaration: "ExportNamedDeclaration";
    readonly ExportSpecifier: "ExportSpecifier";
    readonly ForStatement: "ForStatement";
    readonly ForInStatement: "ForInStatement";
    readonly ForOfStatement: "ForOfStatement";
    readonly FunctionDeclaration: "FunctionDeclaration";
    readonly Identifier: "Identifier";
    readonly IfStatement: "IfStatement";
    readonly ImportDeclaration: "ImportDeclaration";
    readonly ImportDefaultSpecifier: "ImportDefaultSpecifier";
    readonly LineComment: "LineComment";
    readonly Literal: "Literal";
    readonly LogicalExpression: "LogicalExpression";
    readonly MemberExpression: "MemberExpression";
    readonly ObjectExpression: "ObjectExpression";
    readonly Program: "Program";
    readonly Property: "Property";
    readonly ReturnStatement: "ReturnStatement";
    readonly TemplateElement: "TemplateElement";
    readonly TemplateLiteral: "TemplateLiteral";
    readonly UnaryExpression: "UnaryExpression";
    readonly UpdateExpression: "UpdateExpression";
    readonly VariableDeclaration: "VariableDeclaration";
    readonly VariableDeclarator: "VariableDeclarator";
    readonly WhileStatement: "WhileStatement";
};

/**
 * Arcade AST Node Types.
 */
declare type NodeTypes = (typeof NodeTypes)[keyof typeof NodeTypes];

/**
 * Define an Arcade non-computed member expression.
 * Example: foo.bar
 */
declare interface NonComputedMemberExpression extends NodeBase<typeof NodeTypes.MemberExpression> {
    readonly computed: false;
    /**
     * The object of the member expression.
     * Example: foo.bar
     * The object is foo.
     */
    object: Expression;
    /**
     * The property of the member expression.
     * Example: foo.bar
     * The property is bar.
     */
    property: Identifier;
}

/**
 * Define an Arcade object expression.
 * Example: { foo: 1, bar: 2 }
 */
declare interface ObjectExpression extends NodeBase<typeof NodeTypes.ObjectExpression> {
    /**
     * The collection of properties of the object expression.
     */
    properties: Property[];
}

/**
 * Arcade operators precedence.
 */
declare const OperatorPrecedence: {
    readonly "||": 1;
    readonly "&&": 2;
    readonly "|": 3;
    readonly "^": 4;
    readonly "&": 5;
    readonly "==": 6;
    readonly "!=": 6;
    readonly "<": 7;
    readonly ">": 7;
    readonly "<=": 7;
    readonly ">=": 7;
    readonly "<<": 8;
    readonly ">>": 8;
    readonly ">>>": 8;
    readonly "+": 9;
    readonly "-": 9;
    readonly "*": 10;
    readonly "/": 10;
    readonly "%": 10;
};

declare function parse(code: string, options?: ParseOptions, delegate?: Delegate): Program;

/**
 * Define the options for the parser.
 */
declare interface ParseOptions {
    tolerant?: boolean;
    tokens?: boolean;
    comments?: boolean;
}

declare namespace Parser {
    export {
        parse,
        tokenize,
        isProgram,
        isStatement,
        isBlockStatement,
        isBlockComment,
        isBreakStatement,
        isContinueStatement,
        isEmptyStatement,
        isExpressionStatement,
        isForInStatement,
        isForOfStatement,
        isForStatement,
        isFunctionDeclaration,
        isIfStatement,
        isReturnStatement,
        isVariableDeclaration,
        isExpression,
        isArrayExpression,
        isAssignmentExpression,
        isBinaryExpression,
        isCallExpression,
        isIdentifier,
        isLiteral,
        isLogicalExpression,
        isObjectExpression,
        isTemplateLiteral,
        isMemberExpression,
        isUnaryExpression,
        isUpdateExpression,
        isVariableDeclarator,
        isProperty,
        isTemplateElement,
        Literals,
        Keywords,
        ContextualKeywords,
        NodeTypes,
        UpdateOperators,
        UnaryOperators,
        AssignmentOperators,
        LogicalOperators,
        BinaryOperators,
        OperatorPrecedence,
        Position,
        SourceLocation,
        Marker,
        ItemLocation,
        TokenTypes,
        TokenNames,
        TokenizeOptions,
        Token,
        ParseOptions,
        DiagnosticCodes_2 as DiagnosticCodes,
        DiagnosticMessages_2 as DiagnosticMessages,
        DiagnosticData_3 as DiagnosticData,
        DiagnosticApi,
        Diagnostic_2 as Diagnostic,
        LineComment,
        BlockComment,
        Comment_2 as Comment,
        Delegate,
        Declaration,
        Statement,
        Expression,
        Node_2 as Node,
        NodeBase,
        Program,
        ExportNamedDeclaration,
        ExportSpecifier,
        ImportDeclaration,
        ImportDefaultSpecifier,
        FunctionDeclaration,
        VariableDeclaration,
        VariableDeclarator,
        BlockStatement,
        BreakStatement,
        ContinueStatement,
        EmptyStatement,
        ExpressionStatement,
        ForInStatement,
        ForOfStatement,
        ForStatement,
        WhileStatement,
        IfStatement,
        ReturnStatement,
        ArrayExpression,
        AssignmentExpression,
        BinaryExpression,
        CallExpression,
        Identifier,
        Literal,
        LogicalExpression,
        ComputedMemberExpression,
        MemberExpression,
        ObjectExpression,
        Property,
        TemplateLiteral,
        TemplateElement,
        UnaryExpression,
        UpdateExpression,
        convertProgramToJSON
    }
}

/**
 * Describe a position in the source code as 1-based line number and 0-based column number.
 */
declare interface Position {
    /**
     * The 1-based line number.
     */
    line: number;
    /**
     * The 0-based column number.
     */
    column: number;
}

/**
 * Define an Arcade program.
 */
declare interface Program extends NodeBase<typeof NodeTypes.Program> {
    /**
     * The collection of statements in the program.
     */
    body: Statement[];
    /**
     * The collection of comments inside the program.
     */
    comments?: Comment_2[];
    /**
     * The collection of tokens inside the program.
     */
    tokens?: Token[];
    /**
     * The collection of errors inside the program.
     */
    errors?: Error[];
}

/**
 * Define an Arcade object property.
 */
declare interface Property extends NodeBase<typeof NodeTypes.Property> {
    kind: "init";
    /**
     * The key of the property.
     * Example: { foo: 1 } or { foo }
     * The key is foo.
     */
    key: Identifier | Literal;
    /**
     * The value of the property.
     * Example: { foo: 1 } or { foo }
     * The value is 1 or foo.
     */
    value: Expression;
    /**
     * Indicate if the property is a shorthand.
     * Example: { foo }
     * The property is a shorthand.
     */
    shorthand: boolean;
}

/**
 * Define an Arcade return statement.
 * Example: return 1;
 */
declare interface ReturnStatement extends NodeBase<typeof NodeTypes.ReturnStatement> {
    /**
     * The argument of the return statement.
     */
    argument: Expression | null;
}

/**
 * Describe a range in the source code between two positions as [start, end].
 * Start is inclusive and end is exclusive.
 * Positions are 1-based line number and 0-based column number.
 */
declare interface SourceLocation {
    /**
     * The position of the first character of the parsed source region (inclusive).
     */
    start: Position;
    /**
     * The position of the first character after the parsed source region (exclusive).
     */
    end: Position;
}

/**
 * Define the types of Arcade Statement.
 */
declare type Statement = BlockStatement | BreakStatement | ContinueStatement | Declaration | EmptyStatement | ExpressionStatement | ForInStatement | ForOfStatement | ForStatement | IfStatement | ReturnStatement | WhileStatement;

/**
 * Define an Arcade template element.
 */
declare interface TemplateElement extends NodeBase<typeof NodeTypes.TemplateElement> {
    /**
     * The value of the template element.
     * Example: `foo ${value}`
     * The value is foo.
     */
    value: TemplateElementValue;
    /**
     * Indicate if the template element is a tail.
     * Example: `foo ${value} bar`
     * The template element for foo is not a tail.
     * The template element for bar is a tail.
     */
    tail?: boolean;
}

/**
 * Define an Arcade template element value.
 */
declare interface TemplateElementValue {
    /**
     * The cooked value of the template element.
     */
    cooked?: string;
    /**
     * The raw value of the template element.
     */
    raw: string;
}

/**
 * Define an Arcade template literal.
 * Example: `foo ${value} bar`
 */
declare interface TemplateLiteral extends NodeBase<typeof NodeTypes.TemplateLiteral> {
    /**
     * The collection of quasis of the template literal.
     * Example: `foo ${value} bar`
     * The quasis are foo and bar.
     */
    quasis: TemplateElement[];
    /**
     * The collection of expressions of the template literal.
     * Example: `foo ${value1} - ${value2} bar`
     * The expressions are value1 and value2.
     */
    expressions: Expression[];
}

/**
 * Define a token returned by the scanner.
 */
declare interface Token extends ItemLocation {
    /**
     * The type of the token found.
     */
    type: TokenNames | typeof NodeTypes.BlockComment | typeof NodeTypes.LineComment;
    /**
     * The value of the token.
     */
    value: string;
}

declare function tokenize(code: string, options?: TokenizeOptions, delegate?: (entry: Token) => Token): {
    tokens: Token[];
    errors?: Error[];
};

/**
 * Define the options for the scanner.
 */
declare interface TokenizeOptions {
    tolerant?: boolean;
    range?: boolean;
    loc?: boolean;
    comment?: boolean;
}

/**
 * Arcade scanner token names.
 */
declare const TokenNames: readonly ["Unknown", "Boolean", "<end>", "Identifier", "Keyword", "Null", "Numeric", "Punctuator", "String", "RegularExpression", "Template"];

/**
 * Arcade scanner token names.
 */
declare type TokenNames = (typeof TokenNames)[number];

/**
 * Arcade scanner token types.
 */
declare const TokenTypes: {
    readonly Unknown: 0;
    readonly BooleanLiteral: 1;
    readonly EOF: 2;
    readonly Identifier: 3;
    readonly Keyword: 4;
    readonly NullLiteral: 5;
    readonly NumericLiteral: 6;
    readonly Punctuator: 7;
    readonly StringLiteral: 8;
    readonly Template: 10;
};

/**
 * Arcade scanner token types.
 */
declare type TokenTypes = (typeof TokenTypes)[keyof typeof TokenTypes];

/**
 * Define an Arcade unary expression.
 * Example: -1
 */
declare interface UnaryExpression extends NodeBase<typeof NodeTypes.UnaryExpression> {
    readonly prefix: true;
    /**
     * The operator of the unary expression.
     * Example: -1
     * The operator is -.
     */
    operator: UnaryOperators;
    /**
     * The argument of the unary expression.
     * Example: -1
     * The argument is 1.
     */
    argument: Expression;
}

/**
 * Arcade unary operators.
 */
declare const UnaryOperators: readonly string[];

/**
 * Arcade unary operators.
 */
declare type UnaryOperators = (typeof UnaryOperators)[number];

/**
 * Define an Arcade update expression.
 * Example: a++
 */
declare interface UpdateExpression extends NodeBase<typeof NodeTypes.UpdateExpression> {
    /**
     * The operator of the update expression.
     * Example: a++
     * The operator is ++.
     */
    operator: UpdateOperators;
    /**
     * The argument of the update expression.
     * Example: a++
     * The argument is a.
     */
    argument: CallExpression | Identifier | MemberExpression;
    /**
     * Indicate if the update expression is a prefix.
     * Example: ++a
     * The update expression is a prefix.
     */
    prefix: boolean;
}

/**
 * Arcade update operators.
 */
declare const UpdateOperators: readonly string[];

/**
 * Arcade update operators.
 */
declare type UpdateOperators = (typeof UpdateOperators)[number];

export declare const ValidationDiagnosticCodes: {
    readonly AlreadyDefined: "AlreadyDefined";
    readonly ApiConflict: "ApiConflict";
    readonly AssignedNeverUsed: "AssignedNeverUsed";
    readonly DefinedNeverAssigned: "DefinedNeverAssigned";
    readonly DefinedNeverUsed: "DefinedNeverUsed";
    readonly EmptyBlockStatement: "EmptyBlockStatement";
    readonly ExecutionError: "ExecutionError";
    readonly InvalidApiFunctionUsage: "InvalidApiFunctionUsage";
    readonly InvalidConstantIdentifier: "InvalidConstantIdentifier";
    readonly InvalidPropertyIdentifier: "InvalidPropertyIdentifier";
    readonly NoArgumentExpected: "NoArgumentExpected";
    readonly NotADictionary: "NotADictionary";
    readonly NotDefined: "NotDefined";
    readonly NotEnoughArguments: "NotEnoughArguments";
    readonly ProfileVariablesAreImmutable: "ProfileVariablesAreImmutable";
    readonly ProfileVariablesConflict: "ProfileVariablesConflict";
    readonly ReservedKeyword: "ReservedKeyword";
    readonly TooManyArguments: "TooManyArguments";
    readonly UnexpectedEmptyFunction: "UnexpectedEmptyFunction";
    readonly UnexpectedPropertyIdentifier: "UnexpectedPropertyIdentifier";
    readonly UnknownPropertyIdentifier: "UnknownPropertyIdentifier";
};

export declare type ValidationDiagnosticCodes = (typeof ValidationDiagnosticCodes)[keyof typeof ValidationDiagnosticCodes];

/**
 * Define an Arcade variable declaration.
 * Example: var foo = 1, bar = 2;
 * The declarators are foo = 1 and bar = 2.
 */
declare interface VariableDeclaration extends NodeBase<typeof NodeTypes.VariableDeclaration> {
    /**
     * The declarators of the variable declaration.
     * Example: var foo = 1, bar = 2;
     * The declarators are foo = 1 and bar = 2.
     */
    declarations: VariableDeclarator[];
    /**
     * The kind is always "var" for Arcade.
     */
    kind: "var";
}

/**
 * Define an Arcade variable declarator.
 * Example: var foo = 1;
 * The identifier is foo.
 * The init is 1.
 */
declare interface VariableDeclarator extends NodeBase<typeof NodeTypes.VariableDeclarator> {
    /**
     * The identifier of the variable declarator.
     */
    id: Identifier;
    /**
     * The init of the variable declarator.
     */
    init: Expression | null;
}

/**
 * Define an Arcade function declaration.
 * Example: while (a < 10) { console(a++); }
 */
declare interface WhileStatement extends NodeBase<typeof NodeTypes.WhileStatement> {
    /**
     * The test of the while statement.
     * Example: while (a < 10) { console(a++); }
     * The test is a < 10.
     */
    test: Exclude<Expression, AssignmentExpression | UpdateExpression>;
    /**
     * The body of the while statement.
     */
    body: Statement;
}

export { }
