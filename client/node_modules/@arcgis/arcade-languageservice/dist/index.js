import { CompletionItemKind as F, InsertTextFormat as B, InsertTextMode as S, DiagnosticSeverity as A } from "vscode-languageserver-types";
import { DiagnosticSeverity as pi } from "vscode-languageserver-types";
import { isDictionaryVariable as Gt, isValueVariable as Ct, ApiService as Jt } from "@arcgis/languages-api-utils";
const j = {
  False: "false",
  Null: "null",
  True: "true"
}, f = {
  Break: "break",
  Continue: "continue",
  Else: "else",
  For: "for",
  Function: "function",
  If: "if",
  Import: "import",
  Export: "export",
  In: "in",
  Return: "return",
  Var: "var",
  While: "while"
}, tt = {
  From: "from",
  Of: "of"
}, u = {
  AssignmentExpression: "AssignmentExpression",
  ArrayExpression: "ArrayExpression",
  BlockComment: "BlockComment",
  BlockStatement: "BlockStatement",
  BinaryExpression: "BinaryExpression",
  BreakStatement: "BreakStatement",
  CallExpression: "CallExpression",
  ContinueStatement: "ContinueStatement",
  EmptyStatement: "EmptyStatement",
  ExpressionStatement: "ExpressionStatement",
  ExportNamedDeclaration: "ExportNamedDeclaration",
  ForStatement: "ForStatement",
  ForInStatement: "ForInStatement",
  ForOfStatement: "ForOfStatement",
  FunctionDeclaration: "FunctionDeclaration",
  Identifier: "Identifier",
  IfStatement: "IfStatement",
  ImportDeclaration: "ImportDeclaration",
  ImportDefaultSpecifier: "ImportDefaultSpecifier",
  LineComment: "LineComment",
  Literal: "Literal",
  LogicalExpression: "LogicalExpression",
  MemberExpression: "MemberExpression",
  ObjectExpression: "ObjectExpression",
  Program: "Program",
  Property: "Property",
  ReturnStatement: "ReturnStatement",
  TemplateElement: "TemplateElement",
  TemplateLiteral: "TemplateLiteral",
  UnaryExpression: "UnaryExpression",
  UpdateExpression: "UpdateExpression",
  VariableDeclaration: "VariableDeclaration",
  VariableDeclarator: "VariableDeclarator",
  WhileStatement: "WhileStatement"
}, st = ["++", "--"], Pt = ["-", "+", "!", "~"], Nt = ["=", "/=", "*=", "%=", "+=", "-="], Mt = ["||", "&&"], Qt = [
  "|",
  "&",
  ">>",
  "<<",
  ">>>",
  "^",
  "==",
  "!=",
  "<",
  "<=",
  ">",
  ">=",
  "+",
  "-",
  "*",
  "/",
  "%"
], H = {
  "||": 1,
  "&&": 2,
  "|": 3,
  "^": 4,
  "&": 5,
  "==": 6,
  "!=": 6,
  "<": 7,
  ">": 7,
  "<=": 7,
  ">=": 7,
  "<<": 8,
  ">>": 8,
  ">>>": 8,
  "+": 9,
  "-": 9,
  "*": 10,
  "/": 10,
  "%": 10
}, l = {
  BooleanLiteral: 1,
  EOF: 2,
  Identifier: 3,
  Keyword: 4,
  NullLiteral: 5,
  NumericLiteral: 6,
  Punctuator: 7,
  StringLiteral: 8,
  Template: 10
}, Ut = [
  "Unknown",
  "Boolean",
  "<end>",
  "Identifier",
  "Keyword",
  "Null",
  "Numeric",
  "Punctuator",
  "String",
  "RegularExpression",
  "Template"
], h = {
  InvalidModuleUri: "InvalidModuleUri",
  ForInOfLoopInitializer: "ForInOfLoopInitializer",
  IdentifierExpected: "IdentifierExpected",
  InvalidEscapedReservedWord: "InvalidEscapedReservedWord",
  InvalidExpression: "InvalidExpression",
  InvalidFunctionIdentifier: "InvalidFunctionIdentifier",
  InvalidHexEscapeSequence: "InvalidHexEscapeSequence",
  InvalidLeftHandSideInAssignment: "InvalidLeftHandSideInAssignment",
  InvalidLeftHandSideInForIn: "InvalidLeftHandSideInForIn",
  InvalidTemplateHead: "InvalidTemplateHead",
  InvalidVariableAssignment: "InvalidVariableAssignment",
  KeyMustBeString: "KeyMustBeString",
  NoFunctionInsideBlock: "NoFunctionInsideBlock",
  NoFunctionInsideFunction: "NoFunctionInsideFunction",
  ModuleExportRootOnly: "ModuleExportRootOnly",
  ModuleImportRootOnly: "ModuleImportRootOnly",
  PunctuatorExpected: "PunctuatorExpected",
  TemplateOctalLiteral: "TemplateOctalLiteral",
  UnexpectedBoolean: "UnexpectedBoolean",
  UnexpectedEndOfScript: "UnexpectedEndOfScript",
  UnexpectedIdentifier: "UnexpectedIdentifier",
  UnexpectedKeyword: "UnexpectedKeyword",
  UnexpectedNull: "UnexpectedNull",
  UnexpectedNumber: "UnexpectedNumber",
  UnexpectedPunctuator: "UnexpectedPunctuator",
  UnexpectedString: "UnexpectedString",
  UnexpectedTemplate: "UnexpectedTemplate",
  UnexpectedToken: "UnexpectedToken"
}, Ot = {
  [h.InvalidModuleUri]: "Module uri must be a text literal.",
  [h.ForInOfLoopInitializer]: "for-in loop variable declaration may not have an initializer.",
  [h.IdentifierExpected]: "'${value}' is an invalid identifier.",
  [h.InvalidEscapedReservedWord]: "Keyword cannot contain escaped characters.",
  [h.InvalidExpression]: "Invalid expression.",
  [h.InvalidFunctionIdentifier]: "'${value}' is an invalid function identifier.",
  [h.InvalidHexEscapeSequence]: "Invalid hexadecimal escape sequence.",
  [h.InvalidLeftHandSideInAssignment]: "Invalid left-hand side in assignment.",
  [h.InvalidLeftHandSideInForIn]: "Invalid left-hand side in for-in.",
  [h.InvalidTemplateHead]: "Invalid template structure.",
  [h.InvalidVariableAssignment]: "Invalid variable assignment.",
  [h.KeyMustBeString]: "Object property keys must be a word starting with a letter.",
  [h.NoFunctionInsideBlock]: "Functions cannot be declared inside of code blocks.",
  [h.NoFunctionInsideFunction]: "Functions cannot be declared inside another function.",
  [h.ModuleExportRootOnly]: "Module exports cannot be declared inside of code blocks.",
  [h.ModuleImportRootOnly]: "Module import cannot be declared inside of code blocks.",
  [h.PunctuatorExpected]: "'${value}' expected.",
  [h.TemplateOctalLiteral]: "Octal literals are not allowed in template literals.",
  [h.UnexpectedBoolean]: "Unexpected boolean literal.",
  [h.UnexpectedEndOfScript]: "Unexpected end of Arcade expression.",
  [h.UnexpectedIdentifier]: "Unexpected identifier.",
  [h.UnexpectedKeyword]: "Unexpected keyword.",
  [h.UnexpectedNull]: "Unexpected null literal.",
  [h.UnexpectedNumber]: "Unexpected number.",
  [h.UnexpectedPunctuator]: "Unexpected punctuator.",
  [h.UnexpectedString]: "Unexpected text literal.",
  [h.UnexpectedTemplate]: "Unexpected quasi '${value}'.",
  [h.UnexpectedToken]: "Unexpected token '${value}'."
};
class z extends Error {
  constructor({ code: t, index: e, line: i, column: r, len: s = 0, description: a, data: o }) {
    super(a ?? t), this.declaredRootClass = "esri.arcade.lib.diagnostic", this.name = "ParsingError", this.code = t, this.index = e, this.line = i, this.column = r, this.len = s, this.data = o, this.description = a, this.range = {
      start: { line: i, column: r - 1 },
      end: { line: i, column: r + s }
    }, Error.captureStackTrace?.(
      this,
      z
    );
  }
}
function Zt(n) {
  return !!n && typeof n == "object" && "type" in n && n.type === u.Program;
}
function w(n) {
  return !!n && typeof n == "object" && "type" in n && n.type === u.BlockStatement;
}
function Yt(n) {
  return !!n && typeof n == "object" && "type" in n && n.type === u.BlockComment;
}
function Dt(n) {
  return !!n && typeof n == "object" && "type" in n && n.type === u.EmptyStatement;
}
function Xt(n) {
  return !!n && typeof n == "object" && "type" in n && n.type === u.ExpressionStatement;
}
function Et(n) {
  return !!n && typeof n == "object" && "type" in n && n.type === u.FunctionDeclaration;
}
function ut(n) {
  return !!n && typeof n == "object" && "type" in n && n.type === u.IfStatement;
}
function q(n) {
  return !!n && typeof n == "object" && "type" in n && n.type === u.VariableDeclaration;
}
function G(n) {
  return !!n && typeof n == "object" && "type" in n && n.type === u.ArrayExpression;
}
function at(n) {
  return !!n && typeof n == "object" && "type" in n && n.type === u.BinaryExpression;
}
function I(n) {
  return !!n && typeof n == "object" && "type" in n && n.type === u.Identifier;
}
function zt(n) {
  return !!n && typeof n == "object" && "type" in n && n.type === u.Literal;
}
function ot(n) {
  return !!n && typeof n == "object" && "type" in n && n.type === u.LogicalExpression;
}
function gt(n) {
  return !!n && typeof n == "object" && "type" in n && n.type === u.ObjectExpression;
}
function Ft(n) {
  return !!n && typeof n == "object" && "type" in n && n.type === u.MemberExpression;
}
function te(n) {
  return !!n && typeof n == "object" && "type" in n && n.type === u.UnaryExpression;
}
function ee(n) {
  return !!n && typeof n == "object" && "type" in n && n.type === u.UpdateExpression;
}
function jt(n) {
  return !!n && typeof n == "object" && "type" in n && n.type === u.VariableDeclarator;
}
function ie(n) {
  return !!n && typeof n == "object" && "type" in n && n.type === u.Property;
}
function et(n, t) {
  return t.loc.end.line === n.loc.start.line && t.loc.end.column <= n.loc.start.column;
}
function xt(n, t) {
  return n.range[0] >= t.range[0] && n.range[1] <= t.range[1];
}
class ne {
  constructor() {
    this.comments = [], this._nodeStack = [], this._newComments = [];
  }
  insertInnerComments(t) {
    if (!w(t) || t.body.length !== 0)
      return;
    const e = [];
    for (let i = this._newComments.length - 1; i >= 0; i--) {
      const r = this._newComments[i];
      t.range[1] >= r.range[0] && (e.unshift(r), this._newComments.splice(i, 1));
    }
    e.length && (t.innerComments = e);
  }
  attachTrailingComments(t) {
    const e = this._nodeStack.at(-1);
    if (!e)
      return;
    if (w(t) && xt(e, t))
      for (let r = this._newComments.length - 1; r >= 0; r--) {
        const s = this._newComments[r];
        xt(s, t) && (e.trailingComments = [...e.trailingComments ?? [], s], this._newComments.splice(r, 1));
      }
    let i = [];
    if (this._newComments.length > 0)
      for (let r = this._newComments.length - 1; r >= 0; r--) {
        const s = this._newComments[r];
        et(s, e) ? (e.trailingComments = [...e.trailingComments ?? [], s], this._newComments.splice(r, 1)) : et(s, t) && (i.unshift(s), this._newComments.splice(r, 1));
      }
    if (e.trailingComments) {
      const r = e.trailingComments[0];
      et(r, t) && (i = [...i, ...e.trailingComments], delete e.trailingComments);
    }
    i.length > 0 && (t.trailingComments = i);
  }
  attachLeadingComments(t) {
    let e;
    for (; this._nodeStack.length > 0; ) {
      const s = this._nodeStack[this._nodeStack.length - 1];
      if (t.range[0] <= s.range[0]) {
        e = s, this._nodeStack.pop();
        continue;
      }
      break;
    }
    const i = [], r = [];
    if (e != null) {
      if (!e.leadingComments)
        return;
      for (let s = e.leadingComments.length - 1; s >= 0; s--) {
        const a = e.leadingComments[s];
        if (t.range[0] >= a.range[1]) {
          i.unshift(a), e.leadingComments.splice(s, 1);
          continue;
        }
        jt(t) && !Yt(a) && (r.unshift(a), e.leadingComments.splice(s, 1));
      }
      e.leadingComments.length === 0 && delete e.leadingComments, i.length && (t.leadingComments = i), r.length && (t.trailingComments = [...r, ...t.trailingComments ?? []]);
      return;
    }
    for (let s = this._newComments.length - 1; s >= 0; s--) {
      const a = this._newComments[s];
      t.range[0] >= a.range[0] && (i.unshift(a), this._newComments.splice(s, 1));
    }
    i.length && (t.leadingComments = i);
  }
  attachComments(t) {
    if (Zt(t) && t.body.length > 0) {
      const e = this._nodeStack.at(-1);
      if (e) {
        e.trailingComments = [...e.trailingComments ?? [], ...this._newComments], this._newComments.length = 0, this._nodeStack.pop();
        return;
      }
      t.trailingComments = [...this._newComments], this._newComments.length = 0;
      return;
    }
    this.attachTrailingComments(t), this.attachLeadingComments(t), this.insertInnerComments(t), this._nodeStack.push(t);
  }
  collectComment(t) {
    this.comments.push(t), this._newComments.push(t);
  }
}
const re = /\$\{(.*?)\}/gu;
function ct(n, t) {
  const e = Ot[n];
  return t ? e.replace(re, (i, r) => t[r]?.toString() ?? "") : e;
}
class Vt {
  constructor(t = !1) {
    this.tolerant = t, this.errors = [];
  }
  recordError(t) {
    this.errors.push(t);
  }
  tolerate(t) {
    if (this.tolerant)
      this.recordError(t);
    else
      throw t;
  }
  throwError(t) {
    throw t.description ??= ct(t.code, t.data), new z(t);
  }
  tolerateError(t) {
    t.description ??= ct(t.code, t.data);
    const e = new z(t);
    if (this.tolerant)
      this.recordError(e);
    else
      throw e;
  }
}
function At(n, t) {
  if (!n)
    throw new Error(`ASSERT: ${t}`);
}
const yt = {
  // Unicode v12.1.0 NonAsciiIdentifierStart:
  NonAsciiIdentifierStart: /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0560-\u0588\u05D0-\u05EA\u05EF-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u08A0-\u08B4\u08B6-\u08BD\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E86-\u0E8A\u0E8C-\u0EA3\u0EA5\u0EA7-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1878\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1C90-\u1CBA\u1CBD-\u1CBF\u1CE9-\u1CEC\u1CEE-\u1CF3\u1CF5\u1CF6\u1CFA\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309B-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312F\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FEF\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7BF\uA7C2-\uA7C6\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA8FE\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB67\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF2D-\uDF4A\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE35\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2\uDD00-\uDD23\uDF00-\uDF1C\uDF27\uDF30-\uDF45\uDFE0-\uDFF6]|\uD804[\uDC03-\uDC37\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD44\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE2B\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF50\uDF5D-\uDF61]|\uD805[\uDC00-\uDC34\uDC47-\uDC4A\uDC5F\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDDD8-\uDDDB\uDE00-\uDE2F\uDE44\uDE80-\uDEAA\uDEB8\uDF00-\uDF1A]|\uD806[\uDC00-\uDC2B\uDCA0-\uDCDF\uDCFF\uDDA0-\uDDA7\uDDAA-\uDDD0\uDDE1\uDDE3\uDE00\uDE0B-\uDE32\uDE3A\uDE50\uDE5C-\uDE89\uDE9D\uDEC0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC2E\uDC40\uDC72-\uDC8F\uDD00-\uDD06\uDD08\uDD09\uDD0B-\uDD30\uDD46\uDD60-\uDD65\uDD67\uDD68\uDD6A-\uDD89\uDD98\uDEE0-\uDEF2]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD81C-\uD820\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872\uD874-\uD879][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDE40-\uDE7F\uDF00-\uDF4A\uDF50\uDF93-\uDF9F\uDFE0\uDFE1\uDFE3]|\uD821[\uDC00-\uDFF7]|\uD822[\uDC00-\uDEF2]|\uD82C[\uDC00-\uDD1E\uDD50-\uDD52\uDD64-\uDD67\uDD70-\uDEFB]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD838[\uDD00-\uDD2C\uDD37-\uDD3D\uDD4E\uDEC0-\uDEEB]|\uD83A[\uDC00-\uDCC4\uDD00-\uDD43\uDD4B]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1\uDEB0-\uDFFF]|\uD87A[\uDC00-\uDFE0]|\uD87E[\uDC00-\uDE1D]/u,
  // Unicode v12.1.0 NonAsciiIdentifierPart:
  NonAsciiIdentifierPart: (
    // eslint-disable-next-line no-misleading-character-class
    /[\xAA\xB5\xB7\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u052F\u0531-\u0556\u0559\u0560-\u0588\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05EF-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u07FD\u0800-\u082D\u0840-\u085B\u0860-\u086A\u08A0-\u08B4\u08B6-\u08BD\u08D3-\u08E1\u08E3-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u09FC\u09FE\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0AF9-\u0AFF\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C00-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58-\u0C5A\u0C60-\u0C63\u0C66-\u0C6F\u0C80-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D00-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D54-\u0D57\u0D5F-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E86-\u0E8A\u0E8C-\u0EA3\u0EA5\u0EA7-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1369-\u1371\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1878\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19DA\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABD\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1C80-\u1C88\u1C90-\u1CBA\u1CBD-\u1CBF\u1CD0-\u1CD2\u1CD4-\u1CFA\u1D00-\u1DF9\u1DFB-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u200C\u200D\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312F\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FEF\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA7BF\uA7C2-\uA7C6\uA7F7-\uA827\uA840-\uA873\uA880-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA8FD-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB67\uAB70-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDDFD\uDE80-\uDE9C\uDEA0-\uDED0\uDEE0\uDF00-\uDF1F\uDF2D-\uDF4A\uDF50-\uDF7A\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCA0-\uDCA9\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00-\uDE03\uDE05\uDE06\uDE0C-\uDE13\uDE15-\uDE17\uDE19-\uDE35\uDE38-\uDE3A\uDE3F\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE6\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2\uDD00-\uDD27\uDD30-\uDD39\uDF00-\uDF1C\uDF27\uDF30-\uDF50\uDFE0-\uDFF6]|\uD804[\uDC00-\uDC46\uDC66-\uDC6F\uDC7F-\uDCBA\uDCD0-\uDCE8\uDCF0-\uDCF9\uDD00-\uDD34\uDD36-\uDD3F\uDD44-\uDD46\uDD50-\uDD73\uDD76\uDD80-\uDDC4\uDDC9-\uDDCC\uDDD0-\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE37\uDE3E\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEEA\uDEF0-\uDEF9\uDF00-\uDF03\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3B-\uDF44\uDF47\uDF48\uDF4B-\uDF4D\uDF50\uDF57\uDF5D-\uDF63\uDF66-\uDF6C\uDF70-\uDF74]|\uD805[\uDC00-\uDC4A\uDC50-\uDC59\uDC5E\uDC5F\uDC80-\uDCC5\uDCC7\uDCD0-\uDCD9\uDD80-\uDDB5\uDDB8-\uDDC0\uDDD8-\uDDDD\uDE00-\uDE40\uDE44\uDE50-\uDE59\uDE80-\uDEB8\uDEC0-\uDEC9\uDF00-\uDF1A\uDF1D-\uDF2B\uDF30-\uDF39]|\uD806[\uDC00-\uDC3A\uDCA0-\uDCE9\uDCFF\uDDA0-\uDDA7\uDDAA-\uDDD7\uDDDA-\uDDE1\uDDE3\uDDE4\uDE00-\uDE3E\uDE47\uDE50-\uDE99\uDE9D\uDEC0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC36\uDC38-\uDC40\uDC50-\uDC59\uDC72-\uDC8F\uDC92-\uDCA7\uDCA9-\uDCB6\uDD00-\uDD06\uDD08\uDD09\uDD0B-\uDD36\uDD3A\uDD3C\uDD3D\uDD3F-\uDD47\uDD50-\uDD59\uDD60-\uDD65\uDD67\uDD68\uDD6A-\uDD8E\uDD90\uDD91\uDD93-\uDD98\uDDA0-\uDDA9\uDEE0-\uDEF6]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD81C-\uD820\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872\uD874-\uD879][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDE60-\uDE69\uDED0-\uDEED\uDEF0-\uDEF4\uDF00-\uDF36\uDF40-\uDF43\uDF50-\uDF59\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDE40-\uDE7F\uDF00-\uDF4A\uDF4F-\uDF87\uDF8F-\uDF9F\uDFE0\uDFE1\uDFE3]|\uD821[\uDC00-\uDFF7]|\uD822[\uDC00-\uDEF2]|\uD82C[\uDC00-\uDD1E\uDD50-\uDD52\uDD64-\uDD67\uDD70-\uDEFB]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99\uDC9D\uDC9E]|\uD834[\uDD65-\uDD69\uDD6D-\uDD72\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB\uDFCE-\uDFFF]|\uD836[\uDE00-\uDE36\uDE3B-\uDE6C\uDE75\uDE84\uDE9B-\uDE9F\uDEA1-\uDEAF]|\uD838[\uDC00-\uDC06\uDC08-\uDC18\uDC1B-\uDC21\uDC23\uDC24\uDC26-\uDC2A\uDD00-\uDD2C\uDD30-\uDD3D\uDD40-\uDD49\uDD4E\uDEC0-\uDEF9]|\uD83A[\uDC00-\uDCC4\uDCD0-\uDCD6\uDD00-\uDD4B\uDD50-\uDD59]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1\uDEB0-\uDFFF]|\uD87A[\uDC00-\uDFE0]|\uD87E[\uDC00-\uDE1D]|\uDB40[\uDD00-\uDDEF]/u
  )
}, m = {
  fromCodePoint(n) {
    return n < 65536 ? String.fromCharCode(n) : String.fromCharCode(55296 + (n - 65536 >> 10)) + String.fromCharCode(56320 + (n - 65536 & 1023));
  },
  // https://tc39.github.io/ecma262/#sec-white-space
  isWhiteSpace(n) {
    return n === 32 || n === 9 || n === 11 || n === 12 || n === 160 || n >= 5760 && [
      5760,
      8192,
      8193,
      8194,
      8195,
      8196,
      8197,
      8198,
      8199,
      8200,
      8201,
      8202,
      8239,
      8287,
      12288,
      65279
    ].includes(n);
  },
  // https://tc39.github.io/ecma262/#sec-line-terminators
  isLineTerminator(n) {
    return n === 10 || n === 13 || n === 8232 || n === 8233;
  },
  // https://tc39.github.io/ecma262/#sec-names-and-keywords
  isIdentifierStart(n) {
    return n === 36 || n === 95 || // $ (dollar) and _ (underscore)
    n >= 65 && n <= 90 || // A..Z
    n >= 97 && n <= 122 || // a..z
    n === 92 || // \ (backslash)
    n >= 128 && yt.NonAsciiIdentifierStart.test(m.fromCodePoint(n));
  },
  isIdentifierPart(n) {
    return n === 36 || n === 95 || // $ (dollar) and _ (underscore)
    n >= 65 && n <= 90 || // A..Z
    n >= 97 && n <= 122 || // a..z
    n >= 48 && n <= 57 || // 0..9
    n === 92 || // \ (backslash)
    n >= 128 && yt.NonAsciiIdentifierPart.test(m.fromCodePoint(n));
  },
  // https://tc39.github.io/ecma262/#sec-literals-numeric-literals
  isDecimalDigit(n) {
    return n >= 48 && n <= 57;
  },
  isHexDigit(n) {
    return n >= 48 && n <= 57 || // 0..9
    n >= 65 && n <= 70 || // A..F
    n >= 97 && n <= 102;
  },
  isOctalDigit(n) {
    return n >= 48 && n <= 55;
  }
};
function Bt(n) {
  return "0123456789abcdef".indexOf(n.toLowerCase());
}
function it(n) {
  return "01234567".indexOf(n);
}
const P = [[], [], []];
st.forEach((n) => P[n.length - 1]?.push(n));
Pt.forEach((n) => P[n.length - 1]?.push(n));
Mt.forEach((n) => P[n.length - 1]?.push(n));
Nt.forEach((n) => P[n.length - 1]?.push(n));
Qt.forEach((n) => P[n.length - 1]?.push(n));
class _t {
  constructor(t, e) {
    this.source = t, this.errorHandler = e, this._length = t.length, this.index = 0, this.lineNumber = 1, this.lineStart = 0, this.curlyStack = [];
  }
  saveState() {
    return {
      index: this.index,
      lineNumber: this.lineNumber,
      lineStart: this.lineStart,
      curlyStack: this.curlyStack.slice()
    };
  }
  restoreState(t) {
    this.index = t.index, this.lineNumber = t.lineNumber, this.lineStart = t.lineStart, this.curlyStack = t.curlyStack;
  }
  eof() {
    return this.index >= this._length;
  }
  throwUnexpectedToken(t = h.UnexpectedToken) {
    this.errorHandler.throwError({
      code: t,
      index: this.index,
      line: this.lineNumber,
      column: this.index - this.lineStart + 1,
      data: { value: this.source.charAt(this.index) }
    });
  }
  tolerateUnexpectedToken(t = h.UnexpectedToken) {
    this.errorHandler.tolerateError({
      code: t,
      index: this.index,
      line: this.lineNumber,
      column: this.index - this.lineStart + 1
    });
  }
  skipSingleLineComment(t) {
    const e = [], i = this.index - t, r = {
      start: {
        line: this.lineNumber,
        column: this.index - this.lineStart - t
      },
      end: { line: 0, column: 0 }
      // Fake for now
    };
    for (; !this.eof(); ) {
      const a = this.source.charCodeAt(this.index);
      if (this.index += 1, m.isLineTerminator(a)) {
        r.end = {
          line: this.lineNumber,
          column: this.index - this.lineStart - 1
        };
        const o = {
          multiLine: !1,
          start: i + t,
          end: this.index - 1,
          range: [i, this.index - 1],
          loc: r
        };
        return e.push(o), a === 13 && this.source.charCodeAt(this.index) === 10 && (this.index += 1), this.lineNumber += 1, this.lineStart = this.index, e;
      }
    }
    r.end = {
      line: this.lineNumber,
      column: this.index - this.lineStart
    };
    const s = {
      multiLine: !1,
      start: i + t,
      end: this.index,
      range: [i, this.index],
      loc: r
    };
    return e.push(s), e;
  }
  skipMultiLineComment() {
    const t = [], e = this.index - 2, i = {
      start: {
        line: this.lineNumber,
        column: this.index - this.lineStart - 2
      },
      end: { line: 0, column: 0 }
      // Fake for now
    };
    for (; !this.eof(); ) {
      const s = this.source.charCodeAt(this.index);
      if (m.isLineTerminator(s))
        s === 13 && this.source.charCodeAt(this.index + 1) === 10 && (this.index += 1), this.lineNumber += 1, this.index += 1, this.lineStart = this.index;
      else if (s === 42) {
        if (this.source.charCodeAt(this.index + 1) === 47) {
          this.index += 2, i.end = {
            line: this.lineNumber,
            column: this.index - this.lineStart
          };
          const a = {
            multiLine: !0,
            start: e + 2,
            end: this.index - 2,
            range: [e, this.index],
            loc: i
          };
          return t.push(a), t;
        }
        this.index += 1;
      } else
        this.index += 1;
    }
    i.end = {
      line: this.lineNumber,
      column: this.index - this.lineStart
    };
    const r = {
      multiLine: !0,
      start: e + 2,
      end: this.index,
      range: [e, this.index],
      loc: i
    };
    return t.push(r), this.tolerateUnexpectedToken(), t;
  }
  scanComments() {
    let t = [];
    for (; !this.eof(); ) {
      let e = this.source.charCodeAt(this.index);
      if (m.isWhiteSpace(e))
        this.index += 1;
      else if (m.isLineTerminator(e))
        this.index += 1, e === 13 && this.source.charCodeAt(this.index) === 10 && (this.index += 1), this.lineNumber += 1, this.lineStart = this.index;
      else if (e === 47)
        if (e = this.source.charCodeAt(this.index + 1), e === 47) {
          this.index += 2;
          const i = this.skipSingleLineComment(2);
          t = [...t, ...i];
        } else if (e === 42) {
          this.index += 2;
          const i = this.skipMultiLineComment();
          t = [...t, ...i];
        } else
          break;
      else
        break;
    }
    return t;
  }
  isKeyword(t) {
    switch (t = t.toLowerCase(), t.length) {
      case 2:
        return t === f.If || t === f.In;
      case 3:
        return t === f.Var || t === f.For;
      case 4:
        return t === f.Else;
      case 5:
        return t === f.Break || t === f.While;
      case 6:
        return t === f.Return || t === f.Import || t === f.Export;
      case 8:
        return t === f.Function || t === f.Continue;
      default:
        return !1;
    }
  }
  codePointAt(t) {
    let e = this.source.charCodeAt(t);
    if (e >= 55296 && e <= 56319) {
      const i = this.source.charCodeAt(t + 1);
      i >= 56320 && i <= 57343 && (e = (e - 55296) * 1024 + i - 56320 + 65536);
    }
    return e;
  }
  scanHexEscape(t) {
    const e = t === "u" ? 4 : 2;
    let i = 0;
    for (let r = 0; r < e; r++)
      if (!this.eof() && m.isHexDigit(this.source.charCodeAt(this.index)))
        i = i * 16 + Bt(this.source[this.index] ?? ""), this.index += 1;
      else
        return null;
    return String.fromCharCode(i);
  }
  scanUnicodeCodePointEscape() {
    let t = this.source[this.index], e = 0;
    for (t === "}" && this.throwUnexpectedToken(); !this.eof() && (t = this.source[this.index] ?? "", this.index += 1, !!m.isHexDigit(t.charCodeAt(0))); )
      e = e * 16 + Bt(t);
    return (e > 1114111 || t !== "}") && this.throwUnexpectedToken(), m.fromCodePoint(e);
  }
  getIdentifier() {
    const t = this.index;
    for (this.index += 1; !this.eof(); ) {
      const e = this.source.charCodeAt(this.index);
      if (e === 92)
        return this.index = t, this.getComplexIdentifier();
      if (e >= 55296 && e < 57343)
        return this.index = t, this.getComplexIdentifier();
      if (m.isIdentifierPart(e))
        this.index += 1;
      else
        break;
    }
    return this.source.slice(t, this.index);
  }
  getComplexIdentifier() {
    let t = this.codePointAt(this.index), e = m.fromCodePoint(t);
    this.index += e.length;
    let i;
    for (t === 92 && (this.source.charCodeAt(this.index) !== 117 && this.throwUnexpectedToken(), this.index += 1, this.source[this.index] === "{" ? (this.index += 1, i = this.scanUnicodeCodePointEscape()) : (i = this.scanHexEscape("u"), (i === null || i === "\\" || !m.isIdentifierStart(i.charCodeAt(0))) && this.throwUnexpectedToken()), e = i); !this.eof() && (t = this.codePointAt(this.index), !!m.isIdentifierPart(t)); )
      i = m.fromCodePoint(t), e += i, this.index += i.length, t === 92 && (e = e.substring(0, e.length - 1), this.source.charCodeAt(this.index) !== 117 && this.throwUnexpectedToken(), this.index += 1, this.source[this.index] === "{" ? (this.index += 1, i = this.scanUnicodeCodePointEscape()) : (i = this.scanHexEscape("u"), (i === null || i === "\\" || !m.isIdentifierPart(i.charCodeAt(0))) && this.throwUnexpectedToken()), e += i);
    return e;
  }
  octalToDecimal(t) {
    let e = t !== "0", i = it(t);
    return !this.eof() && m.isOctalDigit(this.source.charCodeAt(this.index)) && (e = !0, i = i * 8 + it(this.source[this.index] ?? ""), this.index += 1, "0123".includes(t) && !this.eof() && m.isOctalDigit(this.source.charCodeAt(this.index)) && (i = i * 8 + it(this.source[this.index] ?? ""), this.index += 1)), { code: i, octal: e };
  }
  // https://tc39.github.io/ecma262/#sec-names-and-keywords
  scanIdentifier() {
    let t;
    const e = this.index, i = this.source.charCodeAt(e) === 92 ? this.getComplexIdentifier() : this.getIdentifier();
    if (i.length === 1 ? t = l.Identifier : this.isKeyword(i) ? t = l.Keyword : i.toLowerCase() === j.Null ? t = l.NullLiteral : i.toLowerCase() === j.True || i.toLowerCase() === j.False ? t = l.BooleanLiteral : t = l.Identifier, t !== l.Identifier && e + i.length !== this.index) {
      const r = this.index;
      this.index = e, this.tolerateUnexpectedToken(h.InvalidEscapedReservedWord), this.index = r;
    }
    return {
      type: t,
      value: i,
      lineNumber: this.lineNumber,
      lineStart: this.lineStart,
      start: e,
      end: this.index
    };
  }
  // https://tc39.github.io/ecma262/#sec-punctuators
  scanPunctuator() {
    const t = this.index;
    let e = this.source[this.index] ?? "";
    switch (e) {
      case "(":
      case "{":
        e === "{" && this.curlyStack.push("{"), this.index += 1;
        break;
      case ".":
        this.index += 1;
        break;
      case "}":
        this.index += 1, this.curlyStack.pop();
        break;
      case ")":
      case ";":
      case ",":
      case "[":
      case "]":
      case ":":
      case "?":
      case "~":
        this.index += 1;
        break;
      default:
        for (let i = P.length; i > 0; i--)
          if (e = this.source.substring(this.index, this.index + i), P[i - 1]?.includes(e)) {
            this.index += i;
            break;
          }
    }
    return this.index === t && this.throwUnexpectedToken(), {
      type: l.Punctuator,
      value: e,
      lineNumber: this.lineNumber,
      lineStart: this.lineStart,
      start: t,
      end: this.index
    };
  }
  // https://tc39.github.io/ecma262/#sec-literals-numeric-literals
  scanHexLiteral(t) {
    let e = "";
    for (; !this.eof() && m.isHexDigit(this.source.charCodeAt(this.index)); )
      e += this.source[this.index], this.index += 1;
    return e.length === 0 && this.throwUnexpectedToken(), m.isIdentifierStart(this.source.charCodeAt(this.index)) && this.throwUnexpectedToken(), {
      type: l.NumericLiteral,
      value: Number.parseInt(`0x${e}`, 16),
      lineNumber: this.lineNumber,
      lineStart: this.lineStart,
      start: t,
      end: this.index
    };
  }
  scanBinaryLiteral(t) {
    let e = "";
    for (; !this.eof(); ) {
      const i = this.source[this.index];
      if (i !== "0" && i !== "1")
        break;
      e += this.source[this.index], this.index += 1;
    }
    if (e.length === 0 && this.throwUnexpectedToken(), !this.eof()) {
      const i = this.source.charCodeAt(this.index);
      (m.isIdentifierStart(i) || m.isDecimalDigit(i)) && this.throwUnexpectedToken();
    }
    return {
      type: l.NumericLiteral,
      value: Number.parseInt(e, 2),
      lineNumber: this.lineNumber,
      lineStart: this.lineStart,
      start: t,
      end: this.index
    };
  }
  scanOctalLiteral(t, e) {
    let i = "", r = !1;
    for (m.isOctalDigit(t.charCodeAt(0)) && (r = !0, i = `0${this.source[this.index]}`), this.index += 1; !this.eof() && m.isOctalDigit(this.source.charCodeAt(this.index)); )
      i += this.source[this.index], this.index += 1;
    return !r && i.length === 0 && this.throwUnexpectedToken(), (m.isIdentifierStart(this.source.charCodeAt(this.index)) || m.isDecimalDigit(this.source.charCodeAt(this.index))) && this.throwUnexpectedToken(), {
      type: l.NumericLiteral,
      value: Number.parseInt(i, 8),
      lineNumber: this.lineNumber,
      lineStart: this.lineStart,
      start: e,
      end: this.index
    };
  }
  scanNumericLiteral() {
    const t = this.index;
    let e = this.source[t] ?? "";
    At(
      m.isDecimalDigit(e.charCodeAt(0)) || e === ".",
      "Numeric literal must start with a decimal digit or a decimal point"
    );
    let i = "";
    if (e !== ".") {
      if (i = this.source[this.index] ?? "", this.index += 1, e = this.source[this.index] ?? "", i === "0") {
        if (e === "x" || e === "X")
          return this.index += 1, this.scanHexLiteral(t);
        if (e === "b" || e === "B")
          return this.index += 1, this.scanBinaryLiteral(t);
        if (e === "o" || e === "O")
          return this.scanOctalLiteral(e, t);
      }
      for (; m.isDecimalDigit(this.source.charCodeAt(this.index)); )
        i += this.source[this.index], this.index += 1;
      e = this.source[this.index] ?? "";
    }
    if (e === ".") {
      for (i += this.source[this.index], this.index += 1; m.isDecimalDigit(this.source.charCodeAt(this.index)); )
        i += this.source[this.index], this.index += 1;
      e = this.source[this.index] ?? "";
    }
    if (e === "e" || e === "E")
      if (i += this.source[this.index], this.index += 1, e = this.source[this.index] ?? "", (e === "+" || e === "-") && (i += this.source[this.index], this.index += 1), m.isDecimalDigit(this.source.charCodeAt(this.index)))
        for (; m.isDecimalDigit(this.source.charCodeAt(this.index)); )
          i += this.source[this.index], this.index += 1;
      else
        this.throwUnexpectedToken();
    return m.isIdentifierStart(this.source.charCodeAt(this.index)) && this.throwUnexpectedToken(), {
      type: l.NumericLiteral,
      value: Number.parseFloat(i),
      lineNumber: this.lineNumber,
      lineStart: this.lineStart,
      start: t,
      end: this.index
    };
  }
  scanStringLiteral() {
    const t = this.index;
    let e = this.source[t];
    At(e === "'" || e === '"', "String literal must starts with a quote"), this.index += 1;
    let i = !1, r = "";
    for (; !this.eof(); ) {
      let s = this.source[this.index] ?? "";
      if (this.index += 1, s === e) {
        e = "";
        break;
      }
      if (s === "\\")
        if (s = this.source[this.index] ?? "", this.index += 1, !s || !m.isLineTerminator(s.charCodeAt(0)))
          switch (s) {
            case "u":
              if (this.source[this.index] === "{")
                this.index += 1, r += this.scanUnicodeCodePointEscape();
              else {
                const a = this.scanHexEscape(s);
                a === null && this.throwUnexpectedToken(), r += a;
              }
              break;
            case "x": {
              const a = this.scanHexEscape(s);
              a === null && this.throwUnexpectedToken(h.InvalidHexEscapeSequence), r += a;
              break;
            }
            case "n":
              r += `
`;
              break;
            case "r":
              r += "\r";
              break;
            case "t":
              r += "	";
              break;
            case "b":
              r += "\b";
              break;
            case "f":
              r += "\f";
              break;
            case "v":
              r += "\v";
              break;
            case "8":
            case "9":
              r += s, this.tolerateUnexpectedToken();
              break;
            default:
              if (s && m.isOctalDigit(s.charCodeAt(0))) {
                const a = this.octalToDecimal(s);
                i = a.octal || i, r += String.fromCharCode(a.code);
              } else
                r += s;
              break;
          }
        else
          this.lineNumber += 1, s === "\r" && this.source[this.index] === `
` && (this.index += 1), this.lineStart = this.index;
      else {
        if (m.isLineTerminator(s.charCodeAt(0)))
          break;
        r += s;
      }
    }
    return e !== "" && (this.index = t, this.throwUnexpectedToken()), {
      type: l.StringLiteral,
      value: r,
      lineNumber: this.lineNumber,
      lineStart: this.lineStart,
      start: t,
      end: this.index
    };
  }
  scanTemplate() {
    let t = "", e = !1;
    const i = this.index, r = this.source[i] === "`";
    let s = !1, a = 2;
    for (this.index += 1; !this.eof(); ) {
      let o = this.source[this.index] ?? "";
      if (this.index += 1, o === "`") {
        a = 1, s = !0, e = !0;
        break;
      }
      if (o === "$") {
        if (this.source[this.index] === "{") {
          this.curlyStack.push("${"), this.index += 1, e = !0;
          break;
        }
        t += o;
        continue;
      }
      if (o === "\\") {
        if (o = this.source[this.index] ?? "", this.index += 1, m.isLineTerminator(o.charCodeAt(0)))
          this.lineNumber += 1, o === "\r" && this.source[this.index] === `
` && (this.index += 1), this.lineStart = this.index;
        else
          switch (o) {
            case "n":
              t += `
`;
              break;
            case "r":
              t += "\r";
              break;
            case "t":
              t += "	";
              break;
            case "u":
              if (this.source[this.index] === "{")
                this.index += 1, t += this.scanUnicodeCodePointEscape();
              else {
                const c = this.index, d = this.scanHexEscape(o);
                d !== null ? t += d : (this.index = c, t += o);
              }
              break;
            case "x": {
              const c = this.scanHexEscape(o);
              c === null && this.throwUnexpectedToken(h.InvalidHexEscapeSequence), t += c;
              break;
            }
            case "b":
              t += "\b";
              break;
            case "f":
              t += "\f";
              break;
            case "v":
              t += "\v";
              break;
            default:
              o === "0" ? (m.isDecimalDigit(this.source.charCodeAt(this.index)) && this.throwUnexpectedToken(h.TemplateOctalLiteral), t += "\0") : m.isOctalDigit(o.charCodeAt(0)) ? this.throwUnexpectedToken(h.TemplateOctalLiteral) : t += o;
              break;
          }
        continue;
      }
      if (m.isLineTerminator(o.charCodeAt(0))) {
        this.lineNumber += 1, o === "\r" && this.source[this.index] === `
` && (this.index += 1), this.lineStart = this.index, t += `
`;
        continue;
      }
      t += o;
    }
    return e || this.throwUnexpectedToken(), r || this.curlyStack.pop(), {
      type: l.Template,
      value: this.source.slice(i + 1, this.index - a),
      cooked: t,
      head: r,
      tail: s,
      lineNumber: this.lineNumber,
      lineStart: this.lineStart,
      start: i,
      end: this.index
    };
  }
  lex() {
    if (this.eof())
      return {
        type: l.EOF,
        value: "",
        lineNumber: this.lineNumber,
        lineStart: this.lineStart,
        start: this.index,
        end: this.index
      };
    const t = this.source.charCodeAt(this.index);
    return m.isIdentifierStart(t) ? this.scanIdentifier() : t === 40 || t === 41 || t === 59 ? this.scanPunctuator() : t === 39 || t === 34 ? this.scanStringLiteral() : t === 46 ? m.isDecimalDigit(this.source.charCodeAt(this.index + 1)) ? this.scanNumericLiteral() : this.scanPunctuator() : m.isDecimalDigit(t) ? this.scanNumericLiteral() : t === 96 || t === 125 && this.curlyStack[this.curlyStack.length - 1] === "${" ? this.scanTemplate() : t >= 55296 && t < 57343 && m.isIdentifierStart(this.codePointAt(this.index)) ? this.scanIdentifier() : this.scanPunctuator();
  }
}
const y = {
  None: 0,
  Function: 1,
  IfClause: 2,
  ForLoop: 4,
  ForOfLoop: 8,
  WhileLoop: 16
}, nt = {
  AsObject: 0,
  Automatic: 1
};
function St(n, t = 0) {
  let e = n.start - n.lineStart, i = n.lineNumber;
  return e < 0 && (e += t, i -= 1), { index: n.start, line: i, column: e };
}
function It(n) {
  return [
    { index: n.range[0], ...n.loc.start },
    { index: n.range[1], ...n.loc.end }
  ];
}
function wt(n) {
  return n in H ? H[n] : 0;
}
class se {
  constructor(t, e = {}, i) {
    this.delegate = i, this.hasLineTerminator = !1, this.options = {
      tokens: typeof e.tokens == "boolean" && e.tokens,
      comments: typeof e.comments == "boolean" && e.comments,
      tolerant: typeof e.tolerant == "boolean" && e.tolerant
    }, this.options.comments && (this.commentHandler = new ne()), this.errorHandler = new Vt(this.options.tolerant), this.scanner = new _t(t, this.errorHandler), this.context = {
      isAssignmentTarget: !1,
      blockContext: y.None,
      curlyParsingType: nt.AsObject
    }, this.rawToken = {
      type: l.EOF,
      value: "",
      lineNumber: this.scanner.lineNumber,
      lineStart: 0,
      start: 0,
      end: 0
    }, this.tokens = [], this.startMarker = {
      index: 0,
      line: this.scanner.lineNumber,
      column: 0
    }, this.endMarker = {
      index: 0,
      line: this.scanner.lineNumber,
      column: 0
    }, this.readNextRawToken(), this.endMarker = {
      index: this.scanner.index,
      line: this.scanner.lineNumber,
      column: this.scanner.index - this.scanner.lineStart
    };
  }
  throwIfInvalidType(t, e, {
    validTypes: i,
    invalidTypes: r
  }) {
    i?.some((s) => t.type === s) || r?.some((s) => t.type === s) && this.throwError(h.InvalidExpression, e);
  }
  throwError(t, e, i = this.endMarker) {
    const { index: r, line: s, column: a } = e, o = i.index - r - 1;
    this.errorHandler.throwError({ code: t, index: r, line: s, column: a + 1, len: o });
  }
  tolerateError(t, e) {
    throw new Error("######################################### !!!");
  }
  // Throw an exception because of the token.
  unexpectedTokenError(t = {}) {
    const { rawToken: e } = t;
    let { code: i, data: r } = t, s;
    if (e) {
      if (!i)
        switch (e.type) {
          case l.EOF:
            i = h.UnexpectedEndOfScript;
            break;
          case l.Identifier:
            i = h.UnexpectedIdentifier;
            break;
          case l.NumericLiteral:
            i = h.UnexpectedNumber;
            break;
          case l.StringLiteral:
            i = h.UnexpectedString;
            break;
          case l.Template:
            i = h.UnexpectedTemplate;
            break;
        }
      s = e.value.toString();
    } else
      s = "ILLEGAL";
    i ??= h.UnexpectedToken, r ??= { value: s };
    const a = ct(i, r);
    if (e) {
      const d = e.start, C = e.lineNumber, x = e.start - e.lineStart + 1;
      return new z({
        code: i,
        index: d,
        line: C,
        column: x,
        len: e.end - e.start - 1,
        data: r,
        description: a
      });
    }
    const { index: o, line: c } = this.endMarker;
    return new z({ code: i, index: o, line: c, column: this.endMarker.column + 1, data: r, description: a });
  }
  throwUnexpectedToken(t = {}) {
    throw t.rawToken ??= this.rawToken, this.unexpectedTokenError(t);
  }
  collectComments(t) {
    const { commentHandler: e } = this;
    !e || !t.length || t.forEach((i) => {
      const r = {
        type: i.multiLine ? u.BlockComment : u.LineComment,
        value: this.getSourceValue(i),
        range: i.range,
        loc: i.loc
      };
      e.collectComment(r);
    });
  }
  peekAhead(t) {
    const e = () => (this.scanner.scanComments(), this.scanner.lex()), i = this.scanner.saveState(), r = t.call(this, e);
    return this.scanner.restoreState(i), r;
  }
  getSourceValue(t) {
    return this.scanner.source.slice(t.start, t.end);
  }
  convertToToken(t) {
    return {
      type: Ut[t.type],
      value: this.getSourceValue(t),
      range: [t.start, t.end],
      loc: {
        start: {
          line: this.startMarker.line,
          column: this.startMarker.column
        },
        end: {
          line: this.scanner.lineNumber,
          column: this.scanner.index - this.scanner.lineStart
        }
      }
    };
  }
  readNextRawToken() {
    this.endMarker.index = this.scanner.index, this.endMarker.line = this.scanner.lineNumber, this.endMarker.column = this.scanner.index - this.scanner.lineStart;
    const t = this.rawToken;
    this.collectComments(this.scanner.scanComments()), this.scanner.index !== this.startMarker.index && (this.startMarker.index = this.scanner.index, this.startMarker.line = this.scanner.lineNumber, this.startMarker.column = this.scanner.index - this.scanner.lineStart), this.rawToken = this.scanner.lex(), this.hasLineTerminator = t.lineNumber !== this.rawToken.lineNumber, this.options.tokens && this.rawToken.type !== l.EOF && this.tokens.push(this.convertToToken(this.rawToken));
  }
  captureStartMarker() {
    return {
      index: this.startMarker.index,
      line: this.startMarker.line,
      column: this.startMarker.column
    };
  }
  getItemLocation(t) {
    return {
      range: [t.index, this.endMarker.index],
      loc: {
        start: {
          line: t.line,
          column: t.column
        },
        end: {
          line: this.endMarker.line,
          column: this.endMarker.column
        }
      }
    };
  }
  finalize(t) {
    return (this.delegate ?? this.commentHandler) && (this.commentHandler?.attachComments(t), this.delegate?.(t)), t;
  }
  expectPunctuator(t) {
    const e = this.rawToken;
    if (this.matchPunctuator(t)) {
      this.readNextRawToken();
      return;
    }
    this.throwUnexpectedToken({ rawToken: e, code: h.PunctuatorExpected, data: { value: t } });
  }
  expectKeyword(t) {
    if (this.rawToken.type === l.Keyword && this.rawToken.value.toLowerCase() === t.toString()) {
      this.readNextRawToken();
      return;
    }
    this.throwUnexpectedToken({ rawToken: this.rawToken });
  }
  expectContextualKeyword(t) {
    if (this.rawToken.type === l.Identifier && this.rawToken.value.toLowerCase() === t) {
      this.readNextRawToken();
      return;
    }
    this.throwUnexpectedToken({ rawToken: this.rawToken });
  }
  matchKeyword(t) {
    return this.rawToken.type === l.Keyword && this.rawToken.value.toLowerCase() === t;
  }
  matchContextualKeyword(t) {
    return this.rawToken.type === l.Identifier && this.rawToken.value === t;
  }
  matchPunctuator(t) {
    return this.rawToken.type === l.Punctuator && this.rawToken.value === t;
  }
  getMatchingPunctuator(t) {
    if (typeof t == "string" && (t = t.split("")), !(this.rawToken.type !== l.Punctuator || !t.length))
      return t.find(this.matchPunctuator.bind(this));
  }
  // Cover grammar support.
  //
  // When an assignment expression position starts with an left parenthesis, the determination of the type
  // of the syntax is to be deferred arbitrarily long until the end of the parentheses pair (plus a lookahead)
  // or the first comma. This situation also defers the determination of all the expressions nested in the pair.
  //
  // There are two productions that can be parsed in a parentheses pair that needs to be determined
  // after the outermost pair is closed. They are:
  //
  //   1. AssignmentExpression
  //   2. AssignmentTargets
  //
  // In order to avoid exponential backtracking, we use two flags to denote if the production can be
  // assignment target.
  //
  // The two productions have the relationship:
  //
  //   AssignmentTargets ⊆ AssignmentExpression
  //
  // with a single exception that CoverInitializedName when used directly in an Expression, generates
  // an early error.
  //
  // isolateCoverGrammar function runs the given parser function with a new cover grammar context, and it does not
  // effect the current flags. This means the production the parser parses is only used as an expression. Therefore
  // the CoverInitializedName check is conducted.
  //
  // inheritCoverGrammar function runs the given parse function with a new cover grammar context, and it propagates
  // the flags outside of the parser. This means the production the parser parses is used as a part of a potential
  // pattern. The CoverInitializedName check is deferred.
  isolateCoverGrammar(t) {
    const e = this.context.isAssignmentTarget;
    this.context.isAssignmentTarget = !0;
    const i = t.call(this);
    return this.context.isAssignmentTarget = e, i;
  }
  inheritCoverGrammar(t) {
    const e = this.context.isAssignmentTarget;
    this.context.isAssignmentTarget = !0;
    const i = t.call(this);
    return this.context.isAssignmentTarget &&= e, i;
  }
  withBlockContext(t, e) {
    const i = this.context.blockContext;
    this.context.blockContext |= t;
    const r = this.context.curlyParsingType;
    this.context.curlyParsingType = nt.Automatic;
    const s = e.call(this);
    return this.context.blockContext = i, this.context.curlyParsingType = r, s;
  }
  consumeSemicolon() {
    if (this.matchPunctuator(";")) {
      this.readNextRawToken();
      return;
    }
    if (!this.hasLineTerminator) {
      if (this.rawToken.type === l.EOF || this.matchPunctuator("}")) {
        this.endMarker.index = this.startMarker.index, this.endMarker.line = this.startMarker.line, this.endMarker.column = this.startMarker.column;
        return;
      }
      this.throwUnexpectedToken({ rawToken: this.rawToken });
    }
  }
  parsePrimaryExpression() {
    const t = this.captureStartMarker(), e = this.rawToken;
    switch (e.type) {
      case l.Identifier:
        return this.readNextRawToken(), this.finalize({
          type: u.Identifier,
          name: e.value,
          ...this.getItemLocation(t)
        });
      case l.NumericLiteral:
      case l.StringLiteral:
        return this.context.isAssignmentTarget = !1, this.readNextRawToken(), this.finalize({
          type: u.Literal,
          value: e.value,
          raw: this.getSourceValue(e),
          isString: typeof e.value == "string",
          ...this.getItemLocation(t)
        });
      case l.BooleanLiteral:
        return this.context.isAssignmentTarget = !1, this.readNextRawToken(), this.finalize({
          type: u.Literal,
          value: e.value.toLowerCase() === j.True,
          raw: this.getSourceValue(e),
          isString: !1,
          ...this.getItemLocation(t)
        });
      case l.NullLiteral:
        return this.context.isAssignmentTarget = !1, this.readNextRawToken(), this.finalize({
          type: u.Literal,
          value: null,
          raw: this.getSourceValue(e),
          isString: !1,
          ...this.getItemLocation(t)
        });
      case l.Template:
        return this.parseTemplateLiteral();
      case l.Punctuator:
        switch (e.value) {
          case "(":
            return this.inheritCoverGrammar(this.parseGroupExpression.bind(this));
          case "[":
            return this.inheritCoverGrammar(this.parseArrayInitializer.bind(this));
          case "{":
            return this.inheritCoverGrammar(this.parseObjectExpression.bind(this));
          default:
            return this.throwUnexpectedToken({ rawToken: this.rawToken });
        }
      case l.Keyword:
        return this.context.isAssignmentTarget = !1, this.throwUnexpectedToken({ rawToken: this.rawToken });
      default:
        return this.throwUnexpectedToken({ rawToken: this.rawToken });
    }
  }
  parseArrayInitializer() {
    const t = this.captureStartMarker();
    this.expectPunctuator("[");
    const e = [];
    for (; !this.matchPunctuator("]"); ) {
      const i = this.captureStartMarker();
      this.matchPunctuator(",") ? (this.readNextRawToken(), this.throwError(h.InvalidExpression, i)) : (e.push(this.inheritCoverGrammar(this.parseAssignmentExpression.bind(this))), this.matchPunctuator("]") || this.expectPunctuator(","));
    }
    return this.expectPunctuator("]"), this.finalize({ type: u.ArrayExpression, elements: e, ...this.getItemLocation(t) });
  }
  parseObjectPropertyKey() {
    const t = this.captureStartMarker(), e = this.rawToken;
    switch (e.type) {
      case l.StringLiteral:
        return this.readNextRawToken(), this.finalize({
          type: u.Literal,
          value: e.value,
          raw: this.getSourceValue(e),
          isString: !0,
          ...this.getItemLocation(t)
        });
      case l.Identifier:
      case l.BooleanLiteral:
      case l.NullLiteral:
      case l.Keyword:
        return this.readNextRawToken(), this.finalize({
          type: u.Identifier,
          name: e.value,
          ...this.getItemLocation(t)
        });
      default:
        this.throwError(h.KeyMustBeString, t);
    }
  }
  parseObjectProperty() {
    const t = this.rawToken, e = this.captureStartMarker(), i = this.parseObjectPropertyKey();
    let r = !1, s = null;
    return this.matchPunctuator(":") ? (this.readNextRawToken(), s = this.inheritCoverGrammar(this.parseAssignmentExpression.bind(this))) : t.type === l.Identifier ? (r = !0, s = this.finalize({
      type: u.Identifier,
      name: t.value,
      ...this.getItemLocation(e)
    })) : this.throwUnexpectedToken({ rawToken: this.rawToken }), this.finalize({
      type: u.Property,
      kind: "init",
      key: i,
      value: s,
      shorthand: r,
      ...this.getItemLocation(e)
    });
  }
  parseObjectExpression() {
    const t = this.captureStartMarker();
    this.expectPunctuator("{");
    const e = [];
    for (; !this.matchPunctuator("}"); )
      e.push(this.parseObjectProperty()), this.matchPunctuator("}") || this.expectPunctuator(",");
    return this.expectPunctuator("}"), this.finalize({ type: u.ObjectExpression, properties: e, ...this.getItemLocation(t) });
  }
  parseTemplateElement(t = !1) {
    const e = this.rawToken;
    e.type !== l.Template && this.throwUnexpectedToken({ rawToken: e }), t && !e.head && this.throwUnexpectedToken({ code: h.InvalidTemplateHead, rawToken: e });
    const i = this.captureStartMarker();
    this.readNextRawToken();
    const { value: r, cooked: s, tail: a } = e, o = this.finalize({
      type: u.TemplateElement,
      value: { raw: r, cooked: s },
      tail: a,
      ...this.getItemLocation(i)
    });
    return o.loc.start.column += 1, o.loc.end.column -= a ? 1 : 2, o;
  }
  parseTemplateLiteral() {
    const t = this.captureStartMarker(), e = [], i = [];
    let r = this.parseTemplateElement(!0);
    for (i.push(r); !r.tail; )
      e.push(this.parseExpression()), r = this.parseTemplateElement(), i.push(r);
    return this.finalize({
      type: u.TemplateLiteral,
      quasis: i,
      expressions: e,
      ...this.getItemLocation(t)
    });
  }
  parseGroupExpression() {
    this.expectPunctuator("(");
    const t = this.inheritCoverGrammar(this.parseAssignmentExpression.bind(this));
    return this.expectPunctuator(")"), t;
  }
  parseArguments() {
    this.expectPunctuator("(");
    const t = [];
    if (!this.matchPunctuator(")"))
      for (; ; ) {
        const e = this.isolateCoverGrammar(this.parseAssignmentExpression.bind(this));
        if (t.push(e), this.matchPunctuator(")") || (this.expectPunctuator(","), this.matchPunctuator(")")))
          break;
      }
    return this.expectPunctuator(")"), t;
  }
  parseMemberName() {
    const t = this.rawToken, e = this.captureStartMarker();
    return this.readNextRawToken(), t.type !== l.NullLiteral && t.type !== l.Identifier && t.type !== l.Keyword && t.type !== l.BooleanLiteral && this.throwUnexpectedToken({ rawToken: t }), this.finalize({
      type: u.Identifier,
      name: t.value,
      ...this.getItemLocation(e)
    });
  }
  parseLeftHandSideExpression() {
    const t = this.captureStartMarker();
    let e = this.inheritCoverGrammar(this.parsePrimaryExpression.bind(this));
    const i = this.captureStartMarker();
    let r;
    for (; r = this.getMatchingPunctuator("([."); )
      switch (r) {
        case "(": {
          this.context.isAssignmentTarget = !1, e.type !== u.Identifier && e.type !== u.MemberExpression && this.throwError(h.IdentifierExpected, t, i);
          const s = this.parseArguments();
          e = this.finalize({
            type: u.CallExpression,
            callee: e,
            arguments: s,
            ...this.getItemLocation(t)
          });
          continue;
        }
        case "[": {
          this.context.isAssignmentTarget = !0, this.expectPunctuator("[");
          const s = this.isolateCoverGrammar(() => this.parseExpression());
          this.expectPunctuator("]"), e = this.finalize({
            type: u.MemberExpression,
            computed: !0,
            object: e,
            property: s,
            ...this.getItemLocation(t)
          });
          continue;
        }
        case ".": {
          this.context.isAssignmentTarget = !0, this.expectPunctuator(".");
          const s = this.parseMemberName();
          e = this.finalize({
            type: u.MemberExpression,
            computed: !1,
            object: e,
            property: s,
            ...this.getItemLocation(t)
          });
          continue;
        }
      }
    return e;
  }
  parseUpdateExpression() {
    const t = this.captureStartMarker();
    let e = this.getMatchingPunctuator(st);
    if (e) {
      this.readNextRawToken();
      const a = this.captureStartMarker(), o = this.inheritCoverGrammar(this.parseUnaryExpression.bind(this));
      return o.type !== u.Identifier && o.type !== u.MemberExpression && o.type !== u.CallExpression && this.throwError(h.InvalidExpression, a), this.context.isAssignmentTarget || this.tolerateError(h.InvalidLeftHandSideInAssignment, t), this.context.isAssignmentTarget = !1, this.finalize({
        type: u.UpdateExpression,
        operator: e,
        argument: o,
        prefix: !0,
        ...this.getItemLocation(t)
      });
    }
    const i = this.captureStartMarker(), r = this.inheritCoverGrammar(this.parseLeftHandSideExpression.bind(this)), s = this.captureStartMarker();
    return this.hasLineTerminator || (e = this.getMatchingPunctuator(st), !e) ? r : (r.type !== u.Identifier && r.type !== u.MemberExpression && this.throwError(h.InvalidExpression, i, s), this.context.isAssignmentTarget || this.tolerateError(h.InvalidLeftHandSideInAssignment, t), this.readNextRawToken(), this.context.isAssignmentTarget = !1, this.finalize({
      type: u.UpdateExpression,
      operator: e,
      argument: r,
      prefix: !1,
      ...this.getItemLocation(t)
    }));
  }
  parseUnaryExpression() {
    const t = this.getMatchingPunctuator(Pt);
    if (t) {
      const e = this.captureStartMarker();
      this.readNextRawToken();
      const i = this.inheritCoverGrammar(this.parseUnaryExpression.bind(this));
      return this.context.isAssignmentTarget = !1, this.finalize({
        type: u.UnaryExpression,
        operator: t,
        argument: i,
        prefix: !0,
        ...this.getItemLocation(e)
      });
    }
    return this.parseUpdateExpression();
  }
  parseBinaryExpression() {
    const t = this.rawToken;
    let e = this.inheritCoverGrammar(this.parseUnaryExpression.bind(this));
    if (this.rawToken.type !== l.Punctuator)
      return e;
    const i = this.rawToken.value;
    let r = wt(i);
    if (r === 0)
      return e;
    this.readNextRawToken(), this.context.isAssignmentTarget = !1;
    const s = [t, this.rawToken];
    let a = e, o = this.inheritCoverGrammar(
      this.parseUnaryExpression.bind(this)
    );
    const c = [a, i, o], d = [r];
    for (; this.rawToken.type === l.Punctuator && (r = wt(this.rawToken.value)) > 0; ) {
      for (; c.length > 2 && r <= d[d.length - 1]; ) {
        o = c.pop();
        const k = c.pop();
        d.pop(), a = c.pop(), s.pop();
        const $ = s[s.length - 1], X = St($, $.lineStart);
        c.push(this.finalize(this.createBinaryOrLogicalExpression(X, k, a, o)));
      }
      c.push(this.rawToken.value), d.push(r), s.push(this.rawToken), this.readNextRawToken(), c.push(this.inheritCoverGrammar(this.parseUnaryExpression.bind(this)));
    }
    let C = c.length - 1;
    e = c[C];
    let x = s.pop();
    for (; C > 1; ) {
      const k = s.pop();
      if (!k)
        break;
      const $ = x?.lineStart, X = St(k, $), qt = c[C - 1];
      e = this.finalize(
        this.createBinaryOrLogicalExpression(X, qt, c[C - 2], e)
      ), C -= 2, x = k;
    }
    return e;
  }
  createBinaryOrLogicalExpression(t, e, i, r) {
    const s = Mt.includes(e) ? u.LogicalExpression : u.BinaryExpression;
    return s === u.BinaryExpression ? { type: s, operator: e, left: i, right: r, ...this.getItemLocation(t) } : ((i.type === u.AssignmentExpression || i.type === u.UpdateExpression) && this.throwError(h.InvalidExpression, ...It(i)), (r.type === u.AssignmentExpression || r.type === u.UpdateExpression) && this.throwError(h.InvalidExpression, ...It(i)), { type: s, operator: e, left: i, right: r, ...this.getItemLocation(t) });
  }
  parseAssignmentExpression() {
    const t = this.captureStartMarker(), e = this.inheritCoverGrammar(this.parseBinaryExpression.bind(this)), i = this.captureStartMarker(), r = this.getMatchingPunctuator(Nt);
    if (!r)
      return e;
    e.type !== u.Identifier && e.type !== u.MemberExpression && this.throwError(h.InvalidExpression, t, i), this.context.isAssignmentTarget || this.tolerateError(h.InvalidLeftHandSideInAssignment, t), this.matchPunctuator("=") || (this.context.isAssignmentTarget = !1), this.readNextRawToken();
    const s = this.isolateCoverGrammar(this.parseAssignmentExpression.bind(this));
    return this.finalize({
      type: u.AssignmentExpression,
      left: e,
      operator: r,
      right: s,
      ...this.getItemLocation(t)
    });
  }
  parseExpression() {
    return this.isolateCoverGrammar(this.parseAssignmentExpression.bind(this));
  }
  parseStatements(t) {
    const e = [];
    for (; this.rawToken.type !== l.EOF && !this.matchPunctuator(t); ) {
      const i = this.parseStatementListItem();
      Dt(i) || e.push(i);
    }
    return e;
  }
  parseStatementListItem() {
    return this.context.isAssignmentTarget = !0, this.matchKeyword(f.Function) ? this.parseFunctionDeclaration() : this.matchKeyword(f.Export) ? this.parseExportDeclaration() : this.matchKeyword(f.Import) ? this.parseImportDeclaration() : this.parseStatement();
  }
  parseBlock() {
    const t = this.captureStartMarker();
    this.expectPunctuator("{");
    const e = this.parseStatements("}");
    return this.expectPunctuator("}"), this.finalize({ type: u.BlockStatement, body: e, ...this.getItemLocation(t) });
  }
  parseObjectStatement() {
    const t = this.captureStartMarker(), e = this.parseObjectExpression();
    return this.finalize({
      type: u.ExpressionStatement,
      expression: e,
      ...this.getItemLocation(t)
    });
  }
  parseBlockOrObjectStatement() {
    return this.context.curlyParsingType === nt.AsObject ? this.parseObjectStatement() : this.peekAhead((t) => {
      let e = t();
      return !(e.type !== l.Identifier && e.type !== l.StringLiteral || (e = t(), e.type !== l.Punctuator || e.value !== ":"));
    }) ? this.parseObjectStatement() : this.parseBlock();
  }
  parseIdentifier() {
    const t = this.rawToken;
    if (t.type !== l.Identifier)
      return null;
    const e = this.captureStartMarker();
    return this.readNextRawToken(), this.finalize({
      type: u.Identifier,
      name: t.value,
      ...this.getItemLocation(e)
    });
  }
  parseVariableDeclarator() {
    const t = this.captureStartMarker(), e = this.parseIdentifier();
    e || this.throwUnexpectedToken({ code: h.IdentifierExpected });
    let i = null;
    if (this.matchPunctuator("=")) {
      this.readNextRawToken();
      const r = this.rawToken;
      try {
        i = this.isolateCoverGrammar(this.parseAssignmentExpression.bind(this));
      } catch {
        this.throwUnexpectedToken({ rawToken: r, code: h.InvalidVariableAssignment });
      }
    }
    return this.finalize({ type: u.VariableDeclarator, id: e, init: i, ...this.getItemLocation(t) });
  }
  parseVariableDeclarators() {
    const t = [this.parseVariableDeclarator()];
    for (; this.matchPunctuator(","); )
      this.readNextRawToken(), t.push(this.parseVariableDeclarator());
    return t;
  }
  parseVariableDeclaration() {
    const t = this.captureStartMarker();
    this.expectKeyword(f.Var);
    const e = this.parseVariableDeclarators();
    return this.consumeSemicolon(), this.finalize({
      type: u.VariableDeclaration,
      declarations: e,
      kind: "var",
      ...this.getItemLocation(t)
    });
  }
  parseEmptyStatement() {
    const t = this.captureStartMarker();
    return this.expectPunctuator(";"), this.finalize({ type: u.EmptyStatement, ...this.getItemLocation(t) });
  }
  parseExpressionStatement() {
    const t = this.captureStartMarker(), e = this.parseExpression();
    return this.consumeSemicolon(), this.finalize({
      type: u.ExpressionStatement,
      expression: e,
      ...this.getItemLocation(t)
    });
  }
  parseIfClause() {
    return this.withBlockContext(y.IfClause, this.parseStatement.bind(this));
  }
  parseIfStatement() {
    const t = this.captureStartMarker();
    this.expectKeyword(f.If), this.expectPunctuator("(");
    const e = this.captureStartMarker(), i = this.parseExpression(), r = this.captureStartMarker();
    this.expectPunctuator(")"), (i.type === u.AssignmentExpression || i.type === u.UpdateExpression) && this.throwError(h.InvalidExpression, e, r);
    const s = this.parseIfClause();
    let a = null;
    return this.matchKeyword(f.Else) && (this.readNextRawToken(), a = this.parseIfClause()), this.finalize({
      type: u.IfStatement,
      test: i,
      consequent: s,
      alternate: a,
      ...this.getItemLocation(t)
    });
  }
  parseWhileStatement() {
    const t = this.captureStartMarker();
    this.expectKeyword(f.While), this.expectPunctuator("(");
    const e = this.captureStartMarker(), i = this.parseExpression(), r = this.captureStartMarker();
    this.expectPunctuator(")"), (i.type === u.AssignmentExpression || i.type === u.UpdateExpression) && this.throwError(h.InvalidExpression, e, r);
    const s = this.withBlockContext(y.WhileLoop, this.parseStatement.bind(this));
    return this.finalize({
      type: u.WhileStatement,
      test: i,
      body: s,
      ...this.getItemLocation(t)
    });
  }
  parseForStatement() {
    let t = u.ForStatement, e = null, i = null, r = null, s = null, a = null;
    const o = this.captureStartMarker();
    if (this.expectKeyword(f.For), this.expectPunctuator("("), this.matchKeyword(f.Var)) {
      const d = this.captureStartMarker();
      this.readNextRawToken();
      const C = this.parseVariableDeclarators();
      e = this.finalize({
        type: u.VariableDeclaration,
        declarations: C,
        kind: "var",
        ...this.getItemLocation(d)
      });
      const x = this.matchKeyword(f.In), k = this.matchContextualKeyword(tt.Of);
      C.length === 1 && (x || k) && (C[0].init && this.throwError(h.ForInOfLoopInitializer, d), t = x ? u.ForInStatement : u.ForOfStatement, s = e);
    } else if (!this.matchPunctuator(";")) {
      const d = this.context.isAssignmentTarget, C = this.captureStartMarker();
      e = this.inheritCoverGrammar(this.parseAssignmentExpression.bind(this));
      const x = this.matchKeyword(f.In), k = this.matchContextualKeyword(tt.Of);
      x || k ? (this.context.isAssignmentTarget || this.tolerateError(h.InvalidLeftHandSideInForIn, C), e.type !== u.Identifier && this.throwError(h.InvalidLeftHandSideInForIn, C), t = x ? u.ForInStatement : u.ForOfStatement, s = e) : this.context.isAssignmentTarget = d;
    }
    t === u.ForStatement ? (this.expectPunctuator(";"), i = this.matchPunctuator(";") ? null : this.isolateCoverGrammar(this.parseExpression.bind(this)), this.expectPunctuator(";"), r = this.matchPunctuator(")") ? null : this.isolateCoverGrammar(this.parseExpression.bind(this))) : (this.readNextRawToken(), a = this.parseExpression()), this.expectPunctuator(")");
    const c = this.withBlockContext(
      t === u.ForOfStatement ? y.ForOfLoop : y.ForLoop,
      () => this.isolateCoverGrammar(this.parseStatement.bind(this))
    );
    return t === u.ForInStatement || t === u.ForOfStatement ? this.finalize({
      type: t,
      left: s,
      right: a,
      body: c,
      ...this.getItemLocation(o)
    }) : this.finalize({
      type: t,
      init: e,
      test: i,
      update: r,
      body: c,
      ...this.getItemLocation(o)
    });
  }
  parseContinueStatement() {
    const t = this.captureStartMarker();
    return this.expectKeyword(f.Continue), this.consumeSemicolon(), this.finalize({ type: u.ContinueStatement, ...this.getItemLocation(t) });
  }
  parseBreakStatement() {
    const t = this.captureStartMarker();
    return this.expectKeyword(f.Break), this.consumeSemicolon(), this.finalize({ type: u.BreakStatement, ...this.getItemLocation(t) });
  }
  parseReturnStatement() {
    const t = this.captureStartMarker();
    this.expectKeyword(f.Return);
    const e = !this.matchPunctuator(";") && !this.matchPunctuator("}") && !this.hasLineTerminator && this.rawToken.type !== l.EOF || this.rawToken.type === l.StringLiteral || this.rawToken.type === l.Template ? this.parseExpression() : null;
    return this.consumeSemicolon(), this.finalize({ type: u.ReturnStatement, argument: e, ...this.getItemLocation(t) });
  }
  parseStatement() {
    switch (this.rawToken.type) {
      case l.BooleanLiteral:
      case l.NullLiteral:
      case l.NumericLiteral:
      case l.StringLiteral:
      case l.Template:
      case l.Identifier:
        return this.parseExpressionStatement();
      case l.Punctuator:
        return this.rawToken.value === "{" ? this.parseBlockOrObjectStatement() : this.rawToken.value === "(" ? this.parseExpressionStatement() : this.rawToken.value === ";" ? this.parseEmptyStatement() : this.parseExpressionStatement();
      case l.Keyword:
        switch (this.rawToken.value.toLowerCase()) {
          case f.Break:
            return this.parseBreakStatement();
          case f.Continue:
            return this.parseContinueStatement();
          case f.For:
            return this.parseForStatement();
          case f.Function:
            return this.parseFunctionDeclaration();
          case f.If:
            return this.parseIfStatement();
          case f.Return:
            return this.parseReturnStatement();
          case f.Var:
            return this.parseVariableDeclaration();
          case f.While:
            return this.parseWhileStatement();
          default:
            return this.parseExpressionStatement();
        }
      default:
        return this.throwUnexpectedToken({ rawToken: this.rawToken });
    }
  }
  parseFormalParameters() {
    const t = [];
    if (this.expectPunctuator("("), !this.matchPunctuator(")"))
      for (; this.rawToken.type !== l.EOF; ) {
        const e = this.parseIdentifier();
        if (e || this.throwUnexpectedToken({ rawToken: this.rawToken, code: h.IdentifierExpected }), t.push(e), this.matchPunctuator(")") || (this.expectPunctuator(","), this.matchPunctuator(")")))
          break;
      }
    return this.expectPunctuator(")"), t;
  }
  parseFunctionDeclaration() {
    (this.context.blockContext & y.Function) === y.Function && this.throwUnexpectedToken({ code: h.NoFunctionInsideFunction }), ((this.context.blockContext & y.WhileLoop) === y.WhileLoop || (this.context.blockContext & y.ForOfLoop) === y.ForOfLoop || (this.context.blockContext & y.IfClause) === y.IfClause) && this.throwUnexpectedToken({ code: h.NoFunctionInsideBlock });
    const t = this.captureStartMarker();
    this.expectKeyword(f.Function);
    const e = this.parseIdentifier();
    e || this.throwUnexpectedToken({ code: h.InvalidFunctionIdentifier });
    const i = this.parseFormalParameters(), r = this.context.blockContext;
    this.context.blockContext |= y.Function;
    const s = this.parseBlock();
    return this.context.blockContext = r, this.finalize({
      type: u.FunctionDeclaration,
      id: e,
      params: i,
      body: s,
      ...this.getItemLocation(t)
    });
  }
  parseScript() {
    const t = this.captureStartMarker(), e = this.parseStatements(), i = this.finalize({
      type: u.Program,
      body: e,
      ...this.getItemLocation(t)
    });
    return this.options.tokens && (i.tokens = this.tokens), this.options.tolerant && (i.errors = this.errorHandler.errors), i;
  }
  parseExportDeclaration() {
    this.context.blockContext !== y.None && this.throwUnexpectedToken({ code: h.ModuleExportRootOnly });
    let t = null;
    const e = this.captureStartMarker();
    return this.expectKeyword(f.Export), this.matchKeyword(f.Var) ? t = this.parseVariableDeclaration() : this.matchKeyword("function") ? t = this.parseFunctionDeclaration() : this.throwUnexpectedToken({ code: h.InvalidExpression }), this.finalize({
      type: u.ExportNamedDeclaration,
      declaration: t,
      specifiers: [],
      source: null,
      ...this.getItemLocation(e)
    });
  }
  // The module specified part of a import XX from 'MODULESPECIFIER'
  parseModuleSpecifier() {
    const t = this.captureStartMarker(), e = this.rawToken;
    if (e.type === l.StringLiteral)
      return this.readNextRawToken(), this.finalize({
        type: u.Literal,
        value: e.value,
        raw: this.getSourceValue(e),
        isString: !0,
        ...this.getItemLocation(t)
      });
    this.throwError(h.InvalidModuleUri, t);
  }
  parseDefaultSpecifier() {
    const t = this.captureStartMarker(), e = this.parseIdentifier();
    return e || this.throwUnexpectedToken({ code: h.IdentifierExpected }), this.finalize({
      type: u.ImportDefaultSpecifier,
      local: e,
      ...this.getItemLocation(t)
    });
  }
  parseImportDeclaration() {
    this.context.blockContext !== y.None && this.throwUnexpectedToken({ code: h.ModuleImportRootOnly });
    const t = this.captureStartMarker();
    this.expectKeyword(f.Import);
    const e = this.parseDefaultSpecifier();
    this.expectContextualKeyword(tt.From);
    const i = this.parseModuleSpecifier();
    return this.finalize({
      type: u.ImportDeclaration,
      specifiers: [e],
      source: i,
      ...this.getItemLocation(t)
    });
  }
}
class ue {
  constructor(t, e) {
    this.errorHandler = new Vt(), this.errorHandler.tolerant = e ? typeof e.tolerant == "boolean" && e.tolerant : !1, this.scanner = new _t(t, this.errorHandler), this.trackComments = e ? typeof e.comment == "boolean" && e.comment : !1, this.buffer = [];
  }
  errors() {
    return this.errorHandler.errors;
  }
  /**
   * Used by the exposed method 'tokenize'
   */
  getNextToken() {
    if (this.buffer.length === 0) {
      const t = this.scanner.scanComments();
      if (this.trackComments && t.forEach((e) => {
        const i = this.scanner.source.slice(e.start, e.end), r = {
          type: e.multiLine ? u.BlockComment : u.LineComment,
          value: i,
          range: e.range,
          loc: e.loc
        };
        this.buffer.push(r);
      }), !this.scanner.eof()) {
        const e = {
          line: this.scanner.lineNumber,
          column: this.scanner.index - this.scanner.lineStart
        }, i = this.scanner.lex(), r = {
          line: this.scanner.lineNumber,
          column: this.scanner.index - this.scanner.lineStart
        }, s = {
          type: Ut[i.type],
          value: this.scanner.source.slice(i.start, i.end),
          range: [i.start, i.end],
          loc: { start: e, end: r }
        };
        this.buffer.push(s);
      }
    }
    return this.buffer.shift();
  }
}
function $t(n, t, e) {
  return new se(n, t, e).parseScript();
}
function ae(n, t, e) {
  const i = new ue(n, t), r = [];
  let s;
  try {
    let a;
    for (; a = i.getNextToken(); )
      e && (a = e(a)), r.push(a);
  } catch (a) {
    a instanceof Error && i.errorHandler.tolerate(a);
  }
  return i.errorHandler.tolerant && (s = i.errors()), { tokens: r, errors: s };
}
const p = {
  AlreadyDefined: "AlreadyDefined",
  ApiConflict: "ApiConflict",
  AssignedNeverUsed: "AssignedNeverUsed",
  DefinedNeverAssigned: "DefinedNeverAssigned",
  DefinedNeverUsed: "DefinedNeverUsed",
  EmptyBlockStatement: "EmptyBlockStatement",
  ExecutionError: "ExecutionError",
  InvalidApiFunctionUsage: "InvalidApiFunctionUsage",
  InvalidConstantIdentifier: "InvalidConstantIdentifier",
  InvalidPropertyIdentifier: "InvalidPropertyIdentifier",
  NoArgumentExpected: "NoArgumentExpected",
  NotADictionary: "NotADictionary",
  NotDefined: "NotDefined",
  NotEnoughArguments: "NotEnoughArguments",
  ProfileVariablesAreImmutable: "ProfileVariablesAreImmutable",
  ProfileVariablesConflict: "ProfileVariablesConflict",
  ReservedKeyword: "ReservedKeyword",
  TooManyArguments: "TooManyArguments",
  UnexpectedEmptyFunction: "UnexpectedEmptyFunction",
  UnexpectedPropertyIdentifier: "UnexpectedPropertyIdentifier",
  UnknownPropertyIdentifier: "UnknownPropertyIdentifier"
}, oe = {
  [p.AlreadyDefined]: "'${identifier}' is already defined.",
  [p.ApiConflict]: "'${identifier}' is already defined as an Arcade constant or function.",
  [p.AssignedNeverUsed]: "'${identifier}' is assigned but never used.",
  [p.DefinedNeverAssigned]: "'${identifier}' is defined but never assigned.",
  [p.DefinedNeverUsed]: "'${identifier}' is defined but never used.",
  [p.EmptyBlockStatement]: "Empty block statement.",
  [p.ExecutionError]: "Execution Error: '${stack}'",
  [p.InvalidApiFunctionUsage]: "Arcade function '${identifier}' not used in a call expression.",
  [p.InvalidConstantIdentifier]: "Invalid constant identifier, expecting ${list}.",
  [p.InvalidPropertyIdentifier]: "Invalid property identifier, expecting ${list}.",
  [p.NoArgumentExpected]: "Expecting no argument.",
  [p.NotADictionary]: "'${identifier}' doesn't have properties.",
  [p.NotDefined]: "'${identifier}' is not defined.",
  [p.NotEnoughArguments]: "Expecting at least ${min} argument(s).",
  [p.ProfileVariablesAreImmutable]: "Profile variables cannot be modified.",
  [p.ProfileVariablesConflict]: "'${identifier}' is already defined as a profile variable.",
  [p.ReservedKeyword]: "'${identifier}' is a reserved keyword.",
  [p.TooManyArguments]: "Too many arguments, expecting ${max}.",
  [p.UnexpectedEmptyFunction]: "Unexpected empty function '${identifier}'.",
  [p.UnexpectedPropertyIdentifier]: "Unexpected property identifier.",
  [p.UnknownPropertyIdentifier]: "Unknown property identifier '${identifier}'.",
  ...Ot
};
function J(n, t) {
  return n.line - t.line || n.column - t.column;
}
function ce(n, t) {
  const e = {
    start: n.loc.start,
    end: n.loc.end
  }, i = (r) => he(e, r.loc);
  return J(e.start, e.end) < 0 && (e.start = { ...e.start }, t.skipSpaces(e.start), J(e.start, e.end) < 0 && (e.end = { ...e.end }, t.skipSpaces(e.end, !0))), n.leadingComments?.forEach(i), n.trailingComments?.forEach(i), e;
}
function he(n, t) {
  J(t.start, n.start) < 0 && (n.start = t.start), J(n.end, t.end) < 0 && (n.end = t.end);
}
const le = /\S/u;
function R(n = "") {
  return !le.test(n);
}
const rt = {
  indentWidth: 2,
  wrapColumn: 80,
  quote: null
};
function pt(n) {
  return {
    indentWidth: n?.indentWidth ?? rt.indentWidth,
    wrapColumn: n?.wrapColumn ?? rt.wrapColumn,
    quote: n?.quote ?? rt.quote
  };
}
const De = /^\s*/u, pe = /\u000D\u000A|\u000D(?!\u000A)|\u000A|\u2028|\u2029/u;
class Q {
  // private cachedIndentWidth: number | void = void 0;
  constructor(t) {
    this.lineRecords = t, this.length = t.length;
  }
  // private static emptyLines = this.fromString("");
  static fromString(t, e) {
    if (typeof t != "string")
      return t;
    const i = e?.indentWidth;
    return new Q(
      t.split(pe).map((s) => {
        const a = De.exec(s)?.[0] ?? "";
        return {
          line: s,
          indentation: de(a, i),
          // Boolean indicating whether this line can be re-indented.
          locked: !1,
          sliceStart: a.length,
          sliceEnd: s.length
        };
      })
    );
  }
  toString() {
    return this.sliceString(this.firstPos(), this.lastPos());
  }
  charAt(t) {
    const { line: e, column: i } = t, r = this.lineRecords[e - 1];
    if (typeof r > "u" || i < 0)
      return "";
    const s = this.getIndentationAt(e);
    if (i < s)
      return " ";
    const a = i + r.sliceStart - s;
    return a === r.sliceEnd && e < this.length ? `
` : a >= r.sliceEnd ? "" : r.line.charAt(a);
  }
  getIndentationAt(t) {
    return Math.max(this.lineRecords[t - 1].indentation, 0);
  }
  getLineLength(t) {
    const e = this.lineRecords[t - 1];
    return this.getIndentationAt(t) + e.sliceEnd - e.sliceStart;
  }
  getStatementLineSeparators(t) {
    const e = this.slice(t, this.skipSpaces({ ...t }) ?? this.lastPos());
    return e.length === 1 || !R(e.lineRecords[1].line) ? [`
`] : [`
`, `
`];
  }
  getLeadingCommentSeparators(t) {
    const e = this.slice(t, this.skipSpaces({ ...t }) ?? this.lastPos());
    return e.length === 1 ? [" "] : R(e.lineRecords[1].line) ? [`
`, `
`] : [`
`];
  }
  nextPos(t, e = !1) {
    const i = Math.max(t.line, 0);
    return Math.max(t.column, 0) < this.getLineLength(i) ? (t.column += 1, e ? !!this.skipSpaces(t) : !0) : i < this.length ? (t.line += 1, t.column = 0, e ? !!this.skipSpaces(t) : !0) : !1;
  }
  prevPos(t, e = !1) {
    let i = t.line, r = t.column;
    if (r < 1) {
      if (i -= 1, i < 1)
        return !1;
      r = this.getLineLength(i);
    } else
      r = Math.min(r - 1, this.getLineLength(i));
    return t.line = i, t.column = r, e ? !!this.skipSpaces(t, !0) : !0;
  }
  firstPos() {
    return { line: 1, column: 0 };
  }
  lastPos() {
    return {
      line: this.length,
      column: this.getLineLength(this.length)
    };
  }
  skipSpaces(t, e = !1) {
    if (e) {
      for (; this.prevPos(t); )
        if (!R(this.charAt(t)) && this.nextPos(t))
          return t;
      return null;
    } else {
      for (; R(this.charAt(t)); )
        if (!this.nextPos(t))
          return null;
      return t;
    }
  }
  slice(t, e) {
    if (!e && !t)
      return this;
    if (e ??= this.lastPos(), !t)
      throw new Error("cannot slice with end but not start");
    const i = this.lineRecords.slice(t.line - 1, e.line);
    return t.line === e.line ? i[0] = U(i[0], t.column, e.column) : (i[0] = U(i[0], t.column), i.push(U(i.pop() ?? i[0], 0, e.column))), new Q(i);
  }
  sliceString(t = this.firstPos(), e = this.lastPos()) {
    const i = [];
    for (let r = t.line; r <= e.line; r++) {
      let s = this.lineRecords[r - 1];
      r === t.line ? r === e.line ? s = U(s, t.column, e.column) : s = U(s, t.column) : r === e.line && (s = U(s, 0, e.column));
      let a = "";
      const o = Math.max(s.indentation, 0);
      o > 0 && (a += new Array(o + 1).join(" ")), a += s.line.slice(s.sliceStart, s.sliceEnd), i.push(a);
    }
    return i.join(`
`);
  }
}
function de(n, t = 2) {
  let e = 0;
  const i = n.length;
  for (let r = 0; r < i; r++)
    switch (n.charCodeAt(r)) {
      case 9: {
        const s = Math.ceil(e / t) * t;
        s === e ? e += t : e = s;
        break;
      }
      case 11:
      // '\v'
      case 12:
      // '\f'
      case 13:
      // '\r'
      case 65279:
        break;
      case 32:
      // ' '
      default:
        e += 1;
        break;
    }
  return e;
}
function U(n, t, e) {
  let i = n.sliceStart, r = n.sliceEnd, s = Math.max(n.indentation, 0);
  const a = s + r - i;
  return e ??= a, t = Math.max(t, 0), e = Math.min(e, a), e = Math.max(e, t), e < s ? (s = e, r = i) : r -= a - e, t < s ? s -= t : (t -= s, s = 0, i += t), n.indentation === s && n.sliceStart === i && n.sliceEnd === r ? n : {
    line: n.line,
    indentation: s,
    sliceStart: i,
    sliceEnd: r
  };
}
function kt(n, t, e) {
  return !n && !e ? "" : n ? e ? `${n}${t}${e}` : n : e;
}
const me = /\u000D\u000A|\u000D(?!\u000A)|\u000A|\u2028|\u2029/u;
class D {
  constructor(t = []) {
    this.lines = t;
  }
  static fromString(t) {
    return new D(t.split(me));
  }
  /**
   * Append the elements lines together into a new FormattedLines.
   * [ [a, b], c, [ d, e]] => [a, b, c, d, e]
   * @param elements
   * @returns
   */
  static appendLines(t = []) {
    const e = new D();
    return t.forEach((i) => {
      i != null && (typeof i == "string" ? e.lines.push(i) : e.lines.push(...i.lines));
    }), e;
  }
  /**
   * Join the last line of each element to the first line of the next element.
   * [ [a, b], c, [ d, e]] => [a, bcd, e]
   * With separator:
   * [ [a, b], c, [ d, e]] => [a, b<sep>c<sep>d, e]
   * @param elements
   * @returns
   */
  static joinLines(t = [], e = "") {
    const i = new D();
    return t.forEach((r) => {
      if (r == null)
        return;
      const s = i.lines.pop() ?? "";
      typeof r == "string" ? i.lines.push(kt(s, e, r)) : (i.lines.push(kt(s, e, r.lines.slice(0)[0])), i.lines.push(...r.lines.slice(1)));
    }), i;
  }
  /**
   * Aggregates formatted lines coming from two expressions, statements, or comments.
   * Use the location of each to figure out if they are on the same line or different lines.
   * Also reduce the number of empty lines.
   * @param previousFormattedLines
   * @param previousLocation
   * @param formattedLines
   * @param location
   * @param indentation
   * @returns
   */
  static aggregateLines(t, e, i, r, s) {
    if (i.isEmpty)
      return t;
    if (!e || t.isEmpty)
      return i.indentFirstLine(s);
    const a = r.start.line - e.end.line;
    if (a === 0)
      return D.joinLines([t, " ", i]);
    const o = a === 1 ? void 0 : "";
    return D.appendLines([t, o, i.indentFirstLine(s)]);
  }
  get isEmpty() {
    return this.lines.length === 0 || this.lines.length === 1 && this.lines[0].length === 0;
  }
  get maxLineLength() {
    return this.lines.reduce((t, e) => Math.max(t, e.length), 0);
  }
  get firstLineLength() {
    return (this.lines[0] ?? "").length;
  }
  get lastLineLength() {
    return (this.lines[this.lines.length - 1] ?? "").length;
  }
  surroundWith(t = "", e = "") {
    return !t && !e ? this : this.isEmpty ? new D([t + e]) : this.lines.length === 1 ? new D([t + this.lines[0] + e]) : D.joinLines([t, this, e]);
  }
  indentFirstLine(t = "") {
    return this.isEmpty ? this : (this.lines[0] = t + this.lines[0], this);
  }
  suffixWith(t) {
    return this.surroundWith("", t);
  }
  toString(t = `
`) {
    return this.lines.join(t);
  }
}
function dt(n, t) {
  return n * (t.indentWidth ?? 2);
}
function N(n = 0, t) {
  const { indentWidth: e = 2 } = pt(t);
  return new Array(n * e + 1).join(" ");
}
function W(n) {
  return n.replace(/['"]/gu, (t) => t === '"' ? "'" : '"');
}
function fe(n, t) {
  switch (n.type) {
    case u.UnaryExpression:
      return Ft(t) && t.object === n;
    case u.BinaryExpression:
    case u.LogicalExpression:
      switch (t.type) {
        case u.UnaryExpression:
          return !0;
        case u.MemberExpression:
          return t.object === n;
        case u.BinaryExpression:
        case u.LogicalExpression:
          return H[t.operator] > H[n.operator];
        default:
          return !1;
      }
    case u.Literal:
      return Ft(t) && typeof n.value == "number" && t.object === n;
    case u.AssignmentExpression:
      switch (t.type) {
        case u.UnaryExpression:
        case u.BinaryExpression:
        case u.LogicalExpression:
        case u.ReturnStatement:
          return !0;
        case u.MemberExpression:
          return t.object === n;
        default:
          return !1;
      }
    default:
      return !1;
  }
}
function E(n, t, e) {
  switch (n?.type) {
    case u.BinaryExpression:
    case u.LogicalExpression:
      return Ce(n, t, e);
    case u.AssignmentExpression:
      return new mt(n, t, e);
    case u.MemberExpression:
      return new Kt(n, t, e);
    case u.Identifier:
      return new ht(n, t, e);
    case u.CallExpression:
      return new ge(n, t, e);
    case u.ObjectExpression:
      return M(n, t, e);
    case u.ArrayExpression:
      return M(n, t, e);
    case u.Literal:
      return new ht(n, t, e);
    case u.UpdateExpression:
    case u.UnaryExpression:
      return new Wt(n, t, e);
    case u.TemplateLiteral:
      return new xe(n, t, e);
    case u.VariableDeclaration:
      return new lt(n, t, e);
    default:
      throw new Error(`unknown type: ${JSON.stringify(n)}`);
  }
}
function M(n, t, e) {
  const i = new Y(n, t, e);
  switch (n.type) {
    case u.ArrayExpression:
      return i.setupCollection(
        n.elements.map((r) => E(r, n, e)),
        "SquareBrackets"
      ), i;
    case u.ObjectExpression:
      return i.setupCollection(
        n.properties.map((r) => new Fe(r, n, e)),
        "CurlyBrackets"
      ), i;
    case u.VariableDeclaration:
      return i.prefix = "var ", i.setupCollection(
        n.declarations.map((r) => Rt(r, n, e)),
        "None"
      ), i;
    case u.FunctionDeclaration:
      return i.prefix = `function ${n.id.name}`, i.setupCollection(
        n.params.map((r) => E(r, n, e)),
        "Parentheses"
      ), i;
    case u.ForStatement:
      return i.prefix = "for ", i.setupCollection(
        [
          E(n.init, n, e),
          E(n.test, n, e),
          E(n.update, n, e)
        ],
        "Parentheses",
        ";"
      ), i;
    case u.ForInStatement:
    case u.ForOfStatement:
      return i.prefix = "for ", i.setupCollection([new mt(n, t, e)], "Parentheses", ""), i;
    case u.IfStatement:
      return i.prefix = "if ", i.setupCollection([E(n.test, n, e)], "Parentheses", ""), i;
    case u.WhileStatement:
      return i.prefix = "while ", i.setupCollection([E(n.test, n, e)], "Parentheses", ""), i;
    default:
      return i;
  }
}
function Rt(n, t, e) {
  return n.init ? new mt(n, t, e) : new ht(n.id, t, e);
}
function Ce(n, t, e) {
  const r = [
    ...Z(n.left, n.operator),
    ...Z(n.right, n.operator)
  ].map((a) => E(a, n, e)), s = new Y(n, t, e);
  return s.setupCollection(r, "None", ` ${n.operator}`), s;
}
function Z(n, t) {
  return n.type !== u.BinaryExpression && n.type !== u.LogicalExpression ? [n] : n.operator !== t ? [n] : [
    ...Z(n.left, t),
    ...Z(n.right, t)
  ];
}
class b {
  constructor(t, e, i) {
    this.node = t, this.parent = e, this.options = i, this.prefix = "", this.suffix = "", this.groupingParentheses = !1, this.groupingParentheses = fe(t, e);
  }
  get openingParenthesis() {
    return this.groupingParentheses ? "(" : "";
  }
  get closingParenthesis() {
    return this.groupingParentheses ? ")" : "";
  }
  get leadingString() {
    return [this.prefix, this.openingParenthesis].join("");
  }
  get trailingString() {
    return [this.closingParenthesis, this.suffix].join("");
  }
  finalize(t) {
    return typeof t == "string" && (t = D.fromString(t)), t.surroundWith(this.leadingString, this.trailingString);
  }
}
class Y extends b {
  constructor(t, e, i) {
    super(t, e, i), this.node = t, this.parent = e, this.options = i, this.type = "CollectionPrinter", this.bracketsType = "None", this.separator = ",", this.printers = [];
  }
  setupCollection(t = [], e = "None", i) {
    return this.bracketsType = e, this.separator = i ?? this.separator, this.printers = t, this;
  }
  getOpeningBracket(t = !1, e = "singleLine") {
    if (this.bracketsType === "None")
      return "";
    if (this.bracketsType === "CurlyBrackets")
      return `{${t || e === "multiline" ? "" : " "}`;
    switch (this.bracketsType) {
      case "Parentheses":
        return "(";
      case "SquareBrackets":
        return "[";
      default:
        return "";
    }
  }
  getClosingBracket(t = !1, e = "singleLine") {
    if (this.bracketsType === "None")
      return "";
    if (this.bracketsType === "CurlyBrackets")
      return `${t || e === "multiline" ? "" : " "}}`;
    switch (this.bracketsType) {
      case "Parentheses":
        return ")";
      case "SquareBrackets":
        return "]";
      default:
        return "";
    }
  }
  getLinesLevel(t = 0) {
    return this.bracketsType !== "None" || Xt(this.parent) || jt(this.parent) || (ot(this.node) || at(this.node)) && (ot(this.parent) || at(this.parent)) ? t + 1 : t;
  }
  finalize(t, e = "singleLine", i = 0) {
    if (this.bracketsType === "None")
      return super.finalize(t);
    const r = this.getOpeningBracket(t.isEmpty, e), s = this.getClosingBracket(t.isEmpty, e);
    if (e === "singleLine")
      return super.finalize(t.surroundWith(r, s));
    const a = N(i, this.options);
    return super.finalize(D.appendLines([r, t, a + s]));
  }
  singleLineFormat(t = 0) {
    const e = this.printers.length - 1;
    return D.joinLines(
      this.printers.map(
        (i, r) => i.format("singleLine", t).suffixWith(r < e ? this.separator : "")
      ),
      " "
    );
  }
  optimizedPrinterFormat(t, e, i = 0) {
    const r = this.getLinesLevel(i), s = N(r, this.options), a = this.bracketsType === "None" && e === 0 ? "" : s, o = e < this.printers.length - 1 ? this.separator : "", c = t.format("singleLine", r).suffixWith(o);
    return c.maxLineLength + s.length <= this.options.wrapColumn ? c.indentFirstLine(a) : t.format("multiline", r).suffixWith(o).indentFirstLine(a);
  }
  multilineFormat(t = 0) {
    return D.appendLines(
      this.printers.map((e, i) => this.optimizedPrinterFormat(e, i, t))
    );
  }
  format(t = "singleLine", e = 0) {
    if (this.printers.length === 0) {
      const r = this.getOpeningBracket(!0, t), s = this.getClosingBracket(!0, t);
      return super.finalize(D.fromString(r + s));
    }
    if (t === "singleLine") {
      const r = this.singleLineFormat(e);
      return this.finalize(r, t, e);
    }
    const i = this.multilineFormat(e);
    return this.finalize(i, t, e);
  }
}
const Ee = /^[a-zA-Z_$][a-zA-Z_$0-9]*$/u;
class ht extends b {
  constructor(t, e, i) {
    super(t, e, i), this.node = t, this.parent = e, this.options = i, this.type = "StringPrinter";
  }
  format() {
    if (I(this.node))
      return this.finalize(this.node.name);
    if (typeof this.node.value != "string")
      return this.finalize(this.node.raw);
    if (ie(this.parent) && this.parent.key === this.node && zt(this.node) && typeof this.node.value == "string" && Ee.test(this.node.value))
      return this.finalize(this.node.value);
    switch (this.options.quote) {
      case "auto": {
        const t = JSON.stringify(this.node.value), e = W(JSON.stringify(W(this.node.value)));
        return this.finalize(t.length > e.length ? e : t);
      }
      case "single":
        return this.finalize(W(JSON.stringify(W(this.node.value))));
      default:
        return this.finalize(JSON.stringify(this.node.value));
    }
  }
}
class Wt extends b {
  constructor(t, e, i) {
    super(t, e, i), this.node = t, this.parent = e, this.options = i, this.type = "SingleExpressionPrinter";
    const r = te(t), s = ee(t);
    if (r || s) {
      this.prefix = r ? t.operator : "", this.suffix = s && !t.prefix ? t.operator : "", this.printer = E(t.argument, t, this.options);
      return;
    }
    this.printer = E(t, e, this.options);
  }
  format(t = "singleLine", e = 0) {
    return this.finalize(this.printer.format(t, e));
  }
}
class lt extends b {
  constructor(t, e, i) {
    super(t, e, i), this.node = t, this.parent = e, this.options = i, this.type = "VariableDeclaratorsPrinter", t.declarations.length === 1 ? (this.printer = Rt(t.declarations[0], t, this.options), this.printer.prefix = "var ") : this.printer = M(t, e, this.options);
  }
  format(t = "singleLine", e = 0) {
    return this.finalize(this.printer.format(t, e));
  }
}
class ge extends b {
  constructor(t, e, i) {
    super(t, e, i), this.node = t, this.parent = e, this.options = i, this.type = "CallExpressionPrinter", this.argumentsPrinter = new Y(t, e, i), this.argumentsPrinter.setupCollection(
      t.arguments.map((r) => E(r, t, i)),
      "Parentheses"
    ), I(t.callee) ? this.argumentsPrinter.prefix = t.callee.name : this.memberExpressionPrinter = new Kt(t.callee, e, i);
  }
  format(t = "singleLine", e = 0) {
    if (!this.memberExpressionPrinter)
      return this.finalize(this.argumentsPrinter.format(t, e));
    let i = this.memberExpressionPrinter.format("singleLine", e), r = this.argumentsPrinter.format("singleLine", e);
    if (t === "singleLine")
      return this.finalize(D.joinLines([i, r]));
    let s = dt(e, this.options) + this.leadingString.length + i.firstLineLength;
    return s + 1 < this.options.wrapColumn ? (r = this.argumentsPrinter.format("multiline", e), this.finalize(D.joinLines([i, r]))) : (i = this.memberExpressionPrinter.format("multiline", e), s = i.lastLineLength, s + r.maxLineLength > this.options.wrapColumn && (r = this.argumentsPrinter.format("multiline", e + 1)), this.finalize(D.joinLines([i, r])));
  }
}
class Kt extends b {
  constructor(t, e, i) {
    if (super(t, e, i), this.node = t, this.parent = e, this.options = i, this.type = "MemberExpressionPrinter", this.objectPrinter = E(t.object, t, this.options), t.computed) {
      const r = new Y(t.property, t, this.options);
      r.setupCollection([E(t.property, t, this.options)], "SquareBrackets"), this.propertyPrinter = r;
    } else {
      const r = new Wt(t.property, t, this.options);
      r.prefix = ".", this.propertyPrinter = r;
    }
  }
  format(t = "singleLine", e = 0) {
    let i = this.objectPrinter.format("singleLine", e), r = this.propertyPrinter.format("singleLine", e);
    if (t === "singleLine")
      return this.finalize(D.joinLines([i, r]));
    let s = dt(e, this.options) + this.leadingString.length + i.firstLineLength;
    s > this.options.wrapColumn && (i = this.objectPrinter.format("multiline", e), s = i.lastLineLength);
    let a = r.firstLineLength + this.trailingString.length;
    if (s + a < this.options.wrapColumn)
      return this.finalize(D.joinLines([i, r]));
    if (this.node.computed)
      return this.finalize(D.joinLines([i, this.propertyPrinter.format("multiline", e)]));
    const o = e + 1, c = N(o, this.options);
    return r = this.propertyPrinter.format("singleLine", e), a = c.length + r.lastLineLength + this.trailingString.length, a > this.options.wrapColumn && (r = this.propertyPrinter.format("multiline", o)), this.finalize(D.appendLines([i, r.indentFirstLine(c)]));
  }
}
class Fe extends b {
  constructor(t, e, i) {
    super(t, e, i), this.node = t, this.parent = e, this.options = i, this.type = "PropertyPrinter", this.key = E(t.key, t, this.options), t.shorthand || (this.key.suffix = ":", this.value = E(t.value, t, this.options));
  }
  format(t = "singleLine", e = 0) {
    if (this.node.shorthand || !this.value)
      return this.finalize(this.key.format(t, e));
    const i = this.key.format("singleLine", e);
    if (t === "singleLine") {
      const o = this.value.format("singleLine", e);
      return this.finalize(D.joinLines([i, o], " "));
    }
    if (G(this.node.value) || G(this.node.value)) {
      const o = this.value.format("multiline", e);
      return this.finalize(D.joinLines([i, o], " "));
    }
    const r = N(e + 1, this.options);
    let s = this.value.format("singleLine", e + 1).indentFirstLine(r);
    return s.maxLineLength + this.trailingString.length + 1 <= this.options.wrapColumn ? this.finalize(D.appendLines([i, s])) : (s = this.value.format("multiline", e + 1).indentFirstLine(r), this.finalize(D.appendLines([i, s])));
  }
}
class mt extends b {
  constructor(t, e, i) {
    switch (super(t, e, i), this.node = t, this.parent = e, this.options = i, this.type = "OperationPrinter", this.operator = "", this.noNewLineWrapping = !1, t.type) {
      case u.AssignmentExpression:
        this.leftPrinter = E(t.left, t, this.options), this.operator = ` ${t.operator}`, this.rightPrinter = E(t.right, t, this.options), this.noNewLineWrapping = (I(t.left) || zt(t.left)) && (G(t.right) || gt(t.right));
        return;
      case u.VariableDeclarator:
        this.leftPrinter = E(t.id, t, this.options), t.init && (this.operator = " =", this.rightPrinter = E(t.init, t, this.options)), this.noNewLineWrapping = G(t.init) || gt(t.init);
        return;
      case u.ForInStatement:
      case u.ForOfStatement:
        this.leftPrinter = E(t.left, t, this.options), this.operator = t.type === "ForInStatement" ? " in" : " of", this.rightPrinter = E(t.right, t, this.options);
        return;
      case u.BinaryExpression:
      case u.LogicalExpression:
        this.leftPrinter = E(t.left, t, this.options), this.operator = ` ${t.operator}`, this.rightPrinter = E(t.right, t, this.options);
        return;
    }
  }
  format(t = "singleLine", e = 0) {
    if (!this.rightPrinter)
      return this.finalize(this.leftPrinter.format(t, e));
    let i = this.leftPrinter.format("singleLine", e).suffixWith(this.operator), r = this.rightPrinter.format("singleLine", e);
    if (t === "singleLine")
      return this.finalize(D.joinLines([i, r], " "));
    let s = dt(e, this.options) + this.leadingString.length + i.maxLineLength + 1;
    s > this.options.wrapColumn && (i = this.leftPrinter.format("multiline", e).suffixWith(this.operator), s = i.lastLineLength + 1);
    const a = r.firstLineLength + this.trailingString.length + 1;
    if (s + a < this.options.wrapColumn)
      return this.finalize(D.joinLines([i, r], " "));
    const o = this.rightPrinter.format("multiline", e);
    return o.firstLineLength + this.trailingString.length + 1 + s < this.options.wrapColumn || this.noNewLineWrapping ? this.finalize(D.joinLines([i, o], " ")) : (a > this.options.wrapColumn && (r = this.rightPrinter.format("multiline", e + 1)), r = r.indentFirstLine(N(e + 1)), this.finalize(D.appendLines([i, r])));
  }
}
class xe extends b {
  constructor(t, e, i) {
    super(t, e, i), this.node = t, this.parent = e, this.options = i, this.type = "TemplateLiteralPrinter", this.parts = [];
    const r = t.expressions.map(
      (s) => E(s, t, this.options)
    );
    this.parts.push("`"), t.quasis.forEach((s, a) => {
      this.parts.push(s.value.raw), a < r.length && (this.parts.push("${"), this.parts.push(r[a]), this.parts.push("}"));
    }), this.parts.push("`");
  }
  format(t = "singleLine", e = 0) {
    return this.finalize(
      D.joinLines(this.parts.map((i) => typeof i == "string" ? i : i.format(t, e)))
    );
  }
}
function Ae(n) {
  const t = { ...n.leadingComments?.slice(0, 1)[0]?.loc.start ?? n.loc.start }, e = { ...n.trailingComments?.slice(-1)[0]?.loc.end ?? n.loc.end };
  return { start: t, end: e };
}
function ye(n) {
  return n.trailingComments?.slice(-1)[0]?.type === u.LineComment;
}
class L {
  constructor(t, e, i) {
    this.node = t, this.parent = e, this.options = i, this.indentStatementFirstLine = !0, this.externalOffset = 0, this.options = pt(this.options);
  }
  createStatementPrinter(t) {
    switch (t.type) {
      case u.Program:
        return new _(t, this.node, this.options);
      case u.ImportDeclaration:
        return new be(t, this.node, this.options);
      case u.ExpressionStatement:
        return new we(t, this.node, this.options);
      case u.FunctionDeclaration:
        return new Lt(t, this.node, this.options);
      case u.ExportNamedDeclaration:
        return q(t) ? new bt(t, this.node, this.options) : new Lt(t, this.node, this.options);
      case u.BlockStatement:
        return new _(t, this.node, this.options);
      case u.ReturnStatement:
        return new ke(t, this.node, this.options);
      case u.VariableDeclaration:
        return new bt(t, this.node, this.options);
      case u.IfStatement:
        return new Se(t, this.node, this.options);
      case u.ForStatement:
      case u.ForInStatement:
      case u.ForOfStatement:
      case u.WhileStatement:
        return new Ie(t, this.node, this.options);
      case u.EmptyStatement:
      case u.BreakStatement:
      case u.ContinueStatement:
        return new Be(t, this.node, this.options);
      default:
        throw new Error(`unknown type: ${JSON.stringify(t)}`);
    }
  }
  /**
   * We don't to reprint over and over the body that is usually stable for a given level.
   * Uses a cache to optimize the formatting.
   * @param bodyPrinter
   * @param level
   * @returns
   */
  getFormattedBody(t, e = 0) {
    if (this.cachedBody && this.cachedBody.level === e)
      return this.cachedBody.body;
    const i = t.format(e);
    return this.cachedBody = { body: i, level: e }, i;
  }
  getStatementIndentation(t = 0) {
    return this.indentStatementFirstLine ? N(t, this.options) : "";
  }
  getStatementIndentationLength(t = 0) {
    return this.indentStatementFirstLine ? t * this.options.indentWidth : 0;
  }
  /**
   * Gets the indentation string for the corresponding level
   * @param level
   * @returns
   */
  getIndentation(t = 0) {
    return N(t, this.options);
  }
  /**
   * Once the statement has been formatted, we need to wrap the leading and the
   * trailing comments.
   * @param formattedLines
   * @param level
   * @returns
   */
  addComments(t, e = 0) {
    const i = this.getStatementIndentation(e);
    if (!this.node.leadingComments?.length && !this.node.trailingComments?.length)
      return t.indentFirstLine(i);
    const r = (this.node.leadingComments ?? []).reduce(
      (o, c) => {
        const d = this.formatComment(c);
        return {
          formattedLines: D.aggregateLines(
            o.formattedLines,
            o.location,
            d,
            c.loc,
            i
          ),
          location: c.loc
        };
      },
      { formattedLines: new D() }
    ), s = D.aggregateLines(
      r.formattedLines,
      r.location,
      t,
      this.node.loc,
      i
    );
    return (this.node.trailingComments?.reduce(
      (o, c) => {
        const d = this.formatComment(c);
        return {
          formattedLines: D.aggregateLines(
            o.formattedLines,
            o.location,
            d,
            c.loc,
            i
          ),
          location: c.loc
        };
      },
      { formattedLines: s, location: this.node.loc }
    ) ?? { formattedLines: s }).formattedLines;
  }
  formatInnerComments(t = 0) {
    if (!w(this.node) || !Array.isArray(this.node.innerComments) || !this.node.innerComments.length)
      return new D();
    const e = this.getIndentation(t);
    return this.node.innerComments.reduce(
      (r, s) => {
        const a = this.formatComment(s);
        return {
          formattedLines: D.aggregateLines(
            r.formattedLines,
            r.location,
            a,
            s.loc,
            e
          ),
          location: s.loc
        };
      },
      { formattedLines: new D() }
    ).formattedLines;
  }
  formatComment(t) {
    switch (t.type) {
      case u.BlockComment:
        return D.fromString(t.value).surroundWith("/*", "*/");
      default:
        return D.fromString(t.value.trimEnd()).surroundWith("//");
    }
  }
  /**
   * Invoked for a single line format. Measure is the length of the statement would fit
   * the available space
   * @param formattedLines
   * @param level
   * @param offset
   * @returns
   */
  canFitSingleLine(t, e = 0, i = 0) {
    return this.externalOffset + i + this.getStatementIndentationLength(e) + t.lastLineLength <= this.options.wrapColumn;
  }
}
class _ extends L {
  constructor(t, e, i) {
    super(t, e, i), this.node = t, this.printers = [], this.printers = t.body.map((r) => this.createStatementPrinter(r));
  }
  format(t = 0) {
    if (this.printers.length === 0)
      return this.formatEmptyBlock(t);
    const e = [], i = w(this.node);
    i && e.push("{");
    const r = i ? t + 1 : t;
    let s;
    return this.printers.forEach((a) => {
      if (Dt(a.node))
        return;
      const o = Ae(a.node);
      s && o.start.line - s.end.line > 1 && e.push(""), s = o, e.push(a.format(r));
    }), i && e.push(`${this.getIndentation(t)}}`), this.addComments(D.appendLines(e), t);
  }
  formatEmptyBlock(t = 0) {
    if (!w(this.node))
      return this.addComments(D.fromString(""), t);
    const e = this.formatInnerComments(t + 1), i = "{", r = `${this.getIndentation(t)}}`;
    return e.isEmpty ? ut(this.parent) ? this.addComments(D.appendLines([i, r]), t) : this.addComments(D.fromString("{}"), t) : this.addComments(D.appendLines([i, e, r]), t);
  }
}
class Be extends L {
  constructor(t, e, i) {
    switch (super(t, e, i), this.node = t, this.keyword = "", this.node.type) {
      case u.ContinueStatement:
        this.keyword = "continue;";
        break;
      case u.BreakStatement:
        this.keyword = "break;";
        break;
      default:
        this.keyword = ";";
    }
  }
  format(t = 0) {
    return this.addComments(D.fromString(this.keyword), t);
  }
}
class bt extends L {
  constructor(t, e, i) {
    if (super(t, e, i), this.node = t, q(t))
      this.printer = new lt(t, e, i);
    else if (q(t.declaration))
      this.printer = new lt(t.declaration, e, i), this.printer.prefix = "export ";
    else
      throw new Error(`invalid type: ${JSON.stringify(t)}`);
  }
  format(t = 0, e = "optimized") {
    if (e === "singleLine" || e === "optimized") {
      const i = this.printer.format("singleLine", t).suffixWith(";");
      if (e === "singleLine" || this.canFitSingleLine(i, t))
        return this.addComments(i, t);
    }
    return this.addComments(this.printer.format("multiline", t).suffixWith(";"), t);
  }
}
class Lt extends L {
  constructor(t, e, i) {
    if (super(t, e, i), this.node = t, Et(t))
      this.header = M(t, e, i), this.body = new _(t.body, t, i);
    else if (Et(t.declaration))
      this.header = M(t.declaration, e, i), this.header.prefix = "export ", this.body = new _(t.declaration.body, t, i);
    else
      throw new Error(`invalid type: ${JSON.stringify(t)}`);
  }
  format(t = 0, e = "optimized") {
    this.body.indentStatementFirstLine = !1;
    const i = this.getFormattedBody(this.body, t);
    if (e === "singleLine" || e === "optimized") {
      const s = this.header.format("singleLine", t);
      if (e === "singleLine" || this.canFitSingleLine(s, t, i.firstLineLength + 1))
        return this.addComments(D.joinLines([s, i], " "), t);
    }
    const r = this.header.format("multiline", t);
    return this.addComments(D.joinLines([r, i], " "), t);
  }
}
class Se extends L {
  constructor(t, e, i) {
    super(t, e, i), this.node = t, this.header = M(t, e, i), this.consequent = this.createStatementPrinter(t.consequent), this.consequent.indentStatementFirstLine = !1, t.alternate && (this.alternate = this.createStatementPrinter(t.alternate), this.alternate.indentStatementFirstLine = !1);
  }
  format(t = 0, e = "optimized") {
    let i = !1, r;
    if (e === "singleLine" || e === "optimized") {
      const c = this.header.format("singleLine", t), d = w(this.node.consequent) ? 2 : 0;
      (e === "singleLine" || this.canFitSingleLine(c, t, d)) && (r = c);
    }
    r || (i = !0, r = this.header.format("multiline", t));
    let s;
    if (w(this.node.consequent)) {
      const c = this.consequent.format(t, "optimized");
      s = D.joinLines([r, " ", c]);
    } else if (i || ut(this.node.consequent)) {
      this.consequent.indentStatementFirstLine = !0;
      let c = this.consequent.format(t + 1, "singleLine");
      this.canFitSingleLine(c, t + 1) || (c = this.consequent.format(t + 1, "multiline")), s = D.appendLines([r, c]);
    } else {
      this.consequent.indentStatementFirstLine = !1;
      let c = this.consequent.format(t, "singleLine");
      this.canFitSingleLine(c, 0, r.lastLineLength + 1) ? s = D.joinLines([r, " ", c]) : (this.consequent.indentStatementFirstLine = !0, c = this.consequent.format(t + 1, "optimized"), s = D.appendLines([r, c]));
    }
    if (!this.alternate)
      return this.addComments(s, t);
    const a = ye(this.node.consequent) || !w(this.node.consequent);
    let o;
    if (this.alternate.externalOffset = 0, w(this.node.alternate) || ut(this.node.alternate))
      this.alternate.indentStatementFirstLine = !1, this.alternate.externalOffset = a ? 5 : s.lastLineLength + 6, o = this.alternate.format(t, "optimized"), o = D.joinLines(["else ", o]);
    else {
      const c = a ? 4 : s.lastLineLength + 4;
      this.alternate.indentStatementFirstLine = !1, o = this.alternate.format(t, "singleLine"), this.canFitSingleLine(o, t, c + 1) ? o = D.joinLines(["else ", o]) : (this.alternate.indentStatementFirstLine = !0, o = this.alternate.format(t + 1, "optimized"), o = D.appendLines(["else", o]));
    }
    return a ? s = D.appendLines([s, o.indentFirstLine(this.getIndentation(t))]) : s = D.joinLines([s, o], " "), this.addComments(s, t);
  }
}
class Ie extends L {
  constructor(t, e, i) {
    super(t, e, i), this.node = t, this.header = M(t, e, i), this.body = this.createStatementPrinter(t.body);
  }
  format(t = 0, e = "optimized") {
    this.body.indentStatementFirstLine = !1;
    const i = this.getFormattedBody(this.body, t);
    if (e === "singleLine" || e === "optimized") {
      const s = this.header.format("singleLine", t);
      if (e === "singleLine" || this.canFitSingleLine(s, t, i.firstLineLength + 1))
        return this.addComments(D.joinLines([s, i], " "), t);
    }
    const r = this.header.format("multiline", t);
    return this.addComments(D.joinLines([r, i], " "), t);
  }
}
class we extends L {
  constructor(t, e, i) {
    super(t, e, i), this.node = t, this.expression = E(t.expression, t, i);
  }
  format(t = 0, e = "optimized") {
    if (e === "singleLine" || e === "optimized") {
      const i = this.expression.format("singleLine", t).suffixWith(";");
      if (e === "singleLine" || this.canFitSingleLine(i, t))
        return this.addComments(i, t);
    }
    return this.addComments(this.expression.format("multiline", t).suffixWith(";"), t);
  }
}
class ke extends L {
  constructor(t, e, i) {
    super(t, e, i), this.node = t, this.argument = E(t.argument, t, i);
  }
  format(t = 0, e = "optimized") {
    if (e === "singleLine" || e === "optimized") {
      const a = this.argument.format("singleLine", t).surroundWith("return ", ";");
      if (e === "singleLine" || this.canFitSingleLine(a, t))
        return this.addComments(a, t);
    }
    if (!ot(this.node.argument) && !at(this.node.argument)) {
      const a = this.argument.format("multiline", t).surroundWith("return ", ";");
      return this.addComments(a, t);
    }
    const i = this.getIndentation(t + 1), r = this.argument.format("multiline", t + 1).indentFirstLine(i), s = this.getIndentation(t);
    return this.addComments(D.appendLines(["return (", r, `${s});`]), t);
  }
}
class be extends L {
  constructor(t, e, i) {
    super(t, e, i), this.node = t, this.libraryNamePrinter = E(t.specifiers[0].local, t, i), this.librarySourcePrinter = E(t.source, t, i);
  }
  format(t = 0) {
    return this.addComments(
      D.joinLines([
        "import",
        " ",
        this.libraryNamePrinter.format("singleLine", t),
        " from ",
        this.librarySourcePrinter.format("singleLine")
      ]).suffixWith(";"),
      t
    );
  }
}
const Le = { quote: "auto" };
function ci(n, t = {}) {
  try {
    const e = n.getText(), i = n.positionAt(e.length), r = { start: { line: 0, character: 0 }, end: i }, s = { ...Le, ...t.formattingOptions ?? {} }, a = Te(e, s);
    return [{ range: r, newText: a }];
  } catch (e) {
    return console.error("Arcade Formatting Error:", e), [];
  }
}
function Te(n, t) {
  if (!n)
    return "";
  const e = pt(t), i = Q.fromString(n, e), r = i.toString(), s = $t(r, {
    tolerant: !0,
    comments: !0
  }), a = ce(s, i);
  return s.loc.start = a.start, s.loc.end = a.end, new _(s, null, e).format().toString();
}
const ve = Object.values(f), Pe = Object.values(j), Ne = ["case", "catch", "debugger", "switch", "try"], Me = Pe.map((n) => ({ label: n, kind: F.Constant })), Ue = ve.map((n) => ({ label: n, kind: F.Keyword })), Oe = [
  {
    label: "exportfunction",
    kind: F.Snippet,
    detail: "Export Function Statement",
    insertText: `export function \${1:functionName} ($2) {
	$0
}`,
    insertTextMode: S.adjustIndentation,
    insertTextFormat: B.Snippet
  },
  {
    label: "exportvar",
    kind: F.Snippet,
    detail: "Export Variable Statement",
    insertText: "export var ${0:variableName}\n",
    insertTextMode: S.adjustIndentation,
    insertTextFormat: B.Snippet
  },
  {
    label: "for",
    kind: F.Snippet,
    detail: "For Loop Statement",
    insertText: "for (var ${1:i} = 0; ${1:i} < ${2:array.length}; ${1:i}++) {\n	$0\n}",
    insertTextMode: S.adjustIndentation,
    insertTextFormat: B.Snippet
  },
  {
    label: "forin",
    kind: F.Snippet,
    detail: "For-In Loop Statement",
    insertText: "for (var ${1:i} in ${2:arrayOrObject}) {\n	$0\n}",
    insertTextMode: S.adjustIndentation,
    insertTextFormat: B.Snippet
  },
  {
    label: "forof",
    kind: F.Snippet,
    detail: "For-Of Loop Statement",
    insertText: "for (var ${1:i} of ${2:arrayOrObject}) {\n	$0\n}",
    insertTextMode: S.adjustIndentation,
    insertTextFormat: B.Snippet
  },
  {
    label: "function",
    kind: F.Snippet,
    detail: "Function Statement",
    insertText: `function \${1:functionName} ($2) {
	$0
}`,
    insertTextMode: S.adjustIndentation,
    insertTextFormat: B.Snippet
  },
  {
    label: "if",
    kind: F.Snippet,
    detail: "If Statement",
    insertText: `if (\${1:1==1}) {
	$0
}`,
    insertTextMode: S.adjustIndentation,
    insertTextFormat: B.Snippet
  },
  {
    label: "ifelse",
    kind: F.Snippet,
    detail: "If-Else Statement",
    insertText: `if (\${1:1==1}) {
	$0
} else {
	
}`,
    insertTextMode: S.adjustIndentation,
    insertTextFormat: B.Snippet
  },
  {
    label: "else",
    kind: F.Snippet,
    detail: "Else Statement",
    insertText: `else {
	$0
}`,
    insertTextMode: S.adjustIndentation,
    insertTextFormat: B.Snippet
  },
  {
    label: "import",
    kind: F.Snippet,
    detail: "Import Statement",
    insertText: 'import ${1:namespace} from "${0:uri}"',
    insertTextMode: S.adjustIndentation,
    insertTextFormat: B.Snippet
  },
  {
    label: "while",
    kind: F.Snippet,
    detail: "While Loop Statement",
    insertText: `while (\${1:false}) {
	$0
}`,
    insertTextMode: S.adjustIndentation,
    insertTextFormat: B.Snippet
  }
], ze = /\$\{(.*?)\}/gu;
function V(n, t) {
  return t ? n.replace(ze, (e, i) => t[i].toString()) : n;
}
const ft = /[-[\]/{}()*+?.\\^$|]/gu;
function je(n, t) {
  return n.line > t.end.line;
}
function Ve(n, t) {
  return n.line < t.start.line;
}
function Ht(n, t) {
  return !(Ve(n, t) || je(n, t) || n.line === t.start.line && n.column < t.start.column || n.line === t.end.line && n.column > t.end.column);
}
const g = {
  None: 0,
  Keywords: 1,
  All: 255,
  NoKeywords: 254
}, T = {
  identifiers: "a",
  profileVariables: "aa",
  constants: "ab",
  literals: "ab",
  functions: "ac",
  snippets: "b",
  keywords: "c"
};
function _e(n, t, e, i = {}) {
  const r = n.getText({ start: { line: 0, character: 0 }, end: t }), { tokens: s, errors: a = [] } = ae(r, { loc: !0, tolerant: !0 });
  if (a.length)
    return { isIncomplete: !1, items: [] };
  let o = s.at(s.length - 1), c = "";
  const d = ti(t);
  o?.type === "Identifier" && Ht(d, o.loc) && (c = o.value, s.pop(), o = s[s.length - 1]);
  const C = {
    variables: i.profile?.variables ?? [],
    additionalCompletionItems: (i.snippets ?? []).map((x) => ({
      kind: F.Snippet,
      insertTextMode: S.adjustIndentation,
      insertTextFormat: B.Snippet,
      ...x
    })),
    apiDatabase: e
  };
  return o?.type === "Punctuator" && o.value === "." ? Re(s, c, C) : $e(s, c, d, C);
}
function $e(n, t, e, i) {
  const r = He(n, e);
  if (r === g.None)
    return { isIncomplete: !1, items: [] };
  const s = Je(n), a = [], o = new RegExp(t.replaceAll(ft, "\\$&"), "i");
  return s.forEach((c, d) => {
    o.test(d) && a.push({ ...c, sortText: T.identifiers });
  }), i.variables.forEach((c) => {
    o.test(c.name) && c.completion && a.push({ ...c.completion, sortText: T.profileVariables });
  }), Tt(r) && Oe.forEach((c) => {
    c.label.startsWith(t) && a.push({ ...c, sortText: T.snippets });
  }), i.additionalCompletionItems.forEach((c) => {
    o.test(c.label) && a.push({ ...c, sortText: T.snippets });
  }), Tt(r) && Ue.forEach((c) => {
    o.test(c.label) && a.push({ ...c, sortText: T.keywords });
  }), Me.forEach((c) => {
    o.test(c.label) && a.push({ ...c, sortText: T.literals });
  }), i.apiDatabase.constantDefinitions.forEach((c, d) => {
    c.type === "constant" && c.disableDocumentation === !0 || !o.test(d) || a.push({ ...c.completion, sortText: T.constants });
  }), i.apiDatabase.functionDefinitions.forEach((c, d) => {
    o.test(d) && c.overloads.forEach((C) => {
      C.disableDocumentation || a.push({ ...C.completion, sortText: T.functions });
    });
  }), { isIncomplete: !1, items: a };
}
function Re(n, t, e) {
  const i = [...n];
  let r = i.pop();
  const s = r;
  let a = [];
  for (; r && !(r.type !== "Punctuator" || r.value !== "." || (r = i.pop(), r?.type !== "Identifier")); )
    a = [r.value.toLowerCase(), ...a], r = i.pop();
  if (a.length === 0 || !s)
    return { isIncomplete: !1, items: [] };
  let o = We(a, t, e);
  return o || (o = Ke(a, t, s, e), o) ? o : { isIncomplete: !1, items: [] };
}
function We(n, t, e) {
  if (n.length > 1)
    return null;
  const i = e.apiDatabase.constantDefinitions.get(n[0]);
  if (!i)
    return null;
  if (i.type !== "namespace")
    return { isIncomplete: !1, items: [] };
  const r = [], s = new RegExp(t.replaceAll(ft, "\\$&"), "i");
  return i.members.forEach((a) => {
    a.disableDocumentation === !0 || !s.test(a.name) || r.push(a.completion);
  }), { isIncomplete: !1, items: r };
}
function Ke(n, t, e, i) {
  if (!i.variables.length || !n.length)
    return null;
  let r = n.shift(), s = i.variables;
  for (; r; ) {
    const d = s.find((C) => C.name.toLowerCase() === r);
    if (!Gt(d))
      return null;
    s = d.properties ?? [], r = n.shift();
  }
  const a = [], o = new RegExp(t.replaceAll(ft, "\\$&"), "i"), c = ei(e.loc.start);
  return s.forEach((d) => {
    o.test(d.name) && d.completion && a.push(Xe(c, d.completion));
  }), { isIncomplete: !1, items: a };
}
function Tt(n) {
  return (n & g.Keywords) === g.Keywords;
}
function He(n, t) {
  if (!n.length)
    return g.All;
  const e = n[n.length - 1];
  switch (e.type) {
    case "Identifier":
      return g.All;
    case "Keyword":
      return ["return", "in", "else"].includes(e.value) ? g.NoKeywords : g.None;
    case "Punctuator":
      return qe(n);
    case "Template":
      return e.value.endsWith("${") ? g.NoKeywords : g.All;
    default:
      return Ht(t, e.loc) ? g.None : g.All;
  }
}
function qe(n) {
  const t = [...n];
  let e = t.pop();
  if (!e)
    return g.All;
  if (e.type !== "Punctuator")
    return g.None;
  if (e.value !== "(" && e.value !== ",")
    return g.All;
  if (e.value === "(")
    return vt(t);
  let i = 0;
  for (e = t.pop(); e; ) {
    if (e.type === "Keyword")
      return g.None;
    if (e.type !== "Punctuator") {
      e = t.pop();
      continue;
    }
    if (e.value === ")" || e.value === "]") {
      i -= 1, e = t.pop();
      continue;
    }
    if (e.value === "[") {
      if (i === 0)
        return g.NoKeywords;
      i += 1, e = t.pop();
      continue;
    }
    if (e.value === "(") {
      if (i === 0)
        return vt(t);
      i += 1, e = t.pop();
      continue;
    }
    e = t.pop();
  }
  return g.None;
}
function vt(n) {
  const t = [...n];
  let e = t.pop();
  return e ? e.type === "Keyword" ? e.value.toLowerCase() === "for" ? g.All : g.NoKeywords : e.type !== "Identifier" ? g.All : (e = t.pop(), e?.type === "Keyword" && e.value.toLowerCase() === "function" ? g.None : g.NoKeywords) : g.All;
}
class Ge {
  constructor(t) {
    this.tokens = t, this.currentIndex = 0;
  }
  increment() {
    if (!(this.currentIndex >= this.tokens.length))
      return this.currentIndex += 1, this.tokens[this.currentIndex];
  }
  get next() {
    return this.tokens[this.currentIndex + 1];
  }
  get previous() {
    return this.tokens[this.currentIndex - 1];
  }
  get current() {
    return this.tokens[this.currentIndex];
  }
}
const K = {
  parameterFormat: "(parameter) ${name}",
  variableFormat: "var ${name}",
  functionFormat: "function ${name} (${paramsDetail})"
};
function Je(n) {
  const t = /* @__PURE__ */ new Map();
  if (!n.length)
    return t;
  const e = new Ge(n);
  for (; e.current; ) {
    if (e.current.type === "Keyword") {
      if (e.current.value.toLowerCase() === "var") {
        e.increment(), Qe(e, t);
        continue;
      }
      if (e.current.value.toLowerCase() === "function") {
        e.increment(), Ze(e, t);
        continue;
      }
    }
    e.increment();
  }
  return t;
}
function Qe(n, t) {
  for (; n.current; ) {
    if (n.current.type !== "Identifier")
      return;
    const e = n.current.value, i = e.toLowerCase();
    t.set(i, {
      label: e,
      kind: F.Variable,
      detail: V(K.variableFormat, { name: e })
    });
    const r = n.increment();
    if (r?.type !== "Punctuator")
      return;
    if (r.value === ",") {
      n.increment();
      continue;
    }
    if (r.value === "=") {
      n.increment(), Ye(n);
      continue;
    }
  }
}
function Ze(n, t) {
  for (; n.current; ) {
    if (n.current.type !== "Identifier")
      return;
    const e = n.current.value, i = e.toLowerCase(), r = {
      label: e,
      kind: F.Function,
      detail: V(K.functionFormat, { name: e, paramsDetail: "" }),
      insertText: `${e}()`,
      insertTextMode: S.adjustIndentation,
      insertTextFormat: B.Snippet
    };
    t.set(i, r);
    let s = n.increment();
    if (!v(s, "("))
      return;
    s = n.increment();
    const a = [];
    for (; s && !(s.type !== "Identifier" || (a.push(s.value), s = n.increment(), !v(s, ","))); )
      s = n.increment();
    if (a.length) {
      r.detail = V(K.functionFormat, {
        name: r.label,
        paramsDetail: a.join(", ")
      });
      const d = a.map((C, x) => `\${${x + 1}:${C}}`).join(", ");
      r.insertText = `${r.label}(${d})`;
    }
    if (!v(s, ")") || (s = n.increment(), !v(s, "{")))
      return;
    s = n.increment();
    const o = n.currentIndex;
    let c = 1;
    for (; s && c > 0; )
      v(s, "{") ? c += 1 : v(s, "}") && (c -= 1), s = n.increment();
    if (c === 0)
      return;
    n.currentIndex = o, a.forEach((d) => {
      const C = d.toLowerCase();
      t.set(C, {
        label: d,
        kind: F.Variable,
        detail: V(K.parameterFormat, { name: d })
      });
    });
  }
}
function v(n, t) {
  return n?.type === "Punctuator" && n.value === t;
}
function Ye(n) {
  let t = 0;
  for (; n.current; ) {
    if (n.current.type === "Keyword") {
      if (v(n.previous, ".")) {
        n.increment();
        continue;
      }
      return;
    }
    if (n.current.type === "Punctuator" && n.current.value === ";")
      return;
    if (n.current.type === "Template" && n.current.value.startsWith("`")) {
      t += 1, n.increment();
      continue;
    }
    if (n.current.type === "Punctuator" && ["(", "[", "{"].includes(n.current.value)) {
      t += 1, n.increment();
      continue;
    }
    if (n.current.type === "Template" && n.current.value.endsWith("`")) {
      t -= 1, n.increment();
      continue;
    }
    if (n.current.type === "Punctuator" && [")", "]", "}"].includes(n.current.value)) {
      t -= 1, n.increment();
      continue;
    }
    if (!t && n.current.type === "Punctuator" && n.current.value === ",") {
      n.increment();
      return;
    }
    n.increment();
  }
}
function Xe(n, t) {
  return t.insertText?.startsWith("[") && (t.additionalTextEdits = [
    {
      newText: "",
      range: {
        start: { ...n },
        end: {
          line: n.line,
          character: n.character + 1
        }
      }
    }
  ]), t;
}
function ti(n) {
  return { line: n.line + 1, column: n.character };
}
function ei(n) {
  return { line: n.line - 1, character: n.column };
}
class ii {
  constructor(t, e = []) {
    this._apiDatabase = t, this._profileVariables = e, this._isInBlock = !1, this._isInCallExpression = !1, this._identifierBeingAssigned = void 0, this._assignmentValidationMode = "disabled", this._scriptScopeIdentifiers = /* @__PURE__ */ new Map(), this._diagnostics = [], this._undeclaredIdentifiersInFunctions = /* @__PURE__ */ new Map(), this.handleException = (i) => {
      if (ni(i)) {
        const { range: r, code: s, data: a } = i;
        this.logDiagnostic(r, { code: s, data: a });
      } else
        this.logDiagnostic(
          { start: { line: 1, column: 0 }, end: { line: 1, column: 0 } },
          { code: p.ExecutionError, data: { stack: i.stack ?? "" } }
        );
    }, this.validateStatement = (i) => {
      if (i)
        switch (i.type) {
          case u.BlockStatement:
            i.body.forEach(this.validateStatement);
            return;
          case u.VariableDeclaration:
            i.declarations.forEach((r) => this.validateVariableDeclarator(r));
            return;
          case u.FunctionDeclaration:
            this.validateFunctionDeclaration(i);
            return;
          case u.ExportNamedDeclaration:
            this.validateExportDeclaration(i);
            return;
          case u.ImportDeclaration:
            this.validateImportDeclaration(i);
            return;
          case u.WhileStatement:
            this.validateWhileStatement(i);
            return;
          case u.ForStatement:
            this.validateForStatement(i);
            return;
          case u.ForInStatement:
          case u.ForOfStatement:
            this.validateForInOfStatement(i);
            return;
          case u.IfStatement:
            this.validateIfStatement(i);
            return;
          case u.ReturnStatement:
            this.validateExpression(i.argument);
            return;
          case u.ExpressionStatement:
            this.validateExpression(i.expression);
            return;
          // No issue statement
          case u.BreakStatement:
          case u.ContinueStatement:
          case u.EmptyStatement:
            return;
        }
    }, this.validateExpression = (i) => {
      if (i)
        switch (i.type) {
          case u.AssignmentExpression:
            this.validateAssignmentExpression(i);
            return;
          case u.CallExpression:
            this.validateCallExpression(i);
            return;
          case u.Identifier:
            this.validateIdentifier(i);
            return;
          case u.Literal:
            this.validateLiteral(i);
            return;
          case u.ArrayExpression:
            i.elements.forEach(this.validateExpression);
            return;
          case u.ObjectExpression:
            this.validateObjectExpression(i);
            return;
          case u.UnaryExpression:
            this.validateUnaryExpression(i);
            return;
          case u.UpdateExpression:
            this.validateUpdateExpression(i);
            return;
          case u.BinaryExpression:
          case u.LogicalExpression:
            this.validateBinaryAndLogicalExpression(i);
            return;
          case u.MemberExpression:
            this.validateMemberExpression(i);
            return;
          case u.TemplateLiteral:
            i.expressions.forEach(this.validateExpression);
            return;
          default:
            return;
        }
    };
  }
  validateScript(t) {
    if (!t)
      return { diagnostics: [], program: null };
    this._isInBlock = !1, this._identifierBeingAssigned = void 0, this._assignmentValidationMode = "disabled", this._diagnostics = [], this._scriptScopeIdentifiers.clear(), this._undeclaredIdentifiersInFunctions.clear(), this._functionScopeIdentifiers = void 0;
    let e = null;
    try {
      e = $t(t, { tolerant: !0 }), this.handleErrors(e.errors), e.body.forEach(this.validateStatement), this.diagnoseIdentifiers(), this._undeclaredIdentifiersInFunctions.size > 0 && this._undeclaredIdentifiersInFunctions.forEach((i) => {
        for (const r of i)
          this.logDiagnostic(r.node.loc, {
            code: p.NotDefined,
            data: { identifier: r.node.name }
          });
      });
    } catch (i) {
      this.handleException(i);
    }
    return { diagnostics: this._diagnostics, program: e };
  }
  disableRecordIdentifierAssignment(t, e) {
    const i = this._assignmentValidationMode;
    this._assignmentValidationMode = "disabled", t.call(this, e), this._assignmentValidationMode = i;
  }
  inBlock(t, e) {
    const i = this._isInBlock;
    this._isInBlock = !0, t.call(this, e), this._isInBlock = i;
  }
  get _isInFunctionScope() {
    return !!this._functionScopeIdentifiers;
  }
  inFunctionScope(t) {
    this._functionScopeIdentifiers = /* @__PURE__ */ new Map(), t.call(this), this.diagnoseIdentifiers(), this._functionScopeIdentifiers = void 0;
  }
  logDiagnostic(t, e) {
    const i = {
      severity: A.Error,
      ...e,
      message: V(oe[e.code], e.data),
      range: {
        start: { line: t.start.line - 1, character: t.start.column },
        end: { line: t.end.line - 1, character: t.end.column }
      }
    };
    this._diagnostics.push(i);
  }
  handleErrors(t) {
    (t ?? []).forEach(this.handleException);
  }
  getIdentifierInfo(t) {
    return this._functionScopeIdentifiers?.get(t) ?? this._scriptScopeIdentifiers.get(t);
  }
  setIdentifierInfo(t, e) {
    if (this._functionScopeIdentifiers) {
      this._functionScopeIdentifiers.set(t, e);
      return;
    }
    this._scriptScopeIdentifiers.set(t, e), this._undeclaredIdentifiersInFunctions.has(t) && (this._undeclaredIdentifiersInFunctions.delete(t), e.used = !0);
  }
  isProfileVariable(t) {
    return this._profileVariables.some((e) => e.name.toLowerCase() === t);
  }
  isApiConstant(t) {
    return !!this._apiDatabase?.constantDefinitions.get(t);
  }
  isApiFunction(t) {
    return !!this._apiDatabase?.functionDefinitions.get(t);
  }
  isApiItem(t) {
    return this.isApiConstant(t) || this.isApiFunction(t);
  }
  validateVariableDeclarator(t) {
    this.validateExpression(t.init), this.recordVariableIdentifier(t.id, { initialized: !!t.init });
  }
  validateFunctionDeclaration(t) {
    this.recordFunctionIdentifier(t), this.inFunctionScope(() => {
      t.params.forEach((e) => this.recordParamAsIdentifier(e)), O(t.body) && this.logDiagnostic(t.body.loc, {
        code: p.UnexpectedEmptyFunction,
        data: { identifier: t.id.name },
        severity: A.Warning
      }), this.validateStatement(t.body);
    });
  }
  validateExportDeclaration(t) {
    this.validateStatement(t.declaration);
  }
  validateImportDeclaration(t) {
    this.recordImportIdentifier(t);
  }
  validateForStatement(t) {
    q(t.init) ? this.inBlock(this.validateStatement, t.init) : this.validateExpression(t.init), this.validateExpression(t.update), this.validateExpression(t.test), O(t.body) && this.logDiagnostic(t.body.loc, {
      code: p.EmptyBlockStatement,
      severity: A.Warning
    }), this.inBlock(this.validateStatement, t.body);
  }
  validateWhileStatement(t) {
    this.validateExpression(t.test), O(t.body) && this.logDiagnostic(t.body.loc, {
      code: p.EmptyBlockStatement,
      severity: A.Warning
    }), this.inBlock(this.validateStatement, t.body);
  }
  validateForInOfStatement(t) {
    if (I(t.left)) {
      const e = this._assignmentValidationMode;
      this._assignmentValidationMode = "left", this._identifierBeingAssigned = t.left.name.toLowerCase(), this.validateExpression(t.left), this._assignmentValidationMode = e;
    } else
      this.recordVariableIdentifier(t.left.declarations[0].id, { initialized: !0, inBlock: !0 });
    this.validateExpression(t.right), O(t.body) && this.logDiagnostic(t.body.loc, {
      code: p.EmptyBlockStatement,
      severity: A.Warning
    }), this.validateStatement(t.body);
  }
  validateIfStatement(t) {
    this.validateExpression(t.test), O(t.consequent) && this.logDiagnostic(t.consequent.loc, {
      code: p.EmptyBlockStatement,
      severity: A.Warning
    }), t.alternate && O(t.alternate) && this.logDiagnostic(t.alternate.loc, {
      code: p.EmptyBlockStatement,
      severity: A.Warning
    }), this.inBlock(this.validateStatement, t.consequent), this.inBlock(this.validateStatement, t.alternate);
  }
  validateAssignmentExpression(t) {
    const e = this._identifierBeingAssigned, i = this._assignmentValidationMode;
    I(t.left) && (this._identifierBeingAssigned = t.left.name.toLowerCase(), this._assignmentValidationMode = "left"), this.validateExpression(t.left), I(t.left) && (this._assignmentValidationMode = "right"), this.validateExpression(t.right), this._identifierBeingAssigned = e, this._assignmentValidationMode = i;
  }
  validateCallExpression(t) {
    const e = this._isInCallExpression;
    if (this._isInCallExpression = !0, this.validateExpression(t.callee), I(t.callee)) {
      const i = t.callee.name.toLowerCase(), r = this.getIdentifierInfo(i), s = this._apiDatabase?.functionDefinitions.get(i);
      if (!r && s) {
        const a = ri(s, t.arguments.length);
        a && this.logDiagnostic(t.loc, a);
      }
    }
    t.arguments.forEach(this.validateExpression), this._isInCallExpression = e;
  }
  validateIdentifier(t) {
    const e = t.name.toLowerCase(), i = this.getIdentifierInfo(e);
    if (i) {
      if (this._assignmentValidationMode === "left" && this._identifierBeingAssigned === e) {
        i.initialized = !0;
        return;
      }
      if (this._assignmentValidationMode === "right" && this._identifierBeingAssigned === e)
        return;
      i.used = !0;
      return;
    }
    if (!(this.isProfileVariable(e) || this.isApiConstant(e))) {
      if (this.isApiFunction(e)) {
        if (this._isInCallExpression)
          return;
        this.logDiagnostic(t.loc, {
          code: p.InvalidApiFunctionUsage,
          data: { identifier: t.name }
        });
        return;
      }
      if (this._isInFunctionScope) {
        let r = this._undeclaredIdentifiersInFunctions.get(e);
        r || (r = [], this._undeclaredIdentifiersInFunctions.set(e, r)), r.push({ node: t, identifier: e });
        return;
      }
      this.logDiagnostic(t.loc, { code: p.NotDefined, data: { identifier: t.name } });
    }
  }
  validateLiteral(t) {
    ui(t.raw).forEach((e) => {
      const i = this.getIdentifierInfo(e.toLowerCase());
      i && (i.used = !0);
    });
  }
  logProfileOrApiConflict(t) {
    const e = t.name.toLowerCase(), i = this.isProfileVariable(e), r = this.isApiItem(e);
    !i && !r || this.logDiagnostic(t.loc, {
      code: i ? p.ProfileVariablesConflict : p.ApiConflict,
      severity: A.Warning,
      data: {
        identifier: t.name
      }
    });
  }
  logReservedKeywordsConflict(t) {
    const e = t.name.toLowerCase();
    Ne.includes(e) && this.logDiagnostic(t.loc, {
      code: p.ReservedKeyword,
      severity: A.Warning,
      data: {
        identifier: t.name
      }
    });
  }
  validateObjectExpression(t) {
    t.properties.forEach((e) => {
      this.validateExpression(e.value);
    });
  }
  validateUnaryExpression(t) {
    this.validateExpression(t.argument);
  }
  validateUpdateExpression(t) {
    this.validateExpression(t.argument);
  }
  validateBinaryAndLogicalExpression(t) {
    this.validateExpression(t.left), this.validateExpression(t.right);
  }
  validateMemberExpression(t) {
    const e = this.flattenMemberExpressionAndValidate(t), i = e[0].object;
    this.disableRecordIdentifierAssignment(this.validateExpression, i), I(i) && (this.getIdentifierInfo(i.name.toLowerCase()) || this.validateMemberExpressionWithProfile(e) || this.validateConstantMemberExpression(e));
  }
  flattenMemberExpressionAndValidate(t) {
    switch (t.type) {
      case u.MemberExpression:
        return (!I(t.property) || t.computed) && this.validateExpression(t.property), [...this.flattenMemberExpressionAndValidate(t.object), t];
      default:
        return [];
    }
  }
  extractAndValidatePropertyName(t) {
    switch (t.type) {
      case u.Identifier:
        return t.name.toLowerCase();
      case u.Literal:
        return typeof t.value != "string" ? (this.logDiagnostic(t.loc, { code: p.UnexpectedPropertyIdentifier }), null) : t.value.toLowerCase();
      default:
        return this.logDiagnostic(t.loc, { code: p.UnexpectedPropertyIdentifier }), null;
    }
  }
  validateConstantMemberExpression(t) {
    const e = t[0];
    if (!I(e.object))
      return !1;
    const i = e.object.name.toLowerCase(), r = this._apiDatabase?.constantDefinitions.get(i);
    if (!r)
      return !1;
    if (r.type !== "namespace")
      return this.logDiagnostic(e.property.loc, {
        code: p.NotADictionary,
        data: { identifier: i }
      }), !0;
    const s = this.extractAndValidatePropertyName(e.property);
    if (!s)
      return !0;
    if (!r.members.some((a) => a.name.toLowerCase() === s)) {
      const a = r.members.reduce(
        (o, c) => `${o}${o ? " | " : ""}${c.completion.label.split(".").pop()}`,
        ""
      );
      this.logDiagnostic(e.property.loc, {
        code: p.InvalidConstantIdentifier,
        data: { list: a }
      });
    }
    return t.length > 1 && this.logDiagnostic(t[1].property.loc, { code: p.UnexpectedPropertyIdentifier }), !0;
  }
  validateMemberExpressionWithProfile(t) {
    const e = t[0];
    if (e.object.type !== u.Identifier)
      return !1;
    const i = e.object.name.toLowerCase(), r = this._profileVariables.find((a) => a.name.toLowerCase() === i);
    if (!r)
      return !1;
    if (Ct(r))
      return this.logDiagnostic(e.object.loc, {
        code: p.NotADictionary,
        data: { identifier: r.name }
      }), !0;
    if (this._identifierBeingAssigned === i)
      return this.logDiagnostic(e.loc, { code: p.ProfileVariablesAreImmutable }), !0;
    let s = r;
    for (let a = 0; a < t.length; a++) {
      if (t[a].computed)
        return !0;
      if (Ct(s))
        return this.logDiagnostic(t[a - 1]?.property.loc ?? t[a].object.loc, {
          code: p.NotADictionary,
          data: { identifier: s.name }
        }), !0;
      const o = this.extractAndValidatePropertyName(t[a].property);
      if (!o)
        return !0;
      if (!s.properties || s.properties.length === 0)
        return this.logDiagnostic(t[a].property.loc, {
          code: p.UnknownPropertyIdentifier,
          data: { identifier: o },
          severity: A.Warning
        }), !0;
      const c = s.properties.find(
        (d) => d.name.toLowerCase() === o
      );
      if (!c) {
        const d = s.properties.reduce(
          (C, x) => `${C}${C ? " | " : ""}${x.name.split(".").pop()}`,
          ""
        );
        return this.logDiagnostic(t[a].property.loc, {
          code: p.InvalidPropertyIdentifier,
          data: { list: d }
        }), !0;
      }
      s = c;
    }
    return !0;
  }
  recordVariableIdentifier(t, e) {
    this.logReservedKeywordsConflict(t), this.logProfileOrApiConflict(t);
    const i = t.name.toLowerCase();
    let r = this.getIdentifierInfo(i);
    const s = this._isInFunctionScope && r?.scope === "function", a = !this._isInFunctionScope && r?.scope === "script";
    (s || a) && this.logDiagnostic(t.loc, {
      code: p.AlreadyDefined,
      data: { identifier: t.name },
      severity: A.Warning
    });
    const o = e.inBlock ?? this._isInBlock, { initialized: c } = e;
    if (!r || this._isInFunctionScope && r.scope !== "function") {
      const d = this._isInFunctionScope ? "function" : o ? "block" : "script";
      r = {
        node: t,
        used: !1,
        initialized: c,
        scope: d
      };
    } else
      r.node = t, r.used = !1, r.initialized = c;
    return r.scope === "block" && !o && (r.scope = "script", this.logDiagnostic(t.loc, {
      code: p.AlreadyDefined,
      data: { identifier: t.name },
      severity: A.Warning
    })), this.setIdentifierInfo(i, r), !1;
  }
  recordImportIdentifier(t) {
    const e = t.specifiers[0].local;
    this.logProfileOrApiConflict(e);
    const i = e.name.toLowerCase();
    let r = this.getIdentifierInfo(i);
    r?.scope && this.logDiagnostic(t.specifiers[0].local.loc, {
      code: p.AlreadyDefined,
      data: { identifier: t.specifiers[0].local.name },
      severity: A.Warning
    }), r = {
      node: t.specifiers[0].local,
      used: !1,
      ...r,
      scope: "script",
      initialized: !0
    }, this.setIdentifierInfo(i, r);
  }
  recordFunctionIdentifier(t) {
    this.logProfileOrApiConflict(t.id);
    const e = t.id.name.toLowerCase();
    let i = this.getIdentifierInfo(e);
    i?.scope && this.logDiagnostic(t.id.loc, {
      code: p.AlreadyDefined,
      data: { identifier: t.id.name },
      severity: A.Warning
    }), i = {
      node: t.id,
      used: !1,
      ...i,
      scope: "script",
      initialized: !0
    }, this.setIdentifierInfo(e, i);
  }
  recordParamAsIdentifier(t) {
    return this.recordVariableIdentifier(t, { initialized: !0 });
  }
  diagnoseIdentifiers() {
    (this._functionScopeIdentifiers ?? this._scriptScopeIdentifiers).forEach((t) => {
      t.used ? t.initialized || this.logDiagnostic(t.node.loc, {
        code: p.DefinedNeverAssigned,
        data: { identifier: t.node.name },
        severity: A.Warning
      }) : this.logDiagnostic(t.node.loc, {
        code: t.initialized ? p.AssignedNeverUsed : p.DefinedNeverUsed,
        data: { identifier: t.node.name },
        severity: A.Warning
      });
    });
  }
}
function ni(n) {
  return !!n && n.name === "ParsingError";
}
function O(n) {
  return Dt(n) || w(n) && !n.body.length;
}
function ri(n, t) {
  const { min: e, max: i } = n.overloads.reduce(
    (r, s) => {
      const { min: a, max: o } = s.parametersInfo;
      return r.min >= 0 && (r.min = Math.min(a, r.min)), r.max >= 0 && (r.max = o < 0 ? o : Math.max(o, r.max)), r;
    },
    { min: Number.POSITIVE_INFINITY, max: 0 }
  );
  return t < e ? e > 0 ? { code: p.NotEnoughArguments, data: { min: e } } : { code: p.NoArgumentExpected } : i >= 0 && t > i ? { code: p.TooManyArguments, data: { max: i } } : null;
}
const si = /\B@\w+/gu;
function ui(n = "") {
  return Array.from(n.matchAll(si), (t) => t[0].slice(1));
}
class hi {
  configure(t) {
    this.apiService = new Jt(t);
  }
  async doValidation(t, e) {
    if (!this.apiService)
      return [];
    const i = await this.apiService.getApiDatabase(e), { profile: { variables: r = [] } = {} } = e, { diagnostics: s } = new ii(i, r).validateScript(t.getText());
    return s;
  }
  async doComplete(t, e, i) {
    if (!this.apiService)
      return { isIncomplete: !1, items: [] };
    const r = await this.apiService.getApiDatabase(i);
    return _e(t, e, r, i);
  }
}
export {
  ve as ArcadeKeywords,
  hi as ArcadeLanguageService,
  Pe as ArcadeLiterals,
  Ne as ArcadeReservedKeywords,
  oe as DiagnosticMessages,
  pi as DiagnosticSeverity,
  p as ValidationDiagnosticCodes,
  ci as arcadeFormat,
  Te as format
};
