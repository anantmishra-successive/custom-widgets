import { c as n } from "../../chunks/runtime.js";
import o from "@arcgis/core/Camera.js";
import { watch as s } from "@arcgis/core/core/reactiveUtils.js";
import c from "@arcgis/core/geometry/Point.js";
import w from "@arcgis/core/views/SceneView.js";
import m from "@arcgis/core/WebScene.js";
import { LitElement as p, createEvent as a, noShadowRoot as v } from "@arcgis/lumina";
import { makeAccessorController as r, reEmitEvent as t, reCreateAccessor as l } from "@arcgis/lumina/controllers/accessor";
import { b as g, p as d, c as y, i as u } from "../../chunks/component-utils.js";
import { css as f } from "@lit/reactive-element/css-tag.js";
/*! All material copyright Esri, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.33/esri/copyright.txt for details.
v4.33.19 */
const V = f`@layer{arcgis-scene{display:block;height:100%;.esri-view{height:100%;width:100%}}}`, b = r(m, {}), C = r(w, {});
class E extends p {
  constructor() {
    super(), this._cameraProperties = {}, this._map = b(this), this.view = C(this), this.allLayerViews = this.view.allLayerViews, this.alphaCompositingEnabled = this.view.alphaCompositingEnabled, this.analyses = this.view.analyses, this.autoDestroyDisabled = !1, this.basemap = this._map.basemap, this.basemapView = this.view.basemapView, this.clippingArea = this.view.clippingArea, this.constraints = this.view.constraints, this.displayFilterDisabled = this.view.displayFilterEnabled, this.environment = this.view.environment, this.fatalError = this.view.fatalError, this.floors = this.view.floors, this.graphics = this.view.graphics, this.ground = this._map.ground, this.groundView = this.view.groundView, this.highlights = this.view.highlights, this.highlightOptions = this.view.highlightOptions, this.layerViews = this.view.layerViews, this.magnifier = this.view.magnifier, this.map = this.view.map, this.navigation = this.view.navigation, this.padding = this.view.padding, this.popup = this.view.popup, this.popupDisabled = this.view.popupEnabled, this.qualityProfile = this.view.qualityProfile, this.ready = this.view.ready, this.spatialReference = this.view.spatialReference, this.suspended = this.view.suspended, this.theme = this.view.theme, this.timeExtent = this.view.timeExtent, this.updating = this.view.updating, this.viewingMode = this.view.viewingMode, this.visibleArea = this.view.visibleArea, this.arcgisViewChange = a(), this.arcgisViewClick = t(() => this.view, "click"), this.arcgisViewDoubleClick = t(() => this.view, "double-click"), this.arcgisViewDrag = t(() => this.view, "drag"), this.arcgisViewHold = t(() => this.view, "hold"), this.arcgisViewImmediateClick = t(() => this.view, "immediate-click"), this.arcgisViewImmediateDoubleClick = t(() => this.view, "immediate-double-click"), this.arcgisViewKeyDown = t(() => this.view, "key-down"), this.arcgisViewKeyUp = t(() => this.view, "key-up"), this.arcgisViewLayerviewCreate = t(() => this.view, "layerview-create"), this.arcgisViewLayerviewCreateError = t(() => this.view, "layerview-create-error"), this.arcgisViewLayerviewDestroy = t(() => this.view, "layerview-destroy"), this.arcgisViewAnalysisViewCreate = t(() => this.view, "analysis-view-create"), this.arcgisViewAnalysisViewCreateError = t(() => this.view, "analysis-view-create-error"), this.arcgisViewAnalysisViewDestroy = t(() => this.view, "analysis-view-destroy"), this.arcgisViewMouseWheel = t(() => this.view, "mouse-wheel"), this.arcgisViewPointerDown = t(() => this.view, "pointer-down"), this.arcgisViewPointerEnter = t(() => this.view, "pointer-enter"), this.arcgisViewPointerLeave = t(() => this.view, "pointer-leave"), this.arcgisViewPointerMove = t(() => this.view, "pointer-move"), this.arcgisViewPointerUp = t(() => this.view, "pointer-up"), this.arcgisViewReadyChange = a(), this.view.ui = {
      components: ["attribution"]
    };
  }
  static {
    this.properties = { _map: 16, view: 32, allLayerViews: 0, alphaCompositingEnabled: 5, analyses: 0, autoDestroyDisabled: 5, basemap: 1, basemapView: 0, camera: 0, cameraFov: 9, cameraHeading: 9, cameraPosition: 1, cameraTilt: 9, center: 1, clippingArea: 0, constraints: 0, displayFilterDisabled: 5, environment: 0, extent: 0, fatalError: 0, floors: 0, focusAreas: 0, gamepad: 32, graphics: 0, ground: 1, groundView: 0, highlights: 0, highlightOptions: 0, interacting: 32, itemId: 3, layerViews: 0, magnifier: 0, map: 0, navigating: 32, navigation: 0, padding: 0, performanceInfo: 32, popup: 0, popupDisabled: 5, qualityProfile: 1, ready: 4, resolution: 32, scale: 9, spatialReference: 0, stationary: 32, suspended: 7, theme: 0, timeExtent: 0, updating: 4, viewingMode: 1, viewpoint: 0, visibleArea: 0, zoom: 9 };
  }
  static {
    this.shadowRootOptions = v;
  }
  static {
    this.styles = V;
  }
  get camera() {
    return this.view.camera;
  }
  set camera(i) {
    g(this.camera, i) || (this.view.camera = i);
  }
  get cameraFov() {
    const { view: i } = this;
    return i.ready ? this.view.camera?.fov : this._cameraProperties.fov;
  }
  set cameraFov(i) {
    i != null && this._mutateCamera((e) => {
      e.fov = i;
    });
  }
  get cameraHeading() {
    const { view: i } = this;
    return i.ready ? i.camera?.heading : this._cameraProperties.heading;
  }
  set cameraHeading(i) {
    i != null && this._mutateCamera((e) => {
      e.heading = i;
    });
  }
  get cameraPosition() {
    const { view: i } = this;
    if (i.ready)
      return i.camera?.position;
    const { position: e } = this._cameraProperties;
    return e ? new c(e) : void 0;
  }
  set cameraPosition(i) {
    const e = d(this.view.camera?.position, i);
    e && this._mutateCamera((h) => {
      h.position = e;
    });
  }
  get cameraTilt() {
    const { view: i } = this;
    return i.ready ? i.camera?.tilt : this._cameraProperties.tilt;
  }
  set cameraTilt(i) {
    i != null && this._mutateCamera((e) => {
      e.tilt = i;
    });
  }
  get center() {
    return this.view.center;
  }
  set center(i) {
    const e = y(i, this.view);
    e && (this.view.center = e);
  }
  get extent() {
    return this.view.extent;
  }
  set extent(i) {
    i && !this.extent.equals(i) && (this.view.extent = i);
  }
  get focusAreas() {
    return this.map ? this.map?.focusAreas : {
      areas: [],
      style: "bright"
    };
  }
  set focusAreas(i) {
    this.map && (this.map.focusAreas = i);
  }
  get gamepad() {
    return this.view.input.gamepad;
  }
  get interacting() {
    return this.view.interacting;
  }
  get itemId() {
    return this._map.portalItem?.id;
  }
  set itemId(i) {
    l(this._map, this), this._map.portalItem = { id: i }, this.view.map = this._map;
  }
  get navigating() {
    return this.view.navigating;
  }
  get performanceInfo() {
    return this.view.performanceInfo;
  }
  get resolution() {
    return this.view.resolution;
  }
  get scale() {
    return this.view.scale;
  }
  set scale(i) {
    this.view.scale = i;
  }
  get stationary() {
    return this.view.stationary;
  }
  get viewpoint() {
    return this.view.viewpoint;
  }
  set viewpoint(i) {
    u(this.viewpoint, i) && (this.view.viewpoint = i);
  }
  get zoom() {
    return this.view.zoom;
  }
  set zoom(i) {
    this.view.zoom = i;
  }
  async addLayer(i, e) {
    this.map?.add(i, e);
  }
  async addLayers(i, e) {
    this.map?.addMany(i, e);
  }
  async addTable(i) {
    this.map?.tables.add(i);
  }
  async addTables(i, e) {
    this.map?.tables.addMany(i, e);
  }
  async closePopup() {
    this.view.closePopup();
  }
  async destroy() {
    await this.manager.destroy();
  }
  async goTo(i, e) {
    return await this.view.goTo(i, e);
  }
  async hitTest(i, e) {
    return await this.view.hitTest(i, e);
  }
  async openPopup(i) {
    await this.view.openPopup(i);
  }
  async takeScreenshot(i) {
    return await this.view.takeScreenshot(i);
  }
  toMap(i, e) {
    return this.view.toMap(i, e);
  }
  toScreen(i) {
    return this.view.toScreen(i);
  }
  async tryFatalErrorRecovery() {
    this.view.tryFatalErrorRecovery();
  }
  async viewOnReady(i, e) {
    return await this.componentOnReady(), await this.view.whenReady().then(() => i?.()).catch(e);
  }
  async whenAnalysisView(i) {
    return await this.view.whenAnalysisView(i);
  }
  async whenLayerView(i) {
    return await this.view.whenLayerView(i);
  }
  load() {
    const i = this;
    i.el.childElem = document.createElement("div"), i.el.append(i.el.childElem), this.view.container = i.el.childElem;
  }
  loaded() {
    this.map ||= this._map, this.manager.onLifecycle(() => [
      s(() => this.map, (i) => {
        i && (this._map = i);
      }, { initial: !0, sync: !0 }),
      s(() => this.view.stationary, () => this.arcgisViewChange.emit(), { initial: !0 }),
      s(() => this.view.ready, (i) => {
        i && (this.camera = this.view.camera.clone().set(this._cameraProperties), this._cameraProperties = {}), this.arcgisViewReadyChange.emit();
      }, { initial: this.view.ready })
    ]);
  }
  _mutateCamera(i) {
    if (!this.view.ready) {
      i(this._cameraProperties);
      return;
    }
    const e = this.view.camera?.clone() ?? new o();
    i(e), this.camera = e;
  }
}
n("arcgis-scene", E);
export {
  E as ArcgisScene
};
