import { WebChartTypes as o, RESTSymbolType as l } from "@arcgis/charts-spec";
import { cloneDeep as x } from "lodash-es";
import "d3-array";
import { aa as d, at as b, a6 as h, V as D, k as p, cs as g, o as N, aC as U, av as F } from "./interfaces.js";
import "@arcgis/core/geometry/support/jsonUtils.js";
import "@arcgis/core/rest/support/AttributeBinsQuery.js";
import "@arcgis/core/rest/support/Query.js";
import "@arcgis/core/rest/support/StatisticDefinition.js";
import "@arcgis/core/time/TimeExtent.js";
import "@arcgis/core/core/promiseUtils.js";
import "@arcgis/core/request.js";
import { C as M } from "./model-with-y-guides.js";
import { b as r, a as c } from "./common.js";
import { M as O, a as G, b as A, c as k } from "./model-with-data-labels.js";
import { h as L, i as w, m as z } from "./data.js";
import { g as u, s as W, a as B, c as E, b as R, d as K, e as j, f as q, h as m, i as y } from "./pie-chart-data.js";
/*! All material copyright Esri, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.33/esri/copyright.txt for details.
v4.33.19 */
const H = (i) => i.legend?.displayNumericValue ?? !1, J = (i, e) => {
  e.series[0]?.type === o.PieSeries && (e.legend === void 0 && (e.legend = d()), e.legend.displayNumericValue = i);
}, Q = (i) => i.legend?.displayPercentage ?? !1, X = (i, e) => {
  e.series[0]?.type === o.PieSeries && (e.legend === void 0 && (e.legend = d()), e.legend.displayPercentage = i);
}, Y = (i) => i.legend?.labelMaxWidth ?? 200, Z = (i, e) => {
  e.series[0]?.type === o.PieSeries && (e.legend === void 0 && (e.legend = d()), e.legend.labelMaxWidth = i);
};
class P extends O {
  /**
   * Gets the setting for the display of numerical value in the legend items.
   * @returns {boolean}
   * @remarks
   * This setting is only applicable to pie charts.
   */
  getDisplayNumericValue() {
    return H(this._config);
  }
  /**
   * Sets the setting for the display of numerical value in the legend items.
   * @param displayNumericValue The setting for the display of numerical value in the legend items
   * @remarks
   * This setting is only applicable to pie charts.
   */
  setDisplayNumericValue(e) {
    J(e, this._config), this.emitConfigUpdate("setDisplayNumericValue");
  }
  /**
   * Gets the setting for the display of percentage in the legend items.
   * @returns {boolean}
   * @remarks
   * This setting is only applicable to pie charts.
   */
  getDisplayPercentage() {
    return Q(this._config);
  }
  /**
   * Sets the setting for the display of percentage in the legend items.
   * @param displayPercentage The setting for the display of percentage in the legend items
   * @remarks
   * This setting is only applicable to pie charts.
   */
  setDisplayPercentage(e) {
    X(e, this._config), this.emitConfigUpdate("setDisplayPercentage");
  }
  /**
   * Gets the maximum width in pixel for the legend item labels.
   * @returns {number}
   * @remarks
   * This setting is only applicable to pie charts.
   */
  getLabelMaxWidth() {
    return Y(this._config);
  }
  /**
   * Sets the maximum width in pixel for the legend item labels.
   * @param labelMaxWidth The maximum width in pixel for the legend item labels
   * @remarks
   * This setting is only applicable to pie charts.
   */
  setLabelMaxWidth(e) {
    Z(e, this._config), this.emitConfigUpdate("setLabelMaxWidth");
  }
}
L(P, [O]);
const $ = (i) => i.series?.[0]?.innerRadius, ee = (i, e) => {
  e.series?.[0] && (e.series[0].innerRadius = i);
}, ie = (i) => i.series?.[0]?.dataLabelsCharacterLimit, te = (i, e) => {
  e.series?.[0] && (e.series[0].dataLabelsCharacterLimit = i);
}, S = (i) => i.series[0]?.startAngle, C = (i, e) => {
  e.series?.[0] && (e.series[0].startAngle = i);
}, se = (i) => i.series?.[0]?.displayCategoryOnTooltip ?? !0, ae = (i) => i.series?.[0]?.displayNumericValueOnTooltip ?? !0, re = (i) => i.series?.[0]?.displayPercentageOnTooltip ?? !0, ne = (i, e) => {
  e.series[0] && (e.series[0].displayPercentageOnTooltip = i);
}, oe = (i) => i.series?.[0]?.valuePrefix, le = (i, e) => {
  e.series?.[0] && (e.series[0].valuePrefix = i);
}, ge = (i) => i.series?.[0]?.valueSuffix, ce = (i, e) => {
  e.series?.[0] && (e.series[0].valueSuffix = i);
}, de = (i) => i.series?.[0]?.percentagePrefix, fe = (i, e) => {
  e.series?.[0] && (e.series[0].percentagePrefix = i);
}, he = (i) => i.series?.[0]?.percentageSuffix, pe = (i, e) => {
  e.series?.[0] && (e.series[0].percentageSuffix = i);
}, ue = (i) => {
  let e;
  const t = i.series?.[0];
  return t?.displayNumericValueOnDataLabel === !0 && t?.displayPercentageOnDataLabel === !0 ? e = r.Both : t?.displayNumericValueOnDataLabel === !0 ? e = r.Value : e = r.Percentage, e;
}, me = (i, e) => {
  const t = i === r.Value || i === r.Both, s = i === r.Percentage || i === r.Both;
  e.series?.[0] && (e.series[0].displayNumericValueOnDataLabel = t, e.series[0].displayPercentageOnDataLabel = s), e.legend && (e.legend = {
    ...e.legend,
    displayNumericValue: t,
    displayPercentage: s
  });
}, ye = (i) => i.series?.[0]?.alignDataLabels ?? !1, Se = (i, e) => {
  e.series[0] && (e.series[0].alignDataLabels = i);
}, Ce = (i) => i.series?.[0]?.dataLabelsInside ?? !1, _e = (i, e) => {
  e.series[0] && (e.series[0].dataLabelsInside = i);
}, be = (i) => i.series?.[0]?.dataLabelsOffset ?? 10, De = (i, e) => {
  e.series[0] && (e.series[0].dataLabelsOffset = i);
}, Oe = (i) => i.series?.[0]?.numericValueFormat?.intlOptions?.minimumFractionDigits, Le = (i, e) => {
  e.series?.[0] && (e.series[0].numericValueFormat ??= h(), e.series[0].numericValueFormat.intlOptions.minimumFractionDigits = i, e.series[0].numericValueFormat.intlOptions.maximumFractionDigits = i, e.series[0].percentValueFormat ??= h(), e.series[0].percentValueFormat.intlOptions.minimumFractionDigits = i, e.series[0].percentValueFormat.intlOptions.maximumFractionDigits = i);
}, Pe = (i) => i.series?.[0]?.optimizeDataLabelsOverlapping ?? !1, Te = (i, e) => {
  e.series[0] && (e.series[0].optimizeDataLabelsOverlapping = i);
}, Ve = (i) => i.series[0]?.ticks?.visible ?? !1, Ie = (i, e) => {
  e.series?.[0] && (e.series[0].ticks ??= b(), e.series[0].ticks.visible = i);
}, ve = (i) => i.series[0]?.ticks?.lineSymbol, xe = (i, e) => {
  i && e.series?.[0] && (e.series[0].ticks ??= b(), e.series[0].ticks.lineSymbol = x(i));
}, Ne = (i, e) => e.series?.[0]?.slices?.[i]?.originalLabel, Ue = (i, e) => e.series?.[0]?.slices?.[i]?.label, Fe = (i, e, t) => {
  t.series?.[0]?.slices?.[e] && (t.series[0].slices[e].label = i);
}, Me = (i, e) => e.series?.[0]?.slices?.[i]?.fillSymbol?.color, Ge = (i, e, t) => {
  const s = t.series?.[0]?.slices?.[e]?.fillSymbol;
  s !== void 0 ? (s.color = i, s.outline !== void 0 ? s.outline.color = i : s.outline = { type: l.SLS, color: i }) : t.series?.[0]?.slices?.[e] !== void 0 && (t.series[0].slices[e].fillSymbol = {
    type: l.SFS,
    color: i,
    outline: { type: l.SLS, color: i }
  });
}, Ae = (i) => i.series?.[0]?.slices?.map((e) => e.sliceId), _ = (i, e) => {
  e.series?.[0]?.slices?.sort(
    (t, s) => i.findIndex((a) => t.sliceId === a) - i.findIndex((a) => s.sliceId === a)
  );
}, ke = (i) => i.series?.[0]?.sliceGrouping, T = (i, e) => {
  e.series?.[0] && (e.series[0].sliceGrouping = i);
}, V = (i) => i.series?.[0]?.sliceGrouping?.percentageThreshold, we = (i, e) => {
  e.series?.[0]?.sliceGrouping !== void 0 ? e.series[0].sliceGrouping.percentageThreshold = i : e.series[0].sliceGrouping = {
    sliceId: D.defaultGroupOfSlicesId,
    percentageThreshold: i
  };
}, ze = (i) => i.series?.[0]?.slices, I = (i, e) => {
  e.series?.[0] && (e.series[0].slices = i);
}, We = (i) => {
  I(void 0, i), T(
    {
      sliceId: D.defaultGroupOfSlicesId,
      percentageThreshold: V(i) ?? 0
    },
    i
  );
}, Be = (i, e) => e.series[0]?.slices?.[i]?.sliceId, Ee = (i, e) => e.series[0]?.slices?.findIndex((t) => t.sliceId === i), Re = (i) => i.series[0]?.slices?.length ?? 0;
class Ke extends M {
  constructor() {
    super(...arguments), this._chartType = o.PieSeries, this._mode = c.Category, this._groupedSliceIds = [];
  }
  async setup(e) {
    await this.loadConfigFromLayer(e);
    const { config: t } = e;
    if (t !== void 0) {
      const s = p(t.series);
      this._mode = s !== g.PieFromFields ? c.Category : c.Fields;
    }
    this.resolveSetup();
  }
  // ---------------------------------------------------------------------------------------------
  // Data Props
  // ---------------------------------------------------------------------------------------------
  /**
   * Gets the category field for the pie chart.
   * @returns {string}
   */
  getCategory() {
    return u(this._config);
  }
  /**
   * Sets the category field for the pie chart.
   * @param {string} category The category field.
   * @async **This method is `async` and must be awaited for the changes to take effect.**
   */
  async setCategory(e) {
    (!N(this._config) || e.trim() !== "") && (await W({
      newCategory: e,
      config: this._config,
      layerInfo: this.layerInfo,
      mode: this._mode
    }), this.dispatchEvent(new CustomEvent("arcgisChartsModelDataChange")), this.emitConfigUpdate("setCategory"));
  }
  /**
   * Gets the numeric fields for the pie chart.
   * @returns {string[]}
   */
  getNumericFields() {
    return B(this._config);
  }
  /**
   * Sets the numeric field or numeric fields array for the pie chart.
   * @param {string[]} numericFields The numeric field or numeric fields array.
   * @async **This method is `async` and must be awaited for the changes to take effect.**
   */
  async setNumericFields(e) {
    typeof e == "string" && (e = [e]), (this.layerInfo !== void 0 ? w(this.layerInfo.layerFieldsInfo, e) : !0) ? (await E({
      newNumericFields: e,
      config: this._config,
      layerInfo: this.layerInfo,
      mode: this._mode
    }), this.dispatchEvent(new CustomEvent("arcgisChartsModelDataChange")), this.emitConfigUpdate("setNumericFields")) : console.log("Invalid numericFields");
  }
  /**
   * Gets the aggregation type for the pie chart.
   * @returns {WebChartStatisticType}
   */
  getAggregationType() {
    return R(this._config, this._mode);
  }
  /**
   * Sets the aggregation type for the pie chart.
   * @param {WebChartStatisticType} aggregationType The aggregation type. Must be one of the values allowed by `WebChartStatisticType`.
   * @async **This method is `async` and must be awaited for the changes to take effect.**
   */
  async setAggregationType(e) {
    await K({
      newAggregationType: e,
      config: this._config,
      layerInfo: this.layerInfo,
      mode: this._mode
    }), this.dispatchEvent(new CustomEvent("arcgisChartsModelDataChange")), this.emitConfigUpdate("setAggregationType");
  }
  /**
   * Gets the sort order for the pie chart.
   * @returns {PieChartDataSortingKinds}
   */
  getSortOrder() {
    return j(this._config, this._mode);
  }
  /**
   * Sets the sort order for the pie chart.
   * @param {PieChartDataSortingKinds} sortOrder The sort order.
   */
  setSortOrder(e, t) {
    q({
      newSortOrderKind: e,
      config: this._config,
      orderByList: t
    }), this.emitConfigUpdate("setSortOrder");
  }
  /* Gets the list of category's values for custom sort
   * @returns {string[]}
   */
  getOrderByList() {
    return m(this._config, this._mode);
  }
  /**
   * Sets the list of category's values for custom sort
   * @param {string[]} orderByList The list of category's values
   */
  setOrderByList(e) {
    y({
      values: e,
      config: this._config,
      mode: this._mode
    }), this.emitConfigUpdate("setOrderByList");
  }
  /**
   * Gets the pie chart data mode (Category or Fields).
   *
   * `category` - The chart is using values from the category field to determine each slice.
   *
   * `fields` - The chart is using aggregated values from the numeric fields to determine each slice.
   *
   * @returns {PieChartDataModes}
   */
  getMode() {
    return this._mode;
  }
  /**
   * Sets the pie chart data mode (Category or Fields).
   *
   * `category` - The chart should use values from the category field to determine each slice.
   *
   * `fields` - The chart should use aggregated values from the numeric fields to determine each slice.
   *
   * @param {PieChartDataModes} mode The mode.
   * @async **This method is `async` and must be awaited for the changes to take effect.**
   */
  setMode(e) {
    this._mode = e, this.emitConfigUpdate("setMode");
  }
  /**
   * Gets the list of the category values for the chart.
   * @returns {string[]}
   */
  async getCustomSortValues() {
    const e = u(this._config), t = p(this._config.series), s = this.getNumericFields();
    let a = [];
    return t === g.PieFromFields ? a = s : e.trim() !== "" && t === g.PieFromCategory && (a = await z({
      category: e,
      config: this._config,
      layerInfo: this.layerInfo
    })), a;
  }
  /**
   * Moves the custom sort values in-place for the order by list in the config.
   *
   * NOTE: This method should be only used when the sort order is set to `customSort`.
   * @param {number} fromIndex The index to move the custom sort item from.
   * @param {number} toIndex The index to move the category item to.
   */
  moveCustomSortValuesInOrderByList(e, t) {
    const s = m(this._config, this._mode), [a] = s.splice(e, 1);
    s.splice(t, 0, a), y({
      values: s,
      config: this._config,
      mode: this._mode
    }), this.emitConfigUpdate("moveCustomSortValuesInOrderByList");
  }
  // ---------------------------------------------------------------------------------------------
  // Format Props
  // ---------------------------------------------------------------------------------------------
  /**
   * Gets the symbol for the ticks connecting the slices to the labels.
   * @returns {ISimpleLineSymbol | undefined}
   */
  getTicksSymbol() {
    return ve(this._config);
  }
  /**
   * Sets the symbol for the ticks connecting the slices to the labels.
   * @param {ISimpleLineSymbol | undefined} lineSymbol The ticks symbol.
   */
  setTicksSymbol(e) {
    xe(e, this._config), this.emitConfigUpdate("setTicksSymbol");
  }
  // ---------------------------------------------------------------------------------------------
  // Slices Props
  // ---------------------------------------------------------------------------------------------
  /**
   * Gets the array of slices for the pie chart.
   * @returns {WebChartPieChartSlice[] | undefined}
   */
  getSlices() {
    return ze(this._config);
  }
  /**
   * Sets the array of slices for the pie chart.
   * @param {WebChartPieChartSlice[] | undefined} slices The slices array.
   */
  setSlices(e) {
    I(e, this._config), this.emitConfigUpdate("setSlices");
  }
  /**
   * Gets the array of grouped slice ids for the pie chart.
   * @returns {string[]}
   */
  getGroupedSliceIds() {
    return this._groupedSliceIds;
  }
  /**
   * Sets the array of grouped slice ids for the pie chart.
   * @param {string[]} groupedSliceIds The grouped slice ids array.
   */
  setGroupedSliceIds(e) {
    this._groupedSliceIds = e, this.emitConfigUpdate("setGroupedSliceIds");
  }
  /**
   * Gets the slice grouping configuration for the pie chart.
   * @returns {WebChartPieChartGroupSlice | undefined}
   */
  getSliceGrouping() {
    return ke(this._config);
  }
  /**
   * Sets the slice grouping configuration for the pie chart.
   * @param {WebChartPieChartGroupSlice | undefined} sliceGrouping The slice grouping configuration.
   */
  setSliceGrouping(e) {
    T(e, this._config), this.emitConfigUpdate("setSliceGrouping");
  }
  /**
   * Gets the inner radius size for the pie chart.
   * @returns {number}
   */
  getInnerRadiusSize() {
    return $(this._config) ?? 0;
  }
  /**
   * Sets the inner radius size for the pie chart.
   * @param {number} size The inner radius size.
   */
  setInnerRadiusSize(e) {
    ee(e, this._config), this.emitConfigUpdate("setInnerRadiusSize");
  }
  /**
   * Gets the threshold below which slices will be grouped.
   * @returns {number}
   */
  getGroupingThreshold() {
    return V(this._config) ?? 0;
  }
  /**
   * Sets the threshold below which slices will be grouped.
   * @param {number} threshold The grouping threshold.
   */
  setGroupingThreshold(e) {
    we(e, this._config), this.emitConfigUpdate("setGroupingThreshold");
  }
  /**
   * Gets the character limit for the slice labels.
   * @returns {number | null}
   */
  getLabelCharacterLimit() {
    return ie(this._config) ?? null;
  }
  /**
   * Sets the character limit for the slice labels.
   * @param {number | null} limit The label character limit.
   */
  setLabelCharacterLimit(e) {
    te(e, this._config), this.emitConfigUpdate("setLabelCharacterLimit");
  }
  /**
   * Gets the number of decimal places to display in the slice values.
   * @returns {number}
   */
  getDecimalPlaces() {
    return Oe(this._config) ?? 1;
  }
  /**
   * Sets the number of decimal places to display in the slice values.
   * @param {number} decimalPlaces The decimal places.
   */
  setDecimalPlaces(e) {
    Le(e, this._config), this.emitConfigUpdate("setDecimalPlaces");
  }
  /**
   * Gets the display type for the pie chart slices. Specifies whether to display the slices as a percentage, value, or both.
   * @returns {PieChartSlicesDisplay}
   */
  getDisplayType() {
    return ue(this._config);
  }
  /**
   * Sets the display type for the pie chart slices. Specifies whether to display the slices as a percentage, value, or both.
   * @param {PieChartSlicesDisplay} displayType The display type.
   */
  setDisplayType(e) {
    me(e, this._config), this.emitConfigUpdate("setDisplayType");
  }
  // ---------------------------------------------------------------------------------------------
  // Protected methods
  // ---------------------------------------------------------------------------------------------
  async generateDefaultConfig() {
    const e = await U();
    return e.series = [await F(this.layerInfo?.objectIdField)], e;
  }
  // ---------------------------------------------------------------------------------------------
  // Series Methods
  // ---------------------------------------------------------------------------------------------
  /**
   * Gets the original name of the slice based on the slice index.
   * @returns {Date | number | string | null | undefined}
   */
  getOriginalSliceName(e) {
    return Ne(e, this._config);
  }
  /**
   * Gets the name of the slice based on the slice index. If the index is out of bounds, this function will return `undefined`.
   * @param {number} sliceIndex The index of the slice.
   * @returns {string | undefined}
   */
  getSliceName(e) {
    return Ue(e, this._config);
  }
  /**
   * Sets name of the slice based on the slice index.
   * @param {string} name The name for the slice.
   * @param {number} sliceIndex The index of the slice.
   */
  setSliceName(e, t) {
    Fe(e, t, this._config), this.emitConfigUpdate("setSliceName");
  }
  /**
   * Gets the color of the slice based on the slice index. If the index is out of bounds, this function will return `undefined`.
   * @param {number} sliceIndex The index of the slice.
   * @returns {Color | undefined}
   */
  getSliceColor(e) {
    return Me(e, this._config);
  }
  /**
   * Sets the color of the slice based on the slice index.
   * @param {Color | undefined} color The color for the slice.
   * @param {number} sliceIndex The index of the slice.
   */
  setSliceColor(e, t) {
    Ge(e, t, this._config), this.emitConfigUpdate("setSliceColor");
  }
  /**
   * Gets the order of the slice array by returning an array of slice ids
   * @returns {string[] | undefined}
   */
  getOrderOfSlices() {
    return Ae(this._config);
  }
  /**
   * Sets the order of the slices array by providing an array of slice ids.
   * @param {string[]} order The order of the slices.
   */
  setOrderOfSlices(e) {
    _(e, this._config), this.emitConfigUpdate("setOrderOfSlices");
  }
  /**
   * Moves a series from one index in the series array to another.
   * @param {number} fromIndex Index to move the series from.
   * @param {number} toIndex Index to move the series to.
   */
  moveSeries(e, t) {
    const s = this.getOrderOfSlices();
    if (s !== void 0) {
      const [a] = s.splice(e, 1);
      s.splice(t, 0, a), _(s, this._config), this.emitConfigUpdate("moveSeries");
    }
  }
  /**
   * Gets the slice id for a given slice index. If the index is out of bounds, this function will return `undefined`.
   * @param {number} sliceIndex The index of the slice.
   * @returns {string | undefined}
   */
  getSliceId(e) {
    return Be(e, this._config);
  }
  /**
   * Gets the slice index for a given slice id. If the `sliceId` is not found, this function will return `undefined`.
   * @param {string} sliceId The id of the slice.
   * @returns {number | undefined}
   */
  getSliceIndex(e) {
    return Ee(e, this._config);
  }
  /**
   * Gets the length of the slices array.
   * @returns {number}
   */
  getSlicesLength() {
    return Re(this._config);
  }
  /**
   * Resets the slices styling to the default styling.
   */
  resetSlices() {
    We(this._config), this.emitConfigUpdate("resetSlices");
  }
  /**
   * Returns whether the series styling is able to be reset.
   * @returns {boolean}
   */
  resetAvailable() {
    const e = !this.getColorMatch();
    let t = !1;
    const s = this.getSlices()?.length ?? 0;
    for (let n = 0; n < s; n += 1) {
      const f = this.getOriginalSliceName(n), v = this.getSliceName(n);
      if (f !== void 0 && f?.toString() !== v?.toString()) {
        t = !0;
        break;
      }
    }
    const a = this.getSliceGrouping();
    return a?.originalLabel !== void 0 && a?.label !== a.originalLabel && (t = !0), e || t;
  }
  /**
   * Gets the visibility of the ticks.
   * @returns {boolean}
   */
  getTicksVisibility() {
    return Ve(this._config);
  }
  /**
   * Sets the visibility of the ticks.
   * @param visibility The visibility setting for the ticks.
   */
  setTicksVisibility(e) {
    Ie(e, this._config), this.emitConfigUpdate("setTicksVisibility");
  }
  /**
   * Gets the start angle of the pie chart.
   * @returns {number | null | undefined}
   */
  getStartAngle() {
    return S(this._config);
  }
  /**
   * Sets the start angle for the pie chart.
   * @param angle The start angle for the pie chart.
   */
  setStartAngle(e) {
    C(e, this._config), this.emitConfigUpdate("setStartAngle");
  }
  /**
   * Gets the end angle of the pie chart.
   * @returns {number | null | undefined}
   */
  getEndAngle() {
    return S(this._config);
  }
  /**
   * Sets the end angle for the pie chart.
   * @param angle The end angle for the pie chart.
   */
  setEndAngle(e) {
    C(e, this._config), this.emitConfigUpdate("setEndAngle");
  }
  /**
   * Gets the display category value on tooltip setting from the chart config.
   * @returns {boolean}
   * @remarks If the setting is not found in the config, it will default to `true`.
   */
  getDisplayCategoryValueOnTooltip() {
    return se(this._config);
  }
  /**
   * Gets the display numeric value on tooltip setting from the chart config.
   * @returns {boolean}
   * @remarks If the setting is not found in the config, it will default to `true`.
   */
  getDisplayNumericValueOnTooltip() {
    return ae(this._config);
  }
  /**
   * Sets the display category value on tooltip setting in the chart config.
   * @param display The boolean value to set the displayCategoryOnTooltip to
   */
  setDisplayCategoryOnTooltip(e) {
    this._config.series[0].displayCategoryOnTooltip = e, this.emitConfigUpdate("setDisplayCategoryValue");
  }
  /**
   * Sets the display numeric value on tooltip setting in the chart config.
   * @param display The boolean value to set the displayNumericValueOnTooltip to
   */
  setDisplayNumericValueOnTooltip(e) {
    this._config.series[0].displayNumericValueOnTooltip = e, this.emitConfigUpdate("setDisplayNumericValue");
  }
  /**
   * Gets the display percentage on tooltip setting from the chart config.
   * @returns {boolean}
   * @remarks If the setting is not found in the config, it will default to `true`.
   */
  getDisplayPercentageOnTooltip() {
    return re(this._config);
  }
  /**
   * Sets the display percentage on tooltip setting in the chart config.
   * @param display The boolean value to set the displayPercentageOnTooltip to
   */
  setDisplayPercentageOnTooltip(e) {
    ne(e, this._config), this.emitConfigUpdate("setDisplayPercentage");
  }
  /**
   * Gets the prefix of the values of the slices.
   * @returns {string | undefined}
   */
  getValuePrefix() {
    return oe(this._config);
  }
  /**
   * Sets the prefix for the values of the slices.
   * @param prefix The prefix for the values of the slices.
   */
  setValuePrefix(e) {
    le(e, this._config), this.emitConfigUpdate("setValuePrefix");
  }
  /**
   * Gets the suffix of the values of the slice.
   * @returns {string | undefined}
   */
  getValueSuffix() {
    return ge(this._config);
  }
  /**
   * Sets the suffix for the values of the slices.
   * @param suffix The suffix for the values of the slices.
   */
  setValueSuffix(e) {
    ce(e, this._config), this.emitConfigUpdate("setValueSuffix");
  }
  /**
   * Gets the prefix of the percentages of the slices.
   * @returns {string | undefined}
   */
  getPercentagePrefix() {
    return de(this._config);
  }
  /**
   * Sets the prefix for the percentages of the slices.
   * @param prefix The prefix for the percentages of the slices.
   */
  setPercentagePrefix(e) {
    fe(e, this._config), this.emitConfigUpdate("setPercentagePrefix");
  }
  /**
   * Gets the suffix of the percentages of the slices.
   * @returns {string | undefined}
   */
  getPercentageSuffix() {
    return he(this._config);
  }
  /**
   * Sets the suffix for the percentages of the slices.
   * @param suffix The suffix for the percentages of the slices.
   */
  setPercentageSuffix(e) {
    pe(e, this._config), this.emitConfigUpdate("setPercentageSuffix");
  }
  /**
   * Gets the offset for the data labels.
   * @returns {string | undefined}
   */
  getDataLabelsOffset() {
    return be(this._config);
  }
  /**
   * Sets the offset for the data labels.
   * @param offset The offset for the data labels.
   */
  setDataLabelsOffset(e) {
    De(e, this._config), this.emitConfigUpdate("setDataLabelsOffset");
  }
  /**
   * Gets the align data labels setting for the pie chart.
   * @returns {boolean | undefined}
   */
  getAlignDataLabels() {
    return ye(this._config);
  }
  /**
   * Sets the align data labels setting for the pie chart.
   * @param align The align data labels setting for the pie chart.
   */
  setAlignDataLabels(e) {
    Se(e, this._config), this.emitConfigUpdate("setAlignDataLabels");
  }
  /**
   * Gets the setting for placing the data labels inside of the slices.
   * @returns {boolean | undefined}
   */
  getDataLabelsInside() {
    return Ce(this._config);
  }
  /**
   * Sets the setting for placing the data labels inside of the slices.
   * @param inside Whether to place the data labels inside of the slices
   */
  setDataLabelsInside(e) {
    _e(e, this._config), this.emitConfigUpdate("setDataLabelsInside");
  }
  /**
   * Gets the optimize data labels overlapping setting for the pie chart.
   * @returns {boolean | undefined}
   */
  getOptimizeDataLabelsOverlapping() {
    return Pe(this._config);
  }
  /**
   * Sets the optimize data labels overlapping setting for the pie chart.
   * @param optimize The optimize data labels overlapping setting for the pie chart.
   */
  setOptimizeDataLabelsOverlapping(e) {
    Te(e, this._config), this.emitConfigUpdate("setOptimizeDataLabelsOverlapping");
  }
}
L(Ke, [P, G, A, k]);
export {
  Ke as PieChartModel
};
