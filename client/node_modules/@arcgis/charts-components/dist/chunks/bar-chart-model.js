import { WebChartTypes as n } from "@arcgis/charts-spec";
import "lodash-es";
import "d3-array";
import { ay as d, ar as l, Y as c, P as f } from "./interfaces.js";
import "@arcgis/core/geometry/support/jsonUtils.js";
import "@arcgis/core/rest/support/AttributeBinsQuery.js";
import "@arcgis/core/rest/support/Query.js";
import "@arcgis/core/rest/support/StatisticDefinition.js";
import "@arcgis/core/time/TimeExtent.js";
import "@arcgis/core/core/promiseUtils.js";
import "@arcgis/core/request.js";
import { S as g, s as h, a as S } from "./serial-chart-model.js";
import { f as m, e as o } from "./data.js";
import { g as p, s as y, a as u, b } from "./bar-chart-series.js";
/*! All material copyright Esri, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.33/esri/copyright.txt for details.
v4.33.19 */
class M extends g {
  constructor() {
    super(...arguments), this._chartType = n.BarSeries;
  }
  async setup(e) {
    await this.loadConfigFromLayer(e), this.commonStrings = await m(), e.config !== void 0 && await this.updateSeriesFromLayerFilter(), this.resolveSetup();
  }
  // ---------------------------------------------------------------------------------------------
  // Protected Methods
  // ---------------------------------------------------------------------------------------------
  async generateDefaultConfig() {
    const e = await d();
    return e.series = [
      await l({
        objectIDField: this.layerInfo?.objectIdField
      })
    ], e;
  }
  // ---------------------------------------------------------------------------------------------
  // Series Methods
  // ---------------------------------------------------------------------------------------------
  /**
   * Gets whether to hide oversized data labels of the side-by-side series based on the series index. If the index is out of bounds, it will return `undefined`.
   * @param {number} seriesIndex The index of the series.
   * @returns {boolean | undefined}
   */
  getSeriesHideOversizedSideBySideLabels(e) {
    return p(e, this._config);
  }
  /**
   * Sets whether to hide oversized data labels of the side-by-side series based on the series index.
   * @param {boolean} hide The value for hiding oversized data labels.
   * @param {number} seriesIndex The index of the series.
   */
  setSeriesHideOversizedSideBySideLabels(e, i) {
    y(e, i, this._config), this.emitConfigUpdate("setSeriesHideOversizedSideBySideLabels");
  }
  /**
   * Gets whether to hide oversized stacked labels of the series based on the series index. If the index is out of bounds, it will return `undefined`.
   * @param {number} seriesIndex The index of the series.
   * @returns {boolean | undefined}
   */
  getSeriesHideOversizedStackedLabels(e) {
    return u(e, this._config);
  }
  /**
   * Sets whether to hide oversized stacked labels of the series based on the series index.
   * @param {boolean} hide The value for hiding oversized stacked labels.
   * @param {number} seriesIndex The index of the series.
   */
  setSeriesHideOversizedStackedLabels(e, i) {
    b(e, i, this._config), this.emitConfigUpdate("setSeriesHideOversizedStackedLabels");
  }
  /**
   * Resets the series styling to the default styling.
   */
  resetSeriesStyling() {
    const e = this.getSeriesLength();
    for (let i = 0; i < e; i += 1) {
      const r = this.getSeriesId(i), t = c({
        colorIndex: i,
        opacity: f
      });
      if (h(t, i, this._config), this.layerInfo !== void 0) {
        const s = o({
          config: this._config,
          seriesIndex: i,
          layerInfo: this.layerInfo,
          commonStrings: this.commonStrings
        });
        s !== this.layerInfo.objectIdField && S(s ?? r, i, this._config);
      }
    }
    this._config.colorMatch = !0, this.emitConfigUpdate("resetSeriesStyling");
  }
  /**
   * Returns whether the series styling is able to be reset.
   * @returns {boolean}
   */
  resetAvailable() {
    const e = !this.getColorMatch();
    let i = !1;
    if (!e && this.layerInfo !== void 0) {
      const r = this.getSeriesLength();
      for (let t = 0; t < r; t += 1) {
        const s = o({
          config: this._config,
          seriesIndex: t,
          layerInfo: this.layerInfo,
          commonStrings: this.commonStrings
        }), a = this.getSeriesName(t);
        if (s !== void 0 && s !== this.layerInfo.objectIdField && s !== a) {
          i = !0;
          break;
        }
      }
    }
    return e || i;
  }
}
export {
  M as BarChartModel
};
