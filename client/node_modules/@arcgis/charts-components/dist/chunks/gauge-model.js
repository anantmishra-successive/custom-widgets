import { WebChartTypes as h, GaugeChartSubTypes as b, WebChartStatisticType as u } from "@arcgis/charts-spec";
import "lodash-es";
import "d3-array";
import { am as a, a2 as f, aw as y, aD as x } from "./interfaces.js";
import "@arcgis/core/geometry/support/jsonUtils.js";
import "@arcgis/core/rest/support/AttributeBinsQuery.js";
import "@arcgis/core/rest/support/Query.js";
import "@arcgis/core/rest/support/StatisticDefinition.js";
import "@arcgis/core/time/TimeExtent.js";
import "@arcgis/core/core/promiseUtils.js";
import "@arcgis/core/request.js";
import { C as m, c as C, b as I } from "./model-with-y-guides.js";
import { g as _, h as v } from "./data.js";
/*! All material copyright Esri, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.33/esri/copyright.txt for details.
v4.33.19 */
const L = (t) => t.axes[0].needle?.visible ?? !0, S = (t, e) => {
  e.axes[0].needle === void 0 && (e.axes[0].needle = a()), e.axes[0].needle.visible = t;
}, A = (t) => t.axes[0].needle?.symbol, N = (t, e) => {
  e.axes[0].needle === void 0 && (e.axes[0].needle = a()), e.axes[0].needle.symbol = t;
}, T = (t) => t.axes[0].needle?.startWidth, F = (t, e) => {
  e.axes[0].needle === void 0 && (e.axes[0].needle = a()), e.axes[0].needle.startWidth = t;
}, w = (t) => t.axes[0].needle?.endWidth, V = (t, e) => {
  e.axes[0].needle === void 0 && (e.axes[0].needle = a()), e.axes[0].needle.endWidth = t;
}, E = (t) => t.axes[0].needle?.innerRadius, U = (t, e) => {
  e.axes[0].needle === void 0 && (e.axes[0].needle = a()), e.axes[0].needle.innerRadius = t;
}, W = (t) => t.axes[0].needle?.displayPin ?? !1, D = (t, e) => {
  e.axes[0].needle === void 0 && (e.axes[0].needle = a()), e.axes[0].needle.displayPin = t;
}, M = (t) => t.axes[0].innerLabel?.visible ?? !0, R = (t, e) => {
  e.axes[0].innerLabel === void 0 && (e.axes[0].innerLabel = f()), e.axes[0].innerLabel.visible = t;
}, G = (t) => t.axes[0].innerLabel?.content, k = (t, e) => {
  e.axes[0].innerLabel === void 0 && (e.axes[0].innerLabel = f()), t !== void 0 && (e.axes[0].innerLabel.content = t);
}, P = (t) => t.axes[0].ticks?.visible ?? !0, $ = (t, e) => {
  e.axes[0].ticks === void 0 && (e.axes[0].ticks = {
    type: h.GaugeAxisTick
  }), e.axes[0].ticks.visible = t;
}, O = (t) => t.axes[0].labelsIncrement, q = (t, e) => {
  e.axes[0].labelsIncrement = t;
}, j = (t) => t.axes[0].onlyShowFirstAndLastLabels ?? !1, X = (t, e) => {
  e.axes[0].onlyShowFirstAndLastLabels = t;
}, B = (t) => t.series[0]?.valueConversion, Q = (t, e) => {
  e.series[0] !== void 0 && (e.series[0].valueConversion = t);
}, p = (t) => t.series[0]?.featureIndex, c = async (t, e, i) => {
  const s = g(e), n = o(e);
  t === null ? delete e.series[0].featureIndex : e.series[0] !== void 0 && (e.series[0].featureIndex = t), await r({ config: e, layerInfo: i, field: s, aggregationType: n });
}, Y = (t) => t.subType ?? b.StatisticGauge, z = (t) => {
  const { config: e, field: i, aggregationType: s } = t;
  if (s !== u.NoAggregation) {
    const n = p(e), l = d(n) ? {} : {
      outStatistics: [
        {
          statisticType: s,
          onStatisticField: i,
          outStatisticFieldName: `${s}_${i}`
        }
      ]
    };
    e.series[0].query = l;
  }
}, H = async (t) => {
  const { config: e, layerInfo: i, field: s, aggregationType: n } = t;
  e.title && (e.title.content.text = await _({
    config: e,
    layerInfo: i,
    numericFields: [s],
    aggregationType: n
  }));
}, r = async (t) => {
  const { config: e, field: i, aggregationType: s } = t;
  e.series[0] === void 0 && (e.series = [y({})]);
  const n = d(e.series[0]?.featureIndex);
  let l = n ? i : `${s}_${i}`;
  n && i.startsWith(`${s}_`) && (l = i.replace(`${s}_`, "")), e.series[0].x = l, z({ config: e, field: i, aggregationType: s }), await H(t);
}, o = (t) => t.series[0]?.query?.outStatistics?.[0]?.statisticType ?? u.Count, J = async (t, e, i) => {
  const s = g(e);
  await r({
    config: e,
    layerInfo: i,
    field: s,
    aggregationType: t
  });
}, d = (t) => typeof t == "number" && t >= 0, g = (t) => d(t.series[0]?.featureIndex) ? t.series[0]?.x : t.series[0]?.query?.outStatistics?.[0]?.onStatisticField ?? "", K = async (t, e, i) => {
  const s = o(e);
  await r({ config: e, layerInfo: i, field: t, aggregationType: s });
}, Z = (t) => t.innerRadius ?? 50, ee = (t, e) => {
  e.innerRadius = t;
}, te = (t) => t.startAngle ?? -90, ie = (t, e) => {
  e.startAngle = t;
}, se = (t) => t.endAngle ?? 270, ne = (t, e) => {
  e.endAngle = t;
};
class ae extends m {
  constructor() {
    super(...arguments), this._chartType = h.GaugeSeries;
  }
  async setup(e) {
    await this.loadConfigFromLayer(e), this.resolveSetup();
  }
  // ---------------------------------------------------------------------------------------------
  // Data Props
  // ---------------------------------------------------------------------------------------------
  /**
   * Gets the data field used for the gauge.
   * @returns {string}
   */
  getField() {
    return g(this._config);
  }
  /**
   * Sets the data field used for the gauge.
   * @param {string} field The field to set.
   * @async **This method is `async` and must be awaited for the changes to take effect.**
   */
  async setField(e) {
    await K(e, this._config, this.layerInfo), this.dispatchEvent(new CustomEvent("arcgisChartsModelDataChange")), this.emitConfigUpdate("setField");
  }
  /**
   * Gets the aggregation type used for the gauge.
   * @returns {WebChartStatisticType}
   */
  getAggregationType() {
    return o(this._config);
  }
  /**
   * Sets the aggregation type used for the gauge.
   * @param {WebChartStatisticType} aggregationType The aggregation type to set. Must be one of the values allowed by `WebChartStatisticType`, excluding `"no_aggregation"`.
   * @async **This method is `async` and must be awaited for the changes to take effect.**
   */
  async setAggregationType(e) {
    await J(e, this._config, this.layerInfo), this.dispatchEvent(new CustomEvent("arcgisChartsModelDataChange")), this.emitConfigUpdate("setAggregationType");
  }
  /**
   * Gets the inner radius of the gauge.
   * @returns {number}
   */
  getInnerRadius() {
    return Z(this._config);
  }
  /**
   * Sets the inner radius of the gauge.
   * @param {number} innerRadius The inner radius to set.
   */
  setInnerRadius(e) {
    ee(e, this._config), this.dispatchEvent(new CustomEvent("arcgisChartsModelDataChange")), this.emitConfigUpdate("setInnerRadius");
  }
  /**
   * Gets the start angle of the gauge.
   * @returns {number}
   */
  getStartAngle() {
    return te(this._config);
  }
  /**
   * Sets the start angle of the gauge.
   * @param {number} startAngle The start angle to set.
   */
  setStartAngle(e) {
    ie(e, this._config), this.dispatchEvent(new CustomEvent("arcgisChartsModelDataChange")), this.emitConfigUpdate("setStartAngle");
  }
  /**
   * Gets the end angle of the gauge.
   * @returns {number}
   */
  getEndAngle() {
    return se(this._config);
  }
  /**
   * Sets the end angle of the gauge.
   * @param {number} endAngle The end angle to set.
   */
  setEndAngle(e) {
    ne(e, this._config), this.dispatchEvent(new CustomEvent("arcgisChartsModelDataChange")), this.emitConfigUpdate("setEndAngle");
  }
  // ---------------------------------------------------------------------------------------------
  // Series Props
  // ---------------------------------------------------------------------------------------------
  /**
   * Gets the conversion to apply to the gauge value
   *
   * @returns {ValueConversion | undefined}
   */
  getValueConversion() {
    return B(this._config);
  }
  /**
   * Sets the conversion to apply to the gauge value
   * @param {ValueConversion} valueConversion The conversion to apply
   */
  setValueConversion(e) {
    Q(e, this._config), this.emitConfigUpdate("setValueConversion");
  }
  /**
   * Gets the index of the feature to be rendered.
   * @returns {number | undefined}
   * @remarks
   * This property will be ignored for a statistic gauge (indicated via `WebGaugeChart.subType` property).
   * For feature-based gauge, if this property is not present, the first feature will be used (featureIndex = 0)
   */
  getFeatureIndex() {
    return p(this._config);
  }
  /**
   * Sets the index of the feature to be rendered.
   * @param {number | null} featureIndex The index of the feature to be rendered
   * @remarks This property will be ignored for a statistic gauge (indicated via `WebGaugeChart.subType` property).
   * For feature-based gauge, if this property is not present, the first feature will be used (featureIndex = 0)
   */
  async setFeatureIndex(e) {
    await c(e, this._config, this.layerInfo), this.emitConfigUpdate("setFeatureIndex");
  }
  /**
   * Removes the existing feature index from the config object
   */
  removeFeatureIndex() {
    c(null, this._config, this.layerInfo), this.emitConfigUpdate("removeFeatureIndex");
  }
  /**
   * Gets the type of Gauge chart, like FeatureGauge and StatisticGauge.
   * @returns {GaugeChartSubTypes}
   * @remarks When this property is not specified, it will be defaulted to GaugeChartSubTypes.StatisticGauge.
   */
  getGaugeSubType() {
    return Y(this._config);
  }
  // ---------------------------------------------------------------------------------------------
  // Axes Props
  // ---------------------------------------------------------------------------------------------
  /**
   * Gets the visibility of the gauge's needle.
   * @returns {boolean}
   */
  getNeedleVisibility() {
    return L(this._config);
  }
  /**
   * Sets the visibility of the gauge's needle.
   * @param {boolean} visible The visibility to set.
   */
  setNeedleVisibility(e) {
    S(e, this._config), this.emitConfigUpdate("setNeedleVisibility");
  }
  /**
   * Gets the symbol of the gauge's needle.
   * @returns {ISimpleFillSymbol | undefined}
   */
  getNeedleSymbol() {
    return A(this._config);
  }
  /**
   * Sets the symbol of the gauge's needle.
   * @param {ISimpleFillSymbol | undefined} needleSymbol The needle symbol to set.
   */
  setNeedleSymbol(e) {
    N(e, this._config), this.emitConfigUpdate("setNeedleSymbol");
  }
  /**
   * Gets the start width of the gauge's needle.
   * @returns {number | null | undefined}
   */
  getNeedleStartWidth() {
    return T(this._config);
  }
  /**
   * Sets the start width of the gauge's needle.
   * @param {number | null | undefined} width The start width to set.
   */
  setNeedleStartWidth(e) {
    F(e, this._config), this.emitConfigUpdate("setNeedleStartWidth");
  }
  /**
   * Gets the end width of the gauge's needle.
   * @returns {number | null | undefined}
   */
  getNeedleEndWidth() {
    return w(this._config);
  }
  /**
   * Sets the end width of the gauge's needle.
   * @param {number | null | undefined} width The end width to set.
   */
  setNeedleEndWidth(e) {
    V(e, this._config), this.emitConfigUpdate("setNeedleEndWidth");
  }
  /**
   * Gets the inner radius of the gauge's needle.
   * @returns {number | null | undefined}
   */
  getNeedleInnerRadius() {
    return E(this._config);
  }
  /**
   * Sets the inner radius of the gauge's needle.
   * @param {number | null | undefined} innerRadius The inner radius to set.
   */
  setNeedleInnerRadius(e) {
    U(e, this._config), this.emitConfigUpdate("setNeedleInnerRadius");
  }
  /**
   * Gets whether to display the pin for the gauge's needle.
   * @returns {boolean}
   */
  getNeedleDisplayPin() {
    return W(this._config);
  }
  /**
   * Sets whether to display the pin for the gauge's needle.
   * @param {boolean} displayPin The display pin state.
   */
  setNeedleDisplayPin(e) {
    D(e, this._config), this.emitConfigUpdate("setNeedleDisplayPin");
  }
  /**
   * Gets whether the inner label is visible.
   * @returns {boolean}
   */
  getInnerLabelVisible() {
    return M(this._config);
  }
  /**
   * Sets whether the inner label is visible.
   * @param {boolean} visible The visibility state to set.
   */
  setInnerLabelVisibility(e) {
    R(e, this._config), this.emitConfigUpdate("setInnerLabelVisibility");
  }
  /**
   * Gets the inner label content symbol.
   * @returns {WebChartTextSymbol | undefined}
   */
  getInnerLabelContent() {
    return G(this._config);
  }
  /**
   * Sets the inner label content symbol.
   * @param {WebChartTextSymbol | undefined} innerLabelContent The content symbol to set.
   */
  setInnerLabelContent(e) {
    k(e, this._config), this.emitConfigUpdate("setInnerLabelContent");
  }
  /**
   * Gets whether the axis ticks are visible.
   * @returns {boolean}
   */
  getAxisTickVisibility() {
    return P(this._config);
  }
  /**
   * Sets whether the axis ticks are visible.
   * @param {boolean} visibile The visibility state to set.
   */
  setAxisTickVisibility(e) {
    $(e, this._config), this.emitConfigUpdate("setAxisTickVisibility");
  }
  /**
   * Gets the labels increment for the gauge.
   * @returns {number | undefined}
   */
  getLabelsIncrement() {
    return O(this._config);
  }
  /**
   * Sets the labels increment for the gauge.
   * @param {number | undefined} increment The increment to set.
   */
  setLabelsIncrement(e) {
    q(e, this._config), this.emitConfigUpdate("setLabelsIncrement");
  }
  /**
   * Gets whether to only show the first and last labels.
   * @returns {boolean}
   */
  getOnlyShowFirstAndLastLabels() {
    return j(this._config);
  }
  /**
   * Sets whether to only show the first and last axis labels.
   * @param {boolean} showOnlyFirstAndLastLabels Indicator of whether to only show the first and last axis labels
   */
  setOnlyShowFirstAndLastLabels(e) {
    X(e, this._config), this.emitConfigUpdate("setOnlyShowFirstAndLastLabels");
  }
  // ---------------------------------------------------------------------------------------------
  // Protected Methods
  // ---------------------------------------------------------------------------------------------
  async generateDefaultConfig() {
    const e = await x();
    return e.series = [y({ objectIDField: this.layerInfo?.objectIdField })], e;
  }
}
v(ae, [C, I]);
export {
  ae as GaugeModel
};
