/* Copyright (c) 2017-2018 Environmental Systems Research Institute, Inc.
 * Apache-2.0 */
import { request, cleanUrl, appendCustomParams } from "@esri/arcgis-rest-request";
/**
 * Get a feature by id.
 *
 * ```js
 * import { getFeature } from '@esri/arcgis-rest-feature-service';
 *
 * const url = "https://services.arcgis.com/V6ZHFr6zdgNZuVG0/arcgis/rest/services/Landscape_Trees/FeatureServer/0";
 *
 * getFeature({
 *   url,
 *   id: 42
 * }).then(feature => {
 *  console.log(feature.attributes.FID); // 42
 * });
 * ```
 *
 * @param requestOptions - Options for the request
 * @returns A Promise that will resolve with the feature or the [response](https://developer.mozilla.org/en-US/docs/Web/API/Response) itself if `rawResponse: true` was passed in.
 */
export function getFeature(requestOptions) {
    const url = `${cleanUrl(requestOptions.url)}/${requestOptions.id}`;
    // default to a GET request
    const options = Object.assign({ httpMethod: "GET" }, requestOptions);
    return request(url, options).then((response) => {
        if (options.rawResponse) {
            return response;
        }
        return response.feature;
    });
}
/**
 * Query a feature service. See [REST Documentation](https://developers.arcgis.com/rest/services-reference/query-feature-service-layer-.htm) for more information.
 *
 * ```js
 * import { queryFeatures } from '@esri/arcgis-rest-feature-service';
 *
 * queryFeatures({
 *   url: "http://sampleserver6.arcgisonline.com/arcgis/rest/services/Census/MapServer/3",
 *   where: "STATE_NAME = 'Alaska'"
 * })
 *   .then(result)
 * ```
 *
 * @param requestOptions - Options for the request
 * @returns A Promise that will resolve with the query response.
 */
export function queryFeatures(requestOptions) {
    const queryOptions = appendCustomParams(requestOptions, [
        "where",
        "objectIds",
        "relationParam",
        "time",
        "distance",
        "units",
        "outFields",
        "geometry",
        "geometryType",
        "spatialRel",
        "returnGeometry",
        "maxAllowableOffset",
        "geometryPrecision",
        "inSR",
        "outSR",
        "gdbVersion",
        "returnDistinctValues",
        "returnIdsOnly",
        "returnCountOnly",
        "returnExtentOnly",
        "orderByFields",
        "groupByFieldsForStatistics",
        "outStatistics",
        "returnZ",
        "returnM",
        "multipatchOption",
        "resultOffset",
        "resultRecordCount",
        "quantizationParameters",
        "returnCentroid",
        "resultType",
        "historicMoment",
        "returnTrueCurves",
        "sqlFormat",
        "returnExceededLimitFeatures",
        "f"
    ], {
        httpMethod: "GET",
        params: Object.assign({ 
            // set default query parameters
            where: "1=1", outFields: "*" }, requestOptions.params)
    });
    return request(`${cleanUrl(requestOptions.url)}/query`, queryOptions);
}
/**
 * Query a feature service to retrieve all features. See [REST Documentation](https://developers.arcgis.com/rest/services-reference/query-feature-service-layer-.htm) for more information.
 *
 * ```js
 * import { queryAllFeatures } from '@esri/arcgis-rest-feature-service';
 *
 * queryAllFeatures({
 *   url: "http://sampleserver6.arcgisonline.com/arcgis/rest/services/Census/MapServer/3",
 *   where: "STATE_NAME = 'Alaska'"
 * })
 *   .then(result)
 * ```
 *
 * @param requestOptions - Options for the request
 * @returns A Promise that will resolve with the query response.
 */
export async function queryAllFeatures(requestOptions) {
    var _a, _b;
    let offset = 0;
    let hasMore = true;
    let allFeaturesResponse = null;
    // retrieve the maxRecordCount for the service
    const pageSizeResponse = await request(requestOptions.url, {
        httpMethod: "GET"
    });
    // default the pageSize to 2000 if it is not provided
    const pageSize = pageSizeResponse.maxRecordCount || 2000;
    const userRecordCount = (_a = requestOptions.params) === null || _a === void 0 ? void 0 : _a.resultRecordCount;
    // use the user defined count only if it's less than or equal to the page size, otherwise use pageSize
    const recordCountToUse = userRecordCount && userRecordCount <= pageSize ? userRecordCount : pageSize;
    while (hasMore) {
        const pagedOptions = Object.assign(Object.assign({}, requestOptions), { params: Object.assign(Object.assign({ where: "1=1", outFields: "*" }, (requestOptions.params || {})), { resultOffset: offset, resultRecordCount: recordCountToUse }) });
        const queryOptions = appendCustomParams(pagedOptions, [
            "where",
            "objectIds",
            "relationParam",
            "time",
            "distance",
            "units",
            "outFields",
            "geometry",
            "geometryType",
            "spatialRel",
            "returnGeometry",
            "maxAllowableOffset",
            "geometryPrecision",
            "inSR",
            "outSR",
            "gdbVersion",
            "orderByFields",
            "groupByFieldsForStatistics",
            "outStatistics",
            "returnZ",
            "returnM",
            "multipatchOption",
            "resultOffset",
            "resultRecordCount",
            "quantizationParameters",
            "resultType",
            "historicMoment",
            "returnTrueCurves",
            "sqlFormat",
            "f"
        ], {
            httpMethod: "GET",
            params: Object.assign({ where: "1=1", outFields: "*", returnExceededLimitFeatures: true }, pagedOptions.params)
        });
        const response = await request(`${cleanUrl(requestOptions.url)}/query`, queryOptions);
        // save the first response structure
        if (!allFeaturesResponse) {
            allFeaturesResponse = Object.assign({}, response);
        }
        else {
            // append features of subsequent requests
            allFeaturesResponse.features = allFeaturesResponse.features.concat(response.features);
        }
        const returnedCount = response.features.length;
        // check if the response has exceededTransferLimit handles both the standard json and geojson responses
        const exceededTransferLimit = response.exceededTransferLimit ||
            ((_b = response.properties) === null || _b === void 0 ? void 0 : _b.exceededTransferLimit);
        // check if there are more features
        if (returnedCount < pageSize || !exceededTransferLimit) {
            hasMore = false;
        }
        else {
            offset += pageSize;
        }
    }
    return allFeaturesResponse;
}
//# sourceMappingURL=query.js.map