import { c as l } from "../../chunks/runtime.js";
import "@arcgis/charts-spec";
import { isEqual as o } from "lodash-es";
import "d3-array";
import { g as n, a_ as h, b1 as c, b2 as d } from "../../chunks/interfaces.js";
import "@arcgis/core/geometry/support/jsonUtils.js";
import "@arcgis/core/rest/support/AttributeBinsQuery.js";
import "@arcgis/core/rest/support/Query.js";
import "@arcgis/core/rest/support/StatisticDefinition.js";
import "@arcgis/core/time/TimeExtent.js";
import "@arcgis/core/core/promiseUtils.js";
import "@arcgis/core/request.js";
import { h as m } from "../../chunks/index4.js";
import { LitElement as g, createEvent as p } from "@arcgis/lumina";
import { html as a } from "lit";
import { C as s } from "../../chunks/interfaces2.js";
import { css as f } from "@lit/reactive-element/css-tag.js";
/*! All material copyright Esri, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.33/esri/copyright.txt for details.
v4.33.19 */
const C = f`:host{overflow-y:auto;overflow-x:hidden;margin-bottom:var(--arcgis-charts-intra-section-margin);margin-top:var(--arcgis-charts-intra-section-margin);height:100%}`;
class u extends g {
  constructor() {
    super(...arguments), this.popoverElement = null, this.onModelConfigChange = async (t) => {
      const i = t?.detail.config ?? this.model.getConfig();
      this.layer === void 0 && await this.updateFetchLayerFieldsInfo(i);
    }, this.activeColorMatch = !1, this.popoverPlacement = "leading", this.arcgisChartsConfigNoSeriesUpdate = p();
  }
  static {
    this.properties = { layerFieldsInfo: 16, activeColorMatch: 16, model: 0, timeZone: 3, popoverPlacement: 3, seriesColor: 2, calculatedDataMinMaxBounds: 0, calculatedMinMaxBounds: 2, page: 3, layer: 0, usePopupTemplateFieldsInfo: 5 };
  }
  static {
    this.styles = C;
  }
  async load() {
    this.layer !== void 0 && await this.layerChange(this.layer, void 0), this.seriesColor !== void 0 && this.seriesColorChange(this.seriesColor), this.usePopupTemplateFieldsInfo !== void 0 && await this.usePopupTemplateFieldsInfoChange(this.usePopupTemplateFieldsInfo, void 0), this.modelChange(this.model), this.onModelConfigChange();
  }
  async willUpdate(t) {
    t.has("model") && this.modelChange(this.model, t.get("model")), t.has("layer") && await this.layerChange(this.layer, t.get("layer")), t.has("usePopupTemplateFieldsInfo") && await this.usePopupTemplateFieldsInfoChange(this.usePopupTemplateFieldsInfo, t.get("usePopupTemplateFieldsInfo")), t.has("seriesColor") && this.seriesColorChange(this.seriesColor), this.layerFieldsInfo === void 0 && await this.updateFetchLayerFieldsInfo();
  }
  disconnectedCallback() {
    super.disconnectedCallback(), this.model.removeEventListener("arcgisChartsModelConfigChange", this.onModelConfigChange);
  }
  modelChange(t, e) {
    e?.removeEventListener("arcgisChartsModelConfigChange", this.onModelConfigChange), t?.addEventListener("arcgisChartsModelConfigChange", this.onModelConfigChange);
  }
  async layerChange(t, e) {
    t && !o(e, t) && await this.updateFetchLayerFieldsInfo();
  }
  async usePopupTemplateFieldsInfoChange(t, e) {
    t && t !== e && await this.updateFetchLayerFieldsInfo();
  }
  seriesColorChange(t) {
    this.activeColorMatch = t?.get(0)?.markerSymbol === void 0, this.model.getColorMatch() && t?.forEach((e, i) => {
      e && t?.get(0) !== void 0 && ("lineSymbol" in e && (e.lineSymbol?.color !== void 0 && !o(this.model.getSeriesColor(i), e.lineSymbol.color) && this.model.setSeriesColor(e.lineSymbol.color, i), e.lineSymbol?.style !== void 0 && !o(this.model.getSeriesLineStyle(i), e.lineSymbol.style) && this.model.setSeriesLineStyle(e.lineSymbol.style, i), e.lineSymbol?.width !== void 0 && !o(this.model.getSeriesLineWidth(i), e.lineSymbol.width) && this.model.setSeriesLineWidth(e.lineSymbol.width, i)), "markerSymbol" in e && (e.markerSymbol?.color !== void 0 && !o(this.model.getSeriesMarkerColor(i), e.markerSymbol?.color) && this.model.setSeriesMarkerColor(e.markerSymbol?.color, i), e.markerSymbol?.style !== void 0 && !o(this.model.getSeriesMarkerStyle(i), e.markerSymbol?.style) && this.model.setSeriesMarkerStyle(e.markerSymbol?.style, i), e.markerSymbol?.size !== void 0 && this.model.getSeriesMarkerSize(i) !== e.markerSymbol?.size && this.model.setSeriesMarkerSize(e.markerSymbol?.size, i)));
    });
  }
  async updateFetchLayerFieldsInfo(t) {
    const e = t ?? this.model.getConfig();
    let i = this.layer;
    if (!i) {
      const r = m(e) ? e.iLayer : void 0;
      r && (i = await n(r));
    }
    i && (this.layerFieldsInfo = await h(i, this.usePopupTemplateFieldsInfo));
  }
  popoverOpen(t) {
    const { open: e = !1, element: i = null } = { ...t.detail };
    e === !0 && this.popoverElement !== i ? (this.popoverElement !== null && (this.popoverElement.open = !1), this.popoverElement = i) : e === !1 && this.popoverElement === i && (this.popoverElement = null);
  }
  render() {
    const t = this.layerFieldsInfo?.find((r) => r.name === this.model.getXAxisField()), e = t !== void 0 && (c(t) || d(t));
    let i;
    switch (this.page) {
      case s.Data:
        i = a`<arcgis-charts-config-line-chart-data .model=${this.model} .resetTimeInterval=${this.model.resetTimeInterval} .layerFieldsInfo=${this.layerFieldsInfo}></arcgis-charts-config-line-chart-data>`;
        break;
      case s.Series:
        i = a`<arcgis-charts-config-line-chart-series .model=${this.model} .activeColorMatch=${this.activeColorMatch} .popoverPlacement=${this.popoverPlacement} @arcgisChartsConfigLineChartSeriesPopoverChange=${this.popoverOpen}></arcgis-charts-config-line-chart-series>`;
        break;
      case s.Axes:
        i = a`<arcgis-charts-config-axes .model=${this.model} show-min-y-bound-option show-max-y-bound-option show-enable-x-log-option show-enable-y-log-option .calculatedMinMaxBounds=${this.calculatedMinMaxBounds} .calculatedDataMinMaxBounds=${this.calculatedDataMinMaxBounds}></arcgis-charts-config-axes>`;
        break;
      case s.Guides:
        i = a`<arcgis-charts-config-guides .model=${this.model} .timeZone=${this.timeZone} .calculatedMinMaxBounds=${this.calculatedMinMaxBounds} .enableXAxisGuide=${e} enable-y-axis-guide @arcgisChartsConfigGuidePopoverChange=${this.popoverOpen}></arcgis-charts-config-guides>`;
        break;
      case s.Format:
        i = a`<arcgis-charts-config-format .model=${this.model} @arcgisChartsConfigFormatPopoverChange=${this.popoverOpen}></arcgis-charts-config-format>`;
        break;
      case s.General:
        i = a`<arcgis-charts-config-general .model=${this.model}></arcgis-charts-config-general>`;
        break;
      default:
        i = "";
        break;
    }
    return i;
  }
}
l("arcgis-charts-config-line-chart", u);
export {
  u as ArcgisChartsConfigLineChart
};
