import { WebChartTypes as u, WebChartOrderDataByTypes as m, WebChartSortOrderKinds as F, RESTFieldType as ne } from "@arcgis/charts-spec";
import { memoize as j, isEmpty as de, isEqual as ce, cloneDeep as J } from "lodash-es";
import { ae as q, b as D, W as x, b4 as ye, a5 as ue, a4 as me, c9 as w, z as Se, i as fe, b6 as X, b7 as _, bR as O, a3 as G, U as H, af as Q, ao as pe, as as Z, aS as R } from "./interfaces.js";
import "@arcgis/core/geometry/support/jsonUtils.js";
import "@arcgis/core/rest/support/AttributeBinsQuery.js";
import "@arcgis/core/rest/support/Query.js";
import "@arcgis/core/rest/support/StatisticDefinition.js";
import "@arcgis/core/time/TimeExtent.js";
import "@arcgis/core/core/promiseUtils.js";
import "@arcgis/core/request.js";
import { g as P, p as be } from "./index4.js";
import { k as xe, u as v, b as N, c as W, l as he, m as Fe, f as z, n as ge } from "./data.js";
import { B as y } from "./common.js";
import "d3-array";
/*! All material copyright Esri, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.33/esri/copyright.txt for details.
v4.33.19 */
const Je = (s, e) => e?.series?.[s]?.name, Xe = (s, e, t) => {
  const i = t;
  i?.series?.[e] !== void 0 && (i.series[e].name = s);
}, _e = (s, e) => {
  let t;
  const i = e.series?.[s];
  return i?.type === u.BoxPlotSeries ? t = i.fillSymbol?.color : i?.type === u.LineSeries && (t = i.lineSymbol?.color), t;
}, Be = (s) => {
  const e = s.series[0];
  return s.showMean === !0 && P(e) ? e.fillSymbol?.color : void 0;
}, we = (s, e) => {
  const t = e.series[0];
  e.showMean === !0 && P(t) && (t.fillSymbol !== void 0 ? t.fillSymbol.color = s : t.fillSymbol = {
    ...q(),
    color: s
  });
}, Ge = (s, e, t) => {
  const r = t?.series?.[e];
  r?.type === u.BoxPlotSeries && r.fillSymbol !== void 0 ? r.fillSymbol.color = s : r?.type === u.LineSeries && r.lineSymbol !== void 0 && (r.lineSymbol.color = s, r.markerSymbol !== void 0 && (r.markerSymbol.color = s));
}, Ae = (s) => s.series.map((e) => e.id), ve = (s, e) => {
  e?.series?.sort(
    (t, i) => s.findIndex((r) => t.id === r) - s.findIndex((r) => i.id === r)
  );
}, He = (s, e, t) => {
  const i = Ae(t), [r] = i.splice(s, 1);
  i.splice(e, 0, r), ve(i, t);
}, Qe = (s) => k(s) ? s.series.findIndex((e) => e.type === u.BoxPlotSeries) : -1, A = (s) => D(s)?.x ?? x, E = j(
  (s) => {
    const e = D(s), t = e?.query?.where?.split("=")[0].trim() ?? "";
    return fe(e?.query?.where) ? "" : t;
  },
  (s) => D(s)?.query?.where
), V = j(
  // without memoizing, the worst case efficiency is O(series.length), best case is O(1)
  // with memoizing, the worst case efficiency for repeated calls becomes O(1)
  (s) => Se(s?.series).filter((e) => e !== ""),
  // using series array address as key, since a change to the numeric fields will always rebuild a fresh series array
  (s) => s?.series
), T = async (s) => {
  const { category: e, seriesIndex: t, y: i } = s, l = {
    ...await Z(t),
    x: e === void 0 || e === "" ? x : e,
    y: i,
    query: {}
  };
  return J(l);
}, Ce = async (s) => {
  const { category: e, seriesIndex: t, y: i } = s, l = {
    ...await pe({ seriesIndex: t }),
    x: e === void 0 || e === "" ? x : e,
    y: i,
    query: {}
  };
  return J(l);
};
async function ee(s) {
  const { x: e, y: t, seriesTemplate: i } = s, { id: r, fillSymbol: l } = i ?? {}, o = await Z(), a = r ?? `series_${Date.now()}`;
  return o.id = a, o.name = a, o.x = e, o.y = t, l ? o.fillSymbol = l : o.fillSymbol && (o.fillSymbol.color = R, o.fillSymbol?.outline && (o.fillSymbol.outline.color = R)), o;
}
async function se(s) {
  const { numericFields: e, config: t, layerInfo: i, category: r } = s, { layerFieldsInfo: l } = i, o = [], a = r ?? A(t);
  let n = !1;
  if (e.length === 0) {
    const d = await T({
      y: "",
      seriesIndex: 0,
      category: a
    });
    o.push(d);
  } else if (a === x) {
    const d = await z(), c = e.length > 1 ? e : e[0], C = await T({
      y: c,
      seriesIndex: 0,
      category: a
    }), h = e.length > 1 ? d.axisLabels.values : w(i.layerFieldsInfo, e[0]), b = {
      ...C,
      id: e[0],
      name: h,
      x: a
    }, f = t.series.find((S) => ce(c, S.y) && S.query?.where === void 0);
    f !== void 0 && (!t.colorMatch && "fillSymbol" in f && (b.fillSymbol = f.fillSymbol, n = !0), b.id = f.id, b.name = f.name), o.push(b);
  } else
    for (let d = 0; d < e.length; d += 1) {
      const c = e[d], C = await T({
        y: c,
        seriesIndex: d,
        category: a
      }), h = w(l, c), b = {
        ...C,
        id: c,
        name: h,
        x: a
      }, f = t.series.find((S) => c === S.y);
      f !== void 0 && (!t.colorMatch && "fillSymbol" in f && (b.fillSymbol = f.fillSymbol, n = !0), b.id = f.id, b.name = f.name), o.push(b);
    }
  return t.series.length === 1 && o.length === 1 && !t.colorMatch && "fillSymbol" in t.series[0] && (o[0].fillSymbol = t.series[0].fillSymbol, n = !0), t.colorMatch = !n, o;
}
const te = (s) => s?.query?.where?.split("=")[1].trim().replace(/'/gu, "") ?? "", Le = (s) => s.series.some((e) => e.type === u.LineSeries) && s.series.some((e) => e.type === u.BoxPlotSeries);
async function Me(s, e) {
  const t = [];
  return s.forEach((i) => {
    if (i.type === u.BoxPlotSeries) {
      const { type: r, fillSymbol: l, ...o } = i;
      t.push({
        ...o,
        type: u.LineSeries,
        lineSymbol: {
          ...G({ width: H }),
          ...l !== void 0 ? { color: l.color } : {}
        },
        markerSymbol: {
          ...Q(),
          ...l !== void 0 ? { color: l.color } : {}
        }
      });
    }
  }), t.unshift(
    await ee({
      x: s[0].x,
      y: s[0].y,
      seriesTemplate: e
    })
  ), t;
}
function Oe(s) {
  const e = s.slice(1), t = [];
  return e.forEach((i) => {
    if (i.type === u.LineSeries) {
      const { type: r, lineSymbol: l, markerSymbol: o, ...a } = i, n = q();
      t.push({
        ...a,
        type: u.BoxPlotSeries,
        fillSymbol: {
          ...n,
          color: l?.color
        }
      });
    }
  }), t;
}
function ie(s) {
  const { formerSeries: e, newSeries: t, showMean: i } = s;
  let r = t;
  const l = (n) => n.type === (i ? u.LineSeries : u.BoxPlotSeries), o = e.filter(l).map((n) => n.id), a = t.filter(l).map((n) => n.id);
  return o.length === a.length && JSON.stringify(o) !== JSON.stringify(a) && (r = r.sort(
    (n, d) => o.findIndex((c) => c === n.id) - o.findIndex((c) => c === d.id)
  )), r;
}
async function Te(s) {
  const { config: e, layerInfo: t, splitByField: i, numericFields: r, category: l } = s, { layer: o, layerFieldsInfo: a } = t, { fetchNullValues: n } = D(e)?.query ?? {}, d = l ?? A(e), { categoriesArray: c, splitByFieldType: C } = await ge({
    config: e,
    layer: o,
    layerFieldsInfo: a,
    xAxisField: d !== x ? d : void 0,
    aggregationFields: r,
    splitByField: i,
    fetchNullValues: n
  });
  let h = [], b = !1;
  const f = Le(e);
  if (c.length === 0) {
    h = await se({
      numericFields: r,
      category: d,
      config: e,
      layerInfo: t
    });
    for (const S of h)
      S.query && (S.query.where = `${i}=''`);
  } else
    for (let S = 0; S < c.length; S += 1) {
      const B = c[S], M = {
        y: r,
        seriesIndex: S,
        category: d
      }, Y = f ? await Ce(M) : await T(M), le = {
        fieldName: i,
        fieldValueToMatch: B ?? "",
        subtypeInfo: X(t.layer),
        fieldList: t.layerFieldsInfo
      }, oe = _(le), I = `${B}`, g = {
        ...Y,
        id: I,
        name: oe ?? I,
        x: d === void 0 || d === "" ? x : d,
        query: {
          ...Y.query,
          where: `${i}=${C === ne.String && B !== null ? `'${B}'` : B}`
        }
      }, p = e.series.find((ae) => te(ae) === I);
      p !== void 0 && (e.colorMatch || (g.type === u.BoxPlotSeries ? P(p) ? g.fillSymbol = p.fillSymbol : g.fillSymbol = {
        ...q(),
        color: p.lineSymbol?.color
      } : P(p) ? (g.lineSymbol = {
        ...G({ width: H }),
        ...p.fillSymbol !== void 0 ? { color: p.fillSymbol.color } : {}
      }, g.markerSymbol = {
        ...Q(),
        ...p.fillSymbol !== void 0 ? { color: p.fillSymbol.color } : {}
      }) : (g.lineSymbol = p.lineSymbol, g.markerSymbol = p.markerSymbol), b = !0), g.id = p.id, g.name = p.name), h.push(g);
    }
  if (h = ie({
    formerSeries: e.series,
    newSeries: h,
    showMean: k(e)
  }), e.colorMatch = !b, k(e)) {
    const S = e.series.find((M) => M.type === u.BoxPlotSeries), B = await ee({
      x: d,
      y: r,
      seriesTemplate: S
    });
    h.unshift(B);
  }
  return h;
}
const K = async (s) => {
  const { splitByField: e, numericFields: t, category: i, config: r, layerInfo: l } = s, a = !(t.length > 1 && i !== x) && e !== "";
  U(a ? r.showMean : !1, r), r.series = a ? await Te({
    config: r,
    layerInfo: l,
    splitByField: e,
    numericFields: t,
    category: i
  }) : await se({
    numericFields: t,
    config: r,
    layerInfo: l,
    category: i
  });
}, De = (s) => s?.standardizeValues ?? !1;
async function L(s, e) {
  const { layerFieldsInfo: t } = e, i = De(s), r = await z();
  let l = i ? r.axisLabels.standardizedValues : r.axisLabels.values, o = s?.series?.map((a) => a.y).flat();
  return o = [...new Set(o)], o.length === 1 && (l = w(t, o[0])), l;
}
async function $(s, e) {
  const { layerFieldsInfo: t } = e, i = A(s), r = V(s), l = E(s), o = r.map((c) => w(t ?? [], c)).join(", "), a = w(t ?? [], i);
  let n = "";
  const d = await z();
  return r.length > 0 && (i !== x && l !== "" ? n = O(d.titleLabels.distributionOfFieldsByCategoryAndSplitBy, {
    valueFields: o,
    category: a,
    splitByField: l
  }) : i !== x ? n = O(d.titleLabels.distributionOfFieldsByCategory, {
    valueFields: o,
    category: a
  }) : l !== "" ? n = O(d.titleLabels.distributionOfFieldsByCategory, {
    valueFields: o,
    category: l
  }) : n = O(d.titleLabels.distributionOfField, {
    valueField: o
  })), n;
}
const Ze = async (s, e, t) => {
  const { layerFieldsInfo: i } = t, r = A(e), l = E(e), o = V(e), a = ye(i);
  let n;
  !a.includes(r) && a.includes(s) ? n = ue() : a.includes(r) && !a.includes(s) && (n = me()), n !== void 0 && xe(e, n), await K({
    splitByField: l,
    numericFields: o,
    category: s,
    config: e,
    layerInfo: t
  });
  const d = s !== x ? w(i, s) : "";
  v(e, 0, d);
  const c = await L(e, t);
  v(e, 1, c), e?.title !== void 0 && (e.title.content.text = await $(e, t)), N(e, null), W(e, null);
}, es = async (s, e, t) => {
  const i = A(e), r = E(e);
  await K({
    splitByField: r,
    numericFields: s,
    category: i,
    config: e,
    layerInfo: t
  });
  const l = await L(e, t);
  v(e, 1, l), e?.title !== void 0 && (e.title.content.text = await $(e, t)), N(e, null), W(e, null);
}, ss = (s) => {
  const { series: e, splitByField: t, layerInfo: i, commonStrings: r } = s;
  let l = typeof e.y == "string" ? w(i.layerFieldsInfo, e.y) : r.axisLabels.values;
  de(t) || (l = te(e));
  const o = {
    fieldName: t,
    fieldValueToMatch: l ?? "",
    subtypeInfo: X(i.layer),
    fieldList: i.layerFieldsInfo
  };
  return l = _(o) ?? l, l ?? e.id;
}, ts = async (s, e, t) => {
  const i = A(e), r = V(e);
  await K({
    splitByField: s,
    numericFields: r,
    category: i,
    config: e,
    layerInfo: t
  });
  const l = await L(e, t);
  v(e, 1, l), e?.title !== void 0 && (e.title.content.text = await $(e, t)), N(e, null), W(e, null);
}, is = (s) => s?.showOutliers ?? !1, rs = async (s, e, t) => {
  e.showOutliers = s;
  const i = await L(e, t);
  v(e, 1, i);
}, ls = async (s, e, t) => {
  e.standardizeValues = s;
  const i = await L(e, t);
  v(e, 1, i);
}, re = (s) => {
  let e = y.xAxisAsc;
  const t = s.orderOptions?.data?.orderType ?? m.Category, i = s.orderOptions?.data?.orderBy ?? F.Ascending;
  switch (t) {
    case m.Category:
      e = Array.isArray(i) ? y.customSort : i === F.Ascending ? y.xAxisAsc : y.xAxisDesc;
      break;
    case m.Mean:
      e = i === F.Ascending ? y.meanAsc : y.meanDesc;
      break;
    case m.Median:
      e = i === F.Ascending ? y.medianAsc : y.medianDesc;
      break;
  }
  return e;
}, os = (s, e, t) => {
  let i = m.Category, r = F.Ascending;
  if (e.orderOptions = e.orderOptions ?? {}, s === y.customSort && t !== void 0)
    e.orderOptions.data = {
      orderType: m.Category,
      orderBy: t
    };
  else {
    switch (s) {
      case y.xAxisAsc: {
        i = m.Category, r = F.Ascending;
        break;
      }
      case y.xAxisDesc: {
        i = m.Category, r = F.Descending;
        break;
      }
      case y.meanAsc: {
        i = m.Mean, r = F.Ascending;
        break;
      }
      case y.meanDesc: {
        i = m.Mean, r = F.Descending;
        break;
      }
      case y.medianAsc: {
        i = m.Median, r = F.Ascending;
        break;
      }
      case y.medianDesc: {
        i = m.Median, r = F.Descending;
        break;
      }
    }
    e.orderOptions.data = {
      orderType: i,
      orderBy: r
    };
  }
}, k = (s) => s.showMean ?? !1, U = async (s = !1, e, t) => {
  const i = s ? t : Be(e), r = (s ?? !1) !== (e.showMean ?? !1);
  if (e.showMean = s, r) {
    let l;
    s ? l = be(e.series) ? await Me(e.series) : e.series : l = Oe(e.series), l && (l = ie({
      formerSeries: e.series,
      newSeries: l,
      showMean: s
    }), e.series = l);
  }
  return s && t !== void 0 && we(t, e), { previousMeanLinesBoxColor: i };
}, as = (s) => {
  let e = [];
  const t = s.orderOptions?.data?.orderType;
  return re(s) === y.customSort && t === m.Category && (e = s.orderOptions?.data?.orderBy), e;
}, ns = (s, e) => {
  e.orderOptions ??= {};
  const t = e.orderOptions?.data?.orderType;
  re(e) === y.customSort && t === m.Category && (e.orderOptions.data = {
    orderType: m.Category,
    orderBy: s
  });
}, ds = (s) => s.dataFilters, cs = (s, e) => {
  s !== void 0 ? e.dataFilters = s : delete e.dataFilters;
}, ys = async (s, e) => {
  const t = A(s), i = he(s)?.type, r = V(s);
  let l = [];
  return i === u.CategoryAxisFormat && (t === x ? l = r : t.trim() !== "" && t !== x && (l = await Fe({
    layerInfo: e,
    config: s,
    category: t
  }))), l;
};
export {
  Ae as A,
  ve as B,
  He as C,
  Qe as D,
  ss as E,
  ys as a,
  V as b,
  es as c,
  E as d,
  ts as e,
  is as f,
  A as g,
  rs as h,
  De as i,
  ls as j,
  re as k,
  os as l,
  as as m,
  ns as n,
  K as o,
  ds as p,
  cs as q,
  k as r,
  Ze as s,
  U as t,
  Be as u,
  we as v,
  Je as w,
  Xe as x,
  _e as y,
  Ge as z
};
