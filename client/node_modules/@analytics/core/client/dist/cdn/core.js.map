{"version":3,"file":"core.js","sources":["../../../../../node_modules/.pnpm/@analytics+type-utils@0.6.4/node_modules/@analytics/type-utils/dist/analytics-util-types.module.js","../../../../analytics-utils/dist/analytics-utils.module.js","../../../../../node_modules/.pnpm/@analytics+global-storage-utils@0.1.9/node_modules/@analytics/global-storage-utils/dist/analytics-util-global-storage.module.js","../../../src/vendor/redux/utils/defs.js","../../../src/vendor/redux/createStore.js","../../../src/vendor/redux/combineReducers.js","../../../src/vendor/redux/compose.js","../../../src/vendor/redux/applyMiddleware.js","../../../src/constants.js","../../../src/utils/internalConstants.js","../../../src/events.js","../../../src/middleware/initialize.js","../../../src/modules/user.js","../../../src/middleware/identify.js","../../../src/utils/callback-stack.js","../../../src/utils/waitForReady.js","../../../src/utils/heartbeat.js","../../../src/middleware/plugins/engine.js","../../../src/middleware/plugins/index.js","../../../src/utils/filterDisabled.js","../../../src/middleware/storage.js","../../../src/middleware/dynamic.js","../../../src/modules/plugins.js","../../../src/utils/serialize.js","../../../src/modules/track.js","../../../src/modules/queue.js","../../../src/modules/page.js","../../../src/modules/context.js","../../../src/utils/getOSName/browser.js","../../../src/utils/handleNetworkEvents.js","../../../src/utils/debug.js","../../../src/utils/ensureArray.js","../../../src/utils/enrichMeta.js","../../../src/utils/getCallback.js","../../../src/utils/timestamp.js","../../../src/index.js"],"sourcesContent":["var n=\"function\",t=\"string\",e=\"undefined\",r=\"boolean\",o=\"object\",u=\"array\",c=\"number\",i=\"symbol\",a=\"null\",f=\"error\",s=\"typeError\",l=\"syntaxError\",p=\"asyncFunction\",d=\"generatorFunction\",y=\"asyncGeneratorFunction\",g=function(){},m=\"any\",v=\"*\",b=\"none\",h=\"hidden\",O=\"__\",S=\"form\",j=\"input\",A=\"button\",E=\"select\",N=\"change\",w=\"submit\",D=/^\\d{4}-[01]\\d-[0-3]\\dT[0-2]\\d:[0-5]\\d:[0-5]\\d\\.\\d+([+-][0-2]\\d:[0-5]\\d|Z)$/,z=/^[a-zA-Z0-9.!#$%&'*+\\/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/,Z=/^\\{[\\s\\S]*\\}$|^\\[[\\s\\S]*\\]$/,P=typeof process!==e?process:{},x=P.env&&P.env.NODE_ENV||\"\",C=\"production\"===x,F=\"staging\"===x,L=\"development\"===x,$=typeof document!==e,T=$&&\"localhost\"===window.location.hostname,_=null!=P.versions&&null!=P.versions.node,k=typeof Deno!==e&&typeof Deno.core!==e,B=typeof self===o&&self.constructor&&\"DedicatedWorkerGlobalScope\"===self.constructor.name,G=$&&\"nodejs\"===window.name||typeof navigator!==e&&typeof navigator.userAgent!==e&&(navigator.userAgent.includes(\"Node.js\")||navigator.userAgent.includes(\"jsdom\"));function M(n,t){return t.charAt(0)[n]()+t.slice(1)}var U=M.bind(null,\"toUpperCase\"),H=M.bind(null,\"toLowerCase\");function J(n){return Y(n)?U(a):typeof n===o?yn(n):Object.prototype.toString.call(n).slice(8,-1)}function R(n,t){void 0===t&&(t=!0);var e=J(n);return t?H(e):e}function V(n,t){return typeof t===n}var W=V.bind(null,n),q=V.bind(null,t),I=V.bind(null,e);function K(n){return!I(n)}var Q=V.bind(null,r),X=V.bind(null,i);function Y(n){return null===n}function nn(n){return R(n)===c&&!isNaN(n)}function tn(n){return!isNaN(parseFloat(n))}function en(n){return!!W(n)&&/^class /.test(Function.prototype.toString.call(n))}function rn(n){return R(n)===u}function on(n){if(!un(n))return!1;for(var t=n;null!==Object.getPrototypeOf(t);)t=Object.getPrototypeOf(t);return Object.getPrototypeOf(n)===t}function un(n){return n&&(typeof n===o||null!==n)}function cn(n){if(!q(n)||!Z.test(n))return!1;try{JSON.parse(n)}catch(n){return!1}return!0}function an(n){if(Y(n))return!0;switch(typeof n){case t:case c:case i:case e:case r:return!0;default:return!1}}function fn(n,t){return on(n)&&W(n[t])}function sn(n){return!!n&&!!(!I(Promise)&&n instanceof Promise||n.then&&W(n.then))}function ln(n){return un(n)&&W(n.throw)&&W(n.return)&&W(n.next)}function pn(n){return R(n)===d}function dn(n){return R(n)===p}function yn(n){return W(n.constructor)?n.constructor.name:null}function gn(n){return n instanceof Set}function mn(n){return n instanceof Map}function vn(n){return n instanceof RegExp}function bn(n){return!(!n.constructor||!W(n.constructor.isBuffer))&&n.constructor.isBuffer(n)}function hn(n){return n instanceof Error||q(n.message)&&n.constructor&&nn(n.constructor.stackTraceLimit)}function On(n){return un(n)&&q(n.message)&&q(n.name)}function Sn(n,t){if(\"object\"!=typeof t||Y(t))return!1;if(t instanceof n)return!0;var e=R(new n(\"\"));if(hn(t))for(;t;){if(R(t)===e)return!0;t=Object.getPrototypeOf(t)}return!1}var jn=Sn.bind(null,TypeError),An=Sn.bind(null,SyntaxError);function En(n){if(!W(n))return!1;var t=/{(\\r|\\n|\\s)*}/gm,e=g+\"\";return e===(n.toString().match(t)||[\"\"])[0].replace(t,e)}function Nn(n){try{if(nn(n.length)&&W(n.callee))return!0}catch(n){if(-1!==n.message.indexOf(\"callee\"))return!0}return!1}function wn(n){return!(q(n)&&\"false\"===n.toLowerCase()||!n)}function Dn(n){return!n}function zn(n){return!0===n}function Zn(n){return!1===n}function Pn(n){return!(n.length>320)&&z.test(n)}function xn(n){return n instanceof Date||W(n.toDateString)&&W(n.getDate)&&W(n.setDate)}function Cn(n){return D.test(n)}function Fn(n){return!(!Y(n)&&(rn(n)?n.length:gn(n)||mn(n)?n.size:on(n)&&Object.keys(n).length))}function Ln(n){return NodeList.prototype.isPrototypeOf(n)}function $n(n,t){var e=n instanceof Element||n instanceof HTMLDocument;return e&&t?Tn(n,t):e}function Tn(n,t){return void 0===t&&(t=\"\"),n&&n.nodeName===t.toUpperCase()}function _n(n){var t=[].slice.call(arguments,1);return function(){return n.apply(void 0,[].slice.call(arguments).concat(t))}}var kn=_n($n,S),Bn=_n($n,A),Gn=_n($n,j),Mn=_n($n,E);function Un(n,t){if(!n||getComputedStyle(n).visibility===h)return!0;for(;n;){if(null!=t&&n===t)return!1;if(getComputedStyle(n).display===b)return!0;n=n.parentElement}return!1}function Hn(n){return n?rn(n)?n:[n]:[]}export{v as ALL,m as ANY,u as ARRAY,p as ASYNC_FUNCTION,y as ASYNC_GENERATOR_FUNCTION,r as BOOLEAN,A as BUTTON,N as CHANGE,x as ENV,f as ERROR,S as FORM,n as FUNCTION,d as GENERATOR_FUNCTION,h as HIDDEN,j as INPUT,b as NONE,a as NULL,c as NUMBER,o as OBJECT,O as PREFIX,z as REGEX_EMAIL,D as REGEX_ISO,Z as REGEX_JSON,E as SELECT,t as STRING,w as SUBMIT,i as SYMBOL,l as SYNTAX_ERROR,s as TYPE_ERROR,e as UNDEFINED,yn as ctorName,Hn as ensureArray,R as getType,J as getTypeName,Nn as isArguments,rn as isArray,dn as isAsyncFunction,Q as isBoolean,$ as isBrowser,bn as isBuffer,Bn as isButton,en as isClass,xn as isDate,K as isDefined,k as isDeno,L as isDev,$n as isElement,Pn as isEmail,Fn as isEmpty,hn as isError,On as isErrorLike,Zn as isFalse,Dn as isFalsy,kn as isForm,W as isFunction,ln as isGenerator,pn as isGeneratorFunction,Un as isHidden,Gn as isInput,Cn as isIsoDate,G as isJsDom,cn as isJson,T as isLocalHost,mn as isMap,fn as isMethod,En as isNoOp,_ as isNode,Ln as isNodeList,Tn as isNodeType,Y as isNull,nn as isNumber,tn as isNumberLike,on as isObject,un as isObjectLike,an as isPrimitive,C as isProd,sn as isPromise,vn as isRegex,Mn as isSelect,gn as isSet,F as isStaging,q as isString,X as isSymbol,An as isSyntaxError,zn as isTrue,wn as isTruthy,jn as isTypeError,I as isUndefined,B as isWebWorker,g as noOp};\n//# sourceMappingURL=analytics-util-types.module.js.map\n","export{default as dotProp}from\"dlv\";import{isBrowser as e,isString as r,isRegex as t}from\"@analytics/type-utils\";function n(e){try{return decodeURIComponent(e.replace(/\\+/g,\" \"))}catch(e){return null}}function o(){if(e){var r=navigator,t=r.languages;return r.userLanguage||(t&&t.length?t[0]:r.language)}}function a(){try{return Intl.DateTimeFormat().resolvedOptions().timeZone}catch(e){}}function i(r){if(!e)return!1;var t=r||document.referrer;if(t){var n=window.document.location.port,o=t.split(\"/\")[2];return n&&(o=o.replace(\":\"+n,\"\")),o!==window.location.hostname}return!1}function u(n){if(!e)return!0;var o=document.getElementsByTagName(\"script\");return!!Object.keys(o).filter(function(e){var a=o[e].src;return r(n)?-1!==a.indexOf(n):!!t(n)&&a.match(n)}).length}function c(e,r){var t=(e.split(\"?\")||[,])[1];if(!t||-1===t.indexOf(r))return e;var n=new RegExp(\"(\\\\&|\\\\?)\"+r+'([_A-Za-z0-9\"+=.\\\\/\\\\-@%]+)',\"g\"),o=(\"?\"+t).replace(n,\"\").replace(/^&/,\"?\");return e.replace(\"?\"+t,o)}function l(e,r){return n((RegExp(e+\"=(.+?)(&|$)\").exec(r)||[,\"\"])[1])}function s(r){return function(e){for(var r,t=Object.create(null),o=/([^&=]+)=?([^&]*)/g;r=o.exec(e);){var a=n(r[1]),i=n(r[2]);if(a)if(\"[]\"===a.substring(a.length-2)){var u=t[a=a.substring(0,a.length-2)]||(t[a]=[]);t[a]=Array.isArray(u)?u:[],t[a].push(i)}else t[a]=\"\"===i||i}for(var c in t){var l=c.split(\"[\");l.length>1&&(m(t,l.map(function(e){return e.replace(/[?[\\]\\\\ ]/g,\"\")}),t[c]),delete t[c])}return t}(function(r){if(r){var t=r.match(/\\?(.*)/);return t&&t[1]?t[1].split(\"#\")[0]:\"\"}return e&&window.location.search.substring(1)}(r))}function m(e,r,t){for(var n=r.length-1,o=0;o<n;++o){var a=r[o];if(\"__proto__\"===a||\"constructor\"===a)break;a in e||(e[a]={}),e=e[a]}e[r[n]]=t}function f(r,t){return e?new Promise(function(e,n){if(window.history&&window.history.replaceState){var o=window.location.href,a=c(o,r);o!==a&&history.replaceState({},\"\",a)}return t&&t(),e()}):Promise.resolve()}function g(r){if(!e)return null;var t=document.createElement(\"a\");return t.setAttribute(\"href\",r),t.hostname}function p(e){return(g(e)||\"\").split(\".\").slice(-2).join(\".\")}function x(e){var r=e.split(\".\");return r.length>1?r.slice(0,-1).join(\".\"):e}var d={trimTld:x,getDomainBase:p,getDomainHost:g},v=\"google\";function h(r,t){if(!e)return!1;var n={source:\"(direct)\",medium:\"(none)\",campaign:\"(not set)\"};r&&i(r)&&(n.referrer=r);var o=function(r){if(!r||!e)return!1;var t=p(r),n=document.createElement(\"a\");if(n.href=r,n.hostname.indexOf(v)>-1&&(t=v),y[t]){var o=y[t],a=new RegExp((\"string\"==typeof o?o:o.p)+\"=.*?([^&#]*|$)\",\"gi\"),u=n.search.match(a);return{source:o.n||x(t),medium:\"organic\",term:(u?u[0].split(\"=\")[1]:\"\")||\"(not provided)\"}}var c=i(r)?\"referral\":\"internal\";return{source:n.hostname,medium:c}}(r);o&&Object.keys(o).length&&(n=Object.assign({},n,o));var a=s(t),u=Object.keys(a);if(!u.length)return n;var c=u.reduce(function(e,r){return r.match(/^utm_/)&&(e[\"\"+r.replace(/^utm_/,\"\")]=a[r]),r.match(/^(d|g)clid/)&&(e.source=v,e.medium=a.gclid?\"cpc\":\"cpm\",e[r]=a[r]),e},{});return Object.assign({},n,c)}var w=\"q\",y={\"daum.net\":w,\"eniro.se\":\"search_word\",\"naver.com\":\"query\",\"yahoo.com\":\"p\",\"msn.com\":w,\"aol.com\":w,\"ask.com\":w,\"baidu.com\":\"wd\",\"yandex.com\":\"text\",\"rambler.ru\":\"words\",google:w,\"bing.com\":{p:w,n:\"live\"}};function b(){for(var e=\"\",r=0,t=4294967295*Math.random()|0;r++<36;){var n=\"xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx\"[r-1],o=15&t;e+=\"-\"==n||\"4\"==n?n:(\"x\"==n?o:3&o|8).toString(16),t=r%8==0?4294967295*Math.random()|0:t>>4}return e}function O(e,r){var t,n,o,a=null,i=0,u=function(){i=new Date,a=null,o=e.apply(t,n)};return function(){var c=new Date;i||(i=c);var l=r-(c-i);return t=this,n=arguments,l<=0?(clearTimeout(a),a=null,i=c,o=e.apply(t,n)):a||(a=setTimeout(u,l)),o}}export{n as decodeUri,o as getBrowserLocale,a as getTimeZone,i as isExternalReferrer,u as isScriptLoaded,c as paramsClean,l as paramsGet,s as paramsParse,f as paramsRemove,h as parseReferrer,O as throttle,d as url,b as uuid};\n//# sourceMappingURL=analytics-utils.module.js.map\n","import{PREFIX as t,OBJECT as e,UNDEFINED as r}from\"@analytics/type-utils\";var n=\"global\",o=t+n+t,l=typeof self===e&&self.self===self&&self||typeof global===e&&global[n]===global&&global||void 0;function f(t){return l[o][t]}function a(t,e){return l[o][t]=e}function i(t){delete l[o][t]}function u(t,e,r){var n;try{if(s(t)){var o=window[t];n=o[e].bind(o)}}catch(t){}return n||r}l[o]||(l[o]={});var c={};function s(t){if(typeof c[t]!==r)return c[t];try{var e=window[t];e.setItem(r,r),e.removeItem(r)}catch(e){return c[t]=!1}return c[t]=!0}export{n as GLOBAL,o as KEY,f as get,l as globalContext,s as hasSupport,i as remove,a as set,u as wrap};\n//# sourceMappingURL=analytics-util-global-storage.module.js.map\n","export const FUNC = 'function'\nexport const UNDEF = 'undefined'\nexport const REDUCER = 'reducer'\n\nconst base = '@@redux/'\nexport const ACTION_INIT = base + 'INIT'\nexport const ACTION_TEST = base + Math.random().toString(36)\n","import { isObject } from '@analytics/type-utils'\nimport { FUNC, UNDEF, ACTION_INIT, REDUCER } from './utils/defs.js'\n\n// eslint-disable-next-line\nconst $$observable = /* #__PURE__ */ (() => (typeof Symbol === FUNC && Symbol.observable) || '@@observable')();\n\n/*\n * Creates a Redux store that holds the state tree.\n * The only way to change the data in the store is to call `dispatch()` on it.\n *\n * There should only be a single store in your app. To specify how different\n * parts of the state tree respond to actions, you may combine several reducers\n * into a single reducer function by using `combineReducers`.\n *\n * @param {Function} reducer A function that returns the next state tree, given\n * the current state tree and the action to handle.\n *\n * @param {any} [preloadedState] The initial state. You may optionally specify it\n * to hydrate the state from the server in universal apps, or to restore a\n * previously serialized user session.\n * If you use `combineReducers` to produce the root reducer function, this must be\n * an object with the same shape as `combineReducers` keys.\n *\n * @param {Function} [enhancer] The store enhancer. You may optionally specify it\n * to enhance the store with third-party capabilities such as middleware,\n * time travel, persistence, etc. The only store enhancer that ships with Redux\n * is `applyMiddleware()`.\n *\n * @returns {Store} A Redux store that lets you read the state, dispatch actions\n * and subscribe to changes.\n */\nconst msg = ' != ' + FUNC\nexport default function createStore(reducer, preloadedState, enhancer) {\n  if (typeof preloadedState === FUNC && typeof enhancer === UNDEF) {\n    enhancer = preloadedState\n    preloadedState = undefined\n  }\n\n  if (typeof enhancer !== UNDEF) {\n    if (typeof enhancer !== FUNC) {\n      throw new Error('enhancer' + msg)\n    }\n\n    return enhancer(createStore)(reducer, preloadedState)\n  }\n\n  if (typeof reducer !== FUNC) {\n    throw new Error(REDUCER + msg)\n  }\n\n  let currentReducer = reducer\n  let currentState = preloadedState\n  let currentListeners = []\n  let nextListeners = currentListeners\n  let isDispatching = false\n\n  function ensureCanMutateNextListeners() {\n    if (nextListeners === currentListeners) {\n      nextListeners = currentListeners.slice()\n    }\n  }\n\n  /*\n   * Reads the state tree managed by the store.\n   *\n   * @returns {any} The current state tree of your application.\n   */\n  function getState() {\n    return currentState\n  }\n\n  /*\n   * Adds a change listener. It will be called any time an action is dispatched,\n   * and some part of the state tree may potentially have changed. You may then\n   * call `getState()` to read the current state tree inside the callback.\n   *\n   * You may call `dispatch()` from a change listener, with the following\n   * caveats:\n   *\n   * 1. The subscriptions are snapshotted just before every `dispatch()` call.\n   * If you subscribe or unsubscribe while the listeners are being invoked, this\n   * will not have any effect on the `dispatch()` that is currently in progress.\n   * However, the next `dispatch()` call, whether nested or not, will use a more\n   * recent snapshot of the subscription list.\n   *\n   * 2. The listener should not expect to see all state changes, as the state\n   * might have been updated multiple times during a nested `dispatch()` before\n   * the listener is called. It is, however, guaranteed that all subscribers\n   * registered before the `dispatch()` started will be called with the latest\n   * state by the time it exits.\n   *\n   * @param {Function} listener A callback to be invoked on every dispatch.\n   * @returns {Function} A function to remove this change listener.\n   */\n  function subscribe(listener) {\n    if (typeof listener !== FUNC) {\n      throw new Error('Listener' + msg)\n    }\n\n    let isSubscribed = true\n\n    ensureCanMutateNextListeners()\n    nextListeners.push(listener)\n\n    return function unsubscribe() {\n      if (!isSubscribed) {\n        return\n      }\n\n      isSubscribed = false\n\n      ensureCanMutateNextListeners()\n      const index = nextListeners.indexOf(listener)\n      nextListeners.splice(index, 1)\n    }\n  }\n\n  /**\n   * Dispatches an action. It is the only way to trigger a state change.\n   *\n   * The `reducer` function, used to create the store, will be called with the\n   * current state tree and the given `action`. Its return value will\n   * be considered the **next** state of the tree, and the change listeners\n   * will be notified.\n   *\n   * The base implementation only supports plain object actions. If you want to\n   * dispatch a Promise, an Observable, a thunk, or something else, you need to\n   * wrap your store creating function into the corresponding middleware. For\n   * example, see the documentation for the `redux-thunk` package. Even the\n   * middleware will eventually dispatch plain object actions using this method.\n   *\n   * @param {Object} action A plain object representing “what changed”. It is\n   * a good idea to keep actions serializable so you can record and replay user\n   * sessions, or use the time travelling `redux-devtools`. An action must have\n   * a `type` property which may not be `undefined`. It is a good idea to use\n   * string constants for action types.\n   *\n   * @returns {Object} For convenience, the same action object you dispatched.\n   *\n   * Note that, if you use a custom middleware, it may wrap `dispatch()` to\n   * return something else (for example, a Promise you can await).\n   */\n  function dispatch(action) {\n    /* // add default info to actions... \n    console.log('dispatch before', _action)\n    const action = {\n      ..._action,\n      ...{\n        action: {\n          ..._action.action,\n          ...{ customInfo: 'yoooo'} \n        }\n      }\n    }\n    console.log('dispatch after', action)\n    /** */\n\n    if (!isObject(action)) {\n      throw new Error('Act != obj')\n    }\n\n    if (typeof action.type === UNDEF) {\n      throw new Error('ActType ' + UNDEF)\n    }\n\n    if (isDispatching) {\n      throw new Error('Dispatch in ' + REDUCER)\n    }\n\n    try {\n      isDispatching = true\n      currentState = currentReducer(currentState, action)\n    } finally {\n      isDispatching = false\n    }\n\n    const listeners = currentListeners = nextListeners\n    for (let i = 0; i < listeners.length; i++) {\n      const listener = listeners[i]\n      listener()\n    }\n\n    return action\n  }\n\n  /**\n   * Replaces the reducer currently used by the store to calculate the state.\n   *\n   * You might need this if your app implements code splitting and you want to\n   * load some of the reducers dynamically. You might also need this if you\n   * implement a hot reloading mechanism for Redux.\n   *\n   * @param {Function} nextReducer The reducer for the store to use instead.\n   * @returns {void}\n   */\n  function replaceReducer(nextReducer) {\n    if (typeof nextReducer !== FUNC) {\n      throw new Error('next ' + REDUCER + msg)\n    }\n\n    currentReducer = nextReducer\n    dispatch({ type: ACTION_INIT })\n  }\n\n  /**\n   * Interoperability point for observable/reactive libraries.\n   * @returns {observable} A minimal observable of state changes.\n   * For more information, see the observable proposal:\n   * https://github.com/tc39/proposal-observable\n   */\n  function observable() {\n    const outerSubscribe = subscribe\n    return {\n      /*\n       * The minimal observable subscription method.\n       * @param {Object} observer Any object that can be used as an observer.\n       * The observer object should have a `next` method.\n       * @returns {subscription} An object with an `unsubscribe` method that can\n       * be used to unsubscribe the observable from the store, and prevent further\n       * emission of values from the observable.\n       */\n      subscribe(observer) {\n        if (typeof observer !== 'object') {\n          throw new TypeError('Observer != obj')\n        }\n\n        function observeState() {\n          if (observer.next) {\n            observer.next(getState())\n          }\n        }\n\n        observeState()\n        const unsubscribe = outerSubscribe(observeState)\n        return { unsubscribe }\n      },\n\n      [$$observable]() {\n        return this\n      }\n    }\n  }\n\n  // When a store is created, an \"INIT\" action is dispatched so that every\n  // reducer returns their initial state. This effectively populates\n  // the initial state tree.\n  dispatch({ type: ACTION_INIT })\n\n  return {\n    dispatch,\n    subscribe,\n    getState,\n    replaceReducer,\n    [$$observable]: observable\n  }\n}\n","import { isObject } from '@analytics/type-utils'\nimport warning from './utils/warning.js'\nimport { FUNC, UNDEF, REDUCER, ACTION_INIT, ACTION_TEST } from './utils/defs.js'\n\nfunction getUndefinedStateErrorMessage(key, action) {\n  const actionType = action && action.type\n  const actionName = (actionType && actionType.toString()) || '?'\n\n  return ('action ' + actionName + REDUCER + ' ' + key + ' returns ' + UNDEF)\n}\n\nfunction getUnexpectedStateShapeWarningMessage(inputState, reducers, action, unexpectedKeyCache) {\n  const reducerKeys = Object.keys(reducers)\n  const argumentName = action && action.type === ACTION_INIT ? 'preloadedState arg passed to createStore' : 'previous state received by ' + REDUCER\n\n  if (reducerKeys.length === 0) {\n    return ('Store has no valid reducers')\n  }\n\n  if (!isObject(inputState)) {\n    return (\n      `The ${argumentName} has unexpected type of \"` +\n      ({}).toString.call(inputState).match(/\\s([a-z|A-Z]+)/)[1] +\n      `\". Expected argument to be an object with the following ` +\n      `keys: \"${reducerKeys.join('\", \"')}\"`\n    )\n  }\n\n  const unexpectedKeys = Object.keys(inputState).filter(key =>\n    !reducers.hasOwnProperty(key) && !unexpectedKeyCache[key]\n  )\n\n  unexpectedKeys.forEach(key => {\n    unexpectedKeyCache[key] = true\n  })\n\n  if (unexpectedKeys.length > 0) {\n    return (\n      `Unexpected keys ${unexpectedKeys.join('\", \"')} in ${argumentName}. ` +\n      `Expected to find 1 of the known reducer keys instead: ${reducerKeys.join('\", \"')}`\n    )\n  }\n}\n\nfunction assertReducerShape(reducers) {\n  Object.keys(reducers).forEach(key => {\n    const reducer = reducers[key]\n    const initialState = reducer(undefined, { type: ACTION_INIT })\n    if (\n      typeof initialState === UNDEF ||\n      typeof reducer(undefined, { type: ACTION_TEST }) === UNDEF\n    ) {\n      throw new Error(REDUCER + ' ' + key + ' ' + UNDEF)\n    }\n  })\n}\n\n/**\n * Turns an object whose values are different reducer functions, into a single\n * reducer function. It will call every child reducer, and gather their results\n * into a single state object, whose keys correspond to the keys of the passed\n * reducer functions.\n *\n * @param {Object} reducers An object whose values correspond to different\n * reducer functions that need to be combined into one. One handy way to obtain\n * it is to use ES6 `import * as reducers` syntax. The reducers may never return\n * undefined for any action. Instead, they should return their initial state\n * if the state passed to them was undefined, and the current state for any\n * unrecognized action.\n *\n * @returns {Function} A reducer function that invokes every reducer inside the\n * passed object, and builds a state object with the same shape.\n */\nexport default function combineReducers(reducers) {\n  const reducerKeys = Object.keys(reducers)\n  const finalReducers = {}\n  for (let i = 0; i < reducerKeys.length; i++) {\n    const key = reducerKeys[i]\n\n    if (NODE_ENV !== 'production') {\n      if (typeof reducers[key] === UNDEF) {\n        warning(`No reducer > ${key}`)\n      }\n    }\n\n    if (typeof reducers[key] === FUNC) {\n      finalReducers[key] = reducers[key]\n    }\n  }\n  const finalReducerKeys = Object.keys(finalReducers)\n\n  let unexpectedKeyCache\n  if (NODE_ENV !== 'production') {\n    unexpectedKeyCache = {}\n  }\n\n  let shapeAssertionError\n  try {\n    assertReducerShape(finalReducers)\n  } catch (e) {\n    shapeAssertionError = e\n  }\n\n  return function combination(state = {}, action) {\n    if (shapeAssertionError) {\n      throw shapeAssertionError\n    }\n\n    if (NODE_ENV !== 'production') {\n      const warningMessage = getUnexpectedStateShapeWarningMessage(state, finalReducers, action, unexpectedKeyCache)\n      if (warningMessage) {\n        warning(warningMessage)\n      }\n    }\n\n    let hasChanged = false\n    const nextState = {}\n    for (let i = 0; i < finalReducerKeys.length; i++) {\n      const key = finalReducerKeys[i]\n      const reducer = finalReducers[key]\n      const previousStateForKey = state[key]\n      const nextStateForKey = reducer(previousStateForKey, action)\n      if (typeof nextStateForKey === UNDEF) {\n        const errorMessage = getUndefinedStateErrorMessage(key, action)\n        throw new Error(errorMessage)\n      }\n      nextState[key] = nextStateForKey\n      hasChanged = hasChanged || nextStateForKey !== previousStateForKey\n    }\n    return hasChanged ? nextState : state\n  }\n}\n","/**\n * Composes single-argument functions from right to left. The rightmost\n * function can take multiple arguments as it provides the signature for\n * the resulting composite function.\n *\n * @param {...Function} funcs The functions to compose.\n * @returns {Function} A function obtained by composing the argument functions\n * from right to left. For example, compose(f, g, h) is identical to doing\n * (...args) => f(g(h(...args))).\n */\n\nexport default function compose(...funcs) {\n  if (funcs.length === 0) {\n    return arg => arg\n  }\n\n  if (funcs.length === 1) {\n    return funcs[0]\n  }\n\n  return funcs.reduce((a, b) => (...args) => a(b(...args)))\n}\n","import compose from './compose.js'\n\n/**\n * Creates a store enhancer that applies middleware to the dispatch method\n * of the Redux store. This is handy for a variety of tasks, such as expressing\n * asynchronous actions in a concise manner, or logging every action payload.\n *\n * See `redux-thunk` package as an example of the Redux middleware.\n *\n * Because middleware is potentially asynchronous, this should be the first\n * store enhancer in the composition chain.\n *\n * Note that each middleware will be given the `dispatch` and `getState` functions\n * as named arguments.\n *\n * @param {...Function} middlewares The middleware chain to be applied.\n * @returns {Function} A store enhancer applying the middleware.\n */\nexport default function applyMiddleware(...middlewares) {\n  return (createStore) => (reducer, preloadedState, enhancer) => {\n    const store = createStore(reducer, preloadedState, enhancer)\n    let dispatch = store.dispatch\n    let chain = []\n\n    const middlewareAPI = {\n      getState: store.getState,\n      dispatch: (action) => dispatch(action)\n    }\n    chain = middlewares.map(middleware => middleware(middlewareAPI))\n    dispatch = compose(...chain)(store.dispatch)\n\n    return {\n      ...store,\n      dispatch\n    }\n  }\n}\n","/**\n * Core Analytic constants. These are exposed for third party plugins & listeners\n * @typedef {Object} constants\n * @property {ANON_ID} ANON_ID - Anonymous visitor Id localstorage key\n * @property {USER_ID} USER_ID - Visitor Id localstorage key\n * @property {USER_TRAITS} USER_TRAITS - Visitor traits localstorage key\n */\nimport { PREFIX } from '@analytics/type-utils'\n\n\n/**\n * Anonymous visitor Id localstorage key\n * @typedef {String} ANON_ID\n */\nexport const ANON_ID = PREFIX + 'anon_id' // __anon_id\n/**\n * Visitor Id localstorage key\n * @typedef {String} USER_ID\n */\nexport const USER_ID = PREFIX + 'user_id' // __user_id\n/**\n * Visitor traits localstorage key\n * @typedef {String} USER_TRAITS\n */\nexport const USER_TRAITS = PREFIX + 'user_traits' // __user_traits\n","\nexport const LIB_NAME = 'analytics'\n\nexport const ID = 'userId'\n\nexport const ANONID = 'anonymousId'\n\nexport const ERROR_URL = 'https://lytics.dev/errors/'","/* Core Analytic Events */\n\nexport const coreEvents = [\n  /**\n   * `bootstrap` - Fires when analytics library starts up.\n   * This is the first event fired. '.on/once' listeners are not allowed on bootstrap\n   * Plugins can attach logic to this event\n   */\n  'bootstrap',\n  /**\n   * `params` - Fires when analytics parses URL parameters\n   */\n  'params',\n  /**\n   * `campaign` - Fires if params contain \"utm\" parameters\n   */\n  'campaign',\n  /**\n   * `initializeStart` - Fires before 'initialize', allows for plugins to cancel loading of other plugins\n   */\n  'initializeStart',\n  /**\n   * `initialize` - Fires when analytics loads plugins\n   */\n  'initialize',\n  /**\n   * `initializeEnd` - Fires after initialize, allows for plugins to run logic after initialization methods run\n   */\n  'initializeEnd',\n  /**\n   * `ready` - Fires when all analytic providers are fully loaded. This waits for 'initialize' and 'loaded' to return true\n   */\n  'ready',\n  /**\n   * `resetStart` - Fires if analytic.reset() is called.\n   * Use this event to cancel reset based on a specific condition\n   */\n  'resetStart',\n  /**\n   * `reset` - Fires if analytic.reset() is called.\n   * Use this event to run custom cleanup logic (if needed)\n   */\n  'reset',\n  /**\n   * `resetEnd` - Fires after analytic.reset() is called.\n   * Use this event to run a callback after user data is reset\n   */\n  'resetEnd',\n  /******************\n   * Page Events\n   ******************/\n  /**\n   * `pageStart` - Fires before 'page' events fire.\n   *  This allows for dynamic page view cancellation based on current state of user or options passed in.\n   */\n  'pageStart',\n  /**\n   * `page` - Core analytics hook for page views.\n   *  If your plugin or integration tracks page views, this is the event to fire on.\n   */\n  'page',\n  /**\n   * `pageEnd` - Fires after all registered 'page' methods fire.\n   */\n  'pageEnd',\n  /**\n   * `pageAborted` - Fires if 'page' call is cancelled by a plugin\n   */\n  'pageAborted',\n  /****************\n   * Track Events\n   ***************/\n  /**\n   * `trackStart` - Called before the 'track' events fires.\n   *  This allows for dynamic page view cancellation based on current state of user or options passed in.\n   */\n  'trackStart',\n  /**\n   * `track` - Core analytics hook for event tracking.\n   *  If your plugin or integration tracks custom events, this is the event to fire on.\n   */\n  'track',\n  /**\n   * `trackEnd` - Fires after all registered 'track' events fire from plugins.\n   */\n  'trackEnd',\n  /**\n   * `trackAborted` - Fires if 'track' call is cancelled by a plugin\n   */\n  'trackAborted',\n  /******************\n   * Identify Events\n   ******************/\n  /**\n   * `identifyStart` - Called before the 'identify' events fires.\n   * This allows for dynamic page view cancellation based on current state of user or options passed in.\n   */\n  'identifyStart',\n  /**\n   * `identify` - Core analytics hook for user identification.\n   *  If your plugin or integration identifies users or user traits, this is the event to fire on.\n   */\n  'identify',\n  /**\n   * `identifyEnd` - Fires after all registered 'identify' events fire from plugins.\n   */\n  'identifyEnd',\n  /**\n   * `identifyAborted` - Fires if 'track' call is cancelled by a plugin\n   */\n  'identifyAborted',\n  /**\n   * `userIdChanged` - Fires when a user id is updated\n   */\n  'userIdChanged',\n  /******************\n   * Plugin Events\n   ******************/\n  /**\n   * `registerPlugins` - Fires when analytics is registering plugins\n   */\n  'registerPlugins',\n  /**\n   * `enablePlugin` - Fires when 'analytics.plugins.enable()' is called\n   */\n  'enablePlugin',\n  /**\n   * `disablePlugin` - Fires when 'analytics.plugins.disable()' is called\n   */\n  'disablePlugin',\n  /*\n   * `loadPlugin` - Fires when 'analytics.loadPlugin()' is called\n   */\n  // 'loadPlugin',\n  /******************\n   * Browser activity events\n   ******************/\n  /**\n   * `online` - Fires when browser network goes online.\n   * This fires only when coming back online from an offline state.\n   */\n  'online',\n  /**\n   * `offline` - Fires when browser network goes offline.\n   */\n  'offline',\n  /******************\n   * Storage events\n   ******************/\n  /**\n   * `setItemStart` - Fires when analytics.storage.setItem is initialized.\n   * This event gives plugins the ability to intercept keys & values and alter them before they are persisted.\n   */\n  'setItemStart',\n  /**\n   * `setItem` - Fires when analytics.storage.setItem is called.\n   * This event gives plugins the ability to intercept keys & values and alter them before they are persisted.\n   */\n  'setItem',\n  /**\n   * `setItemEnd` - Fires when setItem storage is complete.\n   */\n  'setItemEnd',\n  /**\n   * `setItemAborted` - Fires when setItem storage is cancelled by a plugin.\n   */\n  'setItemAborted',\n  /**\n   * `removeItemStart` - Fires when analytics.storage.removeItem is initialized.\n   * This event gives plugins the ability to intercept removeItem calls and abort / alter them.\n   */\n  'removeItemStart',\n  /**\n   * `removeItem` - Fires when analytics.storage.removeItem is called.\n   * This event gives plugins the ability to intercept removeItem calls and abort / alter them.\n   */\n  'removeItem',\n  /**\n   * `removeItemEnd` - Fires when removeItem storage is complete.\n   */\n  'removeItemEnd',\n  /**\n   * `removeItemAborted` - Fires when removeItem storage is cancelled by a plugin.\n   */\n  'removeItemAborted',\n]\n\n/* Keys on a plugin that are not considered events */\nexport const nonEvents = ['name', 'EVENTS', 'config', 'loaded']\n\nconst pluginEvents = {\n  registerPluginType: (name) => `registerPlugin:${name}`,\n  pluginReadyType: (name) => `ready:${name}`,\n}\n\nconst EVENTS = coreEvents.reduce((acc, curr) => {\n  acc[curr] = curr\n  return acc\n}, pluginEvents)\n\nexport default EVENTS\n\nexport function isReservedAction(type) {\n  return coreEvents.includes(type)\n}\n","/* eslint-disable camelcase */\nimport EVENTS from '../events.js'\nimport { ANON_ID, USER_ID, USER_TRAITS } from '../constants.js'\n\nconst utmRegex = /^utm_/\nconst propRegex = /^an_prop_/\nconst traitRegex = /^an_trait_/\n\n// Middleware runs during EVENTS.initialize\nexport default function initializeMiddleware(instance) {\n  const { setItem } = instance.storage\n  return store => next => action => {\n    /* Handle bootstrap event */\n    if (action.type === EVENTS.bootstrap) {\n      const { params, user, persistedUser, initialUser } = action\n      const isKnownId = persistedUser.userId === user.userId\n      /* 1. Set anonymous ID */\n      if (persistedUser.anonymousId !== user.anonymousId) {\n        setItem(ANON_ID, user.anonymousId)\n      }\n      /* 2. Set userId */\n      if (!isKnownId) {\n        setItem(USER_ID, user.userId)\n      }\n      /* 3. Set traits if they are different */\n      if (initialUser.traits) {\n         setItem(USER_TRAITS, {\n          ...(isKnownId && persistedUser.traits) ? persistedUser.traits : {},\n          ...initialUser.traits\n        })\n        /* TODO multi user setup\n        setItem(`${USER_TRAITS}.${user.userId}`, {\n          ...(isKnownId) ? existingTraits : {},\n          ...initialUser.traits\n        })\n        */\n      }\n      /* 4. Parse url params */\n      const paramsArray = Object.keys(action.params)\n      if (paramsArray.length) {\n        const { an_uid, an_event } = params\n        const groupedParams = paramsArray.reduce((acc, key) => {\n          // match utm params & dclid (display) & gclid (cpc)\n          if (key.match(utmRegex) || key.match(/^(d|g)clid/)) {\n            const cleanName = key.replace(utmRegex, '')\n            const keyName = (cleanName === 'campaign') ? 'name' : cleanName\n            acc.campaign[keyName] = params[key]\n          }\n          if (key.match(propRegex)) {\n            acc.props[key.replace(propRegex, '')] = params[key]\n          }\n          if (key.match(traitRegex)) {\n            acc.traits[key.replace(traitRegex, '')] = params[key]\n          }\n          return acc\n        }, {\n          campaign: {},\n          props: {},\n          traits: {}\n        })\n\n        store.dispatch({\n          type: EVENTS.params,\n          raw: params,\n          ...groupedParams,\n          ...(an_uid ? { userId: an_uid } : {}),\n        })\n\n        /* If userId set, call identify */\n        if (an_uid) {\n          // timeout to debounce and make sure integration is registered. Todo refactor\n          setTimeout(() => instance.identify(an_uid, groupedParams.traits), 0)\n        }\n\n        /* If tracking event set, call track */\n        if (an_event) {\n          // timeout to debounce and make sure integration is registered. Todo refactor\n          setTimeout(() => instance.track(an_event, groupedParams.props), 0)\n        }\n\n        // if url has utm params\n        if (Object.keys(groupedParams.campaign).length) {\n          store.dispatch({\n            type: EVENTS.campaign,\n            campaign: groupedParams.campaign\n          })\n        }\n      }\n    }\n    return next(action)\n  }\n}\n","import { get } from '@analytics/global-storage-utils'\nimport { isObject, PREFIX } from '@analytics/type-utils'\nimport { ANON_ID, USER_ID, USER_TRAITS } from '../constants.js'\nimport EVENTS from '../events.js'\n\n/* user reducer */\nexport default function userReducer(storage) {\n  return function user(state = {}, action = {}) {\n\n    if (action.type === EVENTS.setItemEnd) {\n      // Set anonymousId if changed by storage.setItem\n      if (action.key === ANON_ID) {\n        return { ...state, ...{ anonymousId: action.value }}\n      }\n      // Set userId if changed by storage.setItem\n      if (action.key === USER_ID) {\n        return { ...state, ...{ userId: action.value }}\n      }\n    }\n\n    switch (action.type) {\n      case EVENTS.identify:\n        return Object.assign({}, state, {\n          userId: action.userId,\n          traits: {\n            ...state.traits,\n            ...action.traits\n          }\n        })\n      case EVENTS.reset:\n        // Side effect to fix race condition in Node. TODO refactor\n        // This is from default storage.removeItem: (key) => globalContext[key] = undefined\n        [ USER_ID, ANON_ID, USER_TRAITS ].forEach((key) => {\n          // sync storage, not instance.storage\n          storage.removeItem(key)\n        })\n        return Object.assign({}, state, {\n          userId: null,\n          // TODO reset anon id automatically?\n          anonymousId: null,\n          traits: {},\n        })\n      default:\n        return state\n    }\n  }\n}\n\nexport function getPersistedUserData(storage) {\n  return {\n    userId: storage.getItem(USER_ID),\n    anonymousId: storage.getItem(ANON_ID),\n    traits: storage.getItem(USER_TRAITS)\n  }\n}\n\nexport const tempKey = (key) => PREFIX + 'TEMP' + PREFIX + key\n\nexport function getUserPropFunc(storage) {\n  return function getUserProp(key, instance, payload) {\n    /* 1. Try current state */\n    const currentId = instance.getState('user')[key]\n    if (currentId) {\n      /*\n      console.log(`from state ${key}`, currentId)\n      /** */\n      return currentId\n    }\n\n    /* 2. Try event payload */\n    if (payload && isObject(payload) && payload[key]) {\n      /*\n      console.log(`from payload ${key}`, payload[key])\n      /** */\n      return payload[key]\n    }\n\n    /* 3. Try persisted data */\n    const persistedInfo = getPersistedUserData(storage)[key]\n    if (persistedInfo) {\n      /*\n      console.log(`from persistedInfo ${key}`, persistedInfo)\n      /** */\n      return persistedInfo\n    }\n\n    /* 4. Else, try to get in memory placeholder. TODO watch this for future issues */\n    return get(tempKey(key)) || null\n  }\n}\n","import { uuid } from 'analytics-utils'\nimport { remove } from '@analytics/global-storage-utils'\nimport { tempKey } from '../modules/user.js'\nimport { USER_ID, USER_TRAITS, ANON_ID } from '../constants.js'\nimport { ID, ANONID } from '../utils/internalConstants.js'\nimport EVENTS from '../events.js'\n\nexport default function identifyMiddleware(instance) {\n  const { setItem, removeItem, getItem } = instance.storage\n  return store => next => action => {\n    const { userId, traits, options } = action\n    /* Reset user id and traits */\n    if (action.type === EVENTS.reset) {\n      // Remove stored data\n      [ USER_ID, USER_TRAITS, ANON_ID ].forEach((key) => {\n        // Fires async removeItem dispatch\n        removeItem(key)\n      });\n      [ ID, ANONID, 'traits' ].forEach((key) => {\n        // Remove from global context\n        remove(tempKey(key))\n      })\n    }\n\n    if (action.type === EVENTS.identify) {\n      /* If no anon id. Set it! */\n      if (!getItem(ANON_ID)) {\n        setItem(ANON_ID, uuid())\n      }\n\n      const currentId = getItem(USER_ID)\n      const currentTraits = getItem(USER_TRAITS) || {}\n\n      if (currentId && (currentId !== userId)) {\n        store.dispatch({\n          type: EVENTS.userIdChanged,\n          old: {\n            userId: currentId,\n            traits: currentTraits,\n          },\n          new: {\n            userId,\n            traits\n          },\n          options: options,\n        })\n      }\n\n      /* Save user id */\n      if (userId) {\n        setItem(USER_ID, userId)\n      }\n\n      /* Save user traits */\n      if (traits) {\n        setItem(USER_TRAITS, {\n          ...currentTraits,\n          ...traits\n        })\n      }\n    }\n    return next(action)\n  }\n}\n","import { isFunction } from '@analytics/type-utils'\n\n// Stack to temporarily hold deferred promises/callbacks\nconst stack = {}\n\nfunction runCallback(id, payload) {\n  if (stack[id] && isFunction(stack[id])) {\n    // console.log(`run ${id}`)\n    stack[id](payload)\n    delete stack[id]\n  }\n}\n\nexport { stack, runCallback }","/**\n * Wait until a given analytics provider is ready.\n * @param  {Object} data - passthrough resolve data\n * @param  {Function} predicate - function that resolves true\n * @param  {Number} timeout - max wait time\n * @return {Promise}\n */\nexport default function waitForReady(data, predicate, timeout) {\n  return new Promise((resolve, reject) => {\n    if (predicate()) {\n      return resolve(data)\n    }\n    // Timeout. Add to queue\n    if (timeout < 1) {\n      return reject({ ...data, queue: true }) // eslint-disable-line\n    }\n    // Else recursive retry\n    return pause(10).then(_ => {\n      return waitForReady(data, predicate, timeout - 10).then(resolve, reject)\n    })\n  })\n}\n\nfunction pause(ms) {\n  return new Promise(resolve => setTimeout(resolve, ms))\n}\n","import { isFunction, isObject } from '@analytics/type-utils'\nimport { ID, ANONID } from './internalConstants.js'\n\nfunction abort(reason) {\n  return { abort: reason }\n}\n\nexport function processQueue(store, getPlugins, instance) {\n  const abortedCalls = {}\n  const pluginMethods = getPlugins()\n  const { plugins, context, queue, user } = store.getState()\n  const isOnline = !context.offline\n  /* If network connection found and there is items in queue, process them all */\n  if (isOnline && queue && queue.actions && queue.actions.length) {\n    const pipeline = queue.actions.reduce((acc, item, index) => {\n      const isLoaded = plugins[item.plugin].loaded\n      if (isLoaded) {\n        acc.process.push(item)\n        acc.processIndex.push(index)\n      } else {\n        acc.requeue.push(item)\n        acc.requeueIndex.push(index)\n      }\n      return acc\n    }, {\n      processIndex: [],\n      process: [],\n      requeue: [],\n      requeueIndex: []\n    })\n\n    if (pipeline.processIndex && pipeline.processIndex.length) {\n      pipeline.processIndex.forEach((i) => {\n        const processAction = queue.actions[i]\n        // console.log('RePROCESS THIS>', processAction)\n        // Call methods directly right now\n        const currentPlugin = processAction.plugin\n        const currentMethod = processAction.payload.type\n        const method = pluginMethods[currentPlugin][currentMethod]\n        if (method && isFunction(method)) {\n          /* enrich queued payload with userId / anon id if missing */\n          /* TODO hoist enrich into where action queued? */\n          // console.log('before', processAction.payload)\n          const enrichedPayload = enrich(processAction.payload, user)\n          // console.log('user.userId', user.userId)\n          // console.log('user.anonymousId', user.anonymousId)\n          // console.log('after enrich', enrichedPayload)\n          let retVal\n          const isAborted = abortedCalls[enrichedPayload.meta.rid]\n          /* if not aborted call method */\n          if (!isAborted) {\n            // TODO make async\n            retVal = method({\n              payload: enrichedPayload,\n              config: plugins[currentPlugin].config,\n              instance,\n              abort\n            })\n            // If aborted, cancel the downstream calls\n            if (retVal && isObject(retVal) && retVal.abort) {\n              abortedCalls[enrichedPayload.meta.rid] = true\n              return\n            }\n          }\n\n          /* Then redispatch for .on listeners / other middleware */\n          if (!isAborted) {\n            const pluginEvent = `${currentMethod}:${currentPlugin}`\n            store.dispatch({\n              ...enrichedPayload,\n              type: pluginEvent,\n              /* Internal data for analytics engine */\n              _: {\n                called: pluginEvent,\n                from: 'queueDrain'\n              }\n            })\n          }\n        }\n      })\n\n      /* Removed processed actions */\n      const reQueueActions = queue.actions.filter((value, index) => {\n        // note !~ === return pipeline.processIndex.indexOf(index) === -1\n        return !~pipeline.processIndex.indexOf(index)\n      })\n\n      /* Set queue actions. TODO refactor to non mutatable or move out of redux */\n      queue.actions = reQueueActions\n\n      /*\n      if (!reQueueActions.length) {\n        console.log('Queue clears')\n        console.log('abortedCalls', abortedCalls)\n      }\n      /** */\n    }\n  }\n}\n\n/* Heartbeat retries queued events */\nexport default function heartBeat(store, getPlugins, instance) {\n  // 3e3 === 3000 ms\n  return setInterval(() => processQueue(store, getPlugins, instance), 3e3)\n}\n\n// Assign userId && anonymousId values if present in payload but null\nfunction enrich(payload = {}, user = {}) {\n  return [ ID, ANONID ].reduce((acc, key) => {\n    if (payload.hasOwnProperty(key) && user[key] && (user[key] !== payload[key])) {\n      // console.log(`${key} stale update with ${user[key]}`)\n      acc[key] = user[key]\n    }\n    return acc\n  }, payload)\n}\n","import EVENTS from '../../events.js'\nimport fitlerDisabledPlugins from '../../utils/filterDisabled.js'\nimport { isFunction, isObject, isString } from '@analytics/type-utils'\nimport { runCallback } from '../../utils/callback-stack.js'\n\nconst endsWithStartRegex = /Start$/\nconst bootstrapRegex = /^bootstrap/\nconst readyRegex = /^ready/\n\nexport default async function (action, getPlugins, instance, store, eventsInfo) {\n  const pluginObject = isFunction(getPlugins) ? getPlugins() : getPlugins\n  const originalType = action.type\n  const updatedType = originalType.replace(endsWithStartRegex, '')\n\n  /* If action already dispatched exit early. This makes it so plugin methods are not fired twice. */\n  if (action._ && action._.called) {\n    // console.log('Already called', action._.called)\n    return action\n  }\n\n  const state = instance.getState()\n  /* Remove plugins that are disabled by options or by settings */\n  let activePlugins = fitlerDisabledPlugins(pluginObject, state.plugins, action.options)\n\n  /* If analytics.plugin.enable calls do special behavior */\n  if (originalType === EVENTS.initializeStart && action.fromEnable) {\n    // Return list of all enabled plugins that have NOT been initialized yet\n    activePlugins = Object.keys(state.plugins).filter((name) => {\n      const info = state.plugins[name]\n      return action.plugins.includes(name) && !info.initialized\n    }).map((name) => pluginObject[name])\n  }\n  // console.log(`engine activePlugins ${action.type}`, activePlugins)\n\n  const allActivePluginKeys = activePlugins.map((p) => p.name)\n  // console.log('allActivePluginKeys', allActivePluginKeys)\n  const allMatches = getAllMatchingCalls(originalType, activePlugins, pluginObject)\n  // console.log('allMatches', allMatches)\n\n  /* @TODO cache matches and purge on enable/disable/add plugin */\n\n  /**\n   * Process all 'actionBefore' hooks\n   * Example:\n   *  This is processes 'pageStart' methods from plugins and update the event to send through the chain\n   */\n  const actionBefore = await processEvent({\n    action: action,\n    data: {\n      exact: allMatches.before,\n      namespaced: allMatches.beforeNS\n    },\n    state: state,\n    allPlugins: pluginObject,\n    allMatches,\n    instance,\n    store,\n    EVENTS: eventsInfo\n  })\n  // console.log('____ actionBefore out', actionBefore)\n\n  /* Abort if ‘eventBefore’ returns abort data */\n  if (shouldAbortAll(actionBefore, allActivePluginKeys.length)) {\n    return actionBefore\n  }\n\n  /* Filter over the plugin method calls and remove aborted plugin by name */\n  // const activeAndNonAbortedCalls = activePlugins.filter((plugin) => {\n  //   if (shouldAbort(actionBefore, plugin.name)) return false\n  //   return true\n  // })\n  // console.log(`activeAndNonAbortedCalls ${action.type}`, activeAndNonAbortedCalls)\n\n  let actionDuring\n  if (originalType === updatedType) {\n    /* If type the same don't double process */\n    actionDuring = actionBefore\n  } else {\n    /**\n     * Process all 'action' hooks\n     * Example: This is process 'page' methods from plugins and update the event to send through\n     */\n    actionDuring = await processEvent({\n      action: {\n        ...actionBefore,\n        type: updatedType\n      },\n      data: {\n        exact: allMatches.during,\n        namespaced: allMatches.duringNS\n      },\n      state: state,\n      allPlugins: pluginObject,\n      allMatches,\n      instance,\n      store,\n      EVENTS: eventsInfo\n    })\n  }\n  // console.log('____ actionDuring', actionDuring)\n\n  /**\n   * Process all 'actionEnd' hooks\n   * Example:\n   *  This is process 'pageEnd' methods from plugins and update the event to send through\n   */\n  // Only trigger `eventTypeEnd` if originalAction has Start ending.\n  if (originalType.match(endsWithStartRegex)) {\n    const afterName = `${updatedType}End`\n    const actionAfter = await processEvent({\n      action: {\n        ...actionDuring,\n        type: afterName\n      },\n      data: {\n        exact: allMatches.after,\n        namespaced: allMatches.afterNS\n      },\n      state: state,\n      allPlugins: pluginObject,\n      allMatches,\n      instance,\n      store,\n      EVENTS: eventsInfo\n    })\n    // console.log('____ actionAfter', actionAfter)\n\n    /* Fire callback if supplied */\n    if (actionAfter.meta && actionAfter.meta.hasCallback) {\n      /*\n      console.log('End of engine action has callback')\n      console.log(actionAfter.meta)\n      console.log('stack', stack)\n      /** */\n\n      // @TODO figure out exact args calls and .on will get\n      runCallback(actionAfter.meta.rid, { payload: actionAfter })\n    }\n  }\n\n  return actionBefore\n}\n\n/**\n * Async reduce over matched plugin methods\n * Fires plugin functions\n */\nasync function processEvent({\n  data,\n  action,\n  instance,\n  state,\n  allPlugins,\n  allMatches,\n  store,\n  EVENTS\n}) {\n  const { plugins, context } = state\n  const method = action.type\n  const isStartEvent = method.match(endsWithStartRegex)\n  // console.log(`data ${method}`, data)\n  // console.log(`data allMatches ${method}`, allMatches)\n  let abortable = data.exact.map((x) => {\n    return x.pluginName\n  })\n\n  /* If abort is called from xyzStart */\n  if (isStartEvent) {\n    abortable = allMatches.during.map((x) => {\n      return x.pluginName\n    })\n  }\n\n  /* make args for functions to concume */\n  const makeArgs = argumentFactory(instance, abortable)\n  // console.log('makeArgs', makeArgs)\n\n  /* Check if plugin loaded, if not mark action for queue */\n  const queueData = data.exact.reduce((acc, thing) => {\n    const { pluginName, methodName } = thing\n    let addToQueue = false\n    // Queue actions if plugin not loaded except for initialize and reset\n    if (!methodName.match(/^initialize/) && !methodName.match(/^reset/)) {\n      addToQueue = !plugins[pluginName].loaded\n    }\n    /* If offline and its a core method. Add to queue */\n    if (context.offline && (methodName.match(/^(page|track|identify)/))) {\n      addToQueue = true\n    }\n    acc[`${pluginName}`] = addToQueue\n    return acc\n  }, {})\n\n  /* generate plugin specific payloads */\n  const payloads = await data.exact.reduce(async (scoped, curr, i) => {\n    const { pluginName } = curr\n    const curScope = await scoped\n    if (data.namespaced && data.namespaced[pluginName]) {\n      const scopedPayload = await data.namespaced[pluginName].reduce(async (acc, p, count) => {\n        // await value\n        const curScopeData = await acc\n        if (!p.method || !isFunction(p.method)) {\n          return curScopeData\n        }\n\n        /* Make sure plugins don’t call themselves */\n        validateMethod(p.methodName, p.pluginName)\n\n        function genAbort(currentAct, pname, otherPlug) {\n          return function (reason, plugins) {\n            const callsite = otherPlug || pname\n            // console.log(`__abort msg: ${reason}`)\n            // console.log(`__abort ${pname}`)\n            // console.log(`__abort xxx: ${plugins}`)\n            // console.log(`__abort otherPlug`, otherPlug)\n            return {\n              ...currentAct,\n              abort: {\n                reason: reason,\n                plugins: plugins || [pname],\n                caller: method,\n                from: callsite\n              }\n            }\n          }\n        }\n\n        const val = await p.method({\n          payload: curScopeData,\n          instance,\n          abort: genAbort(curScopeData, pluginName, p.pluginName),\n          config: getConfig(p.pluginName, plugins, allPlugins),\n          plugins: plugins\n        })\n        const returnValue = isObject(val) ? val : {}\n        return Promise.resolve({\n          ...curScopeData,\n          ...returnValue\n        })\n      }, Promise.resolve(action))\n\n      /* Set scoped payload */\n      curScope[pluginName] = scopedPayload\n    } else {\n      /* Set payload as default action */\n      curScope[pluginName] = action\n    }\n    return Promise.resolve(curScope)\n  }, Promise.resolve({}))\n  // console.log(`aaa scoped payloads ${action.type}`, payloads)\n\n  // Then call the normal methods with scoped payload\n  const resolvedAction = await data.exact.reduce(async (promise, curr, i) => {\n    const lastLoop = data.exact.length === (i + 1)\n    const { pluginName } = curr\n    const currentPlugin = allPlugins[pluginName]\n    const currentActionValue = await promise\n\n    let payloadValue = (payloads[pluginName]) ? payloads[pluginName] : {}\n    /* If eventStart, allow for value merging */\n    if (isStartEvent) {\n      payloadValue = currentActionValue\n    }\n\n    if (shouldAbort(payloadValue, pluginName)) {\n      // console.log(`> Abort from payload specific \"${pluginName}\" abort value`, payloadValue)\n      abortDispatch({\n        data: payloadValue,\n        method,\n        instance,\n        pluginName,\n        store\n      })\n      return Promise.resolve(currentActionValue)\n    }\n    if (shouldAbort(currentActionValue, pluginName)) {\n      // console.log(`> Abort from ${method} abort value`, currentActionValue)\n      if (lastLoop) {\n        abortDispatch({\n          data: currentActionValue,\n          method,\n          instance,\n          // pluginName,\n          store\n        })\n      }\n      return Promise.resolve(currentActionValue)\n    }\n\n    if (queueData.hasOwnProperty(pluginName) && queueData[pluginName] === true) {\n      // console.log('Queue this instead', pluginName)\n      store.dispatch({\n        type: `queue`,\n        plugin: pluginName,\n        payload: payloadValue,\n        /* Internal data for analytics engine */\n        _: {\n          called: `queue`,\n          from: 'queueMechanism' // for debugging\n        }\n      })\n      return Promise.resolve(currentActionValue)\n    }\n    /*\n    const checkForLoaded = () => {\n      const p = instance.getState('plugins')\n      return p[currentPlugin.name].loaded\n    }\n    // const p = instance.getState('plugins')\n    console.log(`loaded \"${currentPlugin.name}\" > ${method}:`, p[currentPlugin.name].loaded)\n    // await waitForReady(currentPlugin, checkForLoaded, 10000).then((d) => {\n    //   console.log(`Loaded ${method}`, currentPlugin.name)\n    // }).catch((e) => {\n    //   console.log(`Error ${method} ${currentPlugin.name}`, e)\n    //   // TODO dispatch failure\n    // })\n    */\n\n    // @TODO figure out if we want queuing semantics\n\n    const funcArgs = makeArgs(payloads[pluginName], allPlugins[pluginName])\n\n    // console.log(`funcArgs ${method} ${pluginName}`, funcArgs)\n\n    /* Run the plugin function */\n    const val = await currentPlugin[method]({\n      // currentPlugin: pluginName,\n      abort: funcArgs.abort,\n      // Send in original action value or scope payload\n      payload: payloadValue,\n      instance,\n      config: getConfig(pluginName, plugins, allPlugins),\n      plugins: plugins\n    })\n\n    const returnValue = isObject(val) ? val : {}\n    const merged = {\n      ...currentActionValue,\n      ...returnValue\n    }\n\n    const scopedPayload = payloads[pluginName] // || currentActionValue\n    if (shouldAbort(scopedPayload, pluginName)) {\n      // console.log(`>> HANDLE abort ${method} ${pluginName}`)\n      abortDispatch({\n        data: scopedPayload,\n        method,\n        instance,\n        pluginName,\n        store\n      })\n    } else {\n      const nameSpaceEvent = `${method}:${pluginName}`\n      const actionDepth = (nameSpaceEvent.match(/:/g) || []).length\n      if (actionDepth < 2 && !method.match(bootstrapRegex) && !method.match(readyRegex)) {\n        const updatedPayload = (isStartEvent) ? merged : payloadValue\n        // Dispatched for `.on('xyz') listeners.\n        instance.dispatch({\n          ...updatedPayload,\n          type: nameSpaceEvent,\n          _: {\n            called: nameSpaceEvent,\n            from: 'submethod'\n          }\n        })\n      }\n    }\n    // console.log('merged', merged)\n    return Promise.resolve(merged)\n  }, Promise.resolve(action))\n\n  // Dispatch End. Make sure actions don't get double dispatched. EG userIdChanged\n  if (!method.match(endsWithStartRegex) &&\n      !method.match(/^registerPlugin/) &&\n      // !method.match(/^disablePlugin/) &&\n      // !method.match(/^enablePlugin/) &&\n      !method.match(readyRegex) &&\n      !method.match(bootstrapRegex) &&\n      !method.match(/^params/) &&\n      !method.match(/^userIdChanged/)\n  ) {\n    if (EVENTS.plugins.includes(method)) {\n      // console.log(`Dont dispatch for ${method}`, resolvedAction)\n      // return resolvedAction\n    }\n    /*\n      Verify this original action setup.\n      It's intended to keep actions from double dispatching themselves\n    */\n    if (resolvedAction._ && resolvedAction._.originalAction === method) {\n      // console.log(`Dont dispatch for ${method}`, resolvedAction)\n      return resolvedAction\n    }\n\n    let endAction = {\n      ...resolvedAction,\n      ...{\n        _: {\n          originalAction: resolvedAction.type,\n          called: resolvedAction.type,\n          from: 'engineEnd'\n        }\n      }\n    }\n\n    /* If all plugins are aborted, dispatch xAborted */\n    if (shouldAbortAll(resolvedAction, data.exact.length) && !method.match(/End$/)) {\n      endAction = {\n        ...endAction,\n        ...{\n          type: resolvedAction.type + 'Aborted',\n        }\n      }\n    }\n\n    store.dispatch(endAction)\n  }\n\n  return resolvedAction\n}\n\nfunction abortDispatch({ data, method, instance, pluginName, store }) {\n  const postFix = (pluginName) ? ':' + pluginName : ''\n  const abortEvent = method + 'Aborted' + postFix\n  store.dispatch({\n    ...data,\n    type: abortEvent,\n    _: {\n      called: abortEvent,\n      from: 'abort'\n    }\n  })\n}\n\nfunction getConfig(name, pluginState, allPlugins) {\n  const pluginData = pluginState[name] || allPlugins[name]\n  if (pluginData && pluginData.config) {\n    return pluginData.config\n  }\n  return {}\n}\n\nfunction getPluginFunctions(methodName, plugins) {\n  return plugins.reduce((arr, plugin) => {\n    return (!plugin[methodName]) ? arr : arr.concat({\n      methodName: methodName,\n      pluginName: plugin.name,\n      method: plugin[methodName],\n    })\n  }, [])\n}\n\nfunction formatMethod(type) {\n  return type.replace(endsWithStartRegex, '')\n}\n\n/**\n * Return array of event names\n * @param  {String} eventType - original event type\n * @param  {String} namespace - optional namespace postfix\n * @return {array} - type, method, end\n */\nfunction getEventNames(eventType, namespace) {\n  const method = formatMethod(eventType)\n  const postFix = (namespace) ? `:${namespace}` : ''\n  // `typeStart:pluginName`\n  const type = `${eventType}${postFix}`\n  // `type:pluginName`\n  const methodName = `${method}${postFix}`\n  // `typeEnd:pluginName`\n  const end = `${method}End${postFix}`\n  return [ type, methodName, end ]\n}\n\n/* Collect all calls for a given event in the system */\nfunction getAllMatchingCalls(eventType, activePlugins, allPlugins) {\n  const eventNames = getEventNames(eventType)\n  // console.log('eventNames', eventNames)\n  // 'eventStart', 'event', & `eventEnd`\n  const core = eventNames.map((word) => {\n    return getPluginFunctions(word, activePlugins)\n  })\n  // Gather nameSpaced Events\n  return activePlugins.reduce((acc, plugin) => {\n    const { name } = plugin\n    const nameSpacedEvents = getEventNames(eventType, name)\n    // console.log('eventNames namespaced', nameSpacedEvents)\n    const [ beforeFuncs, duringFuncs, afterFuncs ] = nameSpacedEvents.map((word) => {\n      return getPluginFunctions(word, activePlugins)\n    })\n\n    if (beforeFuncs.length) {\n      acc.beforeNS[name] = beforeFuncs\n    }\n    if (duringFuncs.length) {\n      acc.duringNS[name] = duringFuncs\n    }\n    if (afterFuncs.length) {\n      acc.afterNS[name] = afterFuncs\n    }\n    return acc\n  }, {\n    before: core[0],\n    beforeNS: {},\n    during: core[1],\n    duringNS: {},\n    after: core[2],\n    afterNS: {}\n  })\n}\n\nfunction shouldAbort({ abort }, pluginName) {\n  if (!abort) return false\n  if (abort === true) return true\n  return includes(abort, pluginName) || (abort && includes(abort.plugins, pluginName))\n}\n\nfunction shouldAbortAll({ abort }, pluginsCount) {\n  if (!abort) return false\n  if (abort === true || isString(abort)) return true\n  const { plugins } = abort\n  return (isArray(abort) && (abort.length === pluginsCount)) || (isArray(plugins) && (plugins.length === pluginsCount))\n}\n\nfunction isArray(arr) {\n  return Array.isArray(arr)\n}\n\nfunction includes(arr, name) {\n  if (!arr || !isArray(arr)) return false\n  return arr.includes(name)\n}\n\n/**\n * Generate arguments to pass to plugin methods\n * @param  {Object} instance - analytics instance\n * @param  {array} abortablePlugins - plugins that can be cancelled by caller\n * @return {*} function to inject plugin params\n */\nfunction argumentFactory(instance, abortablePlugins) {\n  // console.log('abortablePlugins', abortablePlugins)\n  return function (action, plugin, otherPlugin) {\n    const { config, name } = plugin\n    let method = `${name}.${action.type}`\n    if (otherPlugin) {\n      method = otherPlugin.event\n    }\n\n    const abortF = (action.type.match(endsWithStartRegex))\n      ? abortFunction(name, method, abortablePlugins, otherPlugin, action)\n      : notAbortableError(action, method)\n\n    return {\n      /* self: plugin, for future maybe */\n      // clone objects to avoid reassign\n      payload: formatPayload(action),\n      instance: instance,\n      config: config || {},\n      abort: abortF\n    }\n  }\n}\n\nfunction abortFunction(pluginName, method, abortablePlugins, otherPlugin, action) {\n  return function (reason, plugins) {\n    const caller = (otherPlugin) ? otherPlugin.name : pluginName\n    let pluginsToAbort = (plugins && isArray(plugins)) ? plugins : abortablePlugins\n    if (otherPlugin) {\n      pluginsToAbort = (plugins && isArray(plugins)) ? plugins : [pluginName]\n      if (!pluginsToAbort.includes(pluginName) || pluginsToAbort.length !== 1) {\n        throw new Error(`Method ${method} can only abort ${pluginName} plugin. ${JSON.stringify(pluginsToAbort)} input valid`)\n      }\n    }\n    return {\n      ...action, // 🔥 todo verify this merge is ok\n      abort: {\n        reason: reason,\n        plugins: pluginsToAbort,\n        caller: method,\n        _: caller\n      }\n    }\n  }\n}\n\nfunction notAbortableError(action, method) {\n  return () => {\n    throw new Error(action.type + ' action not cancellable. Remove abort in ' + method)\n  }\n}\n\n/**\n * Verify plugin is not calling itself with whatever:myPluginName self refs\n */\nfunction validateMethod(actionName, pluginName) {\n  const text = getNameSpacedAction(actionName)\n  const methodCallMatchesPluginNamespace = text && (text.name === pluginName)\n  if (methodCallMatchesPluginNamespace) {\n    const sub = getNameSpacedAction(text.method)\n    const subText = (sub) ? 'or ' + sub.method : ''\n    throw new Error([ pluginName + ' plugin is calling method ' + actionName,\n      'Plugins cant call self',\n      `Use ${text.method} ${subText} in ${pluginName} plugin insteadof ${actionName}`]\n      .join('\\n')\n    )\n  }\n}\n\nfunction getNameSpacedAction(event) {\n  const split = event.match(/(.*):(.*)/)\n  if (!split) {\n    return false\n  }\n  return {\n    method: split[1],\n    name: split[2],\n  }\n}\n\nfunction formatPayload(action) {\n  return Object.keys(action).reduce((acc, key) => {\n    // redact type from { payload }\n    if (key === 'type') {\n      return acc\n    }\n    if (isObject(action[key])) {\n      acc[key] = Object.assign({}, action[key])\n    } else {\n      acc[key] = action[key]\n    }\n    return acc\n  }, {})\n}\n\n/*\nfunction getMatchingMethods(eventType, activePlugins) {\n  const exact = getPluginFunctions(eventType, activePlugins)\n  // console.log('exact', exact)\n  // Gather nameSpaced Events\n  return activePlugins.reduce((acc, plugin) => {\n    const { name } = plugin\n    const clean = getPluginFunctions(`${eventType}:${name}`, activePlugins)\n    if (clean.length) {\n      acc.namespaced[name] = clean\n    }\n    return acc\n  }, {\n    exact: exact,\n    namespaced: {}\n  })\n}\n*/\n","import EVENTS, { nonEvents } from '../../events.js'\nimport { runCallback, stack } from '../../utils/callback-stack.js'\nimport waitForReady from '../../utils/waitForReady.js'\nimport { processQueue } from '../../utils/heartbeat.js'\nimport runPlugins from './engine.js'\n\nexport default function pluginMiddleware(instance, getPlugins, systemEvents) {\n  const isReady = {}\n  return store => next => async action => {\n    const { type, abort, plugins } = action\n    let updatedAction = action\n\n    if (abort) {\n      return next(action)\n    }\n\n    /* Analytics.plugins.enable called, we need to init the plugins */\n    if (type === EVENTS.enablePlugin) {\n      store.dispatch({\n        type: EVENTS.initializeStart,\n        plugins: plugins,\n        disabled: [],\n        fromEnable: true,\n        meta: action.meta\n      })\n    }\n    \n    if (type === EVENTS.disablePlugin) {\n      // If cached callback, resolve promise/run callback. debounced to fix race condition\n      setTimeout(() => runCallback(action.meta.rid, { payload: action }), 0)\n    }\n\n    /* @TODO implement\n    if (type === EVENTS.loadPlugin) {\n      // Rerun initialize calls in plugins\n      const allPlugins = getPlugins()\n      const pluginsToLoad = Object.keys(allPlugins).filter((name) => {\n        return plugins.includes(name)\n      }).reduce((acc, curr) => {\n        acc[curr] = allPlugins[curr]\n        return acc\n      }, {})\n      const initializeAction = {\n        type: EVENTS.initializeStart,\n        plugins: plugins\n      }\n      const updated = await runPlugins(initializeAction, pluginsToLoad, instance, store, systemEvents)\n      return next(updated)\n    }\n    */\n\n    //  || type.match(/^initializeAbort:/)\n    if (type === EVENTS.initializeEnd) {\n      const allPlugins = getPlugins()\n      const pluginsArray = Object.keys(allPlugins)\n      const allRegisteredPlugins = pluginsArray.filter((name) => {\n        return plugins.includes(name)\n      }).map((name) => {\n        return allPlugins[name]\n      })\n      let completed = []\n      let failed = []\n      let disabled = action.disabled\n      // console.log('allRegisteredPlugins', allRegisteredPlugins)\n      const waitForPluginsToLoad = allRegisteredPlugins.map((plugin) => {\n        const { loaded, name, config } = plugin\n        const loadedFn = () => loaded({ config }) // @TODO add in more to api to match other funcs?\n        /* Plugins will abort trying to load after 10 seconds. 1e4 === 10000 MS */\n        return waitForReady(plugin, loadedFn, 1e4).then((d) => {\n          if (!isReady[name]) {\n            // only dispatch namespaced rdy once\n            store.dispatch({\n              type: EVENTS.pluginReadyType(name), // `ready:${name}`\n              name: name,\n              events: Object.keys(plugin).filter((name) => {\n                return !nonEvents.includes(name)\n              })\n            })\n            isReady[name] = true\n          }\n          completed = completed.concat(name)\n\n          return plugin\n          // It's loaded! run the command\n        }).catch((e) => {\n          // Timeout Add to queue\n          // console.log('Error generic waitForReady. Push this to queue', e)\n          if (e instanceof Error) {\n            throw new Error(e)\n          }\n          failed = failed.concat(e.name)\n          // Failed to fire, add to queue\n          return e\n        })\n      })\n\n      Promise.all(waitForPluginsToLoad).then((calls) => {\n        // setTimeout to ensure runs after 'page'\n        const payload = {\n          plugins: completed,\n          failed: failed,\n          disabled: disabled\n        }\n        setTimeout(() => {\n          if (pluginsArray.length === (waitForPluginsToLoad.length + disabled.length)) {\n            store.dispatch({\n              ...{ type: EVENTS.ready },\n              ...payload,\n              \n            })\n          }\n        }, 0)\n      })\n    }\n\n    /* New plugin system */\n    if (type !== EVENTS.bootstrap) {\n      if (/^ready:([^:]*)$/.test(type)) {\n        // Immediately flush queue\n        setTimeout(() => processQueue(store, getPlugins, instance), 0)\n      }\n      const updated = await runPlugins(action, getPlugins, instance, store, systemEvents)\n      return next(updated)\n    }\n\n    return next(updatedAction)\n  }\n}\n","import { isBoolean } from '@analytics/type-utils'\n\nexport default function fitlerDisabledPlugins(allPlugins, settings = {}, options = {}) {\n  return Object.keys(allPlugins).filter((name) => {\n    const fromCallOptions = options.plugins || {}\n    // If enabled/disabled by options. Override settings\n    if (isBoolean(fromCallOptions[name])) {\n      return fromCallOptions[name]\n    }\n    // If all: false disable everything unless true explicitly set\n    if (fromCallOptions.all === false) {\n      return false\n    }\n    // else use state.plugin settings\n    if (settings[name] && settings[name].enabled === false) {\n      return false\n    }\n    return true\n  }).map((name) => allPlugins[name])\n}\n","import EVENTS from '../events.js'\n\nexport default function storageMiddleware(storage) {\n  return store => next => action => {\n    const { type, key, value, options } = action\n    if (type === EVENTS.setItem || type === EVENTS.removeItem) {\n      if (action.abort) {\n        return next(action)\n      }\n      // Run storage set or remove\n      if (type === EVENTS.setItem) {\n        storage.setItem(key, value, options)\n      } else {\n        storage.removeItem(key, options)\n      }\n    }\n    return next(action)\n  }\n}\n\n/*\n  Todo: emit events for keys we care about\n  window.addEventListener('storage', (event) => console.log(event));\n*/\n","import { compose } from '../vendor/redux/index.js'\n\n/* Class to fix dynamic middlewares from conflicting with each other\nif more than one analytic instance is active */\nexport default class DynamicMiddleware {\n  before = []\n  after = []\n  addMiddleware = (middlewares, position) => {\n    this[position] = this[position].concat(middlewares)\n  }\n  removeMiddleware = (middleware, position) => {\n    const index = this[position].findIndex(d => d === middleware)\n    if (index === -1) return\n\n    this[position] = [\n      ...this[position].slice(0, index),\n      ...this[position].slice(index + 1),\n    ]\n  }\n  /* Not currently in use\n  resetMiddlewares = (position) => {\n    if (!position) {\n      this.before = []\n      this.after = []\n    } else {\n      this[position] = []\n    }\n  }\n  */\n  dynamicMiddlewares = (position) => {\n    return store => next => action => {\n      const middlewareAPI = {\n        getState: store.getState,\n        dispatch: (act) => store.dispatch(act),\n      }\n      const chain = this[position].map(middleware => middleware(middlewareAPI))\n      return compose(...chain)(next)(action)\n    }\n  }\n}\n","// Integrations Reducer. Follows ducks pattern http://bit.ly/2DnERMc\nimport EVENTS from '../events.js'\n\nexport default function createReducer(getPlugins) {\n  return function plugins(state = {}, action) {\n    let newState = {}\n    if (action.type === 'initialize:aborted') {\n      return state\n    }\n    if (/^registerPlugin:([^:]*)$/.test(action.type)) {\n      const name = getNameFromEventType(action.type, 'registerPlugin')\n      const plugin = getPlugins()[name]\n      if (!plugin || !name) {\n        return state\n      }\n      const isEnabled = action.enabled\n      const config = plugin.config\n      newState[name] = {\n        enabled: isEnabled,\n        /* if no initialization method. Set initialized true */\n        initialized: (isEnabled) ? Boolean(!plugin.initialize) : false,\n        /* If plugin enabled === false, set loaded to false, else check plugin.loaded function */\n        loaded: (isEnabled) ? Boolean(plugin.loaded({ config })) : false,\n        config\n      }\n      return { ...state, ...newState }\n    }\n    if (/^initialize:([^:]*)$/.test(action.type)) {\n      const name = getNameFromEventType(action.type, EVENTS.initialize)\n      const plugin = getPlugins()[name]\n      if (!plugin || !name) {\n        return state\n      }\n      const config = plugin.config\n      newState[name] = {\n        ...state[name],\n        ...{\n          initialized: true,\n          /* check plugin.loaded function */\n          loaded: Boolean(plugin.loaded({ config }))\n        }\n      }\n      return { ...state, ...newState }\n    }\n    if (/^ready:([^:]*)$/.test(action.type)) {\n      // const name = getNameFromEventType(action.type, 'ready')\n      newState[action.name] = {\n        ...state[action.name],\n        ...{ loaded: true }\n      }\n      return { ...state, ...newState }\n    }\n    switch (action.type) {\n      /* case EVENTS.pluginFailed:\n        // console.log('PLUGIN_FAILED', action.name)\n        newState[action.name] = {\n          ...state[action.name],\n          ...{ loaded: false }\n        }\n        return { ...state, ...newState }\n      */\n      /* When analytics.plugins.disable called */\n      case EVENTS.disablePlugin:\n        return { \n          ...state,\n          ...togglePluginStatus(action.plugins, false, state)\n        }\n      /* When analytics.plugins.enable called */\n      case EVENTS.enablePlugin:\n        return {\n          ...state, \n          ...togglePluginStatus(action.plugins, true, state)\n        }\n      default:\n        return state\n    }\n  }\n}\n\nfunction getNameFromEventType(type, baseName) {\n  return type.substring(baseName.length + 1, type.length)\n}\n\nfunction togglePluginStatus(plugins, status, currentState) {\n  return plugins.reduce((acc, pluginKey) => {\n    acc[pluginKey] = {\n      ...currentState[pluginKey],\n      ...{\n        enabled: status \n      }\n    }\n    return acc\n  }, currentState)\n}\n","export default function serialize(obj) {\n  try {\n   return JSON.parse(JSON.stringify(obj))\n  } catch (err) {}\n  return obj\n}","// Track Module. Follows ducks pattern http://bit.ly/2DnERMc\nimport EVENTS from '../events.js'\nimport serialize from '../utils/serialize.js'\n\n// Track State\nconst initialState = {\n  last: {},\n  history: [],\n}\n\n// track reducer\nexport default function trackReducer(state = initialState, action) {\n  const { type, event, properties, options, meta } = action\n\n  switch (type) {\n    case EVENTS.track:\n      const trackEvent = serialize({\n        event,\n        properties,\n        ...(Object.keys(options).length) && { options: options },\n        meta\n      })\n      return {\n        ...state,\n        ...{\n          last: trackEvent,\n          // Todo prevent LARGE arrays https://bit.ly/2MnBwPT\n          history: state.history.concat(trackEvent)\n        }\n      }\n    default:\n      return state\n  }\n}\n","import EVENTS from '../events.js'\n/*\nTODO figure out if this should live in state...\nQueue could be in mermory as well.\nBut also needs to be persisted to storage\n*/\n\nconst initialState = {\n  actions: [],\n}\n\nexport default function queueReducer(state = initialState, action) {\n  const { type, payload } = action\n\n  switch (type) {\n    case 'queue':\n      let actionChain\n      /* prioritize identify in event queue */\n      if (payload && payload.type && payload.type === EVENTS.identify) {\n        actionChain = [action].concat(state.actions)\n      } else {\n        actionChain = state.actions.concat(action)\n      }\n      return {\n        ...state,\n        actions: actionChain\n      }\n    case 'dequeue':\n      return []\n    // todo push events to history\n    default:\n      return state\n  }\n}\n\nexport const queueAction = (data, timestamp) => {\n  return {\n    type: 'queue',\n    timestamp: timestamp,\n    data: data\n  }\n}\n","// Page View Reducer. Follows ducks pattern http://bit.ly/2DnERMc\nimport { isBrowser } from '@analytics/type-utils'\nimport serialize from '../utils/serialize.js'\n\nimport EVENTS from '../events.js'\n\nconst hashRegex = /#.*$/\n\nfunction canonicalUrl() {\n  if (!isBrowser) return\n  const tags = document.getElementsByTagName('link')\n  for (var i = 0, tag; tag = tags[i]; i++) {\n    if (tag.getAttribute('rel') === 'canonical') {\n      return tag.getAttribute('href')\n    }\n  }\n}\n\nfunction urlPath(url) {\n  const regex = /(http[s]?:\\/\\/)?([^\\/\\s]+\\/)(.*)/g\n  const matches = regex.exec(url)\n  const pathMatch = (matches && matches[3]) ? matches[3].split('?')[0].replace(hashRegex, '') : ''\n  return '/' + pathMatch\n}\n\n/**\n * Return the canonical URL and rmove the hash.\n * @param  {string} search - search param\n * @return {string} return current canonical URL\n */\nfunction currentUrl(search) {\n  const canonical = canonicalUrl()\n  if (!canonical) return window.location.href.replace(hashRegex, '')\n  return canonical.match(/\\?/) ? canonical : canonical + search\n}\n\n/**\n * Page data for overides\n * @typedef {object} PageData\n * @property {string} [title] - Page title\n * @property {string} [url] - Page url\n * @property {string} [path] - Page path\n * @property {string} [search] - Page search\n * @property {string} [width] - Page width\n * @property {string} [height] - Page height\n*/\n\n/**\n * Get information about current page\n * @typedef {Function} getPageData\n * @param  {PageData} [pageData = {}] - Page data overides\n * @return {PageData} resolved page data\n */\nexport const getPageData = (pageData = {}) => {\n  if (!isBrowser) return pageData\n  const { title, referrer } = document\n  const { location, innerWidth, innerHeight } = window\n  const { hash, search } = location\n  const url = currentUrl(search)\n  const page = {\n    title: title,\n    url: url,\n    path: urlPath(url),\n    hash: hash,\n    search: search,\n    width: innerWidth,\n    height: innerHeight,\n  }\n  if (referrer && referrer !== '') {\n    page.referrer = referrer\n  }\n\n  return {\n    ...page,\n    /* .page() user overrrides */\n    ...pageData\n  }\n}\n\nconst initialState = {\n  last: {},\n  history: [],\n}\n\n// page reducer\nexport default function page(state = initialState, action) {\n  const { properties, options, meta } = action\n  switch (action.type) {\n    case EVENTS.page:\n      const viewData = serialize({\n        properties,\n        meta,\n        ...(Object.keys(options).length) && { options: options },\n      })\n      return {\n        ...state,\n        ...{\n          last: viewData,\n          // Todo prevent LARGE arrays https://bit.ly/2MnBwPT\n          history: state.history.concat(viewData)\n        }\n      }\n    default:\n      return state\n  }\n}\n","// Context Reducer.  Follows ducks pattern http://bit.ly/2DnERMc\nimport { getBrowserLocale, getTimeZone, uuid } from 'analytics-utils'\nimport { isBrowser } from '@analytics/type-utils'\nimport EVENTS from '../events.js'\nimport { LIB_NAME } from '../utils/internalConstants.js'\nimport getOSNameNode from '../utils/getOSName/node.js'\nimport getOSNameBrowser from '../utils/getOSName/browser.js'\n\nlet osName\nlet referrer\nlet locale\nlet timeZone\nif (BROWSER) {\n  osName = getOSNameBrowser()\n  referrer = (isBrowser) ? document.referrer : null\n  locale = getBrowserLocale()\n  timeZone = getTimeZone()\n} else {\n  osName = getOSNameNode()\n  referrer = {}\n}\n\nconst initialState = {\n  initialized: false,\n  sessionId: uuid(),\n  app: null,\n  version: null,\n  debug: false,\n  offline: (isBrowser) ? !navigator.onLine : false, // use node network is-online\n  os: {\n    name: osName,\n  },\n  userAgent: (isBrowser) ? navigator.userAgent : 'node', // https://github.com/bestiejs/platform.js\n  library: {\n    name: LIB_NAME,\n    // TODO fix version number. npm run publish:patch has wrong version\n    version: VERSION\n  },\n  timezone: timeZone,\n  locale: locale,\n  campaign: {},\n  referrer: referrer,\n}\n\n// context reducer\nexport default function context(state = initialState, action) {\n  const { initialized } = state\n  const { type, campaign } = action\n  switch (type) {\n    case EVENTS.campaign:\n      return {\n        ...state,\n        ...{ campaign: campaign }\n      }\n    case EVENTS.offline:\n      return {\n        ...state,\n        ...{ offline: true }\n      }\n    case EVENTS.online:\n      return {\n        ...state,\n        ...{ offline: false }\n      }\n    default:\n      if (!initialized) {\n        return {\n          ...initialState,\n          ...state,\n          ...{ initialized: true }\n        }\n      }\n      return state\n  }\n}\n\nconst excludeItems = ['plugins', 'reducers', 'storage']\n// Pull plugins and reducers off intital config\nexport function makeContext(config) {\n  return Object.keys(config).reduce((acc, current) => {\n    if (excludeItems.includes(current)) {\n      return acc\n    }\n    acc[current] = config[current]\n    return acc\n  }, {})\n}\n","import { isBrowser } from '@analytics/type-utils'\n\nexport default function getBrowserOS() {\n  if (!isBrowser) return false\n  const os = navigator.appVersion\n  // ~os bitwise operator to check if in navigator\n  if (~os.indexOf('Win')) return 'Windows'\n  if (~os.indexOf('Mac')) return 'MacOS'\n  if (~os.indexOf('X11')) return 'UNIX'\n  if (~os.indexOf('Linux')) return 'Linux'\n  // default\n  return 'Unknown OS'\n}\n","import { isBrowser } from '@analytics/type-utils'\n\nfunction listen(events, func, toAdd) {\n  if (!isBrowser) return\n  const fn = window[(toAdd ? 'add' : 'remove') + 'EventListener']\n  events.split(' ').forEach(ev => {\n    fn(ev, func)\n  })\n}\n\nexport function check() {\n  return Promise.resolve(!navigator.onLine)\n}\n\nexport function watch(cb) {\n  const fn = _ => check().then(cb)\n  const listener = listen.bind(null, 'online offline', fn)\n  listener(true)\n  // return unsubscribe function\n  return _ => listener(false)\n}\n","import { set, globalContext, KEY } from '@analytics/global-storage-utils'\nimport { compose } from '../vendor/redux/index.js'\nimport { LIB_NAME } from './internalConstants.js'\n\nexport function Debug() {\n  // Global key is window.__global__.analytics\n  set(LIB_NAME, [])\n  // Return debugger\n  return (createStore) => {\n    return (reducer, preloadedState, enhancer) => {\n      const store = createStore(reducer, preloadedState, enhancer)\n      const origDispatch = store.dispatch\n      const dispatch = (action) => {\n        const a = action.action || action\n        globalContext[KEY][LIB_NAME].push(a)\n        return origDispatch(action)\n      }\n      return Object.assign(store, { dispatch: dispatch })\n    }\n  }\n}\n\nexport function composeWithDebug(config) {\n  return function () {\n    return compose(compose.apply(null, arguments), Debug(config))\n  }\n}\n","import { isArray } from '@analytics/type-utils'\n\nexport default function ensureArray(singleOrArray) {\n  if (!singleOrArray) return []\n  if (isArray(singleOrArray)) return singleOrArray\n  return [singleOrArray] \n}","import getCallback from './getCallback.js'\nimport { stack } from './callback-stack.js'\nimport timestamp from './timestamp.js'\nimport { uuid } from 'analytics-utils'\n\n// Async promise resolver\nfunction deferredPromiseResolver(resolver, callback) {\n  return (data) => {\n    if (callback) callback(data)\n    resolver(data)\n  }\n}\n\nexport default function generateMeta(meta = {}, resolve, possibleCallbacks) {\n    const rid = uuid()\n    if (resolve) {\n      // stack[`${rid}-info`] = meta\n      stack[rid] = deferredPromiseResolver(resolve, getCallback(possibleCallbacks))\n    }\n    return {\n      ...meta,\n      rid: rid,\n      ts: timestamp(),\n      ...(!resolve) ? {} : { hasCallback: true },\n    }\n  }","import { isFunction } from '@analytics/type-utils'\n\n/**\n * Grab first function found from arguments\n * @param {array} [argArray] - arguments array to find first function\n * @returns {Function|undefined}\n */\nexport default function getCallbackFromArgs(argArray) {\n  const args = argArray || Array.prototype.slice.call(arguments)\n  let cb\n  for (let i = 0; i < args.length; i++) {\n    if (isFunction(args[i])) {\n      cb = args[i]; break;\n    }\n  }\n  return cb\n}","\nexport default function timeStamp() {\n  return new Date().getTime()\n}\n","import { uuid, paramsParse, dotProp } from 'analytics-utils'\nimport { get, set, remove } from '@analytics/global-storage-utils'\nimport { isBrowser, isFunction, isObject, isString } from '@analytics/type-utils'\nimport { createStore, combineReducers, applyMiddleware, compose } from './vendor/redux/index.js'\nimport * as CONSTANTS from './constants.js'\nimport { ID, ANONID, ERROR_URL } from './utils/internalConstants.js'\nimport EVENTS, { coreEvents, nonEvents, isReservedAction } from './events.js'\n// Middleware\nimport * as middleware from './middleware/index.js'\nimport DynamicMiddleware from './middleware/dynamic.js'\n// Modules\nimport pluginsMiddleware from './modules/plugins.js'\nimport track from './modules/track.js'\nimport queue from './modules/queue.js'\nimport page, { getPageData } from './modules/page.js'\nimport context, { makeContext } from './modules/context.js'\nimport user, { getUserPropFunc, tempKey, getPersistedUserData } from './modules/user.js'\n/* Utils */\nimport { watch } from './utils/handleNetworkEvents.js'\nimport { Debug, composeWithDebug } from './utils/debug.js'\nimport heartBeat from './utils/heartbeat.js'\nimport ensureArray from './utils/ensureArray.js'\nimport enrichMeta from './utils/enrichMeta.js'\nimport './pluginTypeDef.js'\n\n/**\n * Analytics library configuration\n *\n * After the library is initialized with config, the core API is exposed & ready for use in the application.\n *\n * @param {object} config - analytics core config\n * @param {string} [config.app] - Name of site / app\n * @param {string|number} [config.version] - Version of your app\n * @param {boolean} [config.debug] - Should analytics run in debug mode\n * @param {Array.<AnalyticsPlugin>}  [config.plugins] - Array of analytics plugins\n * @return {AnalyticsInstance} Analytics Instance\n * @example\n *\n * import Analytics from 'analytics'\n * import pluginABC from 'analytics-plugin-abc'\n * import pluginXYZ from 'analytics-plugin-xyz'\n *\n * // initialize analytics\n * const analytics = Analytics({\n *   app: 'my-awesome-app',\n *   plugins: [\n *     pluginABC,\n *     pluginXYZ\n *   ]\n * })\n *\n */\nfunction analytics(config = {}) {\n  const customReducers = config.reducers || {}\n  const initialUser = config.initialUser || {}\n  // @TODO add custom value resolvers for userId and anonId\n  // const resolvers = config.resolvers || {}\n  // if (BROWSER) {\n  //   console.log('INIT browser')\n  // }\n  // if (SERVER) {\n  //   console.log('INIT SERVER')\n  // }\n  /* Parse plugins array */\n  const parsedOptions = (config.plugins || []).reduce((acc, plugin) => {\n    if (isFunction(plugin)) {\n      /* Custom redux middleware */\n      acc.middlewares = acc.middlewares.concat(plugin)\n      return acc\n    }\n    // Legacy plugin with name\n    if (plugin.NAMESPACE) plugin.name = plugin.NAMESPACE\n    if (!plugin.name) {\n      /* Plugins must supply a \"name\" property. See error url for more details */\n      throw new Error(ERROR_URL + '1')\n    }\n    // Set config if empty\n    if (!plugin.config) plugin.config = {}\n    // if plugin exposes EVENTS capture available events\n    const definedEvents = (plugin.EVENTS) ? Object.keys(plugin.EVENTS).map((k) => {\n      return plugin.EVENTS[k]\n    }) : []\n\n    const enabledFromMerge = !(plugin.enabled === false)\n    const enabledFromPluginConfig = !(plugin.config.enabled === false)\n    // top level { enabled: false } takes precedence over { config: enabled: false }\n    acc.pluginEnabled[plugin.name] = enabledFromMerge && enabledFromPluginConfig\n    delete plugin.enabled\n\n    if (plugin.methods) {\n      acc.methods[plugin.name] = Object.keys(plugin.methods).reduce((a, c) => {\n        // enrich methods with analytics instance\n        a[c] = appendArguments(plugin.methods[c])\n        return a\n      }, {})\n      // Remove additional methods from plugins\n      delete plugin.methods\n    }\n    // Convert available methods into events\n    const methodsToEvents = Object.keys(plugin)\n    // Combine events\n    const allEvents = methodsToEvents.concat(definedEvents)\n    // Dedupe events list\n    const allEventsUnique = new Set(acc.events.concat(allEvents))\n    acc.events = Array.from(allEventsUnique)\n\n    acc.pluginsArray = acc.pluginsArray.concat(plugin)\n\n    if (acc.plugins[plugin.name]) {\n      throw new Error(plugin.name + 'AlreadyLoaded')\n    }\n    acc.plugins[plugin.name] = plugin\n    if (!acc.plugins[plugin.name].loaded) {\n      // set default loaded func\n      acc.plugins[plugin.name].loaded = () => true\n    }\n    return acc\n  }, {\n    plugins: {},\n    pluginEnabled: {},\n    methods: {},\n    pluginsArray: [],\n    middlewares: [],\n    events: []\n  })\n  \n  /* Storage by default is set to global & is not persisted */\n  const storage = (config.storage) ? config.storage : {\n    getItem: get,\n    setItem: set,\n    removeItem: remove\n  }\n\n  const getUserProp = getUserPropFunc(storage)\n\n  // mutable integrations object for dynamic loading\n  let customPlugins = parsedOptions.plugins\n\n  /* Grab all registered events from plugins loaded */\n  const allPluginEvents = parsedOptions.events.filter((name) => {\n    return !nonEvents.includes(name)\n  }).sort()\n  const uniqueEvents = new Set(allPluginEvents.concat(coreEvents).filter((name) => {\n    return !nonEvents.includes(name)\n  }))\n  const allSystemEvents = Array.from(uniqueEvents).sort()\n\n  /* plugin methods(functions) must be kept out of state. thus they live here */\n  const getPlugins = () => customPlugins\n\n  const {\n    addMiddleware,\n    removeMiddleware,\n    dynamicMiddlewares\n  } = new DynamicMiddleware()\n\n  const nonAbortable = () => {\n    // throw new Error(`${ERROR_URL}3`)\n    throw new Error('Abort disabled inListener')\n  }\n  \n  // Parse URL parameters\n  const params = paramsParse()\n  // Initialize visitor information\n  const persistedUser = getPersistedUserData(storage)\n  const visitorInfo = {\n    ...persistedUser,\n    ...initialUser,\n    ...(!params.an_uid) ? {} : { userId: params.an_uid },\n    ...(!params.an_aid) ? {} : { anonymousId: params.an_aid },\n  }\n  // If no anon id set, create one\n  if (!visitorInfo.anonymousId) {\n    visitorInfo.anonymousId = uuid()\n  }\n\n  /**\n   * Async Management methods for plugins. \n   * \n   * This is also where [custom methods](https://bit.ly/329vFXy) are loaded into the instance.\n   * @typedef {Object} Plugins\n   * @property {EnablePlugin} enable - Set storage value\n   * @property {DisablePlugin} disable - Remove storage value\n   * @example\n   *\n   * // Enable a plugin by namespace\n   * analytics.plugins.enable('keenio')\n   *\n   * // Disable a plugin by namespace\n   * analytics.plugins.disable('google-analytics')\n   */\n  const plugins = {\n    /**\n     * Enable analytics plugin\n     * @typedef {Function} EnablePlugin\n     * @param  {string|string[]} plugins - name of plugins(s) to disable\n     * @param  {Function} [callback] - callback after enable runs\n     * @returns {Promise}\n     * @example\n     *\n     * analytics.plugins.enable('google-analytics').then(() => {\n     *   console.log('do stuff')\n     * })\n     *\n     * // Enable multiple plugins at once\n     * analytics.plugins.enable(['google-analytics', 'segment']).then(() => {\n     *   console.log('do stuff')\n     * })\n     */\n    enable: (plugins, callback) => {\n      return new Promise((resolve) => {\n        store.dispatch({\n          type: EVENTS.enablePlugin,\n          plugins: ensureArray(plugins),\n          _: { originalAction: EVENTS.enablePlugin },\n        }, resolve, [ callback ])\n      })\n    },\n    /**\n     * Disable analytics plugin\n     * @typedef {Function} DisablePlugin\n     * @param  {string|string[]} plugins - name of integration(s) to disable\n     * @param  {Function} [callback] - callback after disable runs\n     * @returns {Promise}\n     * @example\n     *\n     * analytics.plugins.disable('google').then(() => {\n     *   console.log('do stuff')\n     * })\n     *\n     * analytics.plugins.disable(['google', 'segment']).then(() => {\n     *   console.log('do stuff')\n     * })\n     */\n    disable: (plugins, callback) => {\n      return new Promise((resolve) => {\n        store.dispatch({\n          type: EVENTS.disablePlugin,\n          plugins: ensureArray(plugins),\n          _: { originalAction: EVENTS.disablePlugin },\n        }, resolve, [callback])\n      })\n    },\n    /*\n     * Load registered analytic providers.\n     * @param  {String} plugins - integration namespace\n     *\n     * @example\n     * analytics.plugins.load('segment')\n     @TODO implement\n    load: (plugins) => {\n      store.dispatch({\n        type: EVENTS.loadPlugin,\n        // Todo handle multiple plugins via array\n        plugins: (plugins) ? [plugins] : Object.keys(getPlugins()),\n      })\n    },\n    */\n    /* @TODO if it stays, state loaded needs to be set. Re PLUGIN_INIT above\n    add: (newPlugin) => {\n      if (typeof newPlugin !== 'object') return false\n      // Set on global integration object\n      customPlugins = Object.assign({}, customPlugins, {\n        [`${newPlugin.name}`]: newPlugin\n      })\n      // then add it, and init state key\n      store.dispatch({\n        type: EVENTS.pluginRegister,\n        name: newPlugin.name,\n        plugin: newPlugin\n      })\n    }, */\n    // Merge in custom plugin methods\n    ...parsedOptions.methods\n  }\n  \n  let readyCalled = false\n  /**\n   * Analytic instance returned from initialization\n   * @typedef {Object} AnalyticsInstance\n   * @property {Identify} identify - Identify a user\n   * @property {Track} track - Track an analytics event\n   * @property {Page} page - Trigger page view\n   * @property {User} user - Get user data\n   * @property {Reset} reset - Clear information about user & reset analytics\n   * @property {Ready} ready - Fire callback on analytics ready event\n   * @property {On} on - Fire callback on analytics lifecycle events.\n   * @property {Once} once - Fire callback on analytics lifecycle events once.\n   * @property {GetState} getState - Get data about user, activity, or context.\n   * @property {Storage} storage - storage methods\n   * @property {Plugins} plugins - plugin methods\n   */\n  const instance = {\n    /**\n    * Identify a user. This will trigger `identify` calls in any installed plugins and will set user data in localStorage\n    * @typedef {Function} Identify\n    * @param  {String}   userId  - Unique ID of user\n    * @param  {Object}   [traits]  - Object of user traits\n    * @param  {Object}   [options] - Options to pass to identify call\n    * @param  {Function} [callback] - Callback function after identify completes\n    * @returns {Promise}\n    * @api public\n    *\n    * @example\n    *\n    * // Basic user id identify\n    * analytics.identify('xyz-123')\n    *\n    * // Identify with additional traits\n    * analytics.identify('xyz-123', {\n    *   name: 'steve',\n    *   company: 'hello-clicky'\n    * })\n    *\n    * // Fire callback with 2nd or 3rd argument\n    * analytics.identify('xyz-123', () => {\n    *   console.log('do this after identify')\n    * })\n    *\n    * // Disable sending user data to specific analytic tools\n    * analytics.identify('xyz-123', {}, {\n    *   plugins: {\n    *     // disable sending this identify call to segment\n    *     segment: false\n    *   }\n    * })\n    *\n    * // Send user data to only to specific analytic tools\n    * analytics.identify('xyz-123', {}, {\n    *   plugins: {\n    *     // disable this specific identify in all plugins except customerio\n    *     all: false,\n    *     customerio: true\n    *   }\n    * })\n    */\n    identify: async (userId, traits, options, callback) => {\n      const id = isString(userId) ? userId : null\n      const data = isObject(userId) ? userId : traits\n      const opts = options || {}\n      const user = instance.user()\n\n      /* sets temporary in memory id. Not to be relied on */\n      set(tempKey(ID), id)\n\n      const resolvedId = id || data.userId || getUserProp(ID, instance, data)\n\n      return new Promise((resolve) => {\n        store.dispatch({\n          type: EVENTS.identifyStart,\n          userId: resolvedId,\n          traits: data || {},\n          options: opts,\n          anonymousId: user.anonymousId,\n          // Add previousId if exists\n          ...(user.id && (user.id !== id) && { previousId: user.id }),\n        }, resolve, [traits, options, callback])\n      })\n    },\n    /**\n     * Track an analytics event. This will trigger `track` calls in any installed plugins\n     * @typedef {Function} Track\n     * @param  {String}   eventName - Event name\n     * @param  {Object}   [payload]   - Event payload\n     * @param  {Object}   [options]   - Event options\n     * @param  {Function} [callback]  - Callback to fire after tracking completes\n     * @returns {Promise}\n     * @api public\n     *\n     * @example\n     *\n     * // Basic event tracking\n     * analytics.track('buttonClicked')\n     *\n     * // Event tracking with payload\n     * analytics.track('itemPurchased', {\n     *   price: 11,\n     *   sku: '1234'\n     * })\n     *\n     * // Fire callback with 2nd or 3rd argument\n     * analytics.track('newsletterSubscribed', () => {\n     *   console.log('do this after track')\n     * })\n     *\n     * // Disable sending this event to specific analytic tools\n     * analytics.track('cartAbandoned', {\n     *   items: ['xyz', 'abc']\n     * }, {\n     *   plugins: {\n     *     // disable track event for segment\n     *     segment: false\n     *   }\n     * })\n     *\n     * // Send event to only to specific analytic tools\n     * analytics.track('customerIoOnlyEventExample', {\n     *   price: 11,\n     *   sku: '1234'\n     * }, {\n     *   plugins: {\n     *     // disable this specific track call all plugins except customerio\n     *     all: false,\n     *     customerio: true\n     *   }\n     * })\n     */\n    track: async (eventName, payload, options, callback) => {\n      const name = isObject(eventName) ? eventName.event : eventName\n      if (!name || !isString(name)) {\n        throw new Error('EventMissing')\n      }\n      const data = isObject(eventName) ? eventName : (payload || {})\n      const opts = isObject(options) ? options : {}\n\n      return new Promise((resolve) => {\n        store.dispatch({\n          type: EVENTS.trackStart,\n          event: name,\n          properties: data,\n          options: opts,\n          userId: getUserProp(ID, instance, payload),\n          anonymousId: getUserProp(ANONID, instance, payload),\n        }, resolve, [payload, options, callback])\n      })\n    },\n    /**\n     * Trigger page view. This will trigger `page` calls in any installed plugins\n     * @typedef {Function} Page\n     * @param  {PageData} [data] - Page data overrides.\n     * @param  {Object}   [options] - Page tracking options\n     * @param  {Function} [callback] - Callback to fire after page view call completes\n     * @returns {Promise}\n     * @api public\n     *\n     * @example\n     *\n     * // Basic page tracking\n     * analytics.page()\n     *\n     * // Page tracking with page data overrides\n     * analytics.page({\n     *   url: 'https://google.com'\n     * })\n     *\n     * // Fire callback with 1st, 2nd or 3rd argument\n     * analytics.page(() => {\n     *   console.log('do this after page')\n     * })\n     *\n     * // Disable sending this pageview to specific analytic tools\n     * analytics.page({}, {\n     *   plugins: {\n     *     // disable page tracking event for segment\n     *     segment: false\n     *   }\n     * })\n     *\n     * // Send pageview to only to specific analytic tools\n     * analytics.page({}, {\n     *   plugins: {\n     *     // disable this specific page in all plugins except customerio\n     *     all: false,\n     *     customerio: true\n     *   }\n     * })\n     */\n    page: async (data, options, callback) => {\n      const d = isObject(data) ? data : {}\n      const opts = isObject(options) ? options : {}\n\n      /*\n      // @TODO add custom value resolvers for userId and anonId\n      if (resolvers.getUserId) {\n        const asyncUserId = await resolvers.getUserId()\n        console.log('x', x)\n      }\n      */\n\n      return new Promise((resolve) => {\n        store.dispatch({\n          type: EVENTS.pageStart,\n          properties: getPageData(d),\n          options: opts,\n          userId: getUserProp(ID, instance, d),\n          anonymousId: getUserProp(ANONID, instance, d),\n        }, resolve, [data, options, callback])\n      })\n    },\n    /**\n     * Get user data\n     * @typedef {Function} User\n     * @param {string} [key] - dot.prop.path of user data. Example: 'traits.company.name'\n     * @returns {string|object} value of user data or null\n     *\n     * @example\n     *\n     * // Get all user data\n     * const userData = analytics.user()\n     *\n     * // Get user id\n     * const userId = analytics.user('userId')\n     *\n     * // Get user company name\n     * const companyName = analytics.user('traits.company.name')\n     */\n    user: (key) => {\n      if (key === ID || key === 'id') {\n        return getUserProp(ID, instance)\n      }\n      if (key === ANONID || key === 'anonId') {\n        return getUserProp(ANONID, instance)\n      }\n      const user = instance.getState('user')\n      if (!key) return user\n      return dotProp(user, key)\n    },\n    /**\n     * Clear all information about the visitor & reset analytic state.\n     * @typedef {Function} Reset\n     * @param {Function} [callback] - Handler to run after reset\n     * @returns {Promise}\n     * @example\n     *\n     * // Reset current visitor\n     * analytics.reset()\n     */\n    reset: (callback) => {\n      return new Promise((resolve) => {\n        store.dispatch({\n          type: EVENTS.resetStart\n        }, resolve, callback)\n      })\n    },\n    /**\n     * Fire callback on analytics ready event\n     * @typedef {Function} Ready\n     * @param  {Function} callback - function to trigger when all providers have loaded\n     * @returns {DetachListeners} - Function to detach listener\n     *\n     * @example\n     *\n     * analytics.ready((payload) => {\n     *   console.log('all plugins have loaded or were skipped', payload);\n     * })\n     */\n    ready: (callback) => {\n      // If ready already fired. Call callback immediately\n      if (readyCalled) callback({ plugins, instance })\n      return instance.on(EVENTS.ready, (x) => {\n        if (callback) callback(x)\n        readyCalled = true\n      })\n    },\n    /**\n     * Attach an event handler function for analytics lifecycle events.\n     * @typedef {Function} On\n     * @param  {String}   name - Name of event to listen to\n     * @param  {Function} callback - function to fire on event\n     * @return {DetachListeners} - Function to detach listener\n     *\n     * @example\n     *\n     * // Fire function when 'track' calls happen\n     * analytics.on('track', ({ payload }) => {\n     *   console.log('track call just happened. Do stuff')\n     * })\n     *\n     * // Remove listener before it is called\n     * const removeListener = analytics.on('track', ({ payload }) => {\n     *   console.log('This will never get called')\n     * })\n     *\n     * // cleanup .on listener\n     * removeListener()\n     */\n    on: (name, callback) => {\n      if (!name || !isFunction(callback)) {\n        return false\n      }\n      if (name === EVENTS.bootstrap) {\n        throw new Error('.on disabled for ' + name)\n      }\n      const startRegex = /Start$|Start:/\n      if (name === '*') {\n        const beforeHandler = store => next => action => {\n          if (action.type.match(startRegex)) {\n            callback({ // eslint-disable-line\n              payload: action,\n              instance,\n              plugins: customPlugins\n            })\n          }\n          return next(action)\n        }\n        const afterHandler = store => next => action => {\n          if (!action.type.match(startRegex)) {\n            callback({ // eslint-disable-line\n              payload: action,\n              instance,\n              plugins: customPlugins\n            })\n          }\n          return next(action)\n        }\n        addMiddleware(beforeHandler, before)\n        addMiddleware(afterHandler, after)\n        /**\n         * Detach listeners\n         * @typedef {Function} DetachListeners\n         */\n        return () => {\n          removeMiddleware(beforeHandler, before)\n          removeMiddleware(afterHandler, after)\n        }\n      }\n\n      const position = (name.match(startRegex)) ? before : after // eslint-disable-line\n      const handler = store => next => action => {\n        // Subscribe to EVERYTHING\n        if (action.type === name) {\n          callback({ // eslint-disable-line\n            payload: action,\n            instance: instance,\n            plugins: customPlugins,\n            abort: nonAbortable\n          })\n        }\n        /* For future matching of event subpaths `track:*` etc\n        } else if (name.match(/\\*$/)) {\n          const match = (name === '*') ? '.' : name\n          const regex = new RegExp(`${match}`, 'g')\n        } */\n        return next(action)\n      }\n      addMiddleware(handler, position)\n      return () => removeMiddleware(handler, position)\n    },\n    /**\n     * Attach a handler function to an event and only trigger it once.\n     * @typedef {Function} Once\n     * @param  {String} name - Name of event to listen to\n     * @param  {Function} callback - function to fire on event\n     * @return {DetachListeners} - Function to detach listener\n     *\n     * @example\n     *\n     * // Fire function only once per 'track'\n     * analytics.once('track', ({ payload }) => {\n     *   console.log('This is only triggered once when analytics.track() fires')\n     * })\n     *\n     * // Remove listener before it is called\n     * const listener = analytics.once('track', ({ payload }) => {\n     *   console.log('This will never get called b/c listener() is called')\n     * })\n     *\n     * // cleanup .once listener before it fires\n     * listener()\n     */\n    once: (name, callback) => {\n      if (!name || !isFunction(callback)) {\n        return false\n      }\n      if (name === EVENTS.bootstrap) {\n        throw new Error('.once disabled for ' + name)\n      }\n      const detachListener = instance.on(name, ({ payload }) => {\n        callback({ // eslint-disable-line\n          payload: payload,\n          instance: instance,\n          plugins: customPlugins,\n          abort: nonAbortable\n        })\n        // detach listener after its called once\n        detachListener()\n      })\n      return detachListener\n    },\n    /**\n     * Get data about user, activity, or context. Access sub-keys of state with `dot.prop` syntax.\n     * @typedef {Function} GetState\n     * @param  {string} [key] - dot.prop.path value of state\n     * @return {any}\n     *\n     * @example\n     *\n     * // Get the current state of analytics\n     * analytics.getState()\n     *\n     * // Get a subpath of state\n     * analytics.getState('context.offline')\n     */\n    getState: (key) => {\n      const state = store.getState()\n      if (key) return dotProp(state, key)\n      return Object.assign({}, state)\n    },\n    /*\n     * Emit events for other plugins or middleware to react to.\n     * @param  {Object} action - event to dispatch\n     */\n    dispatch: (action) => {\n      const actionData = isString(action) ? { type: action } : action\n      if (isReservedAction(actionData.type)) {\n        throw new Error('reserved action ' + actionData.type)\n      }\n      const _private = action._ || {}\n      // Dispatch actionStart\n      // const autoPrefixType = `${actionData.type.replace(/Start$/, '')}Start`\n\n      const dispatchData = {\n        ...actionData,\n        _: {\n          originalAction: actionData.type,\n          ..._private\n        }\n        // type: `${autoPrefixType}`\n      }\n      store.dispatch(dispatchData)\n    },\n    // Do not use. Will be removed. Here for Backwards compatibility.\n    // Moved to analytics.plugins.enable\n    enablePlugin: plugins.enable,\n    /// Do not use. Will be removed. Here for Backwards compatibility.\n    /// Moved to analytics.plugins.disable\n    disablePlugin: plugins.disable,\n    // Do not use. Will be removed. Here for Backwards compatibility.\n    // New plugins api\n    plugins: plugins,\n    /**\n     * Storage utilities for persisting data.\n     * These methods will allow you to save data in localStorage, cookies, or to the window.\n     * @typedef {Object} Storage\n     * @property {GetItem} getItem - Get value from storage\n     * @property {SetItem} setItem - Set storage value\n     * @property {RemoveItem} removeItem - Remove storage value\n     *\n     * @example\n     *\n     * // Pull storage off analytics instance\n     * const { storage } = analytics\n     *\n     * // Get value\n     * storage.getItem('storage_key')\n     *\n     * // Set value\n     * storage.setItem('storage_key', 'value')\n     *\n     * // Remove value\n     * storage.removeItem('storage_key')\n     */\n    storage: {\n      /**\n       * Get value from storage\n       * @typedef {Function} GetItem\n       * @param {String} key - storage key\n       * @param {Object} [options] - storage options\n       * @return {Any}\n       *\n       * @example\n       *\n       * analytics.storage.getItem('storage_key')\n       */\n      getItem: storage.getItem,\n      /**\n       * Set storage value\n       * @typedef {Function} SetItem\n       * @param {String} key - storage key\n       * @param {any} value - storage value\n       * @param {Object} [options] - storage options\n       *\n       * @example\n       *\n       * analytics.storage.setItem('storage_key', 'value')\n       */\n      setItem: (key, value, options) => {\n        store.dispatch({\n          type: EVENTS.setItemStart,\n          key: key,\n          value: value,\n          options: options\n        })\n      },\n      /**\n       * Remove storage value\n       * @typedef {Function} RemoveItem\n       * @param {String} key - storage key\n       * @param {Object} [options] - storage options\n       *\n       * @example\n       *\n       * analytics.storage.removeItem('storage_key')\n       */\n      removeItem: (key, options) => {\n        store.dispatch({\n          type: EVENTS.removeItemStart,\n          key: key,\n          options: options\n        })\n      },\n    },\n    /*\n     * Set the anonymous ID of the visitor\n     * @param {String} anonymousId - anonymous Id to set\n     * @param {Object} [options] - storage options\n     *\n     * @example\n     *\n     * // Set anonymous ID\n     * analytics.setAnonymousId('1234567')\n     */\n    setAnonymousId: (anonymousId, options) => {\n      /* sets temporary in memory id. Not to be relied on */\n      // set(tempKey(ANONID), anonymousId)\n      instance.storage.setItem(CONSTANTS.ANON_ID, anonymousId, options)\n    },\n    /*\n     * Events exposed by core analytics library and all loaded plugins\n     * @type {Array}\n     */\n    events: {\n      core: coreEvents,\n      plugins: allPluginEvents,\n      // byType: (type) => {} @Todo grab logic from engine and give inspectable events\n    }\n  }\n  const enrichMiddleware = storeAPI => next => action => {\n    if (!action.meta) {\n      action.meta = enrichMeta()\n    }\n    return next(action)\n  }\n  const middlewares = parsedOptions.middlewares.concat([\n    enrichMiddleware,\n    /* Core analytics middleware */\n    dynamicMiddlewares(before), // Before dynamic middleware <-- fixed pageStart .on listener\n    /* Plugin engine */\n    middleware.plugins(instance, getPlugins, {\n      all: allSystemEvents,\n      plugins: allPluginEvents\n    }),\n    middleware.storage(storage),\n    middleware.initialize(instance),\n    middleware.identify(instance, storage),\n    /* after dynamic middleware */\n    dynamicMiddlewares(after)\n  ])\n\n  /* Initial analytics state keys */\n  const coreReducers = {\n    context: context,\n    user: user(storage),\n    page: page,\n    track: track,\n    plugins: pluginsMiddleware(getPlugins),\n    queue: queue\n  }\n\n  let composeEnhancers = compose\n  let composeWithGlobalDebug = compose\n  if (isBrowser && config.debug) {\n    const devTools = window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__\n    if (devTools) {\n      composeEnhancers = devTools({ trace: true, traceLimit: 25 })\n    }\n    composeWithGlobalDebug = function() {\n      if (arguments.length === 0) return Debug()\n      if (isObject(typeof arguments[0])) return composeWithDebug(arguments[0])\n      return composeWithDebug().apply(null, arguments)\n    }\n  }\n\n  const initialConfig = makeContext(config)\n\n  const initialPluginState = parsedOptions.pluginsArray.reduce((acc, plugin) => {\n    const { name, config, loaded } = plugin\n    const isEnabled = parsedOptions.pluginEnabled[name]\n    acc[name] = {\n      enabled: isEnabled,\n      // If plugin enabled & has no initialize method, set initialized to true, else false\n      initialized: (isEnabled) ? Boolean(!plugin.initialize) : false,\n      loaded: Boolean(loaded({ config })),\n      config\n    }\n    return acc\n  }, {})\n  \n  const initialState = {\n    context: initialConfig,\n    user: visitorInfo,\n    plugins: initialPluginState,\n    // Todo allow for more userland defined initial state?\n  }\n\n  /* Create analytics store! */\n  const store = createStore(\n    // register reducers\n    combineReducers({ ...coreReducers, ...customReducers }),\n    // set user defined initial state\n    initialState,\n    // register middleware & plugins used\n    composeWithGlobalDebug(\n      composeEnhancers(\n        applyMiddleware(...middlewares),\n      )\n    )\n  )\n\n  /* Supe up dispatch with callback promise resolver. Happens in enrichMeta */\n  function enhanceDispatch(fn) {\n    return function (event, resolver, callbacks) {\n      // console.log('original event', event)\n      const meta = enrichMeta(event.meta, resolver, ensureArray(callbacks))\n      // if (resolver) console.log('dispatch resolver', resolver)\n      // if (callbacks) console.log('dispatch callbacks', callbacks)\n      const newEvent = { ...event, ...{ meta: meta } }\n      // console.log('newEvent', newEvent)\n      return fn.apply(null, [ newEvent ])\n    }\n  }\n\n  // Automatically apply meta to dispatch calls\n  store.dispatch = enhanceDispatch(store.dispatch)\n\n  /* Synchronously call bootstrap & register Plugin methods */\n  const pluginKeys = Object.keys(customPlugins)\n\n  /* Bootstrap analytic plugins */\n  store.dispatch({\n    type: EVENTS.bootstrap,\n    plugins: pluginKeys,\n    config: initialConfig,\n    params: params,\n    user: visitorInfo,\n    initialUser,\n    persistedUser\n  })\n\n  const enabledPlugins = pluginKeys.filter((name) => parsedOptions.pluginEnabled[name])\n  const disabledPlugins = pluginKeys.filter((name) => !parsedOptions.pluginEnabled[name])\n \n  /* Register analytic plugins */\n  store.dispatch({\n    type: EVENTS.registerPlugins,\n    plugins: pluginKeys,\n    enabled: parsedOptions.pluginEnabled,\n  })\n\n  /* dispatch register for individual plugins */\n  parsedOptions.pluginsArray.map((plugin, i) => {\n    const { bootstrap, config, name } = plugin\n    if (bootstrap && isFunction(bootstrap)) {\n      bootstrap({ instance, config, payload: plugin })\n    }\n    /* Register plugins */\n    store.dispatch({\n      type: EVENTS.registerPluginType(name),\n      name: name,\n      enabled: parsedOptions.pluginEnabled[name],\n      plugin: plugin\n    })\n\n    /* All plugins registered initialize, is last loop */\n    if (parsedOptions.pluginsArray.length === (i + 1)) {\n      store.dispatch({\n        type: EVENTS.initializeStart,\n        plugins: enabledPlugins,\n        disabled: disabledPlugins\n      })\n    }\n  })\n\n  if (BROWSER) {\n    /* Watch for network events */\n    watch((offline) => {\n      store.dispatch({\n        type: (offline) ? EVENTS.offline : EVENTS.online,\n      })\n    })\n    /* Tick heartbeat for queued events */\n    heartBeat(store, getPlugins, instance)\n  }\n\n  function appendArguments(fn) {\n    return function () {\n      /* Get original args */\n      const args = Array.prototype.slice.call(arguments)\n      /* Create clone of args */\n      let newArgs = new Array(fn.length)\n      for (let i = 0; i < args.length; i++) {\n        newArgs[i] = args[i]\n      }\n      /* Append new arg to end */\n      newArgs[newArgs.length] = instance\n      // Set instance on extended methods\n      return fn.apply({ instance }, newArgs)\n    }\n  }\n\n  /* Return analytics instance */\n  return instance\n}\n\n// Duplicated strings\nconst before = 'before'\nconst after = 'after'\n\nexport default analytics\n\n/*\n * analytics.init exported for standalone browser build\n * CDN build exposes global _analytics variable\n *\n * Initialize instance with _analytics.init() or _analytics['default']()\n */\nexport { analytics as init }\n\n/*\n * analytics.Analytics exported for node usage\n *\n * Initialize instance with _analytics.init() or _analytics['default']()\n */\nexport { analytics as Analytics }\n/*\n * Core Analytic events. These are exposed for third party plugins & listeners\n * Use these magic strings to attach functions to event names.\n * @type {Object}\n */\nexport { EVENTS }\n\nexport { CONSTANTS }\n"],"names":["UNDEFINED","OBJECT","process","isBrowser","document","method","s","charAt","slice","Deno","window","name","userAgent","navigator","includes","upper","text","bind","lower","val","toLowerCase","t","type","isNull","x","isFunction","constructor","ctorName","Object","prototype","toString","call","getTypeName","kind","typeOf","isString","isBoolean","isObject","obj","isObjectLike","getPrototypeOf","proto","errorType","ErrKind","value","typeName","getType","Error","message","n","isNaN","isNumber","stackTraceLimit","isError","element","isEl","Element","HTMLDocument","nodeName","toUpperCase","isNodeType","bindArgs","fn","arguments","apply","concat","boundArgs","decodeUri","replace","e","TypeError","SyntaxError","isElement","KEY","GLOBAL","globalContext","self","global","key","remove","FUNC","UNDEF","REDUCER","base","ACTION_INIT","ACTION_TEST","Math","random","$$observable","Symbol","observable","msg","createStore","reducer","preloadedState","enhancer","_ref2","undefined","currentReducer","currentState","currentListeners","nextListeners","isDispatching","ensureCanMutateNextListeners","getState","subscribe","listener","isSubscribed","push","index","indexOf","splice","dispatch","action","listeners","i","length","replaceReducer","nextReducer","_ref","outerSubscribe","observer","observeState","next","unsubscribe","this","getUndefinedStateErrorMessage","actionType","compose","funcs","arg","reduce","a","b","applyMiddleware","_arguments","chain","store","middlewareAPI","map","middleware","_extends","ANON_ID","PREFIX","USER_ID","USER_TRAITS","LIB_NAME","ID","ANONID","coreEvents","nonEvents","EVENTS$1","acc","curr","registerPluginType","pluginReadyType","utmRegex","propRegex","traitRegex","initializeMiddleware","instance","setItem","storage","EVENTS","bootstrap","params","user","persistedUser","initialUser","isKnownId","userId","anonymousId","traits","paramsArray","keys","an_uid","an_event","groupedParams","match","cleanName","campaign","props","raw","setTimeout","identify","track","userReducer","state","setItemEnd","assign","reset","forEach","removeItem","getPersistedUserData","getItem","tempKey","identifyMiddleware","_instance$storage","options","uuid","currentId","currentTraits","userIdChanged","old","new","stack","runCallback","id","payload","waitForReady","data","predicate","timeout","Promise","resolve","reject","queue","then","_","abort","reason","processQueue","getPlugins","abortedCalls","pluginMethods","_store$getState","plugins","context","offline","actions","pipeline","item","plugin","loaded","processIndex","requeue","requeueIndex","processAction","currentPlugin","currentMethod","retVal","enrichedPayload","hasOwnProperty","enrich","isAborted","meta","rid","config","pluginEvent","called","from","reQueueActions","filter","processEvent","_ref4","allPlugins","allMatches","isStartEvent","endsWithStartRegex","abortable","exact","pluginName","during","makeArgs","abortablePlugins","otherPlugin","event","abortF","caller","pluginsToAbort","isArray","JSON","stringify","abortFunction","notAbortableError","formatPayload","argumentFactory","queueData","thing","methodName","addToQueue","scoped","curScope","_temp5","_temp4","namespaced","p","count","curScopeData","actionName","getNameSpacedAction","sub","join","validateMethod","currentAct","pname","otherPlug","getConfig","returnValue","scopedPayload","payloads","promise","lastLoop","currentActionValue","payloadValue","shouldAbort","abortDispatch","funcArgs","merged","nameSpaceEvent","bootstrapRegex","readyRegex","resolvedAction","originalAction","endAction","shouldAbortAll","abortEvent","pluginState","pluginData","getPluginFunctions","arr","getEventNames","eventType","namespace","postFix","_ref3","pluginsCount","Array","split","pluginMiddleware","systemEvents","isReady","_temp2","_exit","_result","updatedAction","enablePlugin","initializeStart","disabled","fromEnable","disablePlugin","initializeEnd","pluginsArray","allRegisteredPlugins","completed","failed","waitForPluginsToLoad","d","events","all","calls","ready","_temp","test","eventsInfo","pluginObject","originalType","updatedType","activePlugins","settings","fromCallOptions","enabled","info","initialized","allActivePluginKeys","core","word","_nameSpacedEvents$map","beforeFuncs","duringFuncs","afterFuncs","beforeNS","duringNS","afterNS","before","after","getAllMatchingCalls","actionBefore","_temp3","actionDuring","actionAfter","hasCallback","_processEvent","runPlugins","updated","_next","storageMiddleware","DynamicMiddleware","_this","addMiddleware","middlewares","position","removeMiddleware","findIndex","dynamicMiddlewares","act","createReducer","newState","getNameFromEventType","isEnabled","Boolean","initialize","togglePluginStatus","baseName","substring","status","pluginKey","serialize","parse","err","initialState","last","history","trackReducer","trackEvent","properties","queueReducer","actionChain","hashRegex","urlPath","url","matches","exec","osName","referrer","locale","timeZone","getPageData","pageData","_document","title","_window","location","innerWidth","innerHeight","hash","search","canonical","tag","tags","getElementsByTagName","getAttribute","canonicalUrl","href","currentUrl","page","path","width","height","viewData","os","appVersion","getOSNameBrowser","getBrowserLocale","getTimeZone","sessionId","app","version","debug","onLine","library","timezone","online","excludeItems","listen","func","toAdd","ev","watch","cb","Debug","set","origDispatch","composeWithDebug","ensureArray","singleOrArray","generateMeta","possibleCallbacks","resolver","callback","argArray","args","getCallback","ts","Date","getTime","analytics","customReducers","reducers","parsedOptions","NAMESPACE","ERROR_URL","definedEvents","k","pluginEnabled","methods","c","newArgs","appendArguments","allEvents","allEventsUnique","Set","get","getUserProp","getUserPropFunc","customPlugins","allPluginEvents","sort","uniqueEvents","allSystemEvents","_DynamicMiddleware","nonAbortable","visitorInfo","an_aid","enable","disable","readyCalled","opts","resolvedId","identifyStart","previousId","eventName","trackStart","pageStart","dotProp","resetStart","on","startRegex","beforeHandler","afterHandler","handler","once","detachListener","actionData","dispatchData","setItemStart","removeItemStart","setAnonymousId","CONSTANTS","storeAPI","enrichMeta","coreReducers","pluginsMiddleware","composeEnhancers","composeWithGlobalDebug","devTools","__REDUX_DEVTOOLS_EXTENSION_COMPOSE__","trace","traceLimit","initialConfig","current","makeContext","initialPluginState","reducerKeys","finalReducers","shapeAssertionError","finalReducerKeys","assertReducerShape","hasChanged","nextState","previousStateForKey","nextStateForKey","errorMessage","combineReducers","callbacks","newEvent","enhanceDispatch","pluginKeys","enabledPlugins","disabledPlugins","registerPlugins","setInterval","heartBeat"],"mappings":"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"}