import { StatisticsDefaults as Bs, RESTSimpleLineSymbolStyle as Br, WebChartStatisticType as Se, WebChartTimeAggregationTypes as $r, RESTSymbolType as Oe, RESTHorizontalAlignment as ut, WebChartSortOrderKinds as ir, WebChartOrderDataByTypes as kr, WebChartTypes as $, WebChartCurrentVersion as nr, RESTSimpleFillSymbolStyle as qr, SizePolicyScaleTypes as ks, WebChartDataTransformations as qi, WebChartNullPolicyTypes as qs, WebChartTemporalBinningUnits as Re, WebChartTemporalBinningTypes as Mi, WebChartStackedKinds as Zr, WebChartLegendPositions as Ms, RESTSimpleMarkerSymbolStyle as ji, RESTVerticalAlignment as Vi, OverlayTerms as Ze, WebChartVersionStatus as dr, defaultPieFromFieldsName as ct, defaultPieFromFieldsValue as zi, GaugeChartSubTypes as js, RESTUnits as br, RESTFieldType as $e, RESTRendererType as ha, defaultBarLineFromFieldsName as Vs, defaultBarLineFromFieldsValue as zs } from "@arcgis/charts-spec";
import { WebChartJSONSchemas as wr } from "@arcgis/charts-spec/json-schema";
import { template as Us, isEqual as Ot, isNil as Qs } from "lodash-es";
import { extent as _t } from "d3-array";
import * as Ui from "@arcgis/core/geometry/support/jsonUtils.js";
import * as Hs from "@arcgis/core/layers/support/fieldUtils.js";
import * as Gs from "@arcgis/core/renderers/support/jsonUtils.js";
import Ws from "@arcgis/core/layers/support/Field.js";
import st from "@arcgis/core/request.js";
import Ks from "@arcgis/core/rest/support/FeatureSet.js";
import Js from "@arcgis/core/layers/FeatureLayer.js";
import Xs from "@arcgis/core/portal/Portal.js";
import Ys from "fast-memoize";
import Zs from "@arcgis/core/rest/support/AttributeBinsQuery.js";
import en from "@arcgis/core/rest/support/Query.js";
import rn from "@arcgis/core/rest/support/StatisticDefinition.js";
import Qi from "@arcgis/core/time/TimeExtent.js";
import { g as Ne } from "./series-types.js";
import * as Hi from "@arcgis/core/core/promiseUtils.js";
/*! All material copyright Esri, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.33/esri/copyright.txt for details.
v4.33.19 */
const Nt = {
  Count: "count",
  Start: "minValue",
  End: "maxValue"
}, M = {
  Arabic: "ar",
  ArabicLatin: "ar-u-nu-latn",
  Bosnian: "bs",
  Bulgarian: "bg",
  Catalan: "ca",
  Czech: "cs",
  Danish: "da",
  German: "de",
  Greek: "el",
  English: "en",
  EnglishUSA: "en-US",
  Spanish: "es",
  Estonian: "et",
  Finnish: "fi",
  French: "fr",
  Hebrew: "he",
  Croatian: "hr",
  Hungarian: "hu",
  Indonesian: "id",
  Italian: "it",
  Japanese: "ja",
  Korean: "ko",
  Lithuanian: "lt",
  Latvian: "lv",
  NorwegianBokml: "no",
  Dutch: "nl",
  Polish: "pl",
  PortugueseBrazil: "pt-BR",
  PortuguesePortugal: "pt-PT",
  Romanian: "ro",
  Russian: "ru",
  Serbian: "sr",
  Slovenian: "sl",
  Slovak: "sk",
  Swedish: "sv",
  Thai: "th",
  Turkish: "tr",
  Ukrainian: "uk",
  Vietnamese: "vi",
  ChineseChina: "zh-CN",
  ChineseHongKong: "zh-HK",
  ChineseTaiwan: "zh-TW"
}, an = [
  ...Object.values(M),
  "en-AU",
  "en-GB",
  "es-ES",
  "es-MX",
  "de-CH",
  "de-DE",
  "de-AT",
  "it-CH",
  "it-IT"
];
function qe(a, e) {
  return Us(a)(e);
}
function tn(a) {
  const e = /^([a-z]{2})-([A-Z]{2})$/u, t = a?.match(e);
  let i = M.English;
  return t != null && t?.length > 1 ? i = t[1] : a?.length === 2 && a.toLowerCase() === a && (i = a), i;
}
function sn(a) {
  let e = a;
  if (a !== void 0 && a.includes("-")) {
    const [t, i] = a.split("-");
    e = `${t}-${i.toUpperCase()}`;
  }
  return e;
}
function Bt(a, e) {
  let t = M.English;
  const i = sn(a);
  if (i !== void 0)
    if (e.includes(i))
      t = i;
    else {
      const r = tn(i);
      e.includes(r) ? t = r : r === "nb" && (t = "no");
    }
  return t;
}
function kt(a, e) {
  function t(i) {
    let r;
    return i === void 0 || i === document || i === window ? r = null : r = i.closest(a) || t(i.getRootNode().host), r;
  }
  return t(e);
}
function Mr(a = document.documentElement) {
  const t = kt("[lang]", a)?.lang ?? window.navigator.language, i = Object.values(M), r = Object.values(an), s = Bt(t, i);
  let o = Bt(t, r);
  return o = o === "ar" ? "ar-u-nu-latn" : o, {
    locale: s,
    rtl: kt("[dir]", a)?.getAttribute("dir") === "rtl",
    formatLocale: o
  };
}
function Wu(a) {
  let e;
  return a === "unknown" ? e = "UTC" : a !== void 0 && a !== "system" && (e = a), e;
}
function Ku(a, e) {
  const t = {
    year: "numeric",
    month: "2-digit",
    day: "2-digit",
    timeZone: e
  };
  return new Intl.DateTimeFormat("en-CA", t).format(a);
}
function Ju(a, e) {
  const t = {
    hour: "2-digit",
    minute: "2-digit",
    hour12: !1,
    timeZone: e
  };
  return new Intl.DateTimeFormat("en-US", t).format(a);
}
async function nn(a) {
  const { path: e, locale: t, baseURL: i } = a;
  let r = {};
  try {
    r = await (await fetch(`${i}assets/${e}/t9n/messages.${t}.json`)).json();
  } catch {
    r = await (await fetch(`${i}assets/${e}/t9n/messages.${M.English}.json`)).json();
  }
  return r;
}
async function Xu(a, e, t) {
  let i = a.tagName.toLowerCase();
  t && (i = i.replace("arcgis-", ""));
  const { locale: r, rtl: s } = Mr(a), o = await nn({
    path: i,
    locale: r,
    baseURL: e
  });
  let n = a.getAttribute("dir");
  return n !== "ltr" && n !== "rtl" && (n = s ? "rtl" : "ltr"), { strings: o, direction: n };
}
async function Yu(a) {
  const { element: e, baseURL: t, filePrefix: i } = a, { locale: r } = Mr(e);
  let s;
  try {
    s = await (await fetch(`${t}/messages.${r}.json`)).json();
  } catch {
    s = i === "common" ? ln() : on();
  }
  return s;
}
function Zu(a) {
  const { rtl: e } = Mr(a);
  return e ? "rtl" : "ltr";
}
function ec(a, e) {
  const [, t, , , , i] = 1111.1.toLocaleString(e), r = a.replace(t, "").replace(i, ".");
  return Number.parseFloat(r);
}
function on() {
  return {
    placeholders: {
      barChartCreateMsg: "Bar charts group data by categories along the x-axis. Select a category field or select multiple numeric fields in the Data pane to get started.",
      boxPlotCreateMsg: "Box plots display the distribution of one or more numeric attributes. Select at least one Numeric field in the Data pane to get started.",
      lineChartCreateMsg: "Line charts show change along a continuous axis. Select a date or numeric field in the Data pane to get started.",
      pieChartCreateMsg: "Pie charts group data into slices to visualize part-to-whole relationships. Slices can be created from unique values in a category field, or from multiple numeric fields. Select a category field under Slices from Category or multiple numeric fields under Slices from Fields in the Data pane to get started.",
      histogramCreateMsg: "Histograms visualize the distribution of a numeric attribute by grouping values into bins. Select a numeric field in the Data pane to get started.",
      scatterplotCreateMsg: "Scatterplots visualize the relationship between two numeric attributes. Select two numeric fields in the Data pane to get started."
    },
    notifications: {
      invalidConfig: "The chart configuration is invalid.",
      invalidSeriesConfig: "No data is available to display due to empty data field(s) and/or combination of filters.",
      invalidSeriesConfigTitle: "No data",
      validateAggregationTypeMsg: "Please choose at least one numeric field to display on the y-axis.",
      missingNumericFields: "Numeric field required",
      noAggregationRequiresNumericFields: "Charts with no aggregation require at least one Numeric field."
    },
    errorHeading: "Error",
    tooManySelectedElements: {
      title: "Selection limit exceeded",
      message: "Selections are limited to 500 elements"
    },
    incompatibleChartVersion: {
      title: "Incompatible chart version",
      message: "Chart version ${ chartVersion } is not compatible with this application. Some features may not be available."
    },
    modalHeaders: {
      invalidData: "Invalid data",
      invalidChart: "Invalid chart",
      noDataAvailable: "No data available to display",
      tooManyFeatures: "Too many features",
      cannotCombineNegativeAndPositiveSlices: "Pie charts cannot combine slices with positive values to slices with negative values",
      error: "Error",
      warning: "Warning",
      newChart: "New chart"
    },
    errors: {
      divNode: "Creating a chart requires an HTML div node.",
      errorRequest: "Please fix the following errors: ",
      warningRequest: "Please address the following warnings: ",
      newChartRequest: "Configure chart.",
      invalidValueFormatForLineChart: "The axis 'valueFormat' is invalid. Only numeric type is allowed on the line chart y-axis.",
      invalidValueFormatForBarChart: "The axis 'valueFormat' is invalid. Only numeric type is allowed on the bar chart y-axis.",
      invalidValueFormatForComboBarLineChart: "The axis 'valueFormat' is invalid. Only numeric type is allowed on the bar-line chart y-axis, and category and date types on the x-axis.",
      invalidValueFormatForBoxPlot: "The axis 'valueFormat' is invalid. Only numeric type is allowed on the box plot y-axis, and category and date types on the x-axis.",
      invalidValueFormatForHistogram: "The axis 'valueFormat' is invalid. Only numeric type is allowed on the histogram axes.",
      invalidValueFormatForScatterplot: "The axis 'valueFormat' is invalid. Only numeric type is allowed on the scatter plot axes.",
      invalidValueFormatForGauge: "The axis 'valueFormat' is invalid. Only numeric type is allowed on the gauge.",
      mismatchAxisAndValueFormat: "There's a mismatch between the axis type and the axis 'valueFormat'.",
      queryError: "Failure to read input data.",
      simpleError: "Something went wrong.",
      defaultInvalidChart: "There was an error creating the chart.",
      categoryCountCannotExceedLimit: "There are ${ categoryCount } categories on this chart. Charts are limited to ${ maxCategoryCount } categories. Choose a Category field with fewer unique values or apply a filter to your data.",
      uniqueSeriesBarCountCannotExceedLimit: "There are a total of ${ elementCount } bars in this chart. Bar charts with one series are limited to ${ totalLimit } bars. Choose a Category field with fewer unique values or apply a filter to your data.",
      twoSeriesBarCountCannotExceedLimit: "Bar charts with two series are limited to ${ totalLimit } bars, or ${ seriesLimit } bars per series. Choose a Category field with fewer unique values or apply a filter to your data.",
      threePlusSeriesBarCountCannotExceedLimit: "Bar charts with three or more series are limited to ${ totalLimit } bars, or ${ seriesLimit } bars per series. Choose a Category field with fewer unique values or apply a filter to your data.",
      barSeriesCountCannotExceedLimit: "Bar charts are limited to ${ seriesLimit } series. Choose a split-by field with fewer unique values",
      uniqueSeriesLineCountCannotExceedLimit: "There are a total of ${ elementCount } markers in this chart. Line charts with one series are limited to ${ totalLimit } markers. Choose a numeric field with fewer unique values or apply a filter to your data.",
      twoSeriesLineCountCannotExceedLimit: "Line charts with two series are limited to ${ totalLimit } markers, or ${ seriesLimit } markers per series. Choose a numeric field with fewer unique values or apply a filter to your data.",
      threePlusSeriesLineCountCannotExceedLimit: "Line charts with three or more series are limited to ${ totalLimit } markers, or ${ seriesLimit } markers per series. Choose a numeric field with fewer unique values or apply a filter to your data.",
      uniqueTemporalSeriesLineCountCannotExceedLimit: "There are a total of ${ elementCount } markers in this chart. Line charts with one series are limited to ${ totalLimit } markers. Choose a larger temporal bin size or apply a filter to your data.",
      twoTemporalSeriesLineCountCannotExceedLimit: "Line charts with two series are limited to ${ totalLimit } markers, or ${ seriesLimit } markers per series. Choose a larger temporal bin size or apply a filter to your data.",
      threePlusTemporalSeriesLineCountCannotExceedLimit: "Line charts with three or more series are limited to ${ totalLimit } markers, or ${ seriesLimit } markers per series. Choose a larger temporal bin size or apply a filter to your data.",
      lineSeriesCountCannotExceedLimit: "Line charts are limited to ${ seriesLimit } series. Choose a split-by field with fewer unique values",
      uniqueSeriesBoxCountCannotExceedLimit: "There are a total of ${ elementCount } boxes in this chart. Box plots with one series are limited to ${ totalLimit } boxes. Choose a Category field with fewer unique values or apply a filter to your data.",
      twoSeriesBoxCountCannotExceedLimit: "Box plots with two series are limited to ${ totalLimit } boxes, or ${ seriesLimit } boxes per series. Choose a Category field with fewer unique values or apply a filter to your data.",
      threePlusBoxLineCountCannotExceedLimit: "Box plots with three or more series are limited to ${ totalLimit } boxes, or ${ seriesLimit } boxes per series. Choose a Category field with fewer unique values or apply a filter to your data.",
      boxSeriesCountCannotExceedLimit: "Box plots are limited to ${ seriesLimit } series. Choose a split-by field with fewer unique values",
      boxSeriesOutlierCannotExceedLimit: "Box plots can only display up to ${ totalLimit } outlier points. Filter you data.",
      pieChartCannotHaveMixtureOfPositiveAndNegativeSlices: "Ensure the sum total of the chosen numeric field(s) returns all positive values or all negative values.",
      pieChartSlicesCannotExceedLimit: "There are a total of ${ sliceCount } slices in this chart. Pie charts are limited to ${ totalLimit } slices. Choose a Category field with fewer unique values, add fewer Numeric fields, or apply a filter to your data.",
      gaugeCannotExceedLimit: "Feature-based gauges are limited to ${ totalLimit } features. Filter your data.",
      negativeValueInDataForLogTransformation: "Cannot apply a log transformation to negative or zero values.",
      negativeValueInDataForSqrtTransformation: "Cannot apply a square root transformation to negative values.",
      logarithmicXAxisNotPossible: "Logarithmic value x-axis cannot have negative or zero values.",
      logarithmicYAxisNotPossible: "Logarithmic value y-axis cannot have negative or zero values.",
      histogramEmptyField: "Histograms require at least two numeric values.",
      noDataMessage: "No data is available to display due to empty data field(s) and/or combination of filters.",
      noDataFBSMessage: "Filter by selection is enabled. There are no selected features to display.",
      noDataFBEMessage: "Filter by extent is enabled. There are no features in the map extent to display.",
      exportImageChartNotReady: "Chart is not ready for export",
      exportImage: "Failed to export chart"
    }
  };
}
function ln() {
  return {
    chartType: {
      chart: "Chart",
      barChart: "Bar chart",
      lineChart: "Line chart",
      pieChart: "Pie chart",
      histogram: "Histogram",
      scatterplot: "Scatterplot",
      boxPlot: "Box plot"
    },
    statistics: {
      mean: "Mean",
      median: "Median",
      sum: "Sum",
      discretePercentile: "Discrete percentile",
      minimum: "Minimum",
      maximum: "Maximum",
      firstQuartile: "First quartile",
      thirdQuartile: "Third quartile",
      iqr: "IQR",
      standardDeviation: "Standard deviation",
      variance: "Variance",
      count: "Count",
      aggregation: "${ statistics } of ${ fieldName }",
      percent: "Percent",
      noAggregation: "No aggregation",
      meanValue: "Mean value"
    },
    overlays: {
      mean: "Mean",
      median: "Median",
      stdDev: "Standard Deviation",
      normal: "Normal Distribution",
      trendline: "Trendline"
    },
    actions: {
      editChart: "Edit chart",
      expand: "Expand",
      collapse: "Collapse"
    },
    tooltips: {
      logDisabled: "Logarithmic scales require positive values"
    },
    guideTooltipLabel: "From ${ guideStart } to ${ guideEnd }",
    pieChart: {
      defaultSliceGroupingLabel: "Other"
    },
    notAvailable: "Not Available",
    field: "Field"
  };
}
async function Je(a = Mr().locale) {
  let e = await import("./messages.en2.js");
  switch (a) {
    case M.Arabic:
      e = await import("./messages.ar2.js");
      break;
    case M.Bosnian:
      e = await import("./messages.bs2.js");
      break;
    case M.Bulgarian:
      e = await import("./messages.bg2.js");
      break;
    case M.Catalan:
      e = await import("./messages.ca2.js");
      break;
    case M.Czech:
      e = await import("./messages.cs2.js");
      break;
    case M.Danish:
      e = await import("./messages.da2.js");
      break;
    case M.German:
      e = await import("./messages.de2.js");
      break;
    case M.Greek:
      e = await import("./messages.el2.js");
      break;
    case M.EnglishUSA:
      e = await import("./messages.en-US2.js");
      break;
    case M.Spanish:
      e = await import("./messages.es2.js");
      break;
    case M.Estonian:
      e = await import("./messages.et2.js");
      break;
    case M.Finnish:
      e = await import("./messages.fi2.js");
      break;
    case M.French:
      e = await import("./messages.fr2.js");
      break;
    case M.Hebrew:
      e = await import("./messages.he2.js");
      break;
    case M.Croatian:
      e = await import("./messages.hr2.js");
      break;
    case M.Hungarian:
      e = await import("./messages.hu2.js");
      break;
    case M.Indonesian:
      e = await import("./messages.id2.js");
      break;
    case M.Italian:
      e = await import("./messages.it2.js");
      break;
    case M.Japanese:
      e = await import("./messages.ja2.js");
      break;
    case M.Korean:
      e = await import("./messages.ko2.js");
      break;
    case M.Lithuanian:
      e = await import("./messages.lt2.js");
      break;
    case M.Latvian:
      e = await import("./messages.lv2.js");
      break;
    case M.NorwegianBokml:
      e = await import("./messages.no2.js");
      break;
    case M.Dutch:
      e = await import("./messages.nl2.js");
      break;
    case M.Polish:
      e = await import("./messages.pl2.js");
      break;
    case M.PortugueseBrazil:
      e = await import("./messages.pt-BR2.js");
      break;
    case M.PortuguesePortugal:
      e = await import("./messages.pt-PT2.js");
      break;
    case M.Romanian:
      e = await import("./messages.ro2.js");
      break;
    case M.Russian:
      e = await import("./messages.ru2.js");
      break;
    case M.Serbian:
      e = await import("./messages.sr2.js");
      break;
    case M.Slovak:
      e = await import("./messages.sk2.js");
      break;
    case M.Slovenian:
      e = await import("./messages.sl2.js");
      break;
    case M.Swedish:
      e = await import("./messages.sv2.js");
      break;
    case M.Thai:
      e = await import("./messages.th2.js");
      break;
    case M.Turkish:
      e = await import("./messages.tr2.js");
      break;
    case M.Ukrainian:
      e = await import("./messages.uk2.js");
      break;
    case M.Vietnamese:
      e = await import("./messages.vi2.js");
      break;
    case M.ChineseChina:
      e = await import("./messages.zh-CN2.js");
      break;
    case M.ChineseHongKong:
      e = await import("./messages.zh-HK2.js");
      break;
    case M.ChineseTaiwan:
      e = await import("./messages.zh-TW2.js");
      break;
    case M.English:
  }
  return e;
}
const Gi = {
  Reject: "reject",
  RenderUpToTheLimit: "renderUpToTheLimit"
}, ie = {
  AxisLabels: "axisLabels",
  GuideLabel: "guideLabel",
  AxisTitle: "axisTitle",
  ChartTitle: "chartTitle",
  ChartSubtitle: "chartSubtitle",
  DataLabels: "dataLabels",
  LegendTitle: "legendTitle",
  LegendText: "legendText",
  DescriptionText: "descriptionText"
}, rc = 32, un = "arcgis_charts_features_extent", mr = {
  maxRecordCountFactor: 5,
  maxParallelRequests: 4,
  maxRecords: 2e3,
  orderByJSAPIDelimiter: " ",
  outStatistics: {
    statisticType: Bs.statisticType,
    onStatisticField: "OBJECTID",
    outStatisticFieldName: "arcgis_charts_outStatisticFieldName_default_key"
  },
  uniqueIdsName: "arcgisChartsUniqueIds"
}, cn = ["EXPR_1", "Expr1", "expr1", "EXPR1"], ac = 1, Ve = 0.7, fn = 25, Wi = [156, 156, 156, 255], dn = [156, 156, 156, 255], tc = Br.Solid, ic = 2, sc = {
  defaultGroupOfSlicesId: "arcgis_charts_group_of_slices",
  sliceIdPrefix: "arcgis-charts-slice-id",
  undefinedSliceId: "arcgis-charts-slice-id-undefined",
  nullSliceId: "arcgis-charts-slice-id-null",
  emptySliceId: "arcgis-charts-slice-id-empty"
}, ft = "arcgis_charts_box_plot_category", hn = [
  [31, 120, 180, 255],
  [166, 206, 227, 255],
  [51, 160, 44, 255],
  [178, 223, 138, 255],
  [227, 26, 28, 255],
  [251, 154, 153, 255],
  [255, 127, 0, 255],
  [253, 191, 111, 255],
  [106, 61, 154, 255],
  [202, 178, 214, 255]
], mn = [
  [104, 104, 104, 255],
  [51, 124, 235, 255],
  [132, 0, 168, 255],
  [156, 156, 156, 255]
];
function Ge(a) {
  const { colorIndex: e, opacity: t, histogramOverlays: i } = a, r = Math.max(0, e ?? 0), s = [...i === !0 ? mn : hn], [o, n, f, d] = s[r % s.length], c = t !== void 0 ? t * 255 : d;
  return [o, n, f, c];
}
function Ki(a) {
  return [0, 0, 0, (a ?? Ve) * 255];
}
function nc() {
  return {
    type: $.CursorCrosshair,
    verticalLineVisible: !1,
    horizontalLineVisible: !1,
    style: {
      type: Oe.SLS,
      style: Br.Dot,
      color: [211, 211, 211, 255],
      width: 1
    }
  };
}
function na(a = 1) {
  return [
    Math.floor(Math.random() * 256),
    Math.floor(Math.random() * 256),
    Math.floor(Math.random() * 256),
    a * 255
  ];
}
function ue(a) {
  const e = {
    family: "Arial, Helvetica, sans-serif",
    size: 10
  };
  switch (a) {
    case ie.ChartTitle:
      e.size = 18;
      break;
    case ie.AxisTitle:
      e.size = 14;
      break;
    case ie.LegendText:
      e.size = 12;
      break;
    case ie.LegendTitle:
      e.size = 13;
      break;
    case ie.DescriptionText:
      e.size = 11;
      break;
  }
  return e;
}
function Ji(a = "", e = ue(), t) {
  let i = ut.Center;
  return (t === ie.DataLabels || t === ie.GuideLabel) && (i = void 0), {
    type: Oe.TS,
    color: Ki(),
    text: a,
    font: e,
    horizontalAlignment: i
  };
}
function ne(a) {
  const { text: e, visible: t, font: i, type: r } = a ?? {
    text: "",
    visible: !0,
    font: ue()
  };
  return {
    type: $.Text,
    visible: t,
    content: Ji(e, i, r)
  };
}
function jr(a) {
  const e = a?.useRandomColor ?? !1, t = a?.useRampColor, i = a?.width ?? 1, r = a?.isHistogramOverlay;
  let s = a?.color ?? Ki(1);
  return e ? s = na() : t !== void 0 && (r === !0 ? s = Ge({
    colorIndex: t.colorIndex,
    histogramOverlays: r
  }) : s = Ge({ colorIndex: t.colorIndex })), a?.opacity !== void 0 && (s[3] = a.opacity), {
    type: Oe.SLS,
    style: Br.Solid,
    color: s,
    width: i
  };
}
function pn() {
  return {
    type: $.CategoryAxisFormat,
    characterLimit: 11
  };
}
function oc() {
  return {
    type: $.DateAxisFormat,
    intlOptions: {}
  };
}
function nt() {
  return {
    type: $.NumberAxisFormat,
    intlOptions: {
      style: "decimal",
      minimumFractionDigits: 0,
      maximumFractionDigits: 3,
      useGrouping: !0
    }
  };
}
function lc() {
  return {
    type: $.NumberAxisFormat,
    intlOptions: {
      style: "decimal",
      minimumFractionDigits: 0,
      maximumFractionDigits: 2
    }
  };
}
function uc() {
  return {
    type: $.NumberAxisFormat,
    intlOptions: {
      style: "percent",
      minimumFractionDigits: 0,
      maximumFractionDigits: 0
    }
  };
}
function qt(a = "Category Axis") {
  const e = ne({
    text: a,
    visible: !0,
    font: ue(ie.AxisTitle)
  });
  e.content.horizontalAlignment = ut.Center, e.content.verticalAlignment = Vi.Middle;
  const t = ne({
    text: a,
    visible: !0,
    font: ue(ie.AxisLabels)
  });
  return {
    type: $.Axis,
    visible: !0,
    title: e,
    labels: t,
    valueFormat: pn(),
    lineSymbol: jr({ color: Wi })
  };
}
function ea(a = "Value Axis") {
  const e = ne({
    text: a,
    visible: !0,
    font: ue(ie.AxisTitle)
  }), t = ne({
    text: a,
    visible: !0,
    font: ue(ie.AxisLabels)
  });
  return e.content.verticalAlignment = Vi.Middle, e.content.horizontalAlignment = ut.Center, {
    type: $.Axis,
    visible: !0,
    title: e,
    labels: t,
    valueFormat: nt(),
    lineSymbol: jr({ color: Wi })
  };
}
function pr() {
  return {
    type: $.Legend,
    visible: !0,
    title: ne({
      text: "",
      visible: !0,
      font: ue(ie.LegendTitle)
    }),
    body: Ji("", ue(ie.LegendText)),
    position: Ms.Right,
    maxHeight: Number.NaN
  };
}
function Gr(a) {
  return {
    type: $.Overlay,
    visible: !0,
    created: !1,
    symbol: jr({
      useRampColor: { colorIndex: a },
      isHistogramOverlay: !0
    })
  };
}
function vr() {
  return [255, 255, 255, 255];
}
async function or() {
  return (await Je()).defaultTitle;
}
function lr() {
  return `Chart ${Date.now()}`;
}
function cc(a, e = !1) {
  return {
    type: Oe.SFS,
    style: qr.Solid,
    color: e ? na(Ve) : Ge({
      colorIndex: a ?? 0,
      opacity: Ve
    })
  };
}
function vn(a = 0) {
  return {
    type: Oe.SMS,
    style: ji.Circle,
    color: Ge({
      colorIndex: a,
      opacity: Ve
    }),
    size: 4
  };
}
function gn(a) {
  return {
    type: Oe.SLS,
    style: Br.Solid,
    color: Ge({
      colorIndex: a,
      opacity: Ve
    }),
    width: 2
  };
}
function yn(a = !1) {
  return {
    type: Oe.SMS,
    style: ji.Circle,
    color: a ? na(Ve) : Ge({ colorIndex: 0, opacity: Ve }),
    size: 7
  };
}
function fc() {
  return {
    type: $.SizePolicy,
    field: "",
    scaleType: ks.Linear,
    minSize: 5,
    maxSize: 30
  };
}
function Sn(a = !1) {
  return {
    type: $.Overlays,
    trendLine: {
      type: $.Overlay,
      created: !1,
      visible: !0,
      symbol: {
        type: Oe.SLS,
        style: Br.Solid,
        color: a ? na() : Ge({ colorIndex: 1 }),
        width: 2
      }
    }
  };
}
function bn() {
  return {
    type: $.ScatterSeries,
    id: $.ScatterSeries,
    name: $.ScatterSeries,
    x: "",
    y: "",
    markerSymbol: yn(),
    overlays: Sn(),
    dataLabels: ne({
      text: "",
      visible: !1,
      font: ue(ie.DataLabels)
    })
  };
}
async function Fr(a) {
  const e = await Je(), t = [], i = e.xAxis, r = e.statistics.count;
  let s;
  const o = ea(r), n = jr({
    opacity: fn
  });
  switch (o.grid = n, a) {
    case $.BarSeries: {
      s = qt(i);
      break;
    }
    case $.ScatterSeries: {
      s = ea(i), s.grid = n;
      break;
    }
    case $.RadarSeries:
    case $.LineSeries:
    case $.HistogramSeries: {
      s = ea(i);
      break;
    }
    case $.BoxPlotSeries: {
      s = qt("");
      break;
    }
  }
  return s !== void 0 && t.push(s, o), t;
}
function Pn() {
  return {
    type: $.GaugeNeedle,
    symbol: {
      type: Oe.SFS,
      color: [0, 0, 0, 200]
    }
  };
}
async function wn() {
  const a = await Je(), e = [], t = a.xAxis, i = ea(t);
  return i.needle = Pn(), e.push(i), e;
}
async function En(a) {
  const e = a.objectIDField ?? "ObjectID", t = `${Se.Count}_${e}_0`.toUpperCase(), r = (await Je()).countSeries;
  return {
    type: $.LineSeries,
    id: r,
    name: r,
    query: {
      outStatistics: [
        {
          statisticType: Se.Count,
          onStatisticField: e,
          outStatisticFieldName: t
        }
      ],
      groupByFieldsForStatistics: []
    },
    x: "",
    y: t,
    lineSymbol: gn(a.seriesIndex),
    markerSymbol: vn(a.seriesIndex),
    dataLabels: ne({
      text: "",
      visible: !1,
      font: ue(ie.DataLabels)
    }),
    temporalBinning: {
      type: Mi.FixedDateBased,
      unit: Re.Day,
      size: 0,
      timeAggregationType: $r.Start,
      trimIncompleteTimeInterval: !0,
      nullPolicy: qs.Interpolate
    }
  };
}
async function dc(a) {
  return { ...await En(a), type: $.RadarSeries };
}
function xn(a) {
  return {
    type: Oe.SFS,
    style: qr.Solid,
    color: Ge({
      colorIndex: a,
      opacity: Ve
    })
  };
}
async function hc(a) {
  const e = a.objectIDField ?? "ObjectID", t = `${Se.Count}_${e}_0`.toUpperCase(), r = (await Je()).countSeries;
  return {
    type: $.BarSeries,
    id: r,
    name: r,
    query: {
      outStatistics: [
        {
          statisticType: Se.Count,
          onStatisticField: e,
          outStatisticFieldName: t
        }
      ],
      groupByFieldsForStatistics: []
    },
    x: "",
    y: t,
    fillSymbol: xn(a.seriesIndex),
    dataLabels: ne({
      text: "",
      visible: !1,
      font: ue(ie.DataLabels),
      type: ie.DataLabels
    })
  };
}
async function mc(a) {
  const t = (await Je()).countSeries;
  return {
    name: t,
    type: $.BoxPlotSeries,
    id: t,
    fillSymbol: {
      type: Oe.SFS,
      style: qr.Solid,
      color: Ge({
        colorIndex: a,
        opacity: Ve
      })
    },
    query: {},
    x: ft,
    y: ""
  };
}
function Fn() {
  return {
    type: $.PieTick,
    visible: !0,
    lineSymbol: jr({
      width: 1,
      color: dn
    })
  };
}
function Cn() {
  return {
    type: Oe.SFS,
    style: qr.Solid
  };
}
async function pc(a) {
  const e = `${Se.Count}_${a}_0`.toUpperCase(), i = (await Je()).countSeries;
  return {
    type: $.PieSeries,
    id: i,
    name: i,
    query: {
      outStatistics: [
        {
          statisticType: Se.Count,
          onStatisticField: a ?? "ObjectID",
          outStatisticFieldName: e
        }
      ],
      groupByFieldsForStatistics: []
    },
    x: "",
    y: e,
    fillSymbol: Cn(),
    dataLabels: ne({
      text: "",
      visible: !1,
      font: ue(ie.DataLabels),
      type: ie.DataLabels
    }),
    startAngle: -90,
    endAngle: 270,
    dataLabelsCharacterLimit: 11,
    displayCategoryOnDataLabel: !0,
    displayNumericValueOnDataLabel: !1,
    displayPercentageOnDataLabel: !0,
    numericValueFormat: {
      ...nt(),
      intlOptions: {
        minimumFractionDigits: 1,
        maximumFractionDigits: 1
      }
    },
    percentValueFormat: {
      ...nt(),
      intlOptions: {
        minimumFractionDigits: 1,
        maximumFractionDigits: 1
      }
    },
    ticks: Fn()
  };
}
function vc(a) {
  const e = a.objectIDField ?? "ObjectID", t = `${Se.Count}_${e}_0`.toUpperCase(), i = "Series0";
  return {
    type: $.GaugeSeries,
    id: i,
    name: i,
    query: {
      outStatistics: [
        {
          statisticType: Se.Count,
          onStatisticField: e,
          outStatisticFieldName: t
        }
      ]
    },
    x: ""
  };
}
function Or() {
  return !1;
}
async function gc(a = lr()) {
  return {
    version: nr,
    type: $.Chart,
    id: a,
    colorMatch: !0,
    rotated: Or(),
    orderOptions: {
      data: {
        orderType: kr.Category,
        orderBy: ir.Ascending
      }
    },
    title: ne({
      text: await or(),
      visible: !0,
      font: ue(ie.ChartTitle)
    }),
    subtitle: ne(),
    footer: ne({
      text: "",
      visible: !0,
      font: ue(ie.DescriptionText)
    }),
    background: vr(),
    axes: await Fr($.BarSeries),
    series: [],
    legend: pr()
  };
}
async function yc(a = lr()) {
  return {
    version: nr,
    type: $.Chart,
    id: a,
    rotated: Or(),
    colorMatch: !0,
    orderOptions: {
      data: {
        orderType: kr.Category,
        orderBy: ir.Ascending
      }
    },
    title: ne({
      text: await or(),
      visible: !0,
      font: ue(ie.ChartTitle)
    }),
    subtitle: ne(),
    footer: ne({
      text: "",
      visible: !0,
      font: ue(ie.DescriptionText)
    }),
    background: vr(),
    series: [],
    legend: pr(),
    axes: await Fr($.BoxPlotSeries),
    standardizeValues: !0,
    showOutliers: !1
  };
}
async function Sc(a = lr()) {
  return {
    version: nr,
    type: $.Chart,
    id: a,
    colorMatch: !0,
    rotated: Or(),
    orderOptions: {
      data: {
        orderType: kr.Category,
        orderBy: ir.Ascending
      }
    },
    title: ne({
      text: await or(),
      visible: !0,
      font: ue(ie.ChartTitle)
    }),
    subtitle: ne(),
    footer: ne({
      text: "",
      visible: !0,
      font: ue(ie.DescriptionText)
    }),
    background: vr(),
    axes: await Fr($.LineSeries),
    series: [],
    legend: pr()
  };
}
async function bc(a = lr()) {
  return {
    version: nr,
    type: $.Chart,
    id: a,
    colorMatch: !0,
    orderOptions: {
      data: {
        orderType: kr.Category,
        orderBy: ir.Ascending
      }
    },
    title: ne({
      text: await or(),
      visible: !0,
      font: ue(ie.ChartTitle)
    }),
    subtitle: ne(),
    footer: ne({
      text: "",
      visible: !0,
      font: ue(ie.DescriptionText)
    }),
    background: vr(),
    axes: await Fr($.RadarSeries),
    series: [],
    legend: pr()
  };
}
async function Pc(a = lr()) {
  return {
    version: nr,
    type: $.Chart,
    id: a,
    colorMatch: !0,
    orderOptions: {
      data: {
        orderType: kr.YValue,
        orderBy: ir.Descending
      }
    },
    title: ne({
      text: await or(),
      visible: !0,
      font: ue(ie.ChartTitle)
    }),
    subtitle: ne(),
    footer: ne({
      text: "",
      visible: !0,
      font: ue(ie.DescriptionText)
    }),
    background: vr(),
    series: [],
    legend: {
      ...pr(),
      displayNumericValue: !1,
      displayPercentage: !0
    }
  };
}
async function wc(a = lr()) {
  return {
    version: nr,
    type: $.Chart,
    id: a,
    colorMatch: !0,
    title: ne({
      text: await or(),
      visible: !0,
      font: ue(ie.ChartTitle)
    }),
    series: [],
    axes: await wn()
  };
}
async function Ec(a = lr()) {
  return {
    version: nr,
    type: $.Chart,
    id: a,
    colorMatch: !0,
    title: ne({
      text: await or(),
      visible: !0,
      font: ue(ie.ChartTitle)
    }),
    subtitle: ne(),
    footer: ne({
      text: "",
      visible: !0,
      font: ue(ie.DescriptionText)
    }),
    background: vr(),
    axes: await Fr($.ScatterSeries),
    series: [bn()],
    legend: pr()
  };
}
function An() {
  return {
    type: $.Overlays,
    mean: Gr(1),
    median: Gr(2),
    standardDeviation: Gr(3),
    comparisonDistribution: Gr(4)
  };
}
function Dn() {
  return {
    type: Oe.SFS,
    style: qr.Solid,
    color: Ge({ colorIndex: 0, opacity: Ve })
  };
}
function Tn() {
  return {
    type: $.HistogramSeries,
    id: $.HistogramSeries,
    name: $.HistogramSeries,
    visible: !0,
    dataTooltipVisible: !0,
    dataTooltipReverseColor: !1,
    assignToSecondValueAxis: !1,
    x: "",
    binCount: 32,
    overlays: An(),
    dataTransformationType: qi.None,
    fillSymbol: Dn(),
    dataLabels: ne({
      text: "",
      visible: !1,
      font: ue(ie.DataLabels)
    })
  };
}
async function xc(a = lr()) {
  return {
    version: nr,
    type: $.Chart,
    id: a,
    colorMatch: !0,
    title: ne({
      text: await or(),
      visible: !0,
      font: ue(ie.ChartTitle)
    }),
    subtitle: ne(),
    footer: ne({
      text: "",
      visible: !0,
      font: ue(ie.DescriptionText)
    }),
    background: vr(),
    axes: await Fr($.HistogramSeries),
    series: [Tn()],
    legend: pr()
  };
}
const Wr = {
  // chart's behavior once the limit is reached
  behaviorAfterLimit: Gi.Reject,
  // maximum number of categories for any chart.
  maxCategoryCount: Number.NaN,
  // maximum number of series for a bar chart
  maxBarChartSeriesCount: 100,
  // maximum number of bars for a unique series bar chart
  maxBarUniqueSeriesCountTotal: 1e4,
  // maximum number of bars per series for a 2 series bar chart
  maxBarTwoSeriesCountPerSeries: 1e3,
  // maximum number of bars for a 2 series bar chart
  maxBarTwoSeriesCountTotal: 2e3,
  // maximum number of bars per series for a 3+ series bar chart
  maxBarThreePlusSeriesCountPerSeries: 100,
  // maximum number of bars for a 3+ series bar chart
  maxBarThreePlusSeriesCountTotal: 2e3,
  /**
   * Specifies the maximum number of points to be rendered in a scatter plot.
   * If the number of points are more, then the data will be aggregated in
   * a 2D grid of size sqrt(maxScatterPointsAfterAggregation) x sqrt(maxScatterPointsAfterAggregation)
   */
  maxScatterPointsBeforeAggregation: 1e4,
  // Specifies how many maximum points can be displayed once the scatter plot data is aggregated
  maxScatterPointsAfterAggregation: 1e4,
  // maximum number of series for a line chart
  maxLineChartSeriesCount: 100,
  // maximum number of markers for a unique series line chart
  maxLineUniqueSeriesCountTotal: 1e4,
  // maximum number of markers per series for a 2 series line chart
  maxLineTwoSeriesCountPerSeries: 5e3,
  // maximum number of markers for a 2 series line chart
  maxLineTwoSeriesCountTotal: 1e4,
  // maximum number of markers per series for a 3+ series line chart
  maxLineThreePlusSeriesCountPerSeries: 1e3,
  // maximum number of markers for a 3+ series line chart
  maxLineThreePlusSeriesCountTotal: 1e4,
  // maximum number of slices for pie chart
  maxPieChartSliceCountTotal: 300,
  // maximum number of features for a gauge-by-feature collection
  maxGaugeByFeaturesLimit: 50,
  // maximum number of series for a bar chart
  maxBoxPlotSeriesCount: 100,
  // maximum number of boxes for a unique series box plot
  maxBoxUniqueSeriesCountTotal: 1e4,
  // maximum number of boxes per series for a 2 series box plot
  maxBoxTwoSeriesCountPerSeries: 1e3,
  // maximum number of boxes for a 2 series box plot
  maxBoxTwoSeriesCountTotal: 2e3,
  // maximum number of boxes per series for a 3+ series box plot
  maxBoxThreePlusSeriesCountPerSeries: 100,
  // maximum number of boxes for a 3+ series box plot
  maxBoxThreePlusSeriesCountTotal: 2e3,
  // maximum number of outliers for box plot
  maxBoxPlotOutlierLimit: 1e4
};
function Ln(a) {
  const e = { ...Wr };
  return a !== void 0 && Object.keys(Wr).forEach((t) => {
    const i = t;
    e[i] = a[i] ?? Wr[i];
  }), e;
}
function Fc() {
  return {
    /* Specifies the size of the queries on an aggregated scatter plot, counting the number of cells per query.
    A bigger number implies fewer but slower queries. A smaller number implies more but faster queries.
    */
    maxScatterCellsPerQuery: 500,
    /* Specifies the size of the queries on an aggregated scatter plot, counting the number of cells per query for Hosted feature layers using standard databases in ArcGIS Online.
    A bigger number implies fewer but slower queries. A smaller number implies more but faster queries.
    */
    maxScatterCellsPerQueryForStandard: 175,
    /**
     * Specifies the number of elements (bars, markers, slices) to be considered per selection query.
     */
    maxElementsPerSelectionQuery: 25,
    /**
     * Specifies the maximum number of OIDs to be used in a selection query. They are used as `OBJECTID IN (<oid list>)`
     */
    maxOIDsPerSelectionQuery: 2e3,
    /**
     * Specifies the maximum number of operands (e.g. field < value) in a where clause.
     */
    maxOperandsPerWhereClause: 200
  };
}
async function Cc(a) {
  const e = await Je();
  let t;
  switch (a) {
    case Se.Average: {
      t = e.statistics.mean;
      break;
    }
    case Se.ContinuousPercentile: {
      t = e.statistics.median;
      break;
    }
    case Se.Sum: {
      t = e.statistics.sum;
      break;
    }
    case Se.Minimum: {
      t = e.statistics.minimum;
      break;
    }
    case Se.Maximum: {
      t = e.statistics.maximum;
      break;
    }
    case Se.Variance: {
      t = e.statistics.variance;
      break;
    }
    case Se.DiscretePercentile: {
      t = e.statistics.discretePercentile;
      break;
    }
    case Se.NoAggregation: {
      t = e.statistics.noAggregation;
      break;
    }
    case Se.Count:
    default: {
      t = e.statistics.count;
      break;
    }
  }
  return t;
}
async function Ac(a) {
  const e = await Je();
  let t;
  switch (a) {
    case $r.End: {
      t = e.timeAggregationTypes.end;
      break;
    }
    case $r.Start: {
      t = e.timeAggregationTypes.start;
      break;
    }
    default:
      t = "";
      break;
  }
  return t;
}
function In() {
  return Zr.Side;
}
async function Dc() {
  return (await Je()).notAvailable;
}
const Tc = 0, Rn = "_arcgis_charts_outliers", $n = "_arcgis_charts_z_score", Lc = [210, 210, 210, 255 * Ve], Ic = " percentage ";
/*!
 * @esri/arcgis-html-sanitizer - v4.1.0 - Tue Dec 03 2024 09:13:28 GMT-0500 (Eastern Standard Time)
 * Copyright (c) 2024 - Environmental Systems Research Institute, Inc.
 * Apache-2.0
 * 
 * js-xss
 * Copyright (c) 2012-2018 Zongmin Lei(雷宗民) <leizongmin@gmail.com>
 * http://ucdok.com
 * MIT License, see https://github.com/leizongmin/js-xss/blob/master/LICENSE for details
 */
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var aa = function() {
  return aa = Object.assign || function(e) {
    for (var t, i = 1, r = arguments.length; i < r; i++) {
      t = arguments[i];
      for (var s in t) Object.prototype.hasOwnProperty.call(t, s) && (e[s] = t[s]);
    }
    return e;
  }, aa.apply(this, arguments);
}, ot = { exports: {} }, ge = {}, lt = { exports: {} }, gr = {};
function Xi() {
  var a = {};
  return a["align-content"] = !1, a["align-items"] = !1, a["align-self"] = !1, a["alignment-adjust"] = !1, a["alignment-baseline"] = !1, a.all = !1, a["anchor-point"] = !1, a.animation = !1, a["animation-delay"] = !1, a["animation-direction"] = !1, a["animation-duration"] = !1, a["animation-fill-mode"] = !1, a["animation-iteration-count"] = !1, a["animation-name"] = !1, a["animation-play-state"] = !1, a["animation-timing-function"] = !1, a.azimuth = !1, a["backface-visibility"] = !1, a.background = !0, a["background-attachment"] = !0, a["background-clip"] = !0, a["background-color"] = !0, a["background-image"] = !0, a["background-origin"] = !0, a["background-position"] = !0, a["background-repeat"] = !0, a["background-size"] = !0, a["baseline-shift"] = !1, a.binding = !1, a.bleed = !1, a["bookmark-label"] = !1, a["bookmark-level"] = !1, a["bookmark-state"] = !1, a.border = !0, a["border-bottom"] = !0, a["border-bottom-color"] = !0, a["border-bottom-left-radius"] = !0, a["border-bottom-right-radius"] = !0, a["border-bottom-style"] = !0, a["border-bottom-width"] = !0, a["border-collapse"] = !0, a["border-color"] = !0, a["border-image"] = !0, a["border-image-outset"] = !0, a["border-image-repeat"] = !0, a["border-image-slice"] = !0, a["border-image-source"] = !0, a["border-image-width"] = !0, a["border-left"] = !0, a["border-left-color"] = !0, a["border-left-style"] = !0, a["border-left-width"] = !0, a["border-radius"] = !0, a["border-right"] = !0, a["border-right-color"] = !0, a["border-right-style"] = !0, a["border-right-width"] = !0, a["border-spacing"] = !0, a["border-style"] = !0, a["border-top"] = !0, a["border-top-color"] = !0, a["border-top-left-radius"] = !0, a["border-top-right-radius"] = !0, a["border-top-style"] = !0, a["border-top-width"] = !0, a["border-width"] = !0, a.bottom = !1, a["box-decoration-break"] = !0, a["box-shadow"] = !0, a["box-sizing"] = !0, a["box-snap"] = !0, a["box-suppress"] = !0, a["break-after"] = !0, a["break-before"] = !0, a["break-inside"] = !0, a["caption-side"] = !1, a.chains = !1, a.clear = !0, a.clip = !1, a["clip-path"] = !1, a["clip-rule"] = !1, a.color = !0, a["color-interpolation-filters"] = !0, a["column-count"] = !1, a["column-fill"] = !1, a["column-gap"] = !1, a["column-rule"] = !1, a["column-rule-color"] = !1, a["column-rule-style"] = !1, a["column-rule-width"] = !1, a["column-span"] = !1, a["column-width"] = !1, a.columns = !1, a.contain = !1, a.content = !1, a["counter-increment"] = !1, a["counter-reset"] = !1, a["counter-set"] = !1, a.crop = !1, a.cue = !1, a["cue-after"] = !1, a["cue-before"] = !1, a.cursor = !1, a.direction = !1, a.display = !0, a["display-inside"] = !0, a["display-list"] = !0, a["display-outside"] = !0, a["dominant-baseline"] = !1, a.elevation = !1, a["empty-cells"] = !1, a.filter = !1, a.flex = !1, a["flex-basis"] = !1, a["flex-direction"] = !1, a["flex-flow"] = !1, a["flex-grow"] = !1, a["flex-shrink"] = !1, a["flex-wrap"] = !1, a.float = !1, a["float-offset"] = !1, a["flood-color"] = !1, a["flood-opacity"] = !1, a["flow-from"] = !1, a["flow-into"] = !1, a.font = !0, a["font-family"] = !0, a["font-feature-settings"] = !0, a["font-kerning"] = !0, a["font-language-override"] = !0, a["font-size"] = !0, a["font-size-adjust"] = !0, a["font-stretch"] = !0, a["font-style"] = !0, a["font-synthesis"] = !0, a["font-variant"] = !0, a["font-variant-alternates"] = !0, a["font-variant-caps"] = !0, a["font-variant-east-asian"] = !0, a["font-variant-ligatures"] = !0, a["font-variant-numeric"] = !0, a["font-variant-position"] = !0, a["font-weight"] = !0, a.grid = !1, a["grid-area"] = !1, a["grid-auto-columns"] = !1, a["grid-auto-flow"] = !1, a["grid-auto-rows"] = !1, a["grid-column"] = !1, a["grid-column-end"] = !1, a["grid-column-start"] = !1, a["grid-row"] = !1, a["grid-row-end"] = !1, a["grid-row-start"] = !1, a["grid-template"] = !1, a["grid-template-areas"] = !1, a["grid-template-columns"] = !1, a["grid-template-rows"] = !1, a["hanging-punctuation"] = !1, a.height = !0, a.hyphens = !1, a.icon = !1, a["image-orientation"] = !1, a["image-resolution"] = !1, a["ime-mode"] = !1, a["initial-letters"] = !1, a["inline-box-align"] = !1, a["justify-content"] = !1, a["justify-items"] = !1, a["justify-self"] = !1, a.left = !1, a["letter-spacing"] = !0, a["lighting-color"] = !0, a["line-box-contain"] = !1, a["line-break"] = !1, a["line-grid"] = !1, a["line-height"] = !1, a["line-snap"] = !1, a["line-stacking"] = !1, a["line-stacking-ruby"] = !1, a["line-stacking-shift"] = !1, a["line-stacking-strategy"] = !1, a["list-style"] = !0, a["list-style-image"] = !0, a["list-style-position"] = !0, a["list-style-type"] = !0, a.margin = !0, a["margin-bottom"] = !0, a["margin-left"] = !0, a["margin-right"] = !0, a["margin-top"] = !0, a["marker-offset"] = !1, a["marker-side"] = !1, a.marks = !1, a.mask = !1, a["mask-box"] = !1, a["mask-box-outset"] = !1, a["mask-box-repeat"] = !1, a["mask-box-slice"] = !1, a["mask-box-source"] = !1, a["mask-box-width"] = !1, a["mask-clip"] = !1, a["mask-image"] = !1, a["mask-origin"] = !1, a["mask-position"] = !1, a["mask-repeat"] = !1, a["mask-size"] = !1, a["mask-source-type"] = !1, a["mask-type"] = !1, a["max-height"] = !0, a["max-lines"] = !1, a["max-width"] = !0, a["min-height"] = !0, a["min-width"] = !0, a["move-to"] = !1, a["nav-down"] = !1, a["nav-index"] = !1, a["nav-left"] = !1, a["nav-right"] = !1, a["nav-up"] = !1, a["object-fit"] = !1, a["object-position"] = !1, a.opacity = !1, a.order = !1, a.orphans = !1, a.outline = !1, a["outline-color"] = !1, a["outline-offset"] = !1, a["outline-style"] = !1, a["outline-width"] = !1, a.overflow = !1, a["overflow-wrap"] = !1, a["overflow-x"] = !1, a["overflow-y"] = !1, a.padding = !0, a["padding-bottom"] = !0, a["padding-left"] = !0, a["padding-right"] = !0, a["padding-top"] = !0, a.page = !1, a["page-break-after"] = !1, a["page-break-before"] = !1, a["page-break-inside"] = !1, a["page-policy"] = !1, a.pause = !1, a["pause-after"] = !1, a["pause-before"] = !1, a.perspective = !1, a["perspective-origin"] = !1, a.pitch = !1, a["pitch-range"] = !1, a["play-during"] = !1, a.position = !1, a["presentation-level"] = !1, a.quotes = !1, a["region-fragment"] = !1, a.resize = !1, a.rest = !1, a["rest-after"] = !1, a["rest-before"] = !1, a.richness = !1, a.right = !1, a.rotation = !1, a["rotation-point"] = !1, a["ruby-align"] = !1, a["ruby-merge"] = !1, a["ruby-position"] = !1, a["shape-image-threshold"] = !1, a["shape-outside"] = !1, a["shape-margin"] = !1, a.size = !1, a.speak = !1, a["speak-as"] = !1, a["speak-header"] = !1, a["speak-numeral"] = !1, a["speak-punctuation"] = !1, a["speech-rate"] = !1, a.stress = !1, a["string-set"] = !1, a["tab-size"] = !1, a["table-layout"] = !1, a["text-align"] = !0, a["text-align-last"] = !0, a["text-combine-upright"] = !0, a["text-decoration"] = !0, a["text-decoration-color"] = !0, a["text-decoration-line"] = !0, a["text-decoration-skip"] = !0, a["text-decoration-style"] = !0, a["text-emphasis"] = !0, a["text-emphasis-color"] = !0, a["text-emphasis-position"] = !0, a["text-emphasis-style"] = !0, a["text-height"] = !0, a["text-indent"] = !0, a["text-justify"] = !0, a["text-orientation"] = !0, a["text-overflow"] = !0, a["text-shadow"] = !0, a["text-space-collapse"] = !0, a["text-transform"] = !0, a["text-underline-position"] = !0, a["text-wrap"] = !0, a.top = !1, a.transform = !1, a["transform-origin"] = !1, a["transform-style"] = !1, a.transition = !1, a["transition-delay"] = !1, a["transition-duration"] = !1, a["transition-property"] = !1, a["transition-timing-function"] = !1, a["unicode-bidi"] = !1, a["vertical-align"] = !1, a.visibility = !1, a["voice-balance"] = !1, a["voice-duration"] = !1, a["voice-family"] = !1, a["voice-pitch"] = !1, a["voice-range"] = !1, a["voice-rate"] = !1, a["voice-stress"] = !1, a["voice-volume"] = !1, a.volume = !1, a["white-space"] = !1, a.widows = !1, a.width = !0, a["will-change"] = !1, a["word-break"] = !0, a["word-spacing"] = !0, a["word-wrap"] = !0, a["wrap-flow"] = !1, a["wrap-through"] = !1, a["writing-mode"] = !1, a["z-index"] = !1, a;
}
function On(a, e, t) {
}
function _n(a, e, t) {
}
var Nn = /javascript\s*\:/img;
function Bn(a, e) {
  return Nn.test(e) ? "" : e;
}
gr.whiteList = Xi();
gr.getDefaultWhiteList = Xi;
gr.onAttr = On;
gr.onIgnoreAttr = _n;
gr.safeAttrValue = Bn;
var kn = {
  indexOf: function(a, e) {
    var t, i;
    if (Array.prototype.indexOf)
      return a.indexOf(e);
    for (t = 0, i = a.length; t < i; t++)
      if (a[t] === e)
        return t;
    return -1;
  },
  forEach: function(a, e, t) {
    var i, r;
    if (Array.prototype.forEach)
      return a.forEach(e, t);
    for (i = 0, r = a.length; i < r; i++)
      e.call(t, a[i], i, a);
  },
  trim: function(a) {
    return String.prototype.trim ? a.trim() : a.replace(/(^\s*)|(\s*$)/g, "");
  },
  trimRight: function(a) {
    return String.prototype.trimRight ? a.trimRight() : a.replace(/(\s*$)/g, "");
  }
}, Ir = kn;
function qn(a, e) {
  a = Ir.trimRight(a), a[a.length - 1] !== ";" && (a += ";");
  var t = a.length, i = !1, r = 0, s = 0, o = "";
  function n() {
    if (!i) {
      var c = Ir.trim(a.slice(r, s)), u = c.indexOf(":");
      if (u !== -1) {
        var p = Ir.trim(c.slice(0, u)), l = Ir.trim(c.slice(u + 1));
        if (p) {
          var h = e(r, o.length, p, l, c);
          h && (o += h + "; ");
        }
      }
    }
    r = s + 1;
  }
  for (; s < t; s++) {
    var f = a[s];
    if (f === "/" && a[s + 1] === "*") {
      var d = a.indexOf("*/", s + 2);
      if (d === -1) break;
      s = d + 1, r = s + 1, i = !1;
    } else f === "(" ? i = !0 : f === ")" ? i = !1 : f === ";" ? i || n() : f === `
` && n();
  }
  return Ir.trim(o);
}
var Mn = qn, Kr = gr, jn = Mn;
function Mt(a) {
  return a == null;
}
function Vn(a) {
  var e = {};
  for (var t in a)
    e[t] = a[t];
  return e;
}
function Yi(a) {
  a = Vn(a || {}), a.whiteList = a.whiteList || Kr.whiteList, a.onAttr = a.onAttr || Kr.onAttr, a.onIgnoreAttr = a.onIgnoreAttr || Kr.onIgnoreAttr, a.safeAttrValue = a.safeAttrValue || Kr.safeAttrValue, this.options = a;
}
Yi.prototype.process = function(a) {
  if (a = a || "", a = a.toString(), !a) return "";
  var e = this, t = e.options, i = t.whiteList, r = t.onAttr, s = t.onIgnoreAttr, o = t.safeAttrValue, n = jn(a, function(f, d, c, u, p) {
    var l = i[c], h = !1;
    if (l === !0 ? h = l : typeof l == "function" ? h = l(u) : l instanceof RegExp && (h = l.test(u)), h !== !0 && (h = !1), u = o(c, u), !!u) {
      var g = {
        position: d,
        sourcePosition: f,
        source: p,
        isWhite: h
      };
      if (h) {
        var v = r(c, u, g);
        return Mt(v) ? c + ":" + u : v;
      } else {
        var v = s(c, u, g);
        if (!Mt(v))
          return v;
      }
    }
  });
  return n;
};
var zn = Yi;
(function(a, e) {
  var t = gr, i = zn;
  function r(o, n) {
    var f = new i(n);
    return f.process(o);
  }
  e = a.exports = r, e.FilterCSS = i;
  for (var s in t) e[s] = t[s];
})(lt, lt.exports);
var dt = lt.exports, ht = {
  indexOf: function(a, e) {
    var t, i;
    if (Array.prototype.indexOf)
      return a.indexOf(e);
    for (t = 0, i = a.length; t < i; t++)
      if (a[t] === e)
        return t;
    return -1;
  },
  forEach: function(a, e, t) {
    var i, r;
    if (Array.prototype.forEach)
      return a.forEach(e, t);
    for (i = 0, r = a.length; i < r; i++)
      e.call(t, a[i], i, a);
  },
  trim: function(a) {
    return String.prototype.trim ? a.trim() : a.replace(/(^\s*)|(\s*$)/g, "");
  },
  spaceIndex: function(a) {
    var e = /\s|\n|\t/, t = e.exec(a);
    return t ? t.index : -1;
  }
}, Un = dt.FilterCSS, Qn = dt.getDefaultWhiteList, ta = ht;
function Zi() {
  return {
    a: ["target", "href", "title"],
    abbr: ["title"],
    address: [],
    area: ["shape", "coords", "href", "alt"],
    article: [],
    aside: [],
    audio: [
      "autoplay",
      "controls",
      "crossorigin",
      "loop",
      "muted",
      "preload",
      "src"
    ],
    b: [],
    bdi: ["dir"],
    bdo: ["dir"],
    big: [],
    blockquote: ["cite"],
    br: [],
    caption: [],
    center: [],
    cite: [],
    code: [],
    col: ["align", "valign", "span", "width"],
    colgroup: ["align", "valign", "span", "width"],
    dd: [],
    del: ["datetime"],
    details: ["open"],
    div: [],
    dl: [],
    dt: [],
    em: [],
    figcaption: [],
    figure: [],
    font: ["color", "size", "face"],
    footer: [],
    h1: [],
    h2: [],
    h3: [],
    h4: [],
    h5: [],
    h6: [],
    header: [],
    hr: [],
    i: [],
    img: ["src", "alt", "title", "width", "height"],
    ins: ["datetime"],
    li: [],
    mark: [],
    nav: [],
    ol: [],
    p: [],
    pre: [],
    s: [],
    section: [],
    small: [],
    span: [],
    sub: [],
    summary: [],
    sup: [],
    strong: [],
    strike: [],
    table: ["width", "border", "align", "valign"],
    tbody: ["align", "valign"],
    td: ["width", "rowspan", "colspan", "align", "valign"],
    tfoot: ["align", "valign"],
    th: ["width", "rowspan", "colspan", "align", "valign"],
    thead: ["align", "valign"],
    tr: ["rowspan", "align", "valign"],
    tt: [],
    u: [],
    ul: [],
    video: [
      "autoplay",
      "controls",
      "crossorigin",
      "loop",
      "muted",
      "playsinline",
      "poster",
      "preload",
      "src",
      "height",
      "width"
    ]
  };
}
var es = new Un();
function Hn(a, e, t) {
}
function Gn(a, e, t) {
}
function Wn(a, e, t) {
}
function Kn(a, e, t) {
}
function rs(a) {
  return a.replace(Xn, "&lt;").replace(Yn, "&gt;");
}
function Jn(a, e, t, i) {
  if (t = os(t), e === "href" || e === "src") {
    if (t = ta.trim(t), t === "#") return "#";
    if (!(t.substr(0, 7) === "http://" || t.substr(0, 8) === "https://" || t.substr(0, 7) === "mailto:" || t.substr(0, 4) === "tel:" || t.substr(0, 11) === "data:image/" || t.substr(0, 6) === "ftp://" || t.substr(0, 2) === "./" || t.substr(0, 3) === "../" || t[0] === "#" || t[0] === "/"))
      return "";
  } else if (e === "background") {
    if (Jr.lastIndex = 0, Jr.test(t))
      return "";
  } else if (e === "style") {
    if (jt.lastIndex = 0, jt.test(t) || (Vt.lastIndex = 0, Vt.test(t) && (Jr.lastIndex = 0, Jr.test(t))))
      return "";
    i !== !1 && (i = i || es, t = i.process(t));
  }
  return t = ls(t), t;
}
var Xn = /</g, Yn = />/g, Zn = /"/g, eo = /&quot;/g, ro = /&#([a-zA-Z0-9]*);?/gim, ao = /&colon;?/gim, to = /&newline;?/gim, Jr = /((j\s*a\s*v\s*a|v\s*b|l\s*i\s*v\s*e)\s*s\s*c\s*r\s*i\s*p\s*t\s*|m\s*o\s*c\s*h\s*a):/gi, jt = /e\s*x\s*p\s*r\s*e\s*s\s*s\s*i\s*o\s*n\s*\(.*/gi, Vt = /u\s*r\s*l\s*\(.*/gi;
function as(a) {
  return a.replace(Zn, "&quot;");
}
function ts(a) {
  return a.replace(eo, '"');
}
function is(a) {
  return a.replace(ro, function(t, i) {
    return i[0] === "x" || i[0] === "X" ? String.fromCharCode(parseInt(i.substr(1), 16)) : String.fromCharCode(parseInt(i, 10));
  });
}
function ss(a) {
  return a.replace(ao, ":").replace(to, " ");
}
function ns(a) {
  for (var e = "", t = 0, i = a.length; t < i; t++)
    e += a.charCodeAt(t) < 32 ? " " : a.charAt(t);
  return ta.trim(e);
}
function os(a) {
  return a = ts(a), a = is(a), a = ss(a), a = ns(a), a;
}
function ls(a) {
  return a = as(a), a = rs(a), a;
}
function io() {
  return "";
}
function so(a, e) {
  typeof e != "function" && (e = function() {
  });
  var t = !Array.isArray(a);
  function i(o) {
    return t ? !0 : ta.indexOf(a, o) !== -1;
  }
  var r = [], s = !1;
  return {
    onIgnoreTag: function(o, n, f) {
      if (i(o))
        if (f.isClosing) {
          var d = "[/removed]", c = f.position + d.length;
          return r.push([
            s !== !1 ? s : f.position,
            c
          ]), s = !1, d;
        } else
          return s || (s = f.position), "[removed]";
      else
        return e(o, n, f);
    },
    remove: function(o) {
      var n = "", f = 0;
      return ta.forEach(r, function(d) {
        n += o.slice(f, d[0]), f = d[1];
      }), n += o.slice(f), n;
    }
  };
}
function no(a) {
  for (var e = "", t = 0; t < a.length; ) {
    var i = a.indexOf("<!--", t);
    if (i === -1) {
      e += a.slice(t);
      break;
    }
    e += a.slice(t, i);
    var r = a.indexOf("-->", i);
    if (r === -1)
      break;
    t = r + 3;
  }
  return e;
}
function oo(a) {
  var e = a.split("");
  return e = e.filter(function(t) {
    var i = t.charCodeAt(0);
    return i === 127 ? !1 : i <= 31 ? i === 10 || i === 13 : !0;
  }), e.join("");
}
ge.whiteList = Zi();
ge.getDefaultWhiteList = Zi;
ge.onTag = Hn;
ge.onIgnoreTag = Gn;
ge.onTagAttr = Wn;
ge.onIgnoreTagAttr = Kn;
ge.safeAttrValue = Jn;
ge.escapeHtml = rs;
ge.escapeQuote = as;
ge.unescapeQuote = ts;
ge.escapeHtmlEntities = is;
ge.escapeDangerHtml5Entities = ss;
ge.clearNonPrintableCharacter = ns;
ge.friendlyAttrValue = os;
ge.escapeAttrValue = ls;
ge.onIgnoreTagStripAll = io;
ge.StripTagBody = so;
ge.stripCommentTag = no;
ge.stripBlankChar = oo;
ge.cssFilter = es;
ge.getDefaultCSSWhiteList = Qn;
var oa = {}, tr = ht;
function lo(a) {
  var e = tr.spaceIndex(a), t;
  return e === -1 ? t = a.slice(1, -1) : t = a.slice(1, e + 1), t = tr.trim(t).toLowerCase(), t.slice(0, 1) === "/" && (t = t.slice(1)), t.slice(-1) === "/" && (t = t.slice(0, -1)), t;
}
function uo(a) {
  return a.slice(0, 2) === "</";
}
function co(a, e, t) {
  var i = "", r = 0, s = !1, o = !1, n = 0, f = a.length, d = "", c = "";
  e: for (n = 0; n < f; n++) {
    var u = a.charAt(n);
    if (s === !1) {
      if (u === "<") {
        s = n;
        continue;
      }
    } else if (o === !1) {
      if (u === "<") {
        i += t(a.slice(r, n)), s = n, r = n;
        continue;
      }
      if (u === ">") {
        i += t(a.slice(r, s)), c = a.slice(s, n + 1), d = lo(c), i += e(
          s,
          i.length,
          d,
          c,
          uo(c)
        ), r = n + 1, s = !1;
        continue;
      }
      if (u === '"' || u === "'")
        for (var p = 1, l = a.charAt(n - p); l.trim() === "" || l === "="; ) {
          if (l === "=") {
            o = u;
            continue e;
          }
          l = a.charAt(n - ++p);
        }
    } else if (u === o) {
      o = !1;
      continue;
    }
  }
  return r < a.length && (i += t(a.substr(r))), i;
}
var fo = /[^a-zA-Z0-9\\_:.-]/gim;
function ho(a, e) {
  var t = 0, i = 0, r = [], s = !1, o = a.length;
  function n(p, l) {
    if (p = tr.trim(p), p = p.replace(fo, "").toLowerCase(), !(p.length < 1)) {
      var h = e(p, l || "");
      h && r.push(h);
    }
  }
  for (var f = 0; f < o; f++) {
    var d = a.charAt(f), c, u;
    if (s === !1 && d === "=") {
      s = a.slice(t, f), t = f + 1, i = a.charAt(t) === '"' || a.charAt(t) === "'" ? t : po(a, f + 1);
      continue;
    }
    if (s !== !1 && f === i) {
      if (u = a.indexOf(d, f + 1), u === -1)
        break;
      c = tr.trim(a.slice(i + 1, u)), n(s, c), s = !1, f = u, t = f + 1;
      continue;
    }
    if (/\s|\n|\t/.test(d))
      if (a = a.replace(/\s|\n|\t/g, " "), s === !1)
        if (u = mo(a, f), u === -1) {
          c = tr.trim(a.slice(t, f)), n(c), s = !1, t = f + 1;
          continue;
        } else {
          f = u - 1;
          continue;
        }
      else if (u = vo(a, f - 1), u === -1) {
        c = tr.trim(a.slice(t, f)), c = zt(c), n(s, c), s = !1, t = f + 1;
        continue;
      } else
        continue;
  }
  return t < a.length && (s === !1 ? n(a.slice(t)) : n(s, zt(tr.trim(a.slice(t))))), tr.trim(r.join(" "));
}
function mo(a, e) {
  for (; e < a.length; e++) {
    var t = a[e];
    if (t !== " ")
      return t === "=" ? e : -1;
  }
}
function po(a, e) {
  for (; e < a.length; e++) {
    var t = a[e];
    if (t !== " ")
      return t === "'" || t === '"' ? e : -1;
  }
}
function vo(a, e) {
  for (; e > 0; e--) {
    var t = a[e];
    if (t !== " ")
      return t === "=" ? e : -1;
  }
}
function go(a) {
  return a[0] === '"' && a[a.length - 1] === '"' || a[0] === "'" && a[a.length - 1] === "'";
}
function zt(a) {
  return go(a) ? a.substr(1, a.length - 2) : a;
}
oa.parseTag = co;
oa.parseAttr = ho;
var yo = dt.FilterCSS, je = ge, us = oa, So = us.parseTag, bo = us.parseAttr, ra = ht;
function Xr(a) {
  return a == null;
}
function Po(a) {
  var e = ra.spaceIndex(a);
  if (e === -1)
    return {
      html: "",
      closing: a[a.length - 2] === "/"
    };
  a = ra.trim(a.slice(e + 1, -1));
  var t = a[a.length - 1] === "/";
  return t && (a = ra.trim(a.slice(0, -1))), {
    html: a,
    closing: t
  };
}
function wo(a) {
  var e = {};
  for (var t in a)
    e[t] = a[t];
  return e;
}
function Eo(a) {
  var e = {};
  for (var t in a)
    Array.isArray(a[t]) ? e[t.toLowerCase()] = a[t].map(function(i) {
      return i.toLowerCase();
    }) : e[t.toLowerCase()] = a[t];
  return e;
}
function cs(a) {
  a = wo(a || {}), a.stripIgnoreTag && (a.onIgnoreTag && console.error(
    'Notes: cannot use these two options "stripIgnoreTag" and "onIgnoreTag" at the same time'
  ), a.onIgnoreTag = je.onIgnoreTagStripAll), a.whiteList || a.allowList ? a.whiteList = Eo(a.whiteList || a.allowList) : a.whiteList = je.whiteList, a.onTag = a.onTag || je.onTag, a.onTagAttr = a.onTagAttr || je.onTagAttr, a.onIgnoreTag = a.onIgnoreTag || je.onIgnoreTag, a.onIgnoreTagAttr = a.onIgnoreTagAttr || je.onIgnoreTagAttr, a.safeAttrValue = a.safeAttrValue || je.safeAttrValue, a.escapeHtml = a.escapeHtml || je.escapeHtml, this.options = a, a.css === !1 ? this.cssFilter = !1 : (a.css = a.css || {}, this.cssFilter = new yo(a.css));
}
cs.prototype.process = function(a) {
  if (a = a || "", a = a.toString(), !a) return "";
  var e = this, t = e.options, i = t.whiteList, r = t.onTag, s = t.onIgnoreTag, o = t.onTagAttr, n = t.onIgnoreTagAttr, f = t.safeAttrValue, d = t.escapeHtml, c = e.cssFilter;
  t.stripBlankChar && (a = je.stripBlankChar(a)), t.allowCommentTag || (a = je.stripCommentTag(a));
  var u = !1;
  t.stripIgnoreTagBody && (u = je.StripTagBody(
    t.stripIgnoreTagBody,
    s
  ), s = u.onIgnoreTag);
  var p = So(
    a,
    function(l, h, g, v, S) {
      var A = {
        sourcePosition: l,
        position: h,
        isClosing: S,
        isWhite: Object.prototype.hasOwnProperty.call(i, g)
      }, C = r(g, v, A);
      if (!Xr(C)) return C;
      if (A.isWhite) {
        if (A.isClosing)
          return "</" + g + ">";
        var P = Po(v), E = i[g], D = bo(P.html, function(I, R) {
          var O = ra.indexOf(E, I) !== -1, w = o(g, I, R, O);
          return Xr(w) ? O ? (R = f(g, I, R, c), R ? I + '="' + R + '"' : I) : (w = n(g, I, R, O), Xr(w) ? void 0 : w) : w;
        });
        return v = "<" + g, D && (v += " " + D), P.closing && (v += " /"), v += ">", v;
      } else
        return C = s(g, v, A), Xr(C) ? d(v) : C;
    },
    d
  );
  return u && (p = u.remove(p)), p;
};
var xo = cs;
(function(a, e) {
  var t = ge, i = oa, r = xo;
  function s(n, f) {
    var d = new r(f);
    return d.process(n);
  }
  e = a.exports = s, e.filterXSS = s, e.FilterXSS = r, function() {
    for (var n in t)
      e[n] = t[n];
    for (var f in i)
      e[f] = i[f];
  }();
  function o() {
    return typeof self < "u" && typeof DedicatedWorkerGlobalScope < "u" && self instanceof DedicatedWorkerGlobalScope;
  }
  o() && (self.filterXSS = a.exports);
})(ot, ot.exports);
var Pr = ot.exports, Fo = function(a) {
  if (typeof a != "object" || a === null || Object.prototype.toString.call(a) !== "[object Object]")
    return !1;
  var e = Object.getPrototypeOf(a);
  if (e === null)
    return !0;
  for (; Object.getPrototypeOf(e) !== null; )
    e = Object.getPrototypeOf(e);
  return Object.getPrototypeOf(a) === e;
}, Co = (
  /** @class */
  function() {
    function a(e, t) {
      var i = this;
      this.arcgisWhiteList = {
        a: ["href", "style", "target"],
        abbr: ["title"],
        article: ["style"],
        aside: ["style"],
        audio: ["autoplay", "controls", "loop", "muted", "preload"],
        b: [],
        blockquote: ["style"],
        br: [],
        code: ["style"],
        dd: ["style"],
        del: ["style"],
        details: ["open", "style"],
        div: ["align", "aria-hidden", "aria-label", "style"],
        dl: ["style"],
        dt: ["style"],
        em: [],
        figcaption: ["style"],
        figure: ["style"],
        font: ["color", "face", "size", "style"],
        footer: ["style"],
        h1: ["style"],
        h2: ["style"],
        h3: ["style"],
        h4: ["style"],
        h5: ["style"],
        h6: ["style"],
        header: ["style"],
        hr: [],
        i: [],
        img: ["alt", "border", "height", "src", "style", "width"],
        li: [],
        main: ["style"],
        mark: ["style"],
        nav: ["style"],
        ol: [],
        p: ["style"],
        pre: ["style"],
        section: ["style"],
        source: ["media", "src", "type"],
        span: ["aria-hidden", "aria-label", "style"],
        strong: [],
        sub: ["style"],
        summary: ["style"],
        sup: ["style"],
        table: ["border", "cellpadding", "cellspacing", "height", "style", "width"],
        tbody: [],
        tr: ["align", "height", "style", "valign"],
        td: [
          "align",
          "colspan",
          "height",
          "nowrap",
          "rowspan",
          "style",
          "valign",
          "width"
        ],
        th: [
          "align",
          "colspan",
          "height",
          "nowrap",
          "rowspan",
          "style",
          "valign",
          "width"
        ],
        time: ["style"],
        u: [],
        ul: [],
        video: [
          "autoplay",
          "controls",
          "height",
          "loop",
          "muted",
          "poster",
          "preload",
          "width"
        ]
      }, this.arcgisCSSWhiteList = aa(aa({}, Pr.getDefaultCSSWhiteList()), { "align-items": !0, "align-self": !0, flex: !0, "flex-basis": !0, "flex-direction": !0, "flex-flow": !0, "flex-grow": !0, "flex-shrink": !0, "flex-wrap": !0, float: !0, gap: !0, grid: !0, "grid-area": !0, "grid-auto-columns": !0, "grid-auto-flow": !0, "grid-auto-rows": !0, "grid-column": !0, "grid-column-end": !0, "grid-column-start": !0, "grid-row": !0, "grid-row-end": !0, "grid-row-start": !0, "grid-template": !0, "grid-template-areas": !0, "grid-template-columns": !0, "grid-template-rows": !0, "justify-content": !0, "justify-items": !0, "justify-self": !0, "line-height": !0, overflow: !0 }), this.allowedProtocols = [
        "http",
        "https",
        "mailto",
        "iform",
        "tel",
        "flow",
        "lfmobile",
        "arcgis-navigator",
        "arcgis-appstudio-player",
        "arcgis-survey123",
        "arcgis-collector",
        "arcgis-workforce",
        "arcgis-explorer",
        "arcgis-trek2there",
        "arcgis-quickcapture",
        "mspbi",
        "comgooglemaps",
        "pdfefile",
        "pdfehttp",
        "pdfehttps",
        "boxapp",
        "boxemm",
        "awb",
        "awbs",
        "gropen",
        "radarscope"
      ], this.arcgisFilterOptions = {
        allowCommentTag: !0,
        safeAttrValue: function(s, o, n, f) {
          return s === "a" && o === "href" || (s === "img" || s === "source") && o === "src" ? i.sanitizeUrl(n) : Pr.safeAttrValue(s, o, n, f);
        }
      }, this._entityMap = {
        "&": "&#x38;",
        "<": "&#x3C;",
        ">": "&#x3E;",
        '"': "&#x22;",
        "'": "&#x27;",
        "/": "&#x2F;"
      };
      var r;
      e && !t ? r = e : e && t ? (r = Object.create(this.arcgisFilterOptions), r.css = { whiteList: this.arcgisCSSWhiteList }, Object.keys(e).forEach(function(s) {
        if (s === "whiteList")
          r.whiteList = i._extendObjectOfArrays([
            i.arcgisWhiteList,
            e.whiteList || {}
          ]);
        else if (s === "css") {
          var o = e.css.whiteList;
          o != null && e.css instanceof Object && Object.keys(o).forEach(function(n) {
            return r.css.whiteList[n] = o[n];
          });
        } else
          r[s] = e[s];
      })) : (r = Object.create(this.arcgisFilterOptions), r.whiteList = this.arcgisWhiteList, r.css = { whiteList: this.arcgisCSSWhiteList }), this.xssFilterOptions = r, this._xssFilter = new Pr.FilterXSS(r);
    }
    return a.prototype.sanitize = function(e, t) {
      switch (t === void 0 && (t = {}), typeof e) {
        case "number":
          return isNaN(e) || !isFinite(e) ? null : e;
        case "boolean":
          return e;
        case "string":
          return this._xssFilter.process(e);
        case "object":
          return this._iterateOverObject(e, t);
        default:
          return t.allowUndefined && typeof e > "u" ? void 0 : null;
      }
    }, a.prototype.sanitizeUrl = function(e, t) {
      var i = (t ?? {}).isProtocolRequired, r = i === void 0 ? !0 : i, s = this._trim(e.substring(0, e.indexOf(":"))), o = e === "/", n = /^#/.test(e), f = s && this.allowedProtocols.indexOf(s.toLowerCase()) > -1;
      return o || n || f ? Pr.escapeAttrValue(e) : !s && !r ? Pr.escapeAttrValue("https://".concat(e)) : "";
    }, a.prototype.sanitizeHTMLAttribute = function(e, t, i, r) {
      return typeof this.xssFilterOptions.safeAttrValue == "function" ? this.xssFilterOptions.safeAttrValue(
        e,
        t,
        i,
        // @ts-expect-error safeAttrValue does handle undefined cssFilter
        r
      ) : Pr.safeAttrValue(e, t, i, r);
    }, a.prototype.validate = function(e, t) {
      t === void 0 && (t = {});
      var i = this.sanitize(e, t);
      return {
        isValid: e === i,
        sanitized: i
      };
    }, a.prototype.encodeHTML = function(e) {
      var t = this;
      return String(e).replace(/[&<>"'\/]/g, function(i) {
        return t._entityMap[i];
      });
    }, a.prototype.encodeAttrValue = function(e) {
      var t = /^[a-zA-Z0-9]$/;
      return String(e).replace(/[\x00-\xFF]/g, function(i, r) {
        return t.test(i) ? i : "&#x".concat(Number(e.charCodeAt(r)).toString(16), ";");
      });
    }, a.prototype._extendObjectOfArrays = function(e) {
      var t = {};
      return e.forEach(function(i) {
        Object.keys(i).forEach(function(r) {
          Array.isArray(i[r]) && Array.isArray(t[r]) ? t[r] = t[r].concat(i[r]) : t[r] = i[r];
        });
      }), t;
    }, a.prototype._iterateOverObject = function(e, t) {
      var i = this;
      t === void 0 && (t = {});
      try {
        var r = !1, s = void 0;
        if (Array.isArray(e))
          s = e.reduce(function(n, f) {
            var d = i.validate(f, t);
            return d.isValid ? n.concat([f]) : (r = !0, n.concat([d.sanitized]));
          }, []);
        else if (Fo(e)) {
          var o = Object.keys(e);
          s = o.reduce(function(n, f) {
            var d = e[f], c = i.validate(d, t);
            return c.isValid ? n[f] = d : (r = !0, n[f] = c.sanitized), n;
          }, {});
        } else
          return t.allowUndefined && typeof e > "u" ? void 0 : null;
        return r ? s : e;
      } catch {
        return null;
      }
    }, a.prototype._trim = function(e) {
      return String.prototype.trim ? e.trim() : e.replace(/(^\s*)|(\s*$)/g, "");
    }, a;
  }()
);
const U = {
  // chart with no specific subtype
  NonSpecific: "nonSpecific",
  // non aggregated bar/line chart
  BarAndLineNoAggregation: "barAndLineNoAggregation",
  // mono-series bar/line chart with one numeric field and a category
  BarAndLineMonoField: "barAndLineMonoField",
  // multi-series bar/line chart with numeric fields and a category
  BarAndLineMultiFields: "barAndLineMultiFields",
  // mono-series bar/line chart from numeric fields, no category
  BarAndLineFromFields: "barAndLineFromFields",
  // bar/line chart with split-by field and a category
  BarAndLineSplitBy: "barAndLineSplitBy",
  // non aggregated bar/line chart with split-by field and a category
  BarAndLineSplitByNoAggregation: "barAndLineSplitByNoAggregation",
  // non aggregated pie chart
  PieNoAggregation: "pieNoAggregation",
  // pie chart with a category
  PieFromCategory: "pieFromCategory",
  // pie chart from numeric fields
  PieFromFields: "pieFromFields",
  // box plot with a numeric field, no category
  BoxPlotMonoField: "boxPlotMonoField",
  // box plot with multiple numeric fields, no category
  BoxPlotMultiFields: "boxPlotMultiFields",
  // box plot with a numeric field and a category
  BoxPlotMonoFieldAndCategory: "boxPlotMonoFieldAndCategory",
  // box plot with multiple numeric fields and a category
  BoxPlotMultiFieldsAndCategory: "boxPlotMultiFieldsAndCategory",
  // box plot with a numeric field and a split-by field
  BoxPlotMonoFieldAndSplitBy: "boxPlotMonoFieldAndSplitBy",
  // box plot with multiple numeric fields and a split-by field
  BoxPlotMultiFieldsAndSplitBy: "boxPlotMultiFieldsAndSplitBy",
  // box plot with a numeric field, a category and a split-by field
  BoxPlotMonoFieldAndCategoryAndSplitBy: "boxPlotMonoFieldAndCategoryAndSplitBy"
}, Rc = {
  SelectionByClick: "SelectionByClick",
  SelectionByRange: "SelectionByRange",
  ProgrammaticSelection: "ProgrammaticSelection",
  ClearSelection: "ClearSelection"
};
function $c(a) {
  return a?.colorMatch ?? !1;
}
function Oc(a) {
  let e = Or();
  if (a !== void 0) {
    const t = Ne(a.series);
    (t === $.BarSeries || t === $.LineSeries || t === $.ComboLineAndBarSeries || t === $.BoxPlotSeries) && (e = a.rotated ?? Or());
  }
  return e;
}
function _c(a) {
  return a?.map((e) => e.type) ?? [];
}
function Ao(a) {
  let e = a?.stackedType;
  if (e === void 0 && a !== void 0) {
    const t = Ne(a.series);
    (t === $.BarSeries || t === $.LineSeries || t === $.ComboLineAndBarSeries || t === $.RadarSeries) && (e = In());
  }
  return e;
}
function Do(a) {
  let e = a;
  return e = e.replace(/'/gu, "''"), e = e.replace(/[/\\"|[\]\\]/gu, "\\$&"), e;
}
function To(a) {
  let e = !1;
  if (typeof a != "number") {
    const t = new Intl.Segmenter();
    e = Array.from(t.segment(a), (r) => r.segment).some((r) => r.charCodeAt(0) > 255);
  }
  return e;
}
function Lo(a) {
  let e = a, t = "";
  a.startsWith("'") && a.endsWith("'") && (e = a.slice(1, -1), t = "'"), e = e.replace(/'/gu, "''");
  let i = "";
  return To(e) && (i = "N"), `${i}${t}${e}${t}`;
}
function fs(a) {
  const { value: e, keepSurroundingQuotes: t, escape: i } = a;
  let r = e?.trim();
  if (!We(r)) {
    let s = "";
    r.startsWith("'") && r.endsWith("'") && (r = r.slice(1, -1), t && (s = "'")), i !== !1 && (r = Do(r)), r = `${s}${r}${s}`;
  }
  return r;
}
function Nc(a) {
  const { count: e, seriesCount: t, chartType: i, chartLimits: r } = a, { behaviorAfterLimit: s } = r ?? {};
  let o = !0;
  if (s !== Gi.RenderUpToTheLimit) {
    const {
      maxBarChartSeriesCount: n,
      maxBarUniqueSeriesCountTotal: f,
      maxBarTwoSeriesCountPerSeries: d,
      maxBarTwoSeriesCountTotal: c,
      maxBarThreePlusSeriesCountPerSeries: u,
      maxBarThreePlusSeriesCountTotal: p,
      maxLineChartSeriesCount: l,
      maxLineUniqueSeriesCountTotal: h,
      maxLineTwoSeriesCountPerSeries: g,
      maxLineTwoSeriesCountTotal: v,
      maxLineThreePlusSeriesCountPerSeries: S,
      maxLineThreePlusSeriesCountTotal: A,
      maxPieChartSliceCountTotal: C,
      maxGaugeByFeaturesLimit: P,
      maxBoxPlotSeriesCount: E,
      maxBoxUniqueSeriesCountTotal: D,
      maxBoxTwoSeriesCountTotal: I,
      maxBoxTwoSeriesCountPerSeries: R,
      maxBoxThreePlusSeriesCountTotal: O,
      maxBoxThreePlusSeriesCountPerSeries: w
    } = Ln(r);
    switch (i) {
      case $.BarSeries:
      case $.ComboLineAndBarSeries:
        {
          const x = e / t;
          t <= n ? t === 0 ? o = !0 : t === 1 ? o = e <= f : t === 2 ? o = e <= c && x <= d : t > 2 && (o = e <= p && x <= u) : o = !1;
        }
        break;
      case $.LineSeries:
      case $.RadarSeries:
        {
          const x = e / t;
          t <= l ? t === 0 ? o = !0 : t === 1 ? o = e <= h : t === 2 ? o = e <= v && x <= g : t > 2 && (o = e <= A && x <= S) : o = !1;
        }
        break;
      case $.PieSeries:
        o = e <= C;
        break;
      case $.BoxPlotSeries:
        {
          const x = e / t;
          t <= E ? t === 0 ? o = !0 : t === 1 ? o = e <= D : t === 2 ? o = e <= I && x <= R : t > 2 && (o = e <= O && x <= w) : o = !1;
        }
        break;
      case $.GaugeSeries:
        o = e <= P;
        break;
    }
  }
  return o;
}
function Bc(a = [], e) {
  const t = a.find((i) => i.name === e)?.alias;
  return t !== "" ? t ?? e : e;
}
function kc(a = [], e) {
  const t = a.find((i) => i.alias === e)?.name;
  return t !== "" ? t ?? e : e;
}
function qc(a) {
  let e = !1;
  switch (Ne(a)) {
    case $.PieSeries:
      e = !0;
      break;
    case $.BarSeries:
    case $.LineSeries:
    case $.RadarSeries:
    case $.ComboLineAndBarSeries:
    case $.BoxPlotSeries:
      e = a.length > 1;
      break;
    case $.HistogramSeries:
    case $.ScatterSeries: {
      const i = a[0];
      e = i.overlays !== void 0 && Object.values(i.overlays).some((r) => r.created === !0);
      break;
    }
  }
  return e;
}
function Io(a) {
  let e = !0;
  return Ne(a.series) === $.ScatterSeries && (e = a.series.length === 1), e;
}
function Ro(a) {
  let e = !0;
  return Ne(a.series) === $.HistogramSeries && (e = a.series.length <= 1 && a.series[0].type === $.HistogramSeries && (!("dataTransformationType" in a.series[0]) || a.series[0].dataTransformationType !== void 0 && Object.values(qi).includes(a.series[0].dataTransformationType))), e;
}
function $o(a) {
  let e = !0;
  return Ne(a.series) === $.PieSeries && (e = a.series.length <= 1), e;
}
function Mc(a, e) {
  const t = Ne(e?.series);
  let i = a.includes(t);
  if (i && e !== void 0)
    switch (t) {
      case $.HistogramSeries:
        i = Ro(e);
        break;
      case $.ScatterSeries:
        i = Io(e);
        break;
      case $.PieSeries:
        i = $o(e);
        break;
    }
  return i;
}
function We(a) {
  return a == null || typeof a == "string" && a.trim() === "";
}
function Oo(a, e) {
  const t = e.find((r) => r in a);
  return { isInItem: t !== void 0, expr: t };
}
function jc(a) {
  return Oo(a, cn);
}
function Vc(a, e) {
  let t;
  switch (a) {
    case Re.Second:
      t = e.seconds ?? "";
      break;
    case Re.Minute:
      t = e.minutes ?? "";
      break;
    case Re.Hour:
      t = e.hours ?? "";
      break;
    case Re.Day:
      t = e.days ?? "";
      break;
    case Re.Week:
      t = e.weeks ?? "";
      break;
    case Re.Month:
      t = e.months ?? "";
      break;
    case Re.Year:
      t = e.years ?? "";
      break;
    default:
      t = "";
      break;
  }
  return t;
}
function zc(a) {
  let e;
  switch (a) {
    case Ze.Mean:
      e = 1;
      break;
    case Ze.Median:
      e = 2;
      break;
    case Ze.StdDev:
      e = 3;
      break;
    case Ze.Normal:
    default:
      e = 0;
      break;
  }
  return e;
}
function Uc(a, e) {
  if (e !== void 0) {
    const { seriesId: t, overlayType: i, visible: r } = a.detail;
    let s;
    switch (i) {
      case Ze.Mean:
        e.series[0].type === $.HistogramSeries && (s = e.series[0].overlays?.mean);
        break;
      case Ze.Median:
        e.series[0].type === $.HistogramSeries && (s = e.series[0].overlays?.median);
        break;
      case Ze.StdDev:
        e.series[0].type === $.HistogramSeries && (s = e.series[0].overlays?.standardDeviation);
        break;
      case Ze.Normal:
        e.series[0].type === $.HistogramSeries && (s = e.series[0].overlays?.comparisonDistribution);
        break;
      case Ze.Trendline:
        e.series[0].type === $.ScatterSeries && (s = e.series[0].overlays?.trendLine);
        break;
      default:
        s = e.series.find((o) => o.id === t);
        break;
    }
    s !== void 0 && (s.visible = r);
  }
}
function Qc(a) {
  return new Co().sanitize(a);
}
function Hc(a) {
  return a != null && !Number.isNaN(a) && Number.isFinite(a);
}
function Gc(a, e) {
  let t;
  return e !== void 0 && (t = { ...e, rotated: a }), t;
}
function _o(a, e) {
  let t = { fieldToSort: "" };
  if (!We(a)) {
    const i = a.trim(), s = i.split(" ").at(-1)?.toUpperCase();
    s === ir.Ascending || s === ir.Descending ? t = { fieldToSort: i.substring(0, i.lastIndexOf(" ")), orderBy: s } : (t = { fieldToSort: i }, e !== !1 && (t.orderBy = ir.Ascending));
  }
  return t;
}
function No(a) {
  return a.orderOptions?.orderByFields?.map((e) => _o(e).fieldToSort) ?? [];
}
function Wc(a) {
  return a === U.BarAndLineSplitBy || a === U.BarAndLineSplitByNoAggregation || a === U.BoxPlotMonoFieldAndSplitBy || a === U.BoxPlotMultiFieldsAndSplitBy || a === U.BoxPlotMonoFieldAndCategoryAndSplitBy;
}
function Kc(a, e) {
  let { selectionItems: t } = a ?? {};
  const { selectionOIDs: i } = a ?? {};
  let { selectionItems: r } = e ?? {};
  const { selectionOIDs: s } = e ?? {}, o = (d) => ({
    ...d,
    [un]: void 0
  });
  t !== void 0 && (t = t.map(o)), r !== void 0 && (r = r.map(o));
  const n = !Ot(t, r), f = !Ot(i, s);
  return n || f;
}
function Jc(a) {
  return a?.selectionOIDs === void 0 || a.selectionOIDs.length === 0;
}
function Xc(a = {
  arrayA: [],
  arrayB: [],
  getKey: (e) => e
}) {
  const { arrayA: e, arrayB: t, getKey: i } = a;
  if (t.length === 0 || e.length === 0)
    return e;
  const r = /* @__PURE__ */ new Map();
  t.forEach((f, d) => {
    const c = i(f);
    r.set(c, d);
  });
  const s = [], o = [];
  e.forEach((f, d) => {
    const c = i(f);
    r.has(c) && (s.push(d), o.push(f));
  }), o.sort((f, d) => {
    const c = i(f), u = i(d);
    return r.get(c) - r.get(u);
  });
  const n = [...e];
  return s.forEach((f, d) => {
    n[f] = o[d];
  }), n;
}
const fr = [
  "1.0.0",
  "1.0.1",
  "2.0.0",
  "3.0.0",
  "3.1.0",
  "3.2.0",
  "3.3.0",
  "3.4.0",
  "3.5.0",
  "3.6.0",
  "3.7.0",
  "3.8.0",
  "3.9.0",
  "3.9.1",
  "3.9.2",
  "3.10.0",
  "3.11.0",
  "4.0.0",
  "4.0.1",
  "5.0.0",
  "6.0.0",
  "6.1.0",
  "6.2.0",
  "6.2.1",
  "6.3.0",
  "6.4.0",
  "7.0.0",
  "7.1.0",
  "7.1.1",
  "7.2.0",
  "7.2.1",
  "7.3.1",
  "7.4.0",
  "7.4.1",
  "7.5.0",
  "7.5.1",
  "7.6.0",
  "8.0.0",
  "8.0.1",
  "9.0.0",
  "9.1.0",
  "9.2.0",
  "9.3.0",
  "9.4.0",
  "9.5.0",
  "9.6.0",
  "9.6.1",
  "9.7.0",
  "10.0.0",
  "11.0.0",
  "12.0.0",
  "13.0.0",
  "14.0.0",
  "14.0.1",
  "15.0.0",
  "16.0.0",
  "16.1.0",
  "16.1.1",
  "17.0.0",
  "17.1.0",
  "17.2.0",
  "17.2.1",
  "18.0.0",
  "18.1.0",
  "18.1.1",
  "18.1.2",
  "18.1.3",
  "19.0.0",
  "20.0.0",
  "20.1.0",
  "20.2.0",
  "21.0.0",
  "21.1.0",
  "22.0.0",
  "23.0.0",
  "23.1.0",
  "23.2.0"
], Bo = "1.0.0", ko = "unrecognized.version", qo = [
  $.LineSeries,
  $.BarSeries,
  $.ComboLineAndBarSeries,
  $.RadarSeries
];
function ma(a, e) {
  let t = 0;
  if (a !== e) {
    const i = a.split("."), r = e.split(".");
    for (let s = 0; s < i.length; s += 1) {
      const o = Number.parseInt(i[s], 10), n = Number.parseInt(r[s], 10);
      if (o > n || Number.isNaN(n)) {
        t = 1;
        break;
      }
      if (o < n) {
        t = -1;
        break;
      }
    }
  }
  return t;
}
function Mo(a) {
  return a !== void 0 ? /^([1-9]\d*|0)(\.(([1-9]\d*)|0)){2}$/u.test(a) : !1;
}
function jo(a) {
  let e = dr.Same, t = [];
  if (Mo(a) && a !== void 0) {
    fr.sort(ma);
    const r = ma(a, fr[fr.length - 1]);
    if (r === 1 ? e = dr.Newer : r === -1 && (e = dr.Older), e === dr.Newer || e === dr.Same)
      t.push(a);
    else {
      for (let s = fr.length - 2; s >= 0; s -= 1)
        if (ma(a, fr[s]) >= 0) {
          t = fr.slice(s, fr.length);
          break;
        }
      t.length === 0 && t.push(Bo);
    }
  } else
    e = dr.Unrecognized, t.push(ko);
  return { versionStatus: e, versions: t };
}
function Vo(a) {
  const { series: e } = a;
  let i = ("showMean" in a ? a.showMean : !1) === !0 ? e.find((r) => r.type === $.LineSeries) : e[0];
  return i ??= e[0], i;
}
function Yc(a, e) {
  const t = a !== null ? a.toString() : null, i = e != null ? e.toString() : null;
  return i !== null && i !== t ? Oe.SFS : Oe.SLS;
}
function la(a, e) {
  let t = "";
  return a !== void 0 && a.includes("=") && (t = e !== !1 ? fs({ value: a.split("=")[0] }) : a.split("=")[0].trim()), t;
}
function Vr(a) {
  const { where: e, normalize: t, keepSurroundingQuotes: i, escape: r } = a;
  let s = "";
  return e !== void 0 && e.includes("=") && (s = e.split("=").slice(1).join("=").trim(), s === "null" ? s = null : s.trim() !== "" && !Number.isNaN(Number(s)) ? s = Number(s) : t === !1 ? r === !0 && (s = Lo(s)) : s = fs({ value: s, keepSurroundingQuotes: i, escape: r })), s;
}
function Er(a) {
  let e = !1;
  if (a === void 0 || a === "")
    e = !0;
  else if (a.includes("=")) {
    const t = la(a, !1), i = Vr({ where: a, normalize: !1 });
    e = t === `${i}`;
  }
  return e;
}
function Zc(a) {
  const { where: e, normalize: t, escape: i } = a, r = t === void 0 ? !0 : t, s = la(e), o = Vr({
    where: e,
    normalize: r,
    keepSurroundingQuotes: !0,
    escape: i
  });
  let n = e;
  return s !== "" && o !== "" && (n = `${s}=${o}`), n;
}
function zo(a) {
  let e = U.PieFromCategory;
  return a[0].query?.outStatistics === void 0 ? e = U.PieNoAggregation : a[0].query?.groupByFieldsForStatistics === void 0 && (e = U.PieFromFields), e;
}
function Uo(a) {
  let e = U.BarAndLineMonoField;
  const t = a[0].query?.where;
  return a[0].query?.groupByFieldsForStatistics === void 0 && (a[0].query?.outStatistics ?? []).length > 0 ? e = U.BarAndLineFromFields : t === void 0 && a[0].query?.outStatistics === void 0 ? e = U.BarAndLineNoAggregation : Er(t) ? a.length > 1 && (e = U.BarAndLineMultiFields) : e = a[0].query?.outStatistics === void 0 ? U.BarAndLineSplitByNoAggregation : U.BarAndLineSplitBy, e;
}
function Qo(a) {
  let e = U.BoxPlotMonoField;
  const t = a.length === 1, i = a.find((n) => n.type === $.LineSeries) ?? a[0], { x: r } = i, s = "y" in i ? i.y : "", o = i.query?.where;
  switch (r) {
    case ft:
      typeof s == "object" && s.length > 1 ? Er(o) ? t && (e = U.BoxPlotMultiFields) : e = U.BoxPlotMultiFieldsAndSplitBy : t ? e = U.BoxPlotMonoField : Er(o) || (e = U.BoxPlotMonoFieldAndSplitBy);
      break;
    default:
      t ? e = U.BoxPlotMonoFieldAndCategory : Er(o) ? e = U.BoxPlotMultiFieldsAndCategory : e = U.BoxPlotMonoFieldAndCategoryAndSplitBy;
      break;
  }
  return e;
}
function er(a) {
  let e = U.NonSpecific;
  if (a?.[0] !== void 0)
    switch (Ne(a)) {
      case $.PieSeries:
        e = zo(a);
        break;
      case $.RadarSeries:
      case $.BarSeries:
      case $.LineSeries:
      case $.ComboLineAndBarSeries:
        e = Uo(a);
        break;
      case $.BoxPlotSeries:
        e = Qo(a);
        break;
    }
  return e;
}
function ef(a) {
  const { seriesConfig: e, xAxisValueFormatType: t, setTimeBinningInfoWhenNotProvided: i } = a;
  let r = !1;
  if (Ho(e) && e.binTemporalData !== !1 && t === $.DateAxisFormat) {
    const s = er([e]);
    if (e.temporalBinning && s !== U.BarAndLineNoAggregation && s !== U.BarAndLineSplitByNoAggregation) {
      const { unit: o, size: n } = e.temporalBinning;
      r = i === !0 || n !== void 0 && n > 0 && o !== void 0;
    }
  }
  return r;
}
function Ho(a) {
  return qo.includes(a.type);
}
const de = {
  Min: "min",
  FirstQuartile: "first_quartile",
  Median: "median",
  ThirdQuartile: "third_quartile",
  Max: "max",
  IQR: "iqr",
  Average: "avg",
  StandardDeviation: "stddev",
  Outlier: "outlier"
};
function Go(a) {
  const e = a === void 0 || a === "";
  return {
    [de.Average]: `${e ? "" : `${a}_`}${de.Average}`,
    [de.Min]: `${e ? "" : `${a}_`}${de.Min}`,
    [de.Max]: `${e ? "" : `${a}_`}${de.Max}`,
    [de.FirstQuartile]: `${e ? "" : `${a}_`}${de.FirstQuartile}`,
    [de.Median]: `${e ? "" : `${a}_`}${de.Median}`,
    [de.ThirdQuartile]: `${e ? "" : `${a}_`}${de.ThirdQuartile}`,
    [de.IQR]: `${e ? "" : `${a}_`}${de.IQR}`,
    [de.Outlier]: `${e ? "" : `${a}_`}${de.Outlier}`,
    [de.StandardDeviation]: `${e ? "" : `${a}_`}${de.StandardDeviation}`
  };
}
function Wo(a) {
  return a.subType === js.FeatureGauge;
}
function rf(a) {
  let e;
  return a !== void 0 && ("bins" in a ? e = a.bins : "dataItems" in a && (e = a.dataItems)), e;
}
function Ko(a) {
  return a === U.BoxPlotMultiFields || a === U.BoxPlotMultiFieldsAndCategory || a === U.BoxPlotMultiFieldsAndSplitBy;
}
function ia(a) {
  const { key: e, y: t, chartSubType: i, splitBy: r, splitByValue: s, showOutliers: o, standardizeValues: n } = a;
  let f = s, c = Go(t)[e];
  return o === !0 && (e === de.Min || e === de.Max) && (c = `${c}${Rn}`), n === !0 && (Ko(i) || e === de.Outlier) && (c = `${c}${$n}`), (s === void 0 || `${s}`.trim() === "") && (f = Vr({ where: r, normalize: !0, escape: !1 })), f !== void 0 && `${f}`.trim() !== "" && (c = `${f}${c !== "" ? `_${c}` : ""}`), c;
}
function pa(a) {
  const { dataItem: e, y: t, splitBy: i, showOutliers: r } = a, s = ia({ key: de.FirstQuartile, y: t, splitBy: i, showOutliers: r }), o = ia({ key: de.ThirdQuartile, y: t, splitBy: i, showOutliers: r });
  return Number.isFinite(e[s]) || Number.isFinite(e[o]);
}
function Jo(a) {
  const { configSeries: e, boxPlotDataItem: t, yList: i, showOutliers: r } = a, s = er(e);
  let o = !1;
  switch (s) {
    case U.BoxPlotMonoField:
    case U.BoxPlotMultiFields:
    case U.BoxPlotMonoFieldAndCategory:
      o = pa({ dataItem: t, showOutliers: r });
      break;
    case U.BoxPlotMultiFieldsAndCategory:
      o = i.some(
        (n) => pa({ dataItem: t, y: n, showOutliers: r })
      );
      break;
    case U.BoxPlotMonoFieldAndSplitBy:
    case U.BoxPlotMultiFieldsAndSplitBy:
    case U.BoxPlotMonoFieldAndCategoryAndSplitBy:
      o = e.some(
        (n) => pa({
          dataItem: t,
          splitBy: n.query?.where,
          showOutliers: r
        })
      );
      break;
    default:
      o = !1;
      break;
  }
  return o;
}
function ds(a) {
  return a.map((e) => e.id).filter((e) => e !== "undefined");
}
function sa(a, e) {
  let t = [];
  const i = e ?? ds(a), r = er(a);
  return t = a.filter((s) => i.includes(s.id)).map((s) => {
    let o = "y" in s ? s.y : void 0;
    return o !== void 0 && r === U.BarAndLineSplitByNoAggregation && (o = `${o.toString()}_${Vr({ where: s.query?.where })}`), o;
  }).filter((s) => s !== void 0), Array.from(new Set(t.flat()));
}
function Xo(a) {
  const { seriesConfig: e, filteredSeriesIds: t, showMean: i } = a;
  let r = [];
  if (i === !0) {
    const s = e.find((o) => o.type === $.BoxPlotSeries);
    s !== void 0 && "y" in s && (r = [s.y].flat());
  } else
    r = sa(e, t);
  return r;
}
function hr(a, e) {
  return a === null && e === !0 || Number.isFinite(a);
}
function Yo(a) {
  const { dataItem: e, x: t, y: i, nullAsValid: r = !1 } = a;
  return e[t] !== void 0 && (typeof e[t] != "number" || Number.isFinite(e[t])) && hr(e[i], r);
}
function af(a) {
  const { chartConfig: e, nullAsValid: t = !1, dataSet: i } = a;
  let r = !0;
  if (e !== void 0) {
    const s = Ne(e.series);
    if (i === void 0 || i.length === 0)
      r = !0;
    else {
      const o = sa(e.series);
      r = !i.some((n) => {
        let f = !1;
        switch (s) {
          case $.HistogramSeries:
            {
              const d = n;
              f = hr(d.minValue, t) && hr(d.maxValue, t);
            }
            break;
          case $.ScatterSeries:
            {
              const d = n, { x: c, y: u } = e.series[0];
              f = hr(d[c], t) && hr(d[u], t);
            }
            break;
          case $.ComboLineAndBarSeries:
          case $.RadarSeries:
          case $.LineSeries:
          case $.BarSeries: {
            const d = n, { x: c } = e.series[0];
            f = o.some(
              (u) => Yo({ dataItem: d, x: c, y: u, nullAsValid: t })
            );
            break;
          }
          case $.BoxPlotSeries: {
            const d = e.series, { showOutliers: c } = e;
            f = Jo({
              configSeries: d,
              boxPlotDataItem: n,
              yList: o,
              showOutliers: c
            });
            break;
          }
          case $.PieSeries:
            {
              const d = n;
              let { x: c, y: u } = e.series[0];
              er(e.series) === U.PieFromFields && (c = ct, u = zi);
              const p = d[u];
              f = d[c] !== void 0 && d[c] !== null && !Qs(p) && hr(Number(p), t);
            }
            break;
          case $.GaugeSeries:
            {
              const { x: d } = e.series[0];
              f = hr(n[d], t);
            }
            break;
        }
        return f;
      });
    }
  }
  return r;
}
function Zo(a, e) {
  const t = /* @__PURE__ */ new Map(), i = e ?? ds(a);
  return a.forEach((r) => {
    if (i.includes(r.id) && "y" in r) {
      const s = t.get(r.type) ?? [];
      s.push(r.y), t.set(r.type, s);
    }
  }), t;
}
function el(a) {
  const { seriesConfig: e, filteredSeriesIds: t, filteredData: i } = a, r = Zo(e, t), s = e.find(
    (f) => f.type === $.LineSeries || f.type === $.RadarSeries
  )?.stackNegativeValuesToBaseline ?? !0;
  let o = Number.MIN_SAFE_INTEGER, n = Number.MAX_SAFE_INTEGER;
  return i.forEach((f, d) => {
    r.forEach((c) => {
      if (s) {
        let u = [], p = [];
        for (let l = 0; l < c.length; l += 1) {
          const h = f[c[l]];
          Number.isFinite(h) && (h < 0 ? p[d] = (p[d] ?? 0) + h : u[d] = (u[d] ?? 0) + h);
        }
        u = u.filter((l) => Number.isFinite(l)).sort((l, h) => l - h), p = p.filter((l) => Number.isFinite(l)).sort((l, h) => l - h), o = Math.max(
          o,
          u.length > 0 ? u[u.length - 1] : p[p.length - 1]
        ), n = Math.min(
          n,
          p.length > 0 ? p[0] : u[0]
        );
      } else {
        let u = 0;
        for (let p = 0; p < c.length; p += 1) {
          const l = f[c[p]];
          u += l, o = Math.max(o, u), n = Math.min(n, u);
        }
      }
    });
  }), { stackedMinY: n, stackedMaxY: o };
}
function rl(a) {
  const { dataItem: e, ...t } = a, i = ia({ key: de.Min, ...t }), r = ia({ key: de.Max, ...t }), s = e[i], o = e[r];
  return { min: s, max: o };
}
function tf(a) {
  let e = Number.NaN, t = Number.NaN, i, r;
  const { chartConfig: s, chartData: o, filteredSeriesIds: n } = a, { series: f } = s;
  if (f?.length > 0) {
    const { x: d } = f[0], c = o.filter((l) => l[d] !== null);
    [i, r] = _t(c, (l) => l[d]), s.axes?.[1]?.valueFormat.type === $.DateAxisFormat && i !== void 0 && r !== void 0 && ([i, r] = [new Date(i).valueOf(), new Date(r).valueOf()]);
    const p = Ne(s.series);
    if (p === $.HistogramSeries && o.length > 0) {
      const l = o[0]?.[Nt.Start], h = o[o.length - 1]?.[Nt.End];
      i = typeof l == "number" ? l : i, r = typeof h == "number" ? h : r;
    } else if (p === $.BoxPlotSeries) {
      e = Number.MAX_SAFE_INTEGER, t = Number.MIN_SAFE_INTEGER;
      const l = sa(f, n), h = er(f), g = "standardizeValues" in s ? s.standardizeValues === !0 : void 0, v = s.series.map(
        (S) => S.visible !== !1 ? Vr({ where: S.query?.where }) : ""
      );
      v.length === 0 && v.push(" ");
      for (let S = 0; S < c.length; S += 1)
        for (let A = 0; A < l.length; A += 1) {
          const C = h === U.BoxPlotMultiFieldsAndCategory ? l[A] : void 0;
          for (let P = 0; P < v.length; P += 1) {
            const { min: E, max: D } = rl({
              y: C,
              splitByValue: v[P],
              chartSubType: h,
              showOutliers: !1,
              standardizeValues: g,
              dataItem: c[S]
            });
            E != null && E < e && (e = E), D != null && D > t && (t = D);
          }
        }
    } else
      switch (Ao(s)) {
        case Zr.Stacked100: {
          e = Number.NaN, t = Number.NaN;
          break;
        }
        case Zr.Stacked: {
          const { stackedMinY: h, stackedMaxY: g } = el({
            seriesConfig: f,
            filteredData: c,
            filteredSeriesIds: n
          });
          e = h, t = g;
          break;
        }
        case Zr.Side:
        default: {
          e = Number.MAX_SAFE_INTEGER, t = Number.MIN_SAFE_INTEGER;
          const h = sa(f, n);
          for (let g = 0; g < h.length; g += 1) {
            const v = h[g], [S, A] = _t(
              c,
              (C) => C[v]
            );
            S !== void 0 && S < e && (e = S), A !== void 0 && A > t && (t = A);
          }
          break;
        }
      }
  }
  return { minY: e, maxY: t, minX: i, maxX: r };
}
async function Ke(a = Mr().locale) {
  let e = await import("./messages.en.js");
  switch (a) {
    case M.Arabic:
      e = await import("./messages.ar.js");
      break;
    case M.Bosnian:
      e = await import("./messages.bs.js");
      break;
    case M.Bulgarian:
      e = await import("./messages.bg.js");
      break;
    case M.Catalan:
      e = await import("./messages.ca.js");
      break;
    case M.Czech:
      e = await import("./messages.cs.js");
      break;
    case M.Danish:
      e = await import("./messages.da.js");
      break;
    case M.German:
      e = await import("./messages.de.js");
      break;
    case M.Greek:
      e = await import("./messages.el.js");
      break;
    case M.EnglishUSA:
      e = await import("./messages.en-US.js");
      break;
    case M.Spanish:
      e = await import("./messages.es.js");
      break;
    case M.Estonian:
      e = await import("./messages.et.js");
      break;
    case M.Finnish:
      e = await import("./messages.fi.js");
      break;
    case M.French:
      e = await import("./messages.fr.js");
      break;
    case M.Hebrew:
      e = await import("./messages.he.js");
      break;
    case M.Croatian:
      e = await import("./messages.hr.js");
      break;
    case M.Hungarian:
      e = await import("./messages.hu.js");
      break;
    case M.Indonesian:
      e = await import("./messages.id.js");
      break;
    case M.Italian:
      e = await import("./messages.it.js");
      break;
    case M.Japanese:
      e = await import("./messages.ja.js");
      break;
    case M.Korean:
      e = await import("./messages.ko.js");
      break;
    case M.Lithuanian:
      e = await import("./messages.lt.js");
      break;
    case M.Latvian:
      e = await import("./messages.lv.js");
      break;
    case M.NorwegianBokml:
      e = await import("./messages.no.js");
      break;
    case M.Dutch:
      e = await import("./messages.nl.js");
      break;
    case M.Polish:
      e = await import("./messages.pl.js");
      break;
    case M.PortugueseBrazil:
      e = await import("./messages.pt-BR.js");
      break;
    case M.PortuguesePortugal:
      e = await import("./messages.pt-PT.js");
      break;
    case M.Romanian:
      e = await import("./messages.ro.js");
      break;
    case M.Russian:
      e = await import("./messages.ru.js");
      break;
    case M.Serbian:
      e = await import("./messages.sr.js");
      break;
    case M.Slovak:
      e = await import("./messages.sk.js");
      break;
    case M.Slovenian:
      e = await import("./messages.sl.js");
      break;
    case M.Swedish:
      e = await import("./messages.sv.js");
      break;
    case M.Thai:
      e = await import("./messages.th.js");
      break;
    case M.Turkish:
      e = await import("./messages.tr.js");
      break;
    case M.Ukrainian:
      e = await import("./messages.uk.js");
      break;
    case M.Vietnamese:
      e = await import("./messages.vi.js");
      break;
    case M.ChineseChina:
      e = await import("./messages.zh-CN.js");
      break;
    case M.ChineseHongKong:
      e = await import("./messages.zh-HK.js");
      break;
    case M.ChineseTaiwan:
      e = await import("./messages.zh-TW.js");
      break;
    case M.English:
  }
  return e;
}
class xr extends Error {
  /**
   * Creates a new ArcgisChartsError instance.
   *
   * @param {string} name - A unique error name.
   * @param {string} [message] - A message describing the details of the error.
   * @param {Object} [details] - The details object provides additional details specific to the error.
   */
  constructor(e, t, i) {
    super(t), this.name = e, this.details = i;
  }
}
const sr = {
  Default: "defaultError",
  LayerLoadFailure: "layerLoadFailure",
  QueryFeaturesError: "queryFeaturesError",
  ChartDisposed: "ChartDisposeError",
  LayerFieldsNotFound: "layerFieldsNotFound"
};
function sf(a) {
  return a !== void 0 && (!("url" in a) || !a.url);
}
function mt(a) {
  return a !== void 0 && "layer" in a;
}
function al(a) {
  return a !== void 0 && "type" in a && a.type === "feature";
}
function tl(a) {
  return a !== void 0 && "type" in a && a.type === "subtype-group";
}
function pt(a) {
  return a !== void 0 && "type" in a && a.type === "subtype-sublayer";
}
function nf(a) {
  return al(a) || pt(a);
}
function Ce(a) {
  return pt(a) ? a.parent : a;
}
function hs(a) {
  return a.capabilities?.query?.supportsDistance || Ce(a).sourceJSON?.advancedQueryCapabilities?.supportsQueryWithDistance === !0;
}
function il(a, e) {
  return a.capabilities?.queryAttributeBins?.supportsDate === !0 && (We(e) || a.capabilities?.queryAttributeBins?.supportsStackBy);
}
function of(a) {
  return Ce(
    Te(a)
  )?.sourceJSON?.advancedQueryCapabilities.supportedOperationsWithCacheHint.includes("queryBins");
}
function lf(a) {
  let e = !1;
  const i = Ce(Te(a)).sourceJSON;
  if (i) {
    const r = i.queryBinsCapabilities?.supportsFixedIntervalBin, s = i.queryBinsCapabilities?.supportedStatisticTypes, o = [Se.Maximum, Se.Count].every(
      (n) => s?.includes(n.toUpperCase()) || s?.includes(n.toLowerCase())
    );
    e = r && o;
  }
  return e;
}
function uf(a) {
  let e;
  return mt(a) ? e = a.layer : e = a, e;
}
function Te(a) {
  let e;
  return mt(a) ? e = a.layer : e = a, e;
}
function sl(a) {
  let e = !1;
  const t = Ce(a).sourceJSON?.advancedQueryCapabilities?.supportedSpatialAggregationStatistics ?? [], i = a.capabilities?.query.supportedSpatialAggregationStatistics ?? {};
  return e = t.includes("EnvelopeAggregate") || "envelope" in i && i.envelope === !0, e;
}
function cf(a) {
  const { chartConfig: e, queryObject: t } = a;
  let i;
  const r = Te(t);
  return r && (i = {
    id: r.id,
    layerType: "ArcGISFeatureLayer"
  }, r.url && (i.url = r.url)), { ...e, iLayer: i };
}
const _r = /* @__PURE__ */ new Map();
function nl(a) {
  let e;
  switch (a) {
    case br.Feet:
      e = "esriSRUnit_Foot";
      break;
    case br.Miles:
      e = "esriSRUnit_StatuteMile";
      break;
    case br.NauticalMiles:
      e = "esriSRUnit_NauticalMile";
      break;
    case br.USNauticalMiles:
      e = "esriSRUnit_USNauticalMile";
      break;
    case br.Meters:
      e = "esriSRUnit_Meter";
      break;
    case br.Kilometers:
      e = "esriSRUnit_Kilometer";
      break;
  }
  return e;
}
async function ff(a) {
  const { queryObject: e, queryConfig: t, outputFormat: i, dataFormat: r, outAnalytics: s } = a, { where: o, geometry: n, distance: f, units: d, timeExtent: c } = t;
  let u;
  const p = Te(e), l = Ce(p), g = { query: { where: Nr([o, l.definitionExpression]) } }, v = vt(n)?.extent?.toJSON();
  if (v !== void 0) {
    const A = nl(d), { xmin: C, ymin: P, xmax: E, ymax: D } = v;
    g.query = {
      ...g.query,
      geometryType: "esriGeometryEnvelope",
      geometry: `${C},${P},${E},${D}`,
      distance: f,
      units: A,
      inSR: n?.spatialReference?.wkid
    };
  }
  c && (g.query.time = `${c[0]},${c[1]}`);
  const S = `${l.url}/${l.layerId}/queryAnalytic?f=${i}&dataFormat=${r}&outAnalytics=${s}`;
  try {
    u = (await st(S, g)).data?.features?.[0]?.attributes;
  } catch (A) {
    const C = await Ke();
    throw new xr(sr.QueryFeaturesError, C.queryError, A);
  }
  return u;
}
function ol(a, e) {
  return {
    lowerBoundaryAlias: `charts_lower_boundary_${a}`,
    upperBoundaryAlias: `charts_upper_boundary_${a}`,
    stackAlias: `charts_stack_alias_${e}`
  };
}
async function df(a) {
  const { queryObject: e, queryConfig: t, xStep: i, xMin: r, xMax: s, x: o, y: n, yStep: f, errorStrings: d } = a;
  let c;
  if (e && "queryAttributeBins" in e && Number.isFinite(i) && Number.isFinite(f) && Number.isFinite(r) && Number.isFinite(s) && i > 0 && f > 0) {
    const u = gl({
      queryObject: e,
      queryConfig: t,
      xStep: i,
      xMin: r,
      xMax: s,
      x: o,
      y: n,
      yStep: f
    });
    try {
      c = await e.queryAttributeBins(u);
    } catch (p) {
      throw new xr(sr.QueryFeaturesError, d.errors.queryError, p);
    }
  }
  return c;
}
async function hf(a) {
  const { queryConfig: e, x: t, queryObject: i, chartSubType: r, isGaugeByFeature: s } = a, o = Te(i);
  let n;
  if (i !== void 0) {
    const f = o.objectIdField, { where: d, gdbVersion: c, timeExtent: u, geometry: p, distance: l, units: h } = e, g = hl(u), v = vt(p), S = Ce(o), A = Nr([d, S.definitionExpression]), C = {
      returnDistinctValues: !0,
      // See issue #2653. We need a unique value for the outFields, no matter what it is, except "*", "" or multiple values.
      outFields: s === !0 || r === U.PieNoAggregation || r === U.BarAndLineNoAggregation || r === U.BarAndLineSplitByNoAggregation ? [f] : [t],
      where: A,
      gdbVersion: c ?? S.gdbVersion,
      timeExtent: g ?? S.timeExtent,
      geometry: v
    };
    ps(C) && (C.cacheHint = !0), C.geometry !== void 0 && hs(o) && (l !== void 0 && (C.distance = l), h !== void 0 && (C.units = h));
    try {
      n = await i.queryFeatureCount(C);
    } catch {
      n = Number.NaN;
    }
  }
  return n;
}
async function mf(a) {
  const { queryObject: e, queryConfig: t, abortKey: i } = a, { outStatistics: r } = t, s = /* @__PURE__ */ new Map();
  if (e !== void 0 && r !== void 0 && r.length > 0) {
    const o = r.map((c) => {
      const { statisticType: u, onStatisticField: p, outStatisticFieldName: l } = c;
      return {
        statisticType: u,
        onStatisticField: p,
        outStatisticFieldName: l?.toUpperCase()
      };
    });
    t.outStatistics = o, delete t.num, delete t.orderByFields;
    const n = gs({
      queryObject: e,
      queryConfig: t
    });
    let f;
    try {
      f = await e.queryFeatures(n, {
        signal: i !== void 0 ? _r.get(i)?.signal : void 0
      });
    } catch (c) {
      if (!Hi.isAbortError(c)) {
        const u = await Ke();
        throw new xr(sr.QueryFeaturesError, u.queryError, c);
      }
    }
    const d = f?.features?.[0]?.attributes;
    d !== void 0 && r.forEach((c) => {
      const { outStatisticFieldName: u } = c;
      if (u !== void 0) {
        const p = d[u.toLowerCase()] ?? d[u.toUpperCase()] ?? d[u];
        p !== void 0 && s.set(u, p);
      }
    });
  }
  return s;
}
async function ms(a) {
  const { queryObject: e, queryConfig: t, returnUniqueIdsOnly: i, abortKey: r } = a;
  let s = [];
  const o = Te(e);
  if (e !== void 0) {
    const n = yl(o), f = gs({
      queryObject: e,
      queryConfig: t,
      maxRecordCountFactor: n
    });
    try {
      i === !0 ? "queryObjectIds" in e ? s = await e.queryObjectIds(f) : (f.outFields = [o.objectIdField], s = (await e.queryFeatures(f, {
        signal: r !== void 0 ? _r.get(r)?.signal : void 0
      })).features.map((c) => c.attributes[o.objectIdField])) : s = (await e.queryFeatures(f, {
        signal: r !== void 0 ? _r.get(r)?.signal : void 0
      })).features;
    } catch (d) {
      if (!Hi.isAbortError(d)) {
        const c = await Ke();
        throw new xr(sr.QueryFeaturesError, c.queryError, d);
      }
    }
  }
  return s;
}
async function ll(a) {
  const e = [], { featureCount: t, maxRecords: i, queryConfig: r } = a;
  let s = [], o = 0, n = r?.start ?? 0;
  for (; o < mr.maxParallelRequests && n < t; ) {
    const d = { ...a };
    d.queryConfig = {
      ...r,
      start: n,
      num: Math.min(i, t - n)
    }, e.push(ms(d)), n += i, o += 1;
  }
  return s = (await Promise.all(e)).flat(), s;
}
async function ul(a) {
  const { queryObject: e, queryConfig: t, returnUniqueIdsOnly: i, featureCount: r, noBatch: s, abortKey: o } = a;
  let n = [];
  const f = Te(e);
  if (e !== void 0) {
    const d = r ?? 1, c = vs(f);
    if (s !== !0 && d > c && f.capabilities?.query.supportsPagination) {
      let u = 0, p = 0;
      const l = Math.ceil(d / c), h = Math.ceil(l / mr.maxParallelRequests), g = [];
      for (; p < h; ) {
        u = p * mr.maxParallelRequests * c;
        const S = ll({
          queryConfig: { ...t, start: u },
          queryObject: e,
          maxRecords: c,
          featureCount: d,
          returnUniqueIdsOnly: i,
          abortKey: o
        });
        g.push(S), p += 1;
      }
      n = (await Promise.all(g)).flat();
    } else (Number.isNaN(d) || d >= 0) && (n = await ms({
      queryObject: e,
      queryConfig: t,
      returnUniqueIdsOnly: i,
      abortKey: o
    }));
  }
  return n;
}
async function pf(a) {
  const { queryObject: e, queryConfig: t, uniqueFeature: i, abortKey: r } = a, s = { ...t, returnDistinctValues: !0 };
  return await ul({
    queryObject: e,
    abortKey: r,
    queryConfig: s,
    returnUniqueIdsOnly: !0,
    featureCount: i === !0 ? 1 : void 0
    // in case of querying for a unique feature, we know the query will bring back only 1 entry
  });
}
function vf(a) {
  if (a !== void 0) {
    const e = _r.get(a);
    e !== void 0 && e.abort(), _r.set(a, new AbortController());
  }
}
function cl(a) {
  return {
    lowerBoundaryAlias: `charts_lower_boundary_${a}`,
    upperBoundaryAlias: `charts_upper_boundary_${a}`
  };
}
async function gf(a) {
  const { queryObject: e, dateField: t, splitByField: i, queryConfig: r, temporalBinning: s } = a;
  let o = [], n;
  if (s) {
    const { unit: f } = s;
    try {
      if (f) {
        const d = Ce(Te(e));
        if (n = il(d, i), n && e && "queryAttributeBins" in e) {
          const c = await vl({
            queryObject: e,
            queryConfig: r,
            temporalBinning: s,
            dateField: t,
            splitByField: i
          });
          o = (await e.queryAttributeBins(c)).features;
        }
      }
    } catch (d) {
      const c = await Ke();
      throw new xr(sr.QueryFeaturesError, c.queryError, d);
    }
  }
  if (n === !1) {
    const f = await Ke();
    throw new xr(
      sr.QueryFeaturesError,
      f.queryBinsNotSupported,
      f.queryBinsNotSupported
      // given we are out of a try/catch we set the details to the same error message
    );
  }
  return o;
}
function ps(a) {
  const e = !a.geometry || a.geometry.type === "extent", t = (a.where ?? "").toUpperCase(), i = !t.includes("CURRENT_TIMESTAMP") && !t.includes("CURRENT_DATE") && !t.includes("CURRENT_TIME");
  return e && i;
}
function vs(a) {
  const e = Ce(a)?.sourceJSON;
  let t = e?.maxRecordCount ?? mr.maxRecords;
  return e?.advancedQueryCapabilities?.supportsMaxRecordCountFactor && e?.maxRecordCount !== void 0 && (t = e.maxRecordCount * mr.maxRecordCountFactor), t;
}
function Nr(a, e) {
  let t;
  const i = Array.from(new Set(a)).filter(
    (r) => r != null && r !== "" && !Er(r)
  );
  return i.sort((r, s) => s.length - r.length), i.length === 1 ? [t] = i : i?.forEach((r) => {
    r !== void 0 && (We(t) ? t = `(${r})` : t?.includes(`(${r})`) || (t = `${t} ${e ?? "AND"} (${r})`));
  }), t ?? "1=1";
}
function fl(a, e) {
  let t = e;
  if (a !== void 0) {
    const i = Te(a), r = Ce(i).timeExtent;
    r?.start != null && r?.end != null && (t = [r.start.valueOf(), r.end.valueOf()]);
  }
  return t;
}
function dl(a) {
  const { queryObject: e, defaultGeometry: t, ignoreViewExtent: i } = a;
  let r = t;
  if (!i && mt(e)) {
    const s = e.view.extent, { xmin: o, xmax: n, ymin: f, ymax: d, zmin: c, zmax: u, spatialReference: p } = s;
    r = { xmin: o, ymin: f, zmin: c, xmax: n, ymax: d, zmax: u, spatialReference: p };
  }
  return r;
}
function hl(a) {
  let e;
  return a !== void 0 && (e = new Qi({
    start: new Date(a[0]),
    end: new Date(a[1])
  })), e;
}
function vt(a) {
  let e;
  return a !== void 0 && (e = Ui.fromJSON(a)), e;
}
function ml(a) {
  return a === void 0 ? ["*"] : Array.from(new Set(a));
}
function gt(a) {
  const { queryObject: e, queryConfig: t, queryType: i } = a, { where: r, outStatistics: s, geometry: o, distance: n, units: f, timeExtent: d, returnDistinctValues: c } = t ?? {}, u = i === "Query" ? new en({}) : new Zs({}), p = Te(e), l = Ce(p), h = [r, l.definitionExpression];
  if (u.where = Nr(h), u.returnDistinctValues = c ?? !1, s !== void 0) {
    const S = sl(p);
    u.outStatistics = s.filter(
      (A) => A.statisticType !== Se.EnvelopeAggregate || S
    ).map((A) => rn.fromJSON(A));
  }
  const g = vt(o);
  g !== void 0 && (u.geometry = g, t?.spatialRelationship && (u.spatialRelationship = t.spatialRelationship), hs(p) && (n !== void 0 && (u.distance = n), f !== void 0 && (u.units = f)));
  let v;
  return d && (v = new Qi({
    start: d?.[0],
    end: d?.[1]
  })), v !== void 0 ? u.timeExtent = v : l.timeExtent !== void 0 && (u.timeExtent = l.timeExtent), ps(u) && (u.cacheHint = !0), u;
}
function pl(a) {
  let e;
  switch (a) {
    case $r.Start:
      e = "first";
      break;
    case $r.End:
      e = "last";
      break;
  }
  return e;
}
async function vl(a) {
  const { queryObject: e, queryConfig: t, temporalBinning: i, dateField: r, splitByField: s } = a, o = Te(e), f = (await ua(e)).find((P) => P.name === r)?.type, d = gt({
    queryObject: e,
    queryConfig: t,
    queryType: "AttributeBinsQuery"
  }), { type: c, unit: u, size: p, trimIncompleteTimeInterval: l, timeAggregationType: h } = i, { start: g, end: v, offset: S, outTimeZone: A } = c === Mi.CalendarBased ? i : {}, C = cl(r);
  if (d.lowerBoundaryAlias = C.lowerBoundaryAlias, d.upperBoundaryAlias = C.upperBoundaryAlias, f !== $e.DateOnly && (d.outTimeZone = A ?? Intl.DateTimeFormat().resolvedOptions().timeZone), d.binParameters = {
    type: "date",
    field: r,
    interval: { unit: u, value: p },
    start: g,
    end: v,
    offset: S ? { unit: S.unit, value: S.size } : null
  }, d.binParameters.type === "date" && (o.capabilities?.queryAttributeBins?.supportsSnapToData && (d.binParameters.snapToData = pl(h)), o.capabilities?.queryAttributeBins?.supportsReturnFullIntervalBin && (d.binParameters.returnFullIntervalBin = l === !1)), !We(s)) {
    const E = Ce(o).fields.find((D) => D.name === s)?.type;
    (!E || E === "string" || E === "integer" || E === "small-integer" || E === "big-integer" || E === "double") && (d.binParameters.stackBy = {
      type: "field",
      value: s,
      valueType: E === "string" ? "string" : "integer"
    });
  }
  return d;
}
function gl(a) {
  const { queryObject: e, queryConfig: t, xStep: i, xMin: r, xMax: s, x: o, y: n, yStep: f } = a, d = gt({
    queryObject: e,
    queryConfig: t,
    queryType: "AttributeBinsQuery"
  }), c = ol(o, n);
  return d.lowerBoundaryAlias = c.lowerBoundaryAlias, d.upperBoundaryAlias = c.upperBoundaryAlias, d.binParameters = {
    type: "fixed-interval",
    field: o,
    interval: i,
    start: r,
    end: s,
    stackBy: {
      value: `FLOOR(${n} / ${f})`,
      type: "expression",
      alias: c.stackAlias,
      valueType: "integer"
    }
  }, d;
}
function gs(a) {
  const { queryObject: e, queryConfig: t, maxRecordCountFactor: i } = a, { groupByFieldsForStatistics: r, orderByFields: s, gdbVersion: o, start: n, num: f, outFields: d } = t ?? {}, c = gt({ queryObject: e, queryConfig: t, queryType: "Query" });
  c.returnGeometry = !1;
  const u = Te(e), p = Ce(u);
  return c.outFields = ml(d), c.groupByFieldsForStatistics = r ?? c.groupByFieldsForStatistics, c.orderByFields = s ?? [], c.objectIds = t?.objectIds, i !== void 0 && (c.maxRecordCountFactor = i), o !== void 0 && o !== "" ? c.gdbVersion = o : p.gdbVersion !== void 0 && p.gdbVersion !== "" && (c.gdbVersion = p.gdbVersion), f !== void 0 && (c.num = f), n !== void 0 && (c.start = n, c.num = c.num ?? vs(u)), c;
}
function yl(a) {
  return Ce(a)?.sourceJSON?.advancedQueryCapabilities?.supportsMaxRecordCountFactor === !0 ? mr.maxRecordCountFactor : void 0;
}
function yf(a) {
  let e, t, i;
  return a !== void 0 && (e = a.type, (e === ha.UniqueValue || e === ha.ClassBreaks) && (t = a.field ?? void 0, e === ha.ClassBreaks && (i = a.normalizationField ?? void 0))), { rendererType: e, rendererField: t, rendererNormalizationField: i };
}
const ys = Ys(async (a) => {
  const e = a.featureCollection;
  let t, i;
  if (e?.layers?.[0] !== void 0) {
    const o = e.layers[0];
    t = o.featureSet, i = o.layerDefinition;
  } else
    i = a.layerDefinition;
  const r = {};
  if (t !== void 0) {
    if (r.source = Ks.fromJSON(t).features, i?.fields !== void 0 && (r.fields = i.fields.map((o) => Ws.fromJSON(o))), i?.objectIdField !== void 0 && (r.objectIdField = i.objectIdField), i?.geometryType !== void 0) {
      const o = Ui.fromJSON({
        geometryType: i.geometryType
      });
      o?.type !== void 0 && o?.type !== "extent" && (r.geometryType = o.type);
    }
    i?.spatialReference !== void 0 && (r.spatialReference = i.spatialReference);
  } else
    r.id = a.id, i?.id !== void 0 && (r.layerId = i.id), a.url !== void 0 && (r.url = a.url), a.itemId !== void 0 && i?.id !== void 0 && (r.portalItem = { id: a.itemId });
  if (i !== void 0) {
    const o = i.drawingInfo;
    o?.renderer !== void 0 && (r.renderer = Gs.fromJSON(o.renderer));
  }
  const s = new Js(r);
  return await s.load(), s;
});
async function Sf(a) {
  const { layer: e, view: t, chartConfig: i } = a;
  let r;
  if (e !== void 0) {
    const s = Te(e), o = Ce(s);
    if (t !== void 0 && !o.isTable) {
      o.outFields = ["*"];
      const n = (d) => "highlight" in d, f = await t.whenLayerView(o);
      n(f) && (r = f);
    } else
      r = e;
  } else "iLayer" in i && i.iLayer && (r = await ys(i.iLayer));
  return r;
}
async function ua(a, e) {
  const t = Te(a);
  let i = [];
  if (t !== void 0) {
    await t.load();
    const r = e === !0 && t?.popupTemplate?.fieldInfos !== void 0;
    i = t.fields.map((s) => {
      const o = s.toJSON();
      if (r) {
        const n = t.popupTemplate?.fieldInfos?.find(
          (f) => f.fieldName?.toLowerCase() === s.name.toLowerCase()
        )?.label;
        n !== void 0 && n !== s.name && (o.alias = n);
      }
      return o;
    });
  }
  return i;
}
function yt(a, e = []) {
  return e.find((t) => t.name === a);
}
function bf(a) {
  return a.find((t) => t.type === $e.OID)?.name ?? "";
}
function Ss(a) {
  return [
    $e.Single,
    $e.Double,
    $e.SmallInteger,
    $e.Integer,
    $e.BigInteger
  ].includes(a.type);
}
function Pf(a) {
  return a.type === $e.Date;
}
function wf(a) {
  return [
    $e.SmallInteger,
    $e.Integer,
    $e.BigInteger
  ].includes(a.type);
}
function Ef(a) {
  return a.filter(
    (e) => e.type === $e.Date || e.type === $e.DateOnly || e.type === $e.TimestampOffset
  ).map((e) => e.name);
}
function xf(a) {
  return a.filter((e) => Ss(e)).map((e) => e.name);
}
function Sl(a) {
  const { subtypeInfo: e, fieldName: t, fieldValueToMatch: i } = a;
  let r;
  const s = (o) => `${o.id}` == `${i}`;
  return e?.subtypeField === t && e.subtypes ? r = e.subtypes.find(s)?.name : e?.typeIdField === t && e.types && (r = e.types.find(s)?.name), r;
}
function Ut(a, e) {
  const t = [], i = tl(a) ? a.subtypes : a[e];
  return i?.[0] !== void 0 && i.forEach((r) => {
    const { name: s, domains: o } = r;
    let n = "id" in r ? r.id : void 0;
    !n && "code" in r && (n = r.code);
    const f = Object.entries(o ?? {}), d = [], u = f?.filter(([p, l]) => l?.type === "coded-value")?.map(([p, l]) => {
      let h = { fieldName: p, name: s, codedValues: d };
      if (l && "codedValues" in l) {
        const g = l.codedValues.map(({ code: v, name: S }) => ({
          name: S,
          code: v
        }));
        h = {
          fieldName: p,
          name: l.name,
          codedValues: g
        };
      }
      return h;
    });
    t.push({ id: n ?? "", name: s, domains: u });
  }), t.length === 0 ? void 0 : t;
}
function Ff(a) {
  let e;
  if (a !== void 0) {
    const t = Te(a);
    if (!pt(t) && !We(t?.typeIdField)) {
      const i = Ut(t, "types");
      i !== void 0 && (e = {
        typeIdField: t.typeIdField ?? void 0,
        types: i
      });
    }
    if (!We(t?.subtypeField)) {
      const i = Ce(t), r = Ut(i, "subtypes");
      r !== void 0 && (e = {
        ...e,
        subtypeField: i.subtypeField ?? void 0,
        subtypes: r
      });
    }
  }
  return e;
}
function Cf(a) {
  const { fieldName: e, fieldValueToMatch: t, subtypeInfo: i, fieldList: r } = a;
  let s;
  if ((typeof t != "string" || !We(t)) && !We(e) && (s = Sl({
    subtypeInfo: i,
    fieldName: e,
    fieldValueToMatch: t
  }), s === void 0)) {
    const o = yt(e, r);
    if (i?.types !== void 0) {
      const n = i?.types;
      for (const f of n) {
        const d = f.domains?.filter((c) => c.fieldName === o?.name) ?? [];
        for (const c of d)
          if (s = c?.codedValues?.find((u) => `${u.code}` === t)?.name, s !== void 0)
            break;
        if (s !== void 0)
          break;
      }
    }
    s === void 0 && o?.domain !== void 0 && o.domain.type === "codedValue" && (s = o.domain.codedValues?.find(
      (n) => `${n.code}` == `${t}`
    )?.name);
  }
  return s;
}
async function Af(a) {
  let e = [];
  return !Ce(a).isTable && a.fieldsIndex && (e = await Hs.getRendererFields(a.renderer, a.fieldsIndex)), e;
}
function bl(a) {
  const e = "/rest/services";
  let t = a.toLowerCase();
  const i = t.indexOf(e);
  return t = i > -1 ? a.substring(0, i) : a, `${t}/rest/info`;
}
async function Df(a) {
  let e = !0;
  const t = ".arcgis.com/", i = a.url, r = i?.includes(t);
  if (i && r && Ce(a).sourceJSON.serviceItemId !== void 0) {
    const s = bl(i);
    try {
      const o = (await st(s, { query: { f: "json" } })).data;
      if (o.owningTenant !== void 0 && o.owningSystemUrl !== void 0) {
        const n = `${o.owningSystemUrl}/sharing/rest/portals/${o.owningTenant}`, f = (await st(n, {
          authMode: "auto",
          query: { f: "json" }
        })).data, d = new Xs({ sourceJSON: f });
        await d.load(), e = d?.sourceJSON?.subscriptionInfo?.dataStoreLevel === void 0;
      }
    } catch {
    }
  }
  return e;
}
async function Pl(a) {
  const { queryObject: e, fieldToMatch: t, returnUndefinedIfNotFound: i } = a, r = await ua(e);
  let s = r.find((f) => t === f.name);
  s || (s = r.find((f) => t.toUpperCase() === f.name.toUpperCase()));
  const o = i ? "" : t;
  return s?.name ?? o;
}
async function wl(a) {
  const { fieldsList: e, queryObject: t, returnUndefinedIfNotFound: i } = a;
  let r = e;
  return r !== void 0 && (r = await Promise.all(
    r.map(
      async (s) => await Pl({ queryObject: t, fieldToMatch: s, returnUndefinedIfNotFound: i })
    )
  )), r;
}
function Tf(a) {
  const { queryObject: e, chartConfig: t, runtimeDataFilters: i, ignoreViewExtent: r } = a, { series: s, dataFilters: o } = t, {
    where: n,
    gdbVersion: f,
    timeExtent: d,
    geometry: c,
    distance: u,
    units: p,
    objectIds: l,
    spatialRelationship: h
  } = o ?? {}, {
    where: g,
    gdbVersion: v,
    timeExtent: S,
    geometry: A,
    distance: C,
    units: P,
    objectIds: E,
    spatialRelationship: D
  } = i ?? {}, I = s[0], { query: R } = I, { where: O } = R ?? {}, w = er(s), x = { ...R };
  return x.where = Nr([n, g]), w !== U.BarAndLineSplitBy && w !== U.BoxPlotMonoFieldAndSplitBy && w !== U.BoxPlotMonoFieldAndCategoryAndSplitBy && w !== U.BoxPlotMultiFieldsAndSplitBy && w !== U.BarAndLineSplitByNoAggregation && (x.where = Nr([x.where, O])), t.orderOptions?.orderByFields !== void 0 && (x.orderByFields = t.orderOptions.orderByFields), x.gdbVersion = v ?? f, x.timeExtent = fl(e, S ?? d), x.geometry = dl({
    queryObject: e,
    defaultGeometry: A ?? c,
    ignoreViewExtent: r
  }), x.distance = C ?? u, x.units = P ?? p, x.objectIds = E ?? l, x.spatialRelationship = D ?? h, R?.outStatistics?.[0]?.statisticType === Se.Count && (x.returnDistinctValues = R?.returnDistinctValues ?? !1), x;
}
async function Lf(a) {
  let e = [];
  return a !== void 0 && (e = await xl(a)), e;
}
async function El(a, e) {
  const t = [];
  let i = [];
  const r = a.series;
  let s = e;
  if (a.iLayer && (s = await ys(a.iLayer)), s !== void 0) {
    const o = r[0].x ?? "", n = r.map((p) => "y" in p ? p.y : "").flat(), f = la(a.series[0].query?.where), d = No(a), c = a?.series.map((p) => {
      const l = p.query?.outStatistics?.map((h) => h.onStatisticField) ?? [];
      return l?.length > 0 ? l : "";
    }).flat();
    t.push(o), t.push(...n), t.push(f), t.push(...d), t.push(...c);
    const u = await wl({ fieldsList: t, queryObject: s, returnUndefinedIfNotFound: !0 });
    u && (i = Array.from(new Set(u)).filter((p) => p !== ""));
  }
  return i;
}
async function xl(a) {
  const e = a.charts ?? [];
  let t = [];
  if (e.length > 0) {
    const i = e.map(
      async (r) => await El(r, a)
    );
    t = await Promise.all(i).then((r) => r.flat()), t = Array.from(new Set(t.filter((r) => r !== "")));
  }
  return t;
}
function Fl(a) {
  return a && a.__esModule && Object.prototype.hasOwnProperty.call(a, "default") ? a.default : a;
}
var Rr = { exports: {} };
/** @license URI.js v4.4.1 (c) 2011 Gary Court. License: http://github.com/garycourt/uri-js */
var Cl = Rr.exports, Qt;
function Al() {
  return Qt || (Qt = 1, function(a, e) {
    (function(t, i) {
      i(e);
    })(Cl, function(t) {
      function i() {
        for (var y = arguments.length, m = Array(y), b = 0; b < y; b++)
          m[b] = arguments[b];
        if (m.length > 1) {
          m[0] = m[0].slice(0, -1);
          for (var L = m.length - 1, T = 1; T < L; ++T)
            m[T] = m[T].slice(1, -1);
          return m[L] = m[L].slice(1), m.join("");
        } else
          return m[0];
      }
      function r(y) {
        return "(?:" + y + ")";
      }
      function s(y) {
        return y === void 0 ? "undefined" : y === null ? "null" : Object.prototype.toString.call(y).split(" ").pop().split("]").shift().toLowerCase();
      }
      function o(y) {
        return y.toUpperCase();
      }
      function n(y) {
        return y != null ? y instanceof Array ? y : typeof y.length != "number" || y.split || y.setInterval || y.call ? [y] : Array.prototype.slice.call(y) : [];
      }
      function f(y, m) {
        var b = y;
        if (m)
          for (var L in m)
            b[L] = m[L];
        return b;
      }
      function d(y) {
        var m = "[A-Za-z]", b = "[0-9]", L = i(b, "[A-Fa-f]"), T = r(r("%[EFef]" + L + "%" + L + L + "%" + L + L) + "|" + r("%[89A-Fa-f]" + L + "%" + L + L) + "|" + r("%" + L + L)), Q = "[\\:\\/\\?\\#\\[\\]\\@]", H = "[\\!\\$\\&\\'\\(\\)\\*\\+\\,\\;\\=]", se = i(Q, H), fe = y ? "[\\xA0-\\u200D\\u2010-\\u2029\\u202F-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF]" : "[]", we = y ? "[\\uE000-\\uF8FF]" : "[]", te = i(m, b, "[\\-\\.\\_\\~]", fe);
        r(m + i(m, b, "[\\+\\-\\.]") + "*"), r(r(T + "|" + i(te, H, "[\\:]")) + "*");
        var ce = r(r("25[0-5]") + "|" + r("2[0-4]" + b) + "|" + r("1" + b + b) + "|" + r("0?[1-9]" + b) + "|0?0?" + b), Ee = r(ce + "\\." + ce + "\\." + ce + "\\." + ce), X = r(L + "{1,4}"), me = r(r(X + "\\:" + X) + "|" + Ee), xe = r(r(X + "\\:") + "{6}" + me), pe = r("\\:\\:" + r(X + "\\:") + "{5}" + me), rr = r(r(X) + "?\\:\\:" + r(X + "\\:") + "{4}" + me), Ue = r(r(r(X + "\\:") + "{0,1}" + X) + "?\\:\\:" + r(X + "\\:") + "{3}" + me), Qe = r(r(r(X + "\\:") + "{0,2}" + X) + "?\\:\\:" + r(X + "\\:") + "{2}" + me), Sr = r(r(r(X + "\\:") + "{0,3}" + X) + "?\\:\\:" + X + "\\:" + me), ur = r(r(r(X + "\\:") + "{0,4}" + X) + "?\\:\\:" + me), ke = r(r(r(X + "\\:") + "{0,5}" + X) + "?\\:\\:" + X), He = r(r(r(X + "\\:") + "{0,6}" + X) + "?\\:\\:"), cr = r([xe, pe, rr, Ue, Qe, Sr, ur, ke, He].join("|")), Ye = r(r(te + "|" + T) + "+");
        r("[vV]" + L + "+\\." + i(te, H, "[\\:]") + "+"), r(r(T + "|" + i(te, H)) + "*");
        var Tr = r(T + "|" + i(te, H, "[\\:\\@]"));
        return r(r(T + "|" + i(te, H, "[\\@]")) + "+"), r(r(Tr + "|" + i("[\\/\\?]", we)) + "*"), {
          NOT_SCHEME: new RegExp(i("[^]", m, b, "[\\+\\-\\.]"), "g"),
          NOT_USERINFO: new RegExp(i("[^\\%\\:]", te, H), "g"),
          NOT_HOST: new RegExp(i("[^\\%\\[\\]\\:]", te, H), "g"),
          NOT_PATH: new RegExp(i("[^\\%\\/\\:\\@]", te, H), "g"),
          NOT_PATH_NOSCHEME: new RegExp(i("[^\\%\\/\\@]", te, H), "g"),
          NOT_QUERY: new RegExp(i("[^\\%]", te, H, "[\\:\\@\\/\\?]", we), "g"),
          NOT_FRAGMENT: new RegExp(i("[^\\%]", te, H, "[\\:\\@\\/\\?]"), "g"),
          ESCAPE: new RegExp(i("[^]", te, H), "g"),
          UNRESERVED: new RegExp(te, "g"),
          OTHER_CHARS: new RegExp(i("[^\\%]", te, se), "g"),
          PCT_ENCODED: new RegExp(T, "g"),
          IPV4ADDRESS: new RegExp("^(" + Ee + ")$"),
          IPV6ADDRESS: new RegExp("^\\[?(" + cr + ")" + r(r("\\%25|\\%(?!" + L + "{2})") + "(" + Ye + ")") + "?\\]?$")
          //RFC 6874, with relaxed parsing rules
        };
      }
      var c = d(!1), u = d(!0), p = /* @__PURE__ */ function() {
        function y(m, b) {
          var L = [], T = !0, Q = !1, H = void 0;
          try {
            for (var se = m[Symbol.iterator](), fe; !(T = (fe = se.next()).done) && (L.push(fe.value), !(b && L.length === b)); T = !0)
              ;
          } catch (we) {
            Q = !0, H = we;
          } finally {
            try {
              !T && se.return && se.return();
            } finally {
              if (Q) throw H;
            }
          }
          return L;
        }
        return function(m, b) {
          if (Array.isArray(m))
            return m;
          if (Symbol.iterator in Object(m))
            return y(m, b);
          throw new TypeError("Invalid attempt to destructure non-iterable instance");
        };
      }(), l = function(y) {
        if (Array.isArray(y)) {
          for (var m = 0, b = Array(y.length); m < y.length; m++) b[m] = y[m];
          return b;
        } else
          return Array.from(y);
      }, h = 2147483647, g = 36, v = 1, S = 26, A = 38, C = 700, P = 72, E = 128, D = "-", I = /^xn--/, R = /[^\0-\x7E]/, O = /[\x2E\u3002\uFF0E\uFF61]/g, w = {
        overflow: "Overflow: input needs wider integers to process",
        "not-basic": "Illegal input >= 0x80 (not a basic code point)",
        "invalid-input": "Invalid input"
      }, x = g - v, _ = Math.floor, k = String.fromCharCode;
      function q(y) {
        throw new RangeError(w[y]);
      }
      function z(y, m) {
        for (var b = [], L = y.length; L--; )
          b[L] = m(y[L]);
        return b;
      }
      function Y(y, m) {
        var b = y.split("@"), L = "";
        b.length > 1 && (L = b[0] + "@", y = b[1]), y = y.replace(O, ".");
        var T = y.split("."), Q = z(T, m).join(".");
        return L + Q;
      }
      function G(y) {
        for (var m = [], b = 0, L = y.length; b < L; ) {
          var T = y.charCodeAt(b++);
          if (T >= 55296 && T <= 56319 && b < L) {
            var Q = y.charCodeAt(b++);
            (Q & 64512) == 56320 ? m.push(((T & 1023) << 10) + (Q & 1023) + 65536) : (m.push(T), b--);
          } else
            m.push(T);
        }
        return m;
      }
      var ee = function(m) {
        return String.fromCodePoint.apply(String, l(m));
      }, K = function(m) {
        return m - 48 < 10 ? m - 22 : m - 65 < 26 ? m - 65 : m - 97 < 26 ? m - 97 : g;
      }, J = function(m, b) {
        return m + 22 + 75 * (m < 26) - ((b != 0) << 5);
      }, Le = function(m, b, L) {
        var T = 0;
        for (
          m = L ? _(m / C) : m >> 1, m += _(m / b);
          /* no initialization */
          m > x * S >> 1;
          T += g
        )
          m = _(m / x);
        return _(T + (x + 1) * m / (m + A));
      }, Ae = function(m) {
        var b = [], L = m.length, T = 0, Q = E, H = P, se = m.lastIndexOf(D);
        se < 0 && (se = 0);
        for (var fe = 0; fe < se; ++fe)
          m.charCodeAt(fe) >= 128 && q("not-basic"), b.push(m.charCodeAt(fe));
        for (var we = se > 0 ? se + 1 : 0; we < L; ) {
          for (
            var te = T, ce = 1, Ee = g;
            ;
            /* no condition */
            Ee += g
          ) {
            we >= L && q("invalid-input");
            var X = K(m.charCodeAt(we++));
            (X >= g || X > _((h - T) / ce)) && q("overflow"), T += X * ce;
            var me = Ee <= H ? v : Ee >= H + S ? S : Ee - H;
            if (X < me)
              break;
            var xe = g - me;
            ce > _(h / xe) && q("overflow"), ce *= xe;
          }
          var pe = b.length + 1;
          H = Le(T - te, pe, te == 0), _(T / pe) > h - Q && q("overflow"), Q += _(T / pe), T %= pe, b.splice(T++, 0, Q);
        }
        return String.fromCodePoint.apply(String, b);
      }, Fe = function(m) {
        var b = [];
        m = G(m);
        var L = m.length, T = E, Q = 0, H = P, se = !0, fe = !1, we = void 0;
        try {
          for (var te = m[Symbol.iterator](), ce; !(se = (ce = te.next()).done); se = !0) {
            var Ee = ce.value;
            Ee < 128 && b.push(k(Ee));
          }
        } catch (Lr) {
          fe = !0, we = Lr;
        } finally {
          try {
            !se && te.return && te.return();
          } finally {
            if (fe)
              throw we;
          }
        }
        var X = b.length, me = X;
        for (X && b.push(D); me < L; ) {
          var xe = h, pe = !0, rr = !1, Ue = void 0;
          try {
            for (var Qe = m[Symbol.iterator](), Sr; !(pe = (Sr = Qe.next()).done); pe = !0) {
              var ur = Sr.value;
              ur >= T && ur < xe && (xe = ur);
            }
          } catch (Lr) {
            rr = !0, Ue = Lr;
          } finally {
            try {
              !pe && Qe.return && Qe.return();
            } finally {
              if (rr)
                throw Ue;
            }
          }
          var ke = me + 1;
          xe - T > _((h - Q) / ke) && q("overflow"), Q += (xe - T) * ke, T = xe;
          var He = !0, cr = !1, Ye = void 0;
          try {
            for (var Tr = m[Symbol.iterator](), Lt; !(He = (Lt = Tr.next()).done); He = !0) {
              var It = Lt.value;
              if (It < T && ++Q > h && q("overflow"), It == T) {
                for (
                  var Ur = Q, Qr = g;
                  ;
                  /* no condition */
                  Qr += g
                ) {
                  var Hr = Qr <= H ? v : Qr >= H + S ? S : Qr - H;
                  if (Ur < Hr)
                    break;
                  var Rt = Ur - Hr, $t = g - Hr;
                  b.push(k(J(Hr + Rt % $t, 0))), Ur = _(Rt / $t);
                }
                b.push(k(J(Ur, 0))), H = Le(Q, ke, me == X), Q = 0, ++me;
              }
            }
          } catch (Lr) {
            cr = !0, Ye = Lr;
          } finally {
            try {
              !He && Tr.return && Tr.return();
            } finally {
              if (cr)
                throw Ye;
            }
          }
          ++Q, ++T;
        }
        return b.join("");
      }, be = function(m) {
        return Y(m, function(b) {
          return I.test(b) ? Ae(b.slice(4).toLowerCase()) : b;
        });
      }, Be = function(m) {
        return Y(m, function(b) {
          return R.test(b) ? "xn--" + Fe(b) : b;
        });
      }, F = {
        /**
         * A string representing the current Punycode.js version number.
         * @memberOf punycode
         * @type String
         */
        version: "2.1.0",
        /**
         * An object of methods to convert from JavaScript's internal character
         * representation (UCS-2) to Unicode code points, and back.
         * @see <https://mathiasbynens.be/notes/javascript-encoding>
         * @memberOf punycode
         * @type Object
         */
        ucs2: {
          decode: G,
          encode: ee
        },
        decode: Ae,
        encode: Fe,
        toASCII: Be,
        toUnicode: be
      }, N = {};
      function V(y) {
        var m = y.charCodeAt(0), b = void 0;
        return m < 16 ? b = "%0" + m.toString(16).toUpperCase() : m < 128 ? b = "%" + m.toString(16).toUpperCase() : m < 2048 ? b = "%" + (m >> 6 | 192).toString(16).toUpperCase() + "%" + (m & 63 | 128).toString(16).toUpperCase() : b = "%" + (m >> 12 | 224).toString(16).toUpperCase() + "%" + (m >> 6 & 63 | 128).toString(16).toUpperCase() + "%" + (m & 63 | 128).toString(16).toUpperCase(), b;
      }
      function W(y) {
        for (var m = "", b = 0, L = y.length; b < L; ) {
          var T = parseInt(y.substr(b + 1, 2), 16);
          if (T < 128)
            m += String.fromCharCode(T), b += 3;
          else if (T >= 194 && T < 224) {
            if (L - b >= 6) {
              var Q = parseInt(y.substr(b + 4, 2), 16);
              m += String.fromCharCode((T & 31) << 6 | Q & 63);
            } else
              m += y.substr(b, 6);
            b += 6;
          } else if (T >= 224) {
            if (L - b >= 9) {
              var H = parseInt(y.substr(b + 4, 2), 16), se = parseInt(y.substr(b + 7, 2), 16);
              m += String.fromCharCode((T & 15) << 12 | (H & 63) << 6 | se & 63);
            } else
              m += y.substr(b, 9);
            b += 9;
          } else
            m += y.substr(b, 3), b += 3;
        }
        return m;
      }
      function B(y, m) {
        function b(L) {
          var T = W(L);
          return T.match(m.UNRESERVED) ? T : L;
        }
        return y.scheme && (y.scheme = String(y.scheme).replace(m.PCT_ENCODED, b).toLowerCase().replace(m.NOT_SCHEME, "")), y.userinfo !== void 0 && (y.userinfo = String(y.userinfo).replace(m.PCT_ENCODED, b).replace(m.NOT_USERINFO, V).replace(m.PCT_ENCODED, o)), y.host !== void 0 && (y.host = String(y.host).replace(m.PCT_ENCODED, b).toLowerCase().replace(m.NOT_HOST, V).replace(m.PCT_ENCODED, o)), y.path !== void 0 && (y.path = String(y.path).replace(m.PCT_ENCODED, b).replace(y.scheme ? m.NOT_PATH : m.NOT_PATH_NOSCHEME, V).replace(m.PCT_ENCODED, o)), y.query !== void 0 && (y.query = String(y.query).replace(m.PCT_ENCODED, b).replace(m.NOT_QUERY, V).replace(m.PCT_ENCODED, o)), y.fragment !== void 0 && (y.fragment = String(y.fragment).replace(m.PCT_ENCODED, b).replace(m.NOT_FRAGMENT, V).replace(m.PCT_ENCODED, o)), y;
      }
      function j(y) {
        return y.replace(/^0*(.*)/, "$1") || "0";
      }
      function Z(y, m) {
        var b = y.match(m.IPV4ADDRESS) || [], L = p(b, 2), T = L[1];
        return T ? T.split(".").map(j).join(".") : y;
      }
      function ae(y, m) {
        var b = y.match(m.IPV6ADDRESS) || [], L = p(b, 3), T = L[1], Q = L[2];
        if (T) {
          for (var H = T.toLowerCase().split("::").reverse(), se = p(H, 2), fe = se[0], we = se[1], te = we ? we.split(":").map(j) : [], ce = fe.split(":").map(j), Ee = m.IPV4ADDRESS.test(ce[ce.length - 1]), X = Ee ? 7 : 8, me = ce.length - X, xe = Array(X), pe = 0; pe < X; ++pe)
            xe[pe] = te[pe] || ce[me + pe] || "";
          Ee && (xe[X - 1] = Z(xe[X - 1], m));
          var rr = xe.reduce(function(ke, He, cr) {
            if (!He || He === "0") {
              var Ye = ke[ke.length - 1];
              Ye && Ye.index + Ye.length === cr ? Ye.length++ : ke.push({ index: cr, length: 1 });
            }
            return ke;
          }, []), Ue = rr.sort(function(ke, He) {
            return He.length - ke.length;
          })[0], Qe = void 0;
          if (Ue && Ue.length > 1) {
            var Sr = xe.slice(0, Ue.index), ur = xe.slice(Ue.index + Ue.length);
            Qe = Sr.join(":") + "::" + ur.join(":");
          } else
            Qe = xe.join(":");
          return Q && (Qe += "%" + Q), Qe;
        } else
          return y;
      }
      var re = /^(?:([^:\/?#]+):)?(?:\/\/((?:([^\/?#@]*)@)?(\[[^\/?#\]]+\]|[^\/?#:]*)(?:\:(\d*))?))?([^?#]*)(?:\?([^#]*))?(?:#((?:.|\n|\r)*))?/i, he = "".match(/(){0}/)[1] === void 0;
      function oe(y) {
        var m = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, b = {}, L = m.iri !== !1 ? u : c;
        m.reference === "suffix" && (y = (m.scheme ? m.scheme + ":" : "") + "//" + y);
        var T = y.match(re);
        if (T) {
          he ? (b.scheme = T[1], b.userinfo = T[3], b.host = T[4], b.port = parseInt(T[5], 10), b.path = T[6] || "", b.query = T[7], b.fragment = T[8], isNaN(b.port) && (b.port = T[5])) : (b.scheme = T[1] || void 0, b.userinfo = y.indexOf("@") !== -1 ? T[3] : void 0, b.host = y.indexOf("//") !== -1 ? T[4] : void 0, b.port = parseInt(T[5], 10), b.path = T[6] || "", b.query = y.indexOf("?") !== -1 ? T[7] : void 0, b.fragment = y.indexOf("#") !== -1 ? T[8] : void 0, isNaN(b.port) && (b.port = y.match(/\/\/(?:.|\n)*\:(?:\/|\?|\#|$)/) ? T[4] : void 0)), b.host && (b.host = ae(Z(b.host, L), L)), b.scheme === void 0 && b.userinfo === void 0 && b.host === void 0 && b.port === void 0 && !b.path && b.query === void 0 ? b.reference = "same-document" : b.scheme === void 0 ? b.reference = "relative" : b.fragment === void 0 ? b.reference = "absolute" : b.reference = "uri", m.reference && m.reference !== "suffix" && m.reference !== b.reference && (b.error = b.error || "URI is not a " + m.reference + " reference.");
          var Q = N[(m.scheme || b.scheme || "").toLowerCase()];
          if (!m.unicodeSupport && (!Q || !Q.unicodeSupport)) {
            if (b.host && (m.domainHost || Q && Q.domainHost))
              try {
                b.host = F.toASCII(b.host.replace(L.PCT_ENCODED, W).toLowerCase());
              } catch (H) {
                b.error = b.error || "Host's domain name can not be converted to ASCII via punycode: " + H;
              }
            B(b, c);
          } else
            B(b, L);
          Q && Q.parse && Q.parse(b, m);
        } else
          b.error = b.error || "URI can not be parsed.";
        return b;
      }
      function le(y, m) {
        var b = m.iri !== !1 ? u : c, L = [];
        return y.userinfo !== void 0 && (L.push(y.userinfo), L.push("@")), y.host !== void 0 && L.push(ae(Z(String(y.host), b), b).replace(b.IPV6ADDRESS, function(T, Q, H) {
          return "[" + Q + (H ? "%25" + H : "") + "]";
        })), (typeof y.port == "number" || typeof y.port == "string") && (L.push(":"), L.push(String(y.port))), L.length ? L.join("") : void 0;
      }
      var De = /^\.\.?\//, ve = /^\/\.(\/|$)/, Me = /^\/\.\.(\/|$)/, Ie = /^\/?(?:.|\n)*?(?=\/|$)/;
      function ye(y) {
        for (var m = []; y.length; )
          if (y.match(De))
            y = y.replace(De, "");
          else if (y.match(ve))
            y = y.replace(ve, "/");
          else if (y.match(Me))
            y = y.replace(Me, "/"), m.pop();
          else if (y === "." || y === "..")
            y = "";
          else {
            var b = y.match(Ie);
            if (b) {
              var L = b[0];
              y = y.slice(L.length), m.push(L);
            } else
              throw new Error("Unexpected dot segment condition");
          }
        return m.join("");
      }
      function Pe(y) {
        var m = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, b = m.iri ? u : c, L = [], T = N[(m.scheme || y.scheme || "").toLowerCase()];
        if (T && T.serialize && T.serialize(y, m), y.host && !b.IPV6ADDRESS.test(y.host)) {
          if (m.domainHost || T && T.domainHost)
            try {
              y.host = m.iri ? F.toUnicode(y.host) : F.toASCII(y.host.replace(b.PCT_ENCODED, W).toLowerCase());
            } catch (se) {
              y.error = y.error || "Host's domain name can not be converted to " + (m.iri ? "Unicode" : "ASCII") + " via punycode: " + se;
            }
        }
        B(y, b), m.reference !== "suffix" && y.scheme && (L.push(y.scheme), L.push(":"));
        var Q = le(y, m);
        if (Q !== void 0 && (m.reference !== "suffix" && L.push("//"), L.push(Q), y.path && y.path.charAt(0) !== "/" && L.push("/")), y.path !== void 0) {
          var H = y.path;
          !m.absolutePath && (!T || !T.absolutePath) && (H = ye(H)), Q === void 0 && (H = H.replace(/^\/\//, "/%2F")), L.push(H);
        }
        return y.query !== void 0 && (L.push("?"), L.push(y.query)), y.fragment !== void 0 && (L.push("#"), L.push(y.fragment)), L.join("");
      }
      function _e(y, m) {
        var b = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, L = arguments[3], T = {};
        return L || (y = oe(Pe(y, b), b), m = oe(Pe(m, b), b)), b = b || {}, !b.tolerant && m.scheme ? (T.scheme = m.scheme, T.userinfo = m.userinfo, T.host = m.host, T.port = m.port, T.path = ye(m.path || ""), T.query = m.query) : (m.userinfo !== void 0 || m.host !== void 0 || m.port !== void 0 ? (T.userinfo = m.userinfo, T.host = m.host, T.port = m.port, T.path = ye(m.path || ""), T.query = m.query) : (m.path ? (m.path.charAt(0) === "/" ? T.path = ye(m.path) : ((y.userinfo !== void 0 || y.host !== void 0 || y.port !== void 0) && !y.path ? T.path = "/" + m.path : y.path ? T.path = y.path.slice(0, y.path.lastIndexOf("/") + 1) + m.path : T.path = m.path, T.path = ye(T.path)), T.query = m.query) : (T.path = y.path, m.query !== void 0 ? T.query = m.query : T.query = y.query), T.userinfo = y.userinfo, T.host = y.host, T.port = y.port), T.scheme = y.scheme), T.fragment = m.fragment, T;
      }
      function zr(y, m, b) {
        var L = f({ scheme: "null" }, b);
        return Pe(_e(oe(y, L), oe(m, L), L, !0), L);
      }
      function ca(y, m) {
        return typeof y == "string" ? y = Pe(oe(y, m), m) : s(y) === "object" && (y = oe(Pe(y, m), m)), y;
      }
      function fa(y, m, b) {
        return typeof y == "string" ? y = Pe(oe(y, b), b) : s(y) === "object" && (y = Pe(y, b)), typeof m == "string" ? m = Pe(oe(m, b), b) : s(m) === "object" && (m = Pe(m, b)), y === m;
      }
      function Fs(y, m) {
        return y && y.toString().replace(!m || !m.iri ? c.ESCAPE : u.ESCAPE, V);
      }
      function Xe(y, m) {
        return y && y.toString().replace(!m || !m.iri ? c.PCT_ENCODED : u.PCT_ENCODED, W);
      }
      var Ar = {
        scheme: "http",
        domainHost: !0,
        parse: function(m, b) {
          return m.host || (m.error = m.error || "HTTP URIs must have a host."), m;
        },
        serialize: function(m, b) {
          var L = String(m.scheme).toLowerCase() === "https";
          return (m.port === (L ? 443 : 80) || m.port === "") && (m.port = void 0), m.path || (m.path = "/"), m;
        }
      }, wt = {
        scheme: "https",
        domainHost: Ar.domainHost,
        parse: Ar.parse,
        serialize: Ar.serialize
      };
      function Et(y) {
        return typeof y.secure == "boolean" ? y.secure : String(y.scheme).toLowerCase() === "wss";
      }
      var Dr = {
        scheme: "ws",
        domainHost: !0,
        parse: function(m, b) {
          var L = m;
          return L.secure = Et(L), L.resourceName = (L.path || "/") + (L.query ? "?" + L.query : ""), L.path = void 0, L.query = void 0, L;
        },
        serialize: function(m, b) {
          if ((m.port === (Et(m) ? 443 : 80) || m.port === "") && (m.port = void 0), typeof m.secure == "boolean" && (m.scheme = m.secure ? "wss" : "ws", m.secure = void 0), m.resourceName) {
            var L = m.resourceName.split("?"), T = p(L, 2), Q = T[0], H = T[1];
            m.path = Q && Q !== "/" ? Q : void 0, m.query = H, m.resourceName = void 0;
          }
          return m.fragment = void 0, m;
        }
      }, xt = {
        scheme: "wss",
        domainHost: Dr.domainHost,
        parse: Dr.parse,
        serialize: Dr.serialize
      }, Cs = {}, Ft = "[A-Za-z0-9\\-\\.\\_\\~\\xA0-\\u200D\\u2010-\\u2029\\u202F-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF]", ze = "[0-9A-Fa-f]", As = r(r("%[EFef]" + ze + "%" + ze + ze + "%" + ze + ze) + "|" + r("%[89A-Fa-f]" + ze + "%" + ze + ze) + "|" + r("%" + ze + ze)), Ds = "[A-Za-z0-9\\!\\$\\%\\'\\*\\+\\-\\^\\_\\`\\{\\|\\}\\~]", Ts = "[\\!\\$\\%\\'\\(\\)\\*\\+\\,\\-\\.0-9\\<\\>A-Z\\x5E-\\x7E]", Ls = i(Ts, '[\\"\\\\]'), Is = "[\\!\\$\\'\\(\\)\\*\\+\\,\\;\\:\\@]", Rs = new RegExp(Ft, "g"), yr = new RegExp(As, "g"), $s = new RegExp(i("[^]", Ds, "[\\.]", '[\\"]', Ls), "g"), Ct = new RegExp(i("[^]", Ft, Is), "g"), Os = Ct;
      function da(y) {
        var m = W(y);
        return m.match(Rs) ? m : y;
      }
      var At = {
        scheme: "mailto",
        parse: function(m, b) {
          var L = m, T = L.to = L.path ? L.path.split(",") : [];
          if (L.path = void 0, L.query) {
            for (var Q = !1, H = {}, se = L.query.split("&"), fe = 0, we = se.length; fe < we; ++fe) {
              var te = se[fe].split("=");
              switch (te[0]) {
                case "to":
                  for (var ce = te[1].split(","), Ee = 0, X = ce.length; Ee < X; ++Ee)
                    T.push(ce[Ee]);
                  break;
                case "subject":
                  L.subject = Xe(te[1], b);
                  break;
                case "body":
                  L.body = Xe(te[1], b);
                  break;
                default:
                  Q = !0, H[Xe(te[0], b)] = Xe(te[1], b);
                  break;
              }
            }
            Q && (L.headers = H);
          }
          L.query = void 0;
          for (var me = 0, xe = T.length; me < xe; ++me) {
            var pe = T[me].split("@");
            if (pe[0] = Xe(pe[0]), b.unicodeSupport)
              pe[1] = Xe(pe[1], b).toLowerCase();
            else
              try {
                pe[1] = F.toASCII(Xe(pe[1], b).toLowerCase());
              } catch (rr) {
                L.error = L.error || "Email address's domain name can not be converted to ASCII via punycode: " + rr;
              }
            T[me] = pe.join("@");
          }
          return L;
        },
        serialize: function(m, b) {
          var L = m, T = n(m.to);
          if (T) {
            for (var Q = 0, H = T.length; Q < H; ++Q) {
              var se = String(T[Q]), fe = se.lastIndexOf("@"), we = se.slice(0, fe).replace(yr, da).replace(yr, o).replace($s, V), te = se.slice(fe + 1);
              try {
                te = b.iri ? F.toUnicode(te) : F.toASCII(Xe(te, b).toLowerCase());
              } catch (me) {
                L.error = L.error || "Email address's domain name can not be converted to " + (b.iri ? "Unicode" : "ASCII") + " via punycode: " + me;
              }
              T[Q] = we + "@" + te;
            }
            L.path = T.join(",");
          }
          var ce = m.headers = m.headers || {};
          m.subject && (ce.subject = m.subject), m.body && (ce.body = m.body);
          var Ee = [];
          for (var X in ce)
            ce[X] !== Cs[X] && Ee.push(X.replace(yr, da).replace(yr, o).replace(Ct, V) + "=" + ce[X].replace(yr, da).replace(yr, o).replace(Os, V));
          return Ee.length && (L.query = Ee.join("&")), L;
        }
      }, _s = /^([^\:]+)\:(.*)/, Dt = {
        scheme: "urn",
        parse: function(m, b) {
          var L = m.path && m.path.match(_s), T = m;
          if (L) {
            var Q = b.scheme || T.scheme || "urn", H = L[1].toLowerCase(), se = L[2], fe = Q + ":" + (b.nid || H), we = N[fe];
            T.nid = H, T.nss = se, T.path = void 0, we && (T = we.parse(T, b));
          } else
            T.error = T.error || "URN can not be parsed.";
          return T;
        },
        serialize: function(m, b) {
          var L = b.scheme || m.scheme || "urn", T = m.nid, Q = L + ":" + (b.nid || T), H = N[Q];
          H && (m = H.serialize(m, b));
          var se = m, fe = m.nss;
          return se.path = (T || b.nid) + ":" + fe, se;
        }
      }, Ns = /^[0-9A-Fa-f]{8}(?:\-[0-9A-Fa-f]{4}){3}\-[0-9A-Fa-f]{12}$/, Tt = {
        scheme: "urn:uuid",
        parse: function(m, b) {
          var L = m;
          return L.uuid = L.nss, L.nss = void 0, !b.tolerant && (!L.uuid || !L.uuid.match(Ns)) && (L.error = L.error || "UUID is not valid."), L;
        },
        serialize: function(m, b) {
          var L = m;
          return L.nss = (m.uuid || "").toLowerCase(), L;
        }
      };
      N[Ar.scheme] = Ar, N[wt.scheme] = wt, N[Dr.scheme] = Dr, N[xt.scheme] = xt, N[At.scheme] = At, N[Dt.scheme] = Dt, N[Tt.scheme] = Tt, t.SCHEMES = N, t.pctEncChar = V, t.pctDecChars = W, t.parse = oe, t.removeDotSegments = ye, t.serialize = Pe, t.resolveComponents = _e, t.resolve = zr, t.normalize = ca, t.equal = fa, t.escapeComponent = Fs, t.unescapeComponent = Xe, Object.defineProperty(t, "__esModule", { value: !0 });
    });
  }(Rr, Rr.exports)), Rr.exports;
}
var va, Ht;
function St() {
  return Ht || (Ht = 1, va = function a(e, t) {
    if (e === t) return !0;
    if (e && t && typeof e == "object" && typeof t == "object") {
      if (e.constructor !== t.constructor) return !1;
      var i, r, s;
      if (Array.isArray(e)) {
        if (i = e.length, i != t.length) return !1;
        for (r = i; r-- !== 0; )
          if (!a(e[r], t[r])) return !1;
        return !0;
      }
      if (e.constructor === RegExp) return e.source === t.source && e.flags === t.flags;
      if (e.valueOf !== Object.prototype.valueOf) return e.valueOf() === t.valueOf();
      if (e.toString !== Object.prototype.toString) return e.toString() === t.toString();
      if (s = Object.keys(e), i = s.length, i !== Object.keys(t).length) return !1;
      for (r = i; r-- !== 0; )
        if (!Object.prototype.hasOwnProperty.call(t, s[r])) return !1;
      for (r = i; r-- !== 0; ) {
        var o = s[r];
        if (!a(e[o], t[o])) return !1;
      }
      return !0;
    }
    return e !== e && t !== t;
  }), va;
}
var ga, Gt;
function Dl() {
  return Gt || (Gt = 1, ga = function(e) {
    for (var t = 0, i = e.length, r = 0, s; r < i; )
      t++, s = e.charCodeAt(r++), s >= 55296 && s <= 56319 && r < i && (s = e.charCodeAt(r), (s & 64512) == 56320 && r++);
    return t;
  }), ga;
}
var ya, Wt;
function Cr() {
  if (Wt) return ya;
  Wt = 1, ya = {
    copy: a,
    checkDataType: e,
    checkDataTypes: t,
    coerceToTypes: r,
    toHash: s,
    getProperty: f,
    escapeQuotes: d,
    equal: St(),
    ucs2length: Dl(),
    varOccurences: c,
    varReplace: u,
    schemaHasRules: p,
    schemaHasRulesExcept: l,
    schemaUnknownRules: h,
    toQuotedString: g,
    getPathExpr: v,
    getPath: S,
    getData: P,
    unescapeFragment: D,
    unescapeJsonPointer: O,
    escapeFragment: I,
    escapeJsonPointer: R
  };
  function a(w, x) {
    x = x || {};
    for (var _ in w) x[_] = w[_];
    return x;
  }
  function e(w, x, _, k) {
    var q = k ? " !== " : " === ", z = k ? " || " : " && ", Y = k ? "!" : "", G = k ? "" : "!";
    switch (w) {
      case "null":
        return x + q + "null";
      case "array":
        return Y + "Array.isArray(" + x + ")";
      case "object":
        return "(" + Y + x + z + "typeof " + x + q + '"object"' + z + G + "Array.isArray(" + x + "))";
      case "integer":
        return "(typeof " + x + q + '"number"' + z + G + "(" + x + " % 1)" + z + x + q + x + (_ ? z + Y + "isFinite(" + x + ")" : "") + ")";
      case "number":
        return "(typeof " + x + q + '"' + w + '"' + (_ ? z + Y + "isFinite(" + x + ")" : "") + ")";
      default:
        return "typeof " + x + q + '"' + w + '"';
    }
  }
  function t(w, x, _) {
    switch (w.length) {
      case 1:
        return e(w[0], x, _, !0);
      default:
        var k = "", q = s(w);
        q.array && q.object && (k = q.null ? "(" : "(!" + x + " || ", k += "typeof " + x + ' !== "object")', delete q.null, delete q.array, delete q.object), q.number && delete q.integer;
        for (var z in q)
          k += (k ? " && " : "") + e(z, x, _, !0);
        return k;
    }
  }
  var i = s(["string", "number", "integer", "boolean", "null"]);
  function r(w, x) {
    if (Array.isArray(x)) {
      for (var _ = [], k = 0; k < x.length; k++) {
        var q = x[k];
        (i[q] || w === "array" && q === "array") && (_[_.length] = q);
      }
      if (_.length) return _;
    } else {
      if (i[x])
        return [x];
      if (w === "array" && x === "array")
        return ["array"];
    }
  }
  function s(w) {
    for (var x = {}, _ = 0; _ < w.length; _++) x[w[_]] = !0;
    return x;
  }
  var o = /^[a-z$_][a-z$_0-9]*$/i, n = /'|\\/g;
  function f(w) {
    return typeof w == "number" ? "[" + w + "]" : o.test(w) ? "." + w : "['" + d(w) + "']";
  }
  function d(w) {
    return w.replace(n, "\\$&").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/\f/g, "\\f").replace(/\t/g, "\\t");
  }
  function c(w, x) {
    x += "[^0-9]";
    var _ = w.match(new RegExp(x, "g"));
    return _ ? _.length : 0;
  }
  function u(w, x, _) {
    return x += "([^0-9])", _ = _.replace(/\$/g, "$$$$"), w.replace(new RegExp(x, "g"), _ + "$1");
  }
  function p(w, x) {
    if (typeof w == "boolean") return !w;
    for (var _ in w) if (x[_]) return !0;
  }
  function l(w, x, _) {
    if (typeof w == "boolean") return !w && _ != "not";
    for (var k in w) if (k != _ && x[k]) return !0;
  }
  function h(w, x) {
    if (typeof w != "boolean") {
      for (var _ in w) if (!x[_]) return _;
    }
  }
  function g(w) {
    return "'" + d(w) + "'";
  }
  function v(w, x, _, k) {
    var q = _ ? "'/' + " + x + (k ? "" : ".replace(/~/g, '~0').replace(/\\//g, '~1')") : k ? "'[' + " + x + " + ']'" : "'[\\'' + " + x + " + '\\']'";
    return E(w, q);
  }
  function S(w, x, _) {
    var k = g(_ ? "/" + R(x) : f(x));
    return E(w, k);
  }
  var A = /^\/(?:[^~]|~0|~1)*$/, C = /^([0-9]+)(#|\/(?:[^~]|~0|~1)*)?$/;
  function P(w, x, _) {
    var k, q, z, Y;
    if (w === "") return "rootData";
    if (w[0] == "/") {
      if (!A.test(w)) throw new Error("Invalid JSON-pointer: " + w);
      q = w, z = "rootData";
    } else {
      if (Y = w.match(C), !Y) throw new Error("Invalid JSON-pointer: " + w);
      if (k = +Y[1], q = Y[2], q == "#") {
        if (k >= x) throw new Error("Cannot access property/index " + k + " levels up, current level is " + x);
        return _[x - k];
      }
      if (k > x) throw new Error("Cannot access data " + k + " levels up, current level is " + x);
      if (z = "data" + (x - k || ""), !q) return z;
    }
    for (var G = z, ee = q.split("/"), K = 0; K < ee.length; K++) {
      var J = ee[K];
      J && (z += f(O(J)), G += " && " + z);
    }
    return G;
  }
  function E(w, x) {
    return w == '""' ? x : (w + " + " + x).replace(/([^\\])' \+ '/g, "$1");
  }
  function D(w) {
    return O(decodeURIComponent(w));
  }
  function I(w) {
    return encodeURIComponent(R(w));
  }
  function R(w) {
    return w.replace(/~/g, "~0").replace(/\//g, "~1");
  }
  function O(w) {
    return w.replace(/~1/g, "/").replace(/~0/g, "~");
  }
  return ya;
}
var Sa, Kt;
function bs() {
  if (Kt) return Sa;
  Kt = 1;
  var a = Cr();
  Sa = e;
  function e(t) {
    a.copy(t, this);
  }
  return Sa;
}
var ba = { exports: {} }, Jt;
function Tl() {
  if (Jt) return ba.exports;
  Jt = 1;
  var a = ba.exports = function(i, r, s) {
    typeof r == "function" && (s = r, r = {}), s = r.cb || s;
    var o = typeof s == "function" ? s : s.pre || function() {
    }, n = s.post || function() {
    };
    e(r, o, n, i, "", i);
  };
  a.keywords = {
    additionalItems: !0,
    items: !0,
    contains: !0,
    additionalProperties: !0,
    propertyNames: !0,
    not: !0
  }, a.arrayKeywords = {
    items: !0,
    allOf: !0,
    anyOf: !0,
    oneOf: !0
  }, a.propsKeywords = {
    definitions: !0,
    properties: !0,
    patternProperties: !0,
    dependencies: !0
  }, a.skipKeywords = {
    default: !0,
    enum: !0,
    const: !0,
    required: !0,
    maximum: !0,
    minimum: !0,
    exclusiveMaximum: !0,
    exclusiveMinimum: !0,
    multipleOf: !0,
    maxLength: !0,
    minLength: !0,
    pattern: !0,
    format: !0,
    maxItems: !0,
    minItems: !0,
    uniqueItems: !0,
    maxProperties: !0,
    minProperties: !0
  };
  function e(i, r, s, o, n, f, d, c, u, p) {
    if (o && typeof o == "object" && !Array.isArray(o)) {
      r(o, n, f, d, c, u, p);
      for (var l in o) {
        var h = o[l];
        if (Array.isArray(h)) {
          if (l in a.arrayKeywords)
            for (var g = 0; g < h.length; g++)
              e(i, r, s, h[g], n + "/" + l + "/" + g, f, n, l, o, g);
        } else if (l in a.propsKeywords) {
          if (h && typeof h == "object")
            for (var v in h)
              e(i, r, s, h[v], n + "/" + l + "/" + t(v), f, n, l, o, v);
        } else (l in a.keywords || i.allKeys && !(l in a.skipKeywords)) && e(i, r, s, h, n + "/" + l, f, n, l, o);
      }
      s(o, n, f, d, c, u, p);
    }
  }
  function t(i) {
    return i.replace(/~/g, "~0").replace(/\//g, "~1");
  }
  return ba.exports;
}
var Pa, Xt;
function bt() {
  if (Xt) return Pa;
  Xt = 1;
  var a = Al(), e = St(), t = Cr(), i = bs(), r = Tl();
  Pa = s, s.normalizeId = S, s.fullPath = h, s.url = A, s.ids = C, s.inlineRef = u, s.schema = o;
  function s(P, E, D) {
    var I = this._refs[D];
    if (typeof I == "string")
      if (this._refs[I]) I = this._refs[I];
      else return s.call(this, P, E, I);
    if (I = I || this._schemas[D], I instanceof i)
      return u(I.schema, this._opts.inlineRefs) ? I.schema : I.validate || this._compile(I);
    var R = o.call(this, E, D), O, w, x;
    return R && (O = R.schema, E = R.root, x = R.baseId), O instanceof i ? w = O.validate || P.call(this, O.schema, E, void 0, x) : O !== void 0 && (w = u(O, this._opts.inlineRefs) ? O : P.call(this, O, E, void 0, x)), w;
  }
  function o(P, E) {
    var D = a.parse(E), I = g(D), R = h(this._getId(P.schema));
    if (Object.keys(P.schema).length === 0 || I !== R) {
      var O = S(I), w = this._refs[O];
      if (typeof w == "string")
        return n.call(this, P, w, D);
      if (w instanceof i)
        w.validate || this._compile(w), P = w;
      else if (w = this._schemas[O], w instanceof i) {
        if (w.validate || this._compile(w), O == S(E))
          return { schema: w, root: P, baseId: R };
        P = w;
      } else
        return;
      if (!P.schema) return;
      R = h(this._getId(P.schema));
    }
    return d.call(this, D, R, P.schema, P);
  }
  function n(P, E, D) {
    var I = o.call(this, P, E);
    if (I) {
      var R = I.schema, O = I.baseId;
      P = I.root;
      var w = this._getId(R);
      return w && (O = A(O, w)), d.call(this, D, O, R, P);
    }
  }
  var f = t.toHash(["properties", "patternProperties", "enum", "dependencies", "definitions"]);
  function d(P, E, D, I) {
    if (P.fragment = P.fragment || "", P.fragment.slice(0, 1) == "/") {
      for (var R = P.fragment.split("/"), O = 1; O < R.length; O++) {
        var w = R[O];
        if (w) {
          if (w = t.unescapeFragment(w), D = D[w], D === void 0) break;
          var x;
          if (!f[w] && (x = this._getId(D), x && (E = A(E, x)), D.$ref)) {
            var _ = A(E, D.$ref), k = o.call(this, I, _);
            k && (D = k.schema, I = k.root, E = k.baseId);
          }
        }
      }
      if (D !== void 0 && D !== I.schema)
        return { schema: D, root: I, baseId: E };
    }
  }
  var c = t.toHash([
    "type",
    "format",
    "pattern",
    "maxLength",
    "minLength",
    "maxProperties",
    "minProperties",
    "maxItems",
    "minItems",
    "maximum",
    "minimum",
    "uniqueItems",
    "multipleOf",
    "required",
    "enum"
  ]);
  function u(P, E) {
    if (E === !1) return !1;
    if (E === void 0 || E === !0) return p(P);
    if (E) return l(P) <= E;
  }
  function p(P) {
    var E;
    if (Array.isArray(P)) {
      for (var D = 0; D < P.length; D++)
        if (E = P[D], typeof E == "object" && !p(E)) return !1;
    } else
      for (var I in P)
        if (I == "$ref" || (E = P[I], typeof E == "object" && !p(E))) return !1;
    return !0;
  }
  function l(P) {
    var E = 0, D;
    if (Array.isArray(P)) {
      for (var I = 0; I < P.length; I++)
        if (D = P[I], typeof D == "object" && (E += l(D)), E == 1 / 0) return 1 / 0;
    } else
      for (var R in P) {
        if (R == "$ref") return 1 / 0;
        if (c[R])
          E++;
        else if (D = P[R], typeof D == "object" && (E += l(D) + 1), E == 1 / 0) return 1 / 0;
      }
    return E;
  }
  function h(P, E) {
    E !== !1 && (P = S(P));
    var D = a.parse(P);
    return g(D);
  }
  function g(P) {
    return a.serialize(P).split("#")[0] + "#";
  }
  var v = /#\/?$/;
  function S(P) {
    return P ? P.replace(v, "") : "";
  }
  function A(P, E) {
    return E = S(E), a.resolve(P, E);
  }
  function C(P) {
    var E = S(this._getId(P)), D = { "": E }, I = { "": h(E, !1) }, R = {}, O = this;
    return r(P, { allKeys: !0 }, function(w, x, _, k, q, z, Y) {
      if (x !== "") {
        var G = O._getId(w), ee = D[k], K = I[k] + "/" + q;
        if (Y !== void 0 && (K += "/" + (typeof Y == "number" ? Y : t.escapeFragment(Y))), typeof G == "string") {
          G = ee = S(ee ? a.resolve(ee, G) : G);
          var J = O._refs[G];
          if (typeof J == "string" && (J = O._refs[J]), J && J.schema) {
            if (!e(w, J.schema))
              throw new Error('id "' + G + '" resolves to more than one schema');
          } else if (G != S(K))
            if (G[0] == "#") {
              if (R[G] && !e(w, R[G]))
                throw new Error('id "' + G + '" resolves to more than one schema');
              R[G] = w;
            } else
              O._refs[G] = K;
        }
        D[x] = ee, I[x] = K;
      }
    }), R;
  }
  return Pa;
}
var wa, Yt;
function Pt() {
  if (Yt) return wa;
  Yt = 1;
  var a = bt();
  wa = {
    Validation: i(e),
    MissingRef: i(t)
  };
  function e(r) {
    this.message = "validation failed", this.errors = r, this.ajv = this.validation = !0;
  }
  t.message = function(r, s) {
    return "can't resolve reference " + s + " from id " + r;
  };
  function t(r, s, o) {
    this.message = o || t.message(r, s), this.missingRef = a.url(r, s), this.missingSchema = a.normalizeId(a.fullPath(this.missingRef));
  }
  function i(r) {
    return r.prototype = Object.create(Error.prototype), r.prototype.constructor = r, r;
  }
  return wa;
}
var Ea, Zt;
function Ps() {
  return Zt || (Zt = 1, Ea = function(a, e) {
    e || (e = {}), typeof e == "function" && (e = { cmp: e });
    var t = typeof e.cycles == "boolean" ? e.cycles : !1, i = e.cmp && /* @__PURE__ */ function(s) {
      return function(o) {
        return function(n, f) {
          var d = { key: n, value: o[n] }, c = { key: f, value: o[f] };
          return s(d, c);
        };
      };
    }(e.cmp), r = [];
    return function s(o) {
      if (o && o.toJSON && typeof o.toJSON == "function" && (o = o.toJSON()), o !== void 0) {
        if (typeof o == "number") return isFinite(o) ? "" + o : "null";
        if (typeof o != "object") return JSON.stringify(o);
        var n, f;
        if (Array.isArray(o)) {
          for (f = "[", n = 0; n < o.length; n++)
            n && (f += ","), f += s(o[n]) || "null";
          return f + "]";
        }
        if (o === null) return "null";
        if (r.indexOf(o) !== -1) {
          if (t) return JSON.stringify("__cycle__");
          throw new TypeError("Converting circular structure to JSON");
        }
        var d = r.push(o) - 1, c = Object.keys(o).sort(i && i(o));
        for (f = "", n = 0; n < c.length; n++) {
          var u = c[n], p = s(o[u]);
          p && (f && (f += ","), f += JSON.stringify(u) + ":" + p);
        }
        return r.splice(d, 1), "{" + f + "}";
      }
    }(a);
  }), Ea;
}
var xa, ei;
function ws() {
  return ei || (ei = 1, xa = function(e, t, i) {
    var r = "", s = e.schema.$async === !0, o = e.util.schemaHasRulesExcept(e.schema, e.RULES.all, "$ref"), n = e.self._getId(e.schema);
    if (e.opts.strictKeywords) {
      var f = e.util.schemaUnknownRules(e.schema, e.RULES.keywords);
      if (f) {
        var d = "unknown keyword: " + f;
        if (e.opts.strictKeywords === "log") e.logger.warn(d);
        else throw new Error(d);
      }
    }
    if (e.isTop && (r += " var validate = ", s && (e.async = !0, r += "async "), r += "function(data, dataPath, parentData, parentDataProperty, rootData) { 'use strict'; ", n && (e.opts.sourceCode || e.opts.processCode) && (r += " " + ("/*# sourceURL=" + n + " */") + " ")), typeof e.schema == "boolean" || !(o || e.schema.$ref)) {
      var t = "false schema", c = e.level, u = e.dataLevel, p = e.schema[t], l = e.schemaPath + e.util.getProperty(t), h = e.errSchemaPath + "/" + t, E = !e.opts.allErrors, R, g = "data" + (u || ""), P = "valid" + c;
      if (e.schema === !1) {
        e.isTop ? E = !0 : r += " var " + P + " = false; ";
        var v = v || [];
        v.push(r), r = "", e.createErrors !== !1 ? (r += " { keyword: '" + (R || "false schema") + "' , dataPath: (dataPath || '') + " + e.errorPath + " , schemaPath: " + e.util.toQuotedString(h) + " , params: {} ", e.opts.messages !== !1 && (r += " , message: 'boolean schema is false' "), e.opts.verbose && (r += " , schema: false , parentSchema: validate.schema" + e.schemaPath + " , data: " + g + " "), r += " } ") : r += " {} ";
        var S = r;
        r = v.pop(), !e.compositeRule && E ? e.async ? r += " throw new ValidationError([" + S + "]); " : r += " validate.errors = [" + S + "]; return false; " : r += " var err = " + S + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
      } else
        e.isTop ? s ? r += " return data; " : r += " validate.errors = null; return true; " : r += " var " + P + " = true; ";
      return e.isTop && (r += " }; return validate; "), r;
    }
    if (e.isTop) {
      var A = e.isTop, c = e.level = 0, u = e.dataLevel = 0, g = "data";
      if (e.rootId = e.resolve.fullPath(e.self._getId(e.root.schema)), e.baseId = e.baseId || e.rootId, delete e.isTop, e.dataPathArr = [""], e.schema.default !== void 0 && e.opts.useDefaults && e.opts.strictDefaults) {
        var C = "default is ignored in the schema root";
        if (e.opts.strictDefaults === "log") e.logger.warn(C);
        else throw new Error(C);
      }
      r += " var vErrors = null; ", r += " var errors = 0;     ", r += " if (rootData === undefined) rootData = data; ";
    } else {
      var c = e.level, u = e.dataLevel, g = "data" + (u || "");
      if (n && (e.baseId = e.resolve.url(e.baseId, n)), s && !e.async) throw new Error("async schema in sync schema");
      r += " var errs_" + c + " = errors;";
    }
    var P = "valid" + c, E = !e.opts.allErrors, D = "", I = "", R, O = e.schema.type, w = Array.isArray(O);
    if (O && e.opts.nullable && e.schema.nullable === !0 && (w ? O.indexOf("null") == -1 && (O = O.concat("null")) : O != "null" && (O = [O, "null"], w = !0)), w && O.length == 1 && (O = O[0], w = !1), e.schema.$ref && o) {
      if (e.opts.extendRefs == "fail")
        throw new Error('$ref: validation keywords used in schema at path "' + e.errSchemaPath + '" (see option extendRefs)');
      e.opts.extendRefs !== !0 && (o = !1, e.logger.warn('$ref: keywords ignored in schema at path "' + e.errSchemaPath + '"'));
    }
    if (e.schema.$comment && e.opts.$comment && (r += " " + e.RULES.all.$comment.code(e, "$comment")), O) {
      if (e.opts.coerceTypes)
        var x = e.util.coerceToTypes(e.opts.coerceTypes, O);
      var _ = e.RULES.types[O];
      if (x || w || _ === !0 || _ && !ve(_)) {
        var l = e.schemaPath + ".type", h = e.errSchemaPath + "/type", l = e.schemaPath + ".type", h = e.errSchemaPath + "/type", k = w ? "checkDataTypes" : "checkDataType";
        if (r += " if (" + e.util[k](O, g, e.opts.strictNumbers, !0) + ") { ", x) {
          var q = "dataType" + c, z = "coerced" + c;
          r += " var " + q + " = typeof " + g + "; var " + z + " = undefined; ", e.opts.coerceTypes == "array" && (r += " if (" + q + " == 'object' && Array.isArray(" + g + ") && " + g + ".length == 1) { " + g + " = " + g + "[0]; " + q + " = typeof " + g + "; if (" + e.util.checkDataType(e.schema.type, g, e.opts.strictNumbers) + ") " + z + " = " + g + "; } "), r += " if (" + z + " !== undefined) ; ";
          var Y = x;
          if (Y)
            for (var G, ee = -1, K = Y.length - 1; ee < K; )
              G = Y[ee += 1], G == "string" ? r += " else if (" + q + " == 'number' || " + q + " == 'boolean') " + z + " = '' + " + g + "; else if (" + g + " === null) " + z + " = ''; " : G == "number" || G == "integer" ? (r += " else if (" + q + " == 'boolean' || " + g + " === null || (" + q + " == 'string' && " + g + " && " + g + " == +" + g + " ", G == "integer" && (r += " && !(" + g + " % 1)"), r += ")) " + z + " = +" + g + "; ") : G == "boolean" ? r += " else if (" + g + " === 'false' || " + g + " === 0 || " + g + " === null) " + z + " = false; else if (" + g + " === 'true' || " + g + " === 1) " + z + " = true; " : G == "null" ? r += " else if (" + g + " === '' || " + g + " === 0 || " + g + " === false) " + z + " = null; " : e.opts.coerceTypes == "array" && G == "array" && (r += " else if (" + q + " == 'string' || " + q + " == 'number' || " + q + " == 'boolean' || " + g + " == null) " + z + " = [" + g + "]; ");
          r += " else {   ";
          var v = v || [];
          v.push(r), r = "", e.createErrors !== !1 ? (r += " { keyword: '" + (R || "type") + "' , dataPath: (dataPath || '') + " + e.errorPath + " , schemaPath: " + e.util.toQuotedString(h) + " , params: { type: '", w ? r += "" + O.join(",") : r += "" + O, r += "' } ", e.opts.messages !== !1 && (r += " , message: 'should be ", w ? r += "" + O.join(",") : r += "" + O, r += "' "), e.opts.verbose && (r += " , schema: validate.schema" + l + " , parentSchema: validate.schema" + e.schemaPath + " , data: " + g + " "), r += " } ") : r += " {} ";
          var S = r;
          r = v.pop(), !e.compositeRule && E ? e.async ? r += " throw new ValidationError([" + S + "]); " : r += " validate.errors = [" + S + "]; return false; " : r += " var err = " + S + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ", r += " } if (" + z + " !== undefined) {  ";
          var J = u ? "data" + (u - 1 || "") : "parentData", Le = u ? e.dataPathArr[u] : "parentDataProperty";
          r += " " + g + " = " + z + "; ", u || (r += "if (" + J + " !== undefined)"), r += " " + J + "[" + Le + "] = " + z + "; } ";
        } else {
          var v = v || [];
          v.push(r), r = "", e.createErrors !== !1 ? (r += " { keyword: '" + (R || "type") + "' , dataPath: (dataPath || '') + " + e.errorPath + " , schemaPath: " + e.util.toQuotedString(h) + " , params: { type: '", w ? r += "" + O.join(",") : r += "" + O, r += "' } ", e.opts.messages !== !1 && (r += " , message: 'should be ", w ? r += "" + O.join(",") : r += "" + O, r += "' "), e.opts.verbose && (r += " , schema: validate.schema" + l + " , parentSchema: validate.schema" + e.schemaPath + " , data: " + g + " "), r += " } ") : r += " {} ";
          var S = r;
          r = v.pop(), !e.compositeRule && E ? e.async ? r += " throw new ValidationError([" + S + "]); " : r += " validate.errors = [" + S + "]; return false; " : r += " var err = " + S + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
        }
        r += " } ";
      }
    }
    if (e.schema.$ref && !o)
      r += " " + e.RULES.all.$ref.code(e, "$ref") + " ", E && (r += " } if (errors === ", A ? r += "0" : r += "errs_" + c, r += ") { ", I += "}");
    else {
      var Ae = e.RULES;
      if (Ae) {
        for (var _, Fe = -1, be = Ae.length - 1; Fe < be; )
          if (_ = Ae[Fe += 1], ve(_)) {
            if (_.type && (r += " if (" + e.util.checkDataType(_.type, g, e.opts.strictNumbers) + ") { "), e.opts.useDefaults) {
              if (_.type == "object" && e.schema.properties) {
                var p = e.schema.properties, Be = Object.keys(p), F = Be;
                if (F)
                  for (var N, V = -1, W = F.length - 1; V < W; ) {
                    N = F[V += 1];
                    var B = p[N];
                    if (B.default !== void 0) {
                      var j = g + e.util.getProperty(N);
                      if (e.compositeRule) {
                        if (e.opts.strictDefaults) {
                          var C = "default is ignored for: " + j;
                          if (e.opts.strictDefaults === "log") e.logger.warn(C);
                          else throw new Error(C);
                        }
                      } else
                        r += " if (" + j + " === undefined ", e.opts.useDefaults == "empty" && (r += " || " + j + " === null || " + j + " === '' "), r += " ) " + j + " = ", e.opts.useDefaults == "shared" ? r += " " + e.useDefault(B.default) + " " : r += " " + JSON.stringify(B.default) + " ", r += "; ";
                    }
                  }
              } else if (_.type == "array" && Array.isArray(e.schema.items)) {
                var Z = e.schema.items;
                if (Z) {
                  for (var B, ee = -1, ae = Z.length - 1; ee < ae; )
                    if (B = Z[ee += 1], B.default !== void 0) {
                      var j = g + "[" + ee + "]";
                      if (e.compositeRule) {
                        if (e.opts.strictDefaults) {
                          var C = "default is ignored for: " + j;
                          if (e.opts.strictDefaults === "log") e.logger.warn(C);
                          else throw new Error(C);
                        }
                      } else
                        r += " if (" + j + " === undefined ", e.opts.useDefaults == "empty" && (r += " || " + j + " === null || " + j + " === '' "), r += " ) " + j + " = ", e.opts.useDefaults == "shared" ? r += " " + e.useDefault(B.default) + " " : r += " " + JSON.stringify(B.default) + " ", r += "; ";
                    }
                }
              }
            }
            var re = _.rules;
            if (re) {
              for (var he, oe = -1, le = re.length - 1; oe < le; )
                if (he = re[oe += 1], Me(he)) {
                  var De = he.code(e, he.keyword, _.type);
                  De && (r += " " + De + " ", E && (D += "}"));
                }
            }
            if (E && (r += " " + D + " ", D = ""), _.type && (r += " } ", O && O === _.type && !x)) {
              r += " else { ";
              var l = e.schemaPath + ".type", h = e.errSchemaPath + "/type", v = v || [];
              v.push(r), r = "", e.createErrors !== !1 ? (r += " { keyword: '" + (R || "type") + "' , dataPath: (dataPath || '') + " + e.errorPath + " , schemaPath: " + e.util.toQuotedString(h) + " , params: { type: '", w ? r += "" + O.join(",") : r += "" + O, r += "' } ", e.opts.messages !== !1 && (r += " , message: 'should be ", w ? r += "" + O.join(",") : r += "" + O, r += "' "), e.opts.verbose && (r += " , schema: validate.schema" + l + " , parentSchema: validate.schema" + e.schemaPath + " , data: " + g + " "), r += " } ") : r += " {} ";
              var S = r;
              r = v.pop(), !e.compositeRule && E ? e.async ? r += " throw new ValidationError([" + S + "]); " : r += " validate.errors = [" + S + "]; return false; " : r += " var err = " + S + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ", r += " } ";
            }
            E && (r += " if (errors === ", A ? r += "0" : r += "errs_" + c, r += ") { ", I += "}");
          }
      }
    }
    E && (r += " " + I + " "), A ? (s ? (r += " if (errors === 0) return data;           ", r += " else throw new ValidationError(vErrors); ") : (r += " validate.errors = vErrors; ", r += " return errors === 0;       "), r += " }; return validate;") : r += " var " + P + " = errors === errs_" + c + ";";
    function ve(ye) {
      for (var Pe = ye.rules, _e = 0; _e < Pe.length; _e++)
        if (Me(Pe[_e])) return !0;
    }
    function Me(ye) {
      return e.schema[ye.keyword] !== void 0 || ye.implements && Ie(ye);
    }
    function Ie(ye) {
      for (var Pe = ye.implements, _e = 0; _e < Pe.length; _e++)
        if (e.schema[Pe[_e]] !== void 0) return !0;
    }
    return r;
  }), xa;
}
var Fa, ri;
function Ll() {
  if (ri) return Fa;
  ri = 1;
  var a = bt(), e = Cr(), t = Pt(), i = Ps(), r = ws(), s = e.ucs2length, o = St(), n = t.Validation;
  Fa = f;
  function f(S, A, C, P) {
    var E = this, D = this._opts, I = [void 0], R = {}, O = [], w = {}, x = [], _ = {}, k = [];
    A = A || { schema: S, refVal: I, refs: R };
    var q = d.call(this, S, A, P), z = this._compilations[q.index];
    if (q.compiling) return z.callValidate = J;
    var Y = this._formats, G = this.RULES;
    try {
      var ee = Le(S, A, C, P);
      z.validate = ee;
      var K = z.callValidate;
      return K && (K.schema = ee.schema, K.errors = null, K.refs = ee.refs, K.refVal = ee.refVal, K.root = ee.root, K.$async = ee.$async, D.sourceCode && (K.source = ee.source)), ee;
    } finally {
      c.call(this, S, A, P);
    }
    function J() {
      var B = z.validate, j = B.apply(this, arguments);
      return J.errors = B.errors, j;
    }
    function Le(B, j, Z, ae) {
      var re = !j || j && j.schema == B;
      if (j.schema != A.schema)
        return f.call(E, B, j, Z, ae);
      var he = B.$async === !0, oe = r({
        isTop: !0,
        schema: B,
        isRoot: re,
        baseId: ae,
        root: j,
        schemaPath: "",
        errSchemaPath: "#",
        errorPath: '""',
        MissingRefError: t.MissingRef,
        RULES: G,
        validate: r,
        util: e,
        resolve: a,
        resolveRef: Ae,
        usePattern: N,
        useDefault: V,
        useCustomRule: W,
        opts: D,
        formats: Y,
        logger: E.logger,
        self: E
      });
      oe = v(I, h) + v(O, p) + v(x, l) + v(k, g) + oe, D.processCode && (oe = D.processCode(oe, B));
      var le;
      try {
        var De = new Function(
          "self",
          "RULES",
          "formats",
          "root",
          "refVal",
          "defaults",
          "customRules",
          "equal",
          "ucs2length",
          "ValidationError",
          oe
        );
        le = De(
          E,
          G,
          Y,
          A,
          I,
          x,
          k,
          o,
          s,
          n
        ), I[0] = le;
      } catch (ve) {
        throw E.logger.error("Error compiling schema, function code:", oe), ve;
      }
      return le.schema = B, le.errors = null, le.refs = R, le.refVal = I, le.root = re ? le : j, he && (le.$async = !0), D.sourceCode === !0 && (le.source = {
        code: oe,
        patterns: O,
        defaults: x
      }), le;
    }
    function Ae(B, j, Z) {
      j = a.url(B, j);
      var ae = R[j], re, he;
      if (ae !== void 0)
        return re = I[ae], he = "refVal[" + ae + "]", F(re, he);
      if (!Z && A.refs) {
        var oe = A.refs[j];
        if (oe !== void 0)
          return re = A.refVal[oe], he = Fe(j, re), F(re, he);
      }
      he = Fe(j);
      var le = a.call(E, Le, A, j);
      if (le === void 0) {
        var De = C && C[j];
        De && (le = a.inlineRef(De, D.inlineRefs) ? De : f.call(E, De, A, C, B));
      }
      if (le === void 0)
        be(j);
      else
        return Be(j, le), F(le, he);
    }
    function Fe(B, j) {
      var Z = I.length;
      return I[Z] = j, R[B] = Z, "refVal" + Z;
    }
    function be(B) {
      delete R[B];
    }
    function Be(B, j) {
      var Z = R[B];
      I[Z] = j;
    }
    function F(B, j) {
      return typeof B == "object" || typeof B == "boolean" ? { code: j, schema: B, inline: !0 } : { code: j, $async: B && !!B.$async };
    }
    function N(B) {
      var j = w[B];
      return j === void 0 && (j = w[B] = O.length, O[j] = B), "pattern" + j;
    }
    function V(B) {
      switch (typeof B) {
        case "boolean":
        case "number":
          return "" + B;
        case "string":
          return e.toQuotedString(B);
        case "object":
          if (B === null) return "null";
          var j = i(B), Z = _[j];
          return Z === void 0 && (Z = _[j] = x.length, x[Z] = B), "default" + Z;
      }
    }
    function W(B, j, Z, ae) {
      if (E._opts.validateSchema !== !1) {
        var re = B.definition.dependencies;
        if (re && !re.every(function(Pe) {
          return Object.prototype.hasOwnProperty.call(Z, Pe);
        }))
          throw new Error("parent schema must have all required keywords: " + re.join(","));
        var he = B.definition.validateSchema;
        if (he) {
          var oe = he(j);
          if (!oe) {
            var le = "keyword schema is invalid: " + E.errorsText(he.errors);
            if (E._opts.validateSchema == "log") E.logger.error(le);
            else throw new Error(le);
          }
        }
      }
      var De = B.definition.compile, ve = B.definition.inline, Me = B.definition.macro, Ie;
      if (De)
        Ie = De.call(E, j, Z, ae);
      else if (Me)
        Ie = Me.call(E, j, Z, ae), D.validateSchema !== !1 && E.validateSchema(Ie, !0);
      else if (ve)
        Ie = ve.call(E, ae, B.keyword, j, Z);
      else if (Ie = B.definition.validate, !Ie) return;
      if (Ie === void 0)
        throw new Error('custom keyword "' + B.keyword + '"failed to compile');
      var ye = k.length;
      return k[ye] = Ie, {
        code: "customRule" + ye,
        validate: Ie
      };
    }
  }
  function d(S, A, C) {
    var P = u.call(this, S, A, C);
    return P >= 0 ? { index: P, compiling: !0 } : (P = this._compilations.length, this._compilations[P] = {
      schema: S,
      root: A,
      baseId: C
    }, { index: P, compiling: !1 });
  }
  function c(S, A, C) {
    var P = u.call(this, S, A, C);
    P >= 0 && this._compilations.splice(P, 1);
  }
  function u(S, A, C) {
    for (var P = 0; P < this._compilations.length; P++) {
      var E = this._compilations[P];
      if (E.schema == S && E.root == A && E.baseId == C) return P;
    }
    return -1;
  }
  function p(S, A) {
    return "var pattern" + S + " = new RegExp(" + e.toQuotedString(A[S]) + ");";
  }
  function l(S) {
    return "var default" + S + " = defaults[" + S + "];";
  }
  function h(S, A) {
    return A[S] === void 0 ? "" : "var refVal" + S + " = refVal[" + S + "];";
  }
  function g(S) {
    return "var customRule" + S + " = customRules[" + S + "];";
  }
  function v(S, A) {
    if (!S.length) return "";
    for (var C = "", P = 0; P < S.length; P++)
      C += A(P, S);
    return C;
  }
  return Fa;
}
var Ca = { exports: {} }, ai;
function Il() {
  if (ai) return Ca.exports;
  ai = 1;
  var a = Ca.exports = function() {
    this._cache = {};
  };
  return a.prototype.put = function(t, i) {
    this._cache[t] = i;
  }, a.prototype.get = function(t) {
    return this._cache[t];
  }, a.prototype.del = function(t) {
    delete this._cache[t];
  }, a.prototype.clear = function() {
    this._cache = {};
  }, Ca.exports;
}
var Aa, ti;
function Rl() {
  if (ti) return Aa;
  ti = 1;
  var a = Cr(), e = /^(\d\d\d\d)-(\d\d)-(\d\d)$/, t = [0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31], i = /^(\d\d):(\d\d):(\d\d)(\.\d+)?(z|[+-]\d\d(?::?\d\d)?)?$/i, r = /^(?=.{1,253}\.?$)[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\.[a-z0-9](?:[-0-9a-z]{0,61}[0-9a-z])?)*\.?$/i, s = /^(?:[a-z][a-z0-9+\-.]*:)(?:\/?\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\.[a-z0-9\-._~!$&'()*+,;=:]+)\]|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)|(?:[a-z0-9\-._~!$&'()*+,;=]|%[0-9a-f]{2})*)(?::\d*)?(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*|\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)(?:\?(?:[a-z0-9\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i, o = /^(?:[a-z][a-z0-9+\-.]*:)?(?:\/?\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\.[a-z0-9\-._~!$&'()*+,;=:]+)\]|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)|(?:[a-z0-9\-._~!$&'"()*+,;=]|%[0-9a-f]{2})*)(?::\d*)?(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*|\/(?:(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*)?(?:\?(?:[a-z0-9\-._~!$&'"()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\-._~!$&'"()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i, n = /^(?:(?:[^\x00-\x20"'<>%\\^`{|}]|%[0-9a-f]{2})|\{[+#./;?&=,!@|]?(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\*)?(?:,(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\*)?)*\})*$/i, f = /^(?:(?:http[s\u017F]?|ftp):\/\/)(?:(?:[\0-\x08\x0E-\x1F!-\x9F\xA1-\u167F\u1681-\u1FFF\u200B-\u2027\u202A-\u202E\u2030-\u205E\u2060-\u2FFF\u3001-\uD7FF\uE000-\uFEFE\uFF00-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])+(?::(?:[\0-\x08\x0E-\x1F!-\x9F\xA1-\u167F\u1681-\u1FFF\u200B-\u2027\u202A-\u202E\u2030-\u205E\u2060-\u2FFF\u3001-\uD7FF\uE000-\uFEFE\uFF00-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])*)?@)?(?:(?!10(?:\.[0-9]{1,3}){3})(?!127(?:\.[0-9]{1,3}){3})(?!169\.254(?:\.[0-9]{1,3}){2})(?!192\.168(?:\.[0-9]{1,3}){2})(?!172\.(?:1[6-9]|2[0-9]|3[01])(?:\.[0-9]{1,3}){2})(?:[1-9][0-9]?|1[0-9][0-9]|2[01][0-9]|22[0-3])(?:\.(?:1?[0-9]{1,2}|2[0-4][0-9]|25[0-5])){2}(?:\.(?:[1-9][0-9]?|1[0-9][0-9]|2[0-4][0-9]|25[0-4]))|(?:(?:(?:[0-9a-z\xA1-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])+-)*(?:[0-9a-z\xA1-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])+)(?:\.(?:(?:[0-9a-z\xA1-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])+-)*(?:[0-9a-z\xA1-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])+)*(?:\.(?:(?:[a-z\xA1-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]){2,})))(?::[0-9]{2,5})?(?:\/(?:[\0-\x08\x0E-\x1F!-\x9F\xA1-\u167F\u1681-\u1FFF\u200B-\u2027\u202A-\u202E\u2030-\u205E\u2060-\u2FFF\u3001-\uD7FF\uE000-\uFEFE\uFF00-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])*)?$/i, d = /^(?:urn:uuid:)?[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12}$/i, c = /^(?:\/(?:[^~/]|~0|~1)*)*$/, u = /^#(?:\/(?:[a-z0-9_\-.!$&'()*+,;:=@]|%[0-9a-f]{2}|~0|~1)*)*$/i, p = /^(?:0|[1-9][0-9]*)(?:#|(?:\/(?:[^~/]|~0|~1)*)*)$/;
  Aa = l;
  function l(I) {
    return I = I == "full" ? "full" : "fast", a.copy(l[I]);
  }
  l.fast = {
    // date: http://tools.ietf.org/html/rfc3339#section-5.6
    date: /^\d\d\d\d-[0-1]\d-[0-3]\d$/,
    // date-time: http://tools.ietf.org/html/rfc3339#section-5.6
    time: /^(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)?$/i,
    "date-time": /^\d\d\d\d-[0-1]\d-[0-3]\d[t\s](?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)$/i,
    // uri: https://github.com/mafintosh/is-my-json-valid/blob/master/formats.js
    uri: /^(?:[a-z][a-z0-9+\-.]*:)(?:\/?\/)?[^\s]*$/i,
    "uri-reference": /^(?:(?:[a-z][a-z0-9+\-.]*:)?\/?\/)?(?:[^\\\s#][^\s#]*)?(?:#[^\\\s]*)?$/i,
    "uri-template": n,
    url: f,
    // email (sources from jsen validator):
    // http://stackoverflow.com/questions/201323/using-a-regular-expression-to-validate-an-email-address#answer-8829363
    // http://www.w3.org/TR/html5/forms.html#valid-e-mail-address (search for 'willful violation')
    email: /^[a-z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\.[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?)*$/i,
    hostname: r,
    // optimized https://www.safaribooksonline.com/library/view/regular-expressions-cookbook/9780596802837/ch07s16.html
    ipv4: /^(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)$/,
    // optimized http://stackoverflow.com/questions/53497/regular-expression-that-matches-valid-ipv6-addresses
    ipv6: /^\s*(?:(?:(?:[0-9a-f]{1,4}:){7}(?:[0-9a-f]{1,4}|:))|(?:(?:[0-9a-f]{1,4}:){6}(?::[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(?:(?:[0-9a-f]{1,4}:){5}(?:(?:(?::[0-9a-f]{1,4}){1,2})|:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(?:(?:[0-9a-f]{1,4}:){4}(?:(?:(?::[0-9a-f]{1,4}){1,3})|(?:(?::[0-9a-f]{1,4})?:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){3}(?:(?:(?::[0-9a-f]{1,4}){1,4})|(?:(?::[0-9a-f]{1,4}){0,2}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){2}(?:(?:(?::[0-9a-f]{1,4}){1,5})|(?:(?::[0-9a-f]{1,4}){0,3}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){1}(?:(?:(?::[0-9a-f]{1,4}){1,6})|(?:(?::[0-9a-f]{1,4}){0,4}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?::(?:(?:(?::[0-9a-f]{1,4}){1,7})|(?:(?::[0-9a-f]{1,4}){0,5}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:)))(?:%.+)?\s*$/i,
    regex: D,
    // uuid: http://tools.ietf.org/html/rfc4122
    uuid: d,
    // JSON-pointer: https://tools.ietf.org/html/rfc6901
    // uri fragment: https://tools.ietf.org/html/rfc3986#appendix-A
    "json-pointer": c,
    "json-pointer-uri-fragment": u,
    // relative JSON-pointer: http://tools.ietf.org/html/draft-luff-relative-json-pointer-00
    "relative-json-pointer": p
  }, l.full = {
    date: g,
    time: v,
    "date-time": A,
    uri: P,
    "uri-reference": o,
    "uri-template": n,
    url: f,
    email: /^[a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\.[a-z0-9!#$%&'*+/=?^_`{|}~-]+)*@(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?$/i,
    hostname: r,
    ipv4: /^(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)$/,
    ipv6: /^\s*(?:(?:(?:[0-9a-f]{1,4}:){7}(?:[0-9a-f]{1,4}|:))|(?:(?:[0-9a-f]{1,4}:){6}(?::[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(?:(?:[0-9a-f]{1,4}:){5}(?:(?:(?::[0-9a-f]{1,4}){1,2})|:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(?:(?:[0-9a-f]{1,4}:){4}(?:(?:(?::[0-9a-f]{1,4}){1,3})|(?:(?::[0-9a-f]{1,4})?:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){3}(?:(?:(?::[0-9a-f]{1,4}){1,4})|(?:(?::[0-9a-f]{1,4}){0,2}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){2}(?:(?:(?::[0-9a-f]{1,4}){1,5})|(?:(?::[0-9a-f]{1,4}){0,3}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){1}(?:(?:(?::[0-9a-f]{1,4}){1,6})|(?:(?::[0-9a-f]{1,4}){0,4}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?::(?:(?:(?::[0-9a-f]{1,4}){1,7})|(?:(?::[0-9a-f]{1,4}){0,5}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:)))(?:%.+)?\s*$/i,
    regex: D,
    uuid: d,
    "json-pointer": c,
    "json-pointer-uri-fragment": u,
    "relative-json-pointer": p
  };
  function h(I) {
    return I % 4 === 0 && (I % 100 !== 0 || I % 400 === 0);
  }
  function g(I) {
    var R = I.match(e);
    if (!R) return !1;
    var O = +R[1], w = +R[2], x = +R[3];
    return w >= 1 && w <= 12 && x >= 1 && x <= (w == 2 && h(O) ? 29 : t[w]);
  }
  function v(I, R) {
    var O = I.match(i);
    if (!O) return !1;
    var w = O[1], x = O[2], _ = O[3], k = O[5];
    return (w <= 23 && x <= 59 && _ <= 59 || w == 23 && x == 59 && _ == 60) && (!R || k);
  }
  var S = /t|\s/i;
  function A(I) {
    var R = I.split(S);
    return R.length == 2 && g(R[0]) && v(R[1], !0);
  }
  var C = /\/|:/;
  function P(I) {
    return C.test(I) && s.test(I);
  }
  var E = /[^\\]\\Z/;
  function D(I) {
    if (E.test(I)) return !1;
    try {
      return new RegExp(I), !0;
    } catch {
      return !1;
    }
  }
  return Aa;
}
var Da, ii;
function $l() {
  return ii || (ii = 1, Da = function(e, t, i) {
    var r = " ", s = e.level, o = e.dataLevel, n = e.schema[t], f = e.errSchemaPath + "/" + t, d = !e.opts.allErrors, c = "data" + (o || ""), u = "valid" + s, p, l;
    if (n == "#" || n == "#/")
      e.isRoot ? (p = e.async, l = "validate") : (p = e.root.schema.$async === !0, l = "root.refVal[0]");
    else {
      var h = e.resolveRef(e.baseId, n, e.isRoot);
      if (h === void 0) {
        var g = e.MissingRefError.message(e.baseId, n);
        if (e.opts.missingRefs == "fail") {
          e.logger.error(g);
          var v = v || [];
          v.push(r), r = "", e.createErrors !== !1 ? (r += " { keyword: '$ref' , dataPath: (dataPath || '') + " + e.errorPath + " , schemaPath: " + e.util.toQuotedString(f) + " , params: { ref: '" + e.util.escapeQuotes(n) + "' } ", e.opts.messages !== !1 && (r += " , message: 'can\\'t resolve reference " + e.util.escapeQuotes(n) + "' "), e.opts.verbose && (r += " , schema: " + e.util.toQuotedString(n) + " , parentSchema: validate.schema" + e.schemaPath + " , data: " + c + " "), r += " } ") : r += " {} ";
          var S = r;
          r = v.pop(), !e.compositeRule && d ? e.async ? r += " throw new ValidationError([" + S + "]); " : r += " validate.errors = [" + S + "]; return false; " : r += " var err = " + S + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ", d && (r += " if (false) { ");
        } else if (e.opts.missingRefs == "ignore")
          e.logger.warn(g), d && (r += " if (true) { ");
        else
          throw new e.MissingRefError(e.baseId, n, g);
      } else if (h.inline) {
        var A = e.util.copy(e);
        A.level++;
        var C = "valid" + A.level;
        A.schema = h.schema, A.schemaPath = "", A.errSchemaPath = n;
        var P = e.validate(A).replace(/validate\.schema/g, h.code);
        r += " " + P + " ", d && (r += " if (" + C + ") { ");
      } else
        p = h.$async === !0 || e.async && h.$async !== !1, l = h.code;
    }
    if (l) {
      var v = v || [];
      v.push(r), r = "", e.opts.passContext ? r += " " + l + ".call(this, " : r += " " + l + "( ", r += " " + c + ", (dataPath || '')", e.errorPath != '""' && (r += " + " + e.errorPath);
      var E = o ? "data" + (o - 1 || "") : "parentData", D = o ? e.dataPathArr[o] : "parentDataProperty";
      r += " , " + E + " , " + D + ", rootData)  ";
      var I = r;
      if (r = v.pop(), p) {
        if (!e.async) throw new Error("async schema referenced by sync schema");
        d && (r += " var " + u + "; "), r += " try { await " + I + "; ", d && (r += " " + u + " = true; "), r += " } catch (e) { if (!(e instanceof ValidationError)) throw e; if (vErrors === null) vErrors = e.errors; else vErrors = vErrors.concat(e.errors); errors = vErrors.length; ", d && (r += " " + u + " = false; "), r += " } ", d && (r += " if (" + u + ") { ");
      } else
        r += " if (!" + I + ") { if (vErrors === null) vErrors = " + l + ".errors; else vErrors = vErrors.concat(" + l + ".errors); errors = vErrors.length; } ", d && (r += " else { ");
    }
    return r;
  }), Da;
}
var Ta, si;
function Ol() {
  return si || (si = 1, Ta = function(e, t, i) {
    var r = " ", s = e.schema[t], o = e.schemaPath + e.util.getProperty(t), n = e.errSchemaPath + "/" + t, f = !e.opts.allErrors, d = e.util.copy(e), c = "";
    d.level++;
    var u = "valid" + d.level, p = d.baseId, l = !0, h = s;
    if (h)
      for (var g, v = -1, S = h.length - 1; v < S; )
        g = h[v += 1], (e.opts.strictKeywords ? typeof g == "object" && Object.keys(g).length > 0 || g === !1 : e.util.schemaHasRules(g, e.RULES.all)) && (l = !1, d.schema = g, d.schemaPath = o + "[" + v + "]", d.errSchemaPath = n + "/" + v, r += "  " + e.validate(d) + " ", d.baseId = p, f && (r += " if (" + u + ") { ", c += "}"));
    return f && (l ? r += " if (true) { " : r += " " + c.slice(0, -1) + " "), r;
  }), Ta;
}
var La, ni;
function _l() {
  return ni || (ni = 1, La = function(e, t, i) {
    var r = " ", s = e.level, o = e.dataLevel, n = e.schema[t], f = e.schemaPath + e.util.getProperty(t), d = e.errSchemaPath + "/" + t, c = !e.opts.allErrors, u = "data" + (o || ""), p = "valid" + s, l = "errs__" + s, h = e.util.copy(e), g = "";
    h.level++;
    var v = "valid" + h.level, S = n.every(function(R) {
      return e.opts.strictKeywords ? typeof R == "object" && Object.keys(R).length > 0 || R === !1 : e.util.schemaHasRules(R, e.RULES.all);
    });
    if (S) {
      var A = h.baseId;
      r += " var " + l + " = errors; var " + p + " = false;  ";
      var C = e.compositeRule;
      e.compositeRule = h.compositeRule = !0;
      var P = n;
      if (P)
        for (var E, D = -1, I = P.length - 1; D < I; )
          E = P[D += 1], h.schema = E, h.schemaPath = f + "[" + D + "]", h.errSchemaPath = d + "/" + D, r += "  " + e.validate(h) + " ", h.baseId = A, r += " " + p + " = " + p + " || " + v + "; if (!" + p + ") { ", g += "}";
      e.compositeRule = h.compositeRule = C, r += " " + g + " if (!" + p + ") {   var err =   ", e.createErrors !== !1 ? (r += " { keyword: 'anyOf' , dataPath: (dataPath || '') + " + e.errorPath + " , schemaPath: " + e.util.toQuotedString(d) + " , params: {} ", e.opts.messages !== !1 && (r += " , message: 'should match some schema in anyOf' "), e.opts.verbose && (r += " , schema: validate.schema" + f + " , parentSchema: validate.schema" + e.schemaPath + " , data: " + u + " "), r += " } ") : r += " {} ", r += ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ", !e.compositeRule && c && (e.async ? r += " throw new ValidationError(vErrors); " : r += " validate.errors = vErrors; return false; "), r += " } else {  errors = " + l + "; if (vErrors !== null) { if (" + l + ") vErrors.length = " + l + "; else vErrors = null; } ", e.opts.allErrors && (r += " } ");
    } else
      c && (r += " if (true) { ");
    return r;
  }), La;
}
var Ia, oi;
function Nl() {
  return oi || (oi = 1, Ia = function(e, t, i) {
    var r = " ", s = e.schema[t], o = e.errSchemaPath + "/" + t;
    e.opts.allErrors;
    var n = e.util.toQuotedString(s);
    return e.opts.$comment === !0 ? r += " console.log(" + n + ");" : typeof e.opts.$comment == "function" && (r += " self._opts.$comment(" + n + ", " + e.util.toQuotedString(o) + ", validate.root.schema);"), r;
  }), Ia;
}
var Ra, li;
function Bl() {
  return li || (li = 1, Ra = function(e, t, i) {
    var r = " ", s = e.level, o = e.dataLevel, n = e.schema[t], f = e.schemaPath + e.util.getProperty(t), d = e.errSchemaPath + "/" + t, c = !e.opts.allErrors, u = "data" + (o || ""), p = "valid" + s, l = e.opts.$data && n && n.$data;
    l && (r += " var schema" + s + " = " + e.util.getData(n.$data, o, e.dataPathArr) + "; "), l || (r += " var schema" + s + " = validate.schema" + f + ";"), r += "var " + p + " = equal(" + u + ", schema" + s + "); if (!" + p + ") {   ";
    var h = h || [];
    h.push(r), r = "", e.createErrors !== !1 ? (r += " { keyword: 'const' , dataPath: (dataPath || '') + " + e.errorPath + " , schemaPath: " + e.util.toQuotedString(d) + " , params: { allowedValue: schema" + s + " } ", e.opts.messages !== !1 && (r += " , message: 'should be equal to constant' "), e.opts.verbose && (r += " , schema: validate.schema" + f + " , parentSchema: validate.schema" + e.schemaPath + " , data: " + u + " "), r += " } ") : r += " {} ";
    var g = r;
    return r = h.pop(), !e.compositeRule && c ? e.async ? r += " throw new ValidationError([" + g + "]); " : r += " validate.errors = [" + g + "]; return false; " : r += " var err = " + g + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ", r += " }", c && (r += " else { "), r;
  }), Ra;
}
var $a, ui;
function kl() {
  return ui || (ui = 1, $a = function(e, t, i) {
    var r = " ", s = e.level, o = e.dataLevel, n = e.schema[t], f = e.schemaPath + e.util.getProperty(t), d = e.errSchemaPath + "/" + t, c = !e.opts.allErrors, u = "data" + (o || ""), p = "valid" + s, l = "errs__" + s, h = e.util.copy(e), g = "";
    h.level++;
    var v = "valid" + h.level, S = "i" + s, A = h.dataLevel = e.dataLevel + 1, C = "data" + A, P = e.baseId, E = e.opts.strictKeywords ? typeof n == "object" && Object.keys(n).length > 0 || n === !1 : e.util.schemaHasRules(n, e.RULES.all);
    if (r += "var " + l + " = errors;var " + p + ";", E) {
      var D = e.compositeRule;
      e.compositeRule = h.compositeRule = !0, h.schema = n, h.schemaPath = f, h.errSchemaPath = d, r += " var " + v + " = false; for (var " + S + " = 0; " + S + " < " + u + ".length; " + S + "++) { ", h.errorPath = e.util.getPathExpr(e.errorPath, S, e.opts.jsonPointers, !0);
      var I = u + "[" + S + "]";
      h.dataPathArr[A] = S;
      var R = e.validate(h);
      h.baseId = P, e.util.varOccurences(R, C) < 2 ? r += " " + e.util.varReplace(R, C, I) + " " : r += " var " + C + " = " + I + "; " + R + " ", r += " if (" + v + ") break; }  ", e.compositeRule = h.compositeRule = D, r += " " + g + " if (!" + v + ") {";
    } else
      r += " if (" + u + ".length == 0) {";
    var O = O || [];
    O.push(r), r = "", e.createErrors !== !1 ? (r += " { keyword: 'contains' , dataPath: (dataPath || '') + " + e.errorPath + " , schemaPath: " + e.util.toQuotedString(d) + " , params: {} ", e.opts.messages !== !1 && (r += " , message: 'should contain a valid item' "), e.opts.verbose && (r += " , schema: validate.schema" + f + " , parentSchema: validate.schema" + e.schemaPath + " , data: " + u + " "), r += " } ") : r += " {} ";
    var w = r;
    return r = O.pop(), !e.compositeRule && c ? e.async ? r += " throw new ValidationError([" + w + "]); " : r += " validate.errors = [" + w + "]; return false; " : r += " var err = " + w + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ", r += " } else { ", E && (r += "  errors = " + l + "; if (vErrors !== null) { if (" + l + ") vErrors.length = " + l + "; else vErrors = null; } "), e.opts.allErrors && (r += " } "), r;
  }), $a;
}
var Oa, ci;
function ql() {
  return ci || (ci = 1, Oa = function(e, t, i) {
    var r = " ", s = e.level, o = e.dataLevel, n = e.schema[t], f = e.schemaPath + e.util.getProperty(t), d = e.errSchemaPath + "/" + t, c = !e.opts.allErrors, u = "data" + (o || ""), p = "errs__" + s, l = e.util.copy(e), h = "";
    l.level++;
    var g = "valid" + l.level, v = {}, S = {}, A = e.opts.ownProperties;
    for (D in n)
      if (D != "__proto__") {
        var C = n[D], P = Array.isArray(C) ? S : v;
        P[D] = C;
      }
    r += "var " + p + " = errors;";
    var E = e.errorPath;
    r += "var missing" + s + ";";
    for (var D in S)
      if (P = S[D], P.length) {
        if (r += " if ( " + u + e.util.getProperty(D) + " !== undefined ", A && (r += " && Object.prototype.hasOwnProperty.call(" + u + ", '" + e.util.escapeQuotes(D) + "') "), c) {
          r += " && ( ";
          var I = P;
          if (I)
            for (var R, O = -1, w = I.length - 1; O < w; ) {
              R = I[O += 1], O && (r += " || ");
              var x = e.util.getProperty(R), _ = u + x;
              r += " ( ( " + _ + " === undefined ", A && (r += " || ! Object.prototype.hasOwnProperty.call(" + u + ", '" + e.util.escapeQuotes(R) + "') "), r += ") && (missing" + s + " = " + e.util.toQuotedString(e.opts.jsonPointers ? R : x) + ") ) ";
            }
          r += ")) {  ";
          var k = "missing" + s, q = "' + " + k + " + '";
          e.opts._errorDataPathProperty && (e.errorPath = e.opts.jsonPointers ? e.util.getPathExpr(E, k, !0) : E + " + " + k);
          var z = z || [];
          z.push(r), r = "", e.createErrors !== !1 ? (r += " { keyword: 'dependencies' , dataPath: (dataPath || '') + " + e.errorPath + " , schemaPath: " + e.util.toQuotedString(d) + " , params: { property: '" + e.util.escapeQuotes(D) + "', missingProperty: '" + q + "', depsCount: " + P.length + ", deps: '" + e.util.escapeQuotes(P.length == 1 ? P[0] : P.join(", ")) + "' } ", e.opts.messages !== !1 && (r += " , message: 'should have ", P.length == 1 ? r += "property " + e.util.escapeQuotes(P[0]) : r += "properties " + e.util.escapeQuotes(P.join(", ")), r += " when property " + e.util.escapeQuotes(D) + " is present' "), e.opts.verbose && (r += " , schema: validate.schema" + f + " , parentSchema: validate.schema" + e.schemaPath + " , data: " + u + " "), r += " } ") : r += " {} ";
          var Y = r;
          r = z.pop(), !e.compositeRule && c ? e.async ? r += " throw new ValidationError([" + Y + "]); " : r += " validate.errors = [" + Y + "]; return false; " : r += " var err = " + Y + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
        } else {
          r += " ) { ";
          var G = P;
          if (G)
            for (var R, ee = -1, K = G.length - 1; ee < K; ) {
              R = G[ee += 1];
              var x = e.util.getProperty(R), q = e.util.escapeQuotes(R), _ = u + x;
              e.opts._errorDataPathProperty && (e.errorPath = e.util.getPath(E, R, e.opts.jsonPointers)), r += " if ( " + _ + " === undefined ", A && (r += " || ! Object.prototype.hasOwnProperty.call(" + u + ", '" + e.util.escapeQuotes(R) + "') "), r += ") {  var err =   ", e.createErrors !== !1 ? (r += " { keyword: 'dependencies' , dataPath: (dataPath || '') + " + e.errorPath + " , schemaPath: " + e.util.toQuotedString(d) + " , params: { property: '" + e.util.escapeQuotes(D) + "', missingProperty: '" + q + "', depsCount: " + P.length + ", deps: '" + e.util.escapeQuotes(P.length == 1 ? P[0] : P.join(", ")) + "' } ", e.opts.messages !== !1 && (r += " , message: 'should have ", P.length == 1 ? r += "property " + e.util.escapeQuotes(P[0]) : r += "properties " + e.util.escapeQuotes(P.join(", ")), r += " when property " + e.util.escapeQuotes(D) + " is present' "), e.opts.verbose && (r += " , schema: validate.schema" + f + " , parentSchema: validate.schema" + e.schemaPath + " , data: " + u + " "), r += " } ") : r += " {} ", r += ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; } ";
            }
        }
        r += " }   ", c && (h += "}", r += " else { ");
      }
    e.errorPath = E;
    var J = l.baseId;
    for (var D in v) {
      var C = v[D];
      (e.opts.strictKeywords ? typeof C == "object" && Object.keys(C).length > 0 || C === !1 : e.util.schemaHasRules(C, e.RULES.all)) && (r += " " + g + " = true; if ( " + u + e.util.getProperty(D) + " !== undefined ", A && (r += " && Object.prototype.hasOwnProperty.call(" + u + ", '" + e.util.escapeQuotes(D) + "') "), r += ") { ", l.schema = C, l.schemaPath = f + e.util.getProperty(D), l.errSchemaPath = d + "/" + e.util.escapeFragment(D), r += "  " + e.validate(l) + " ", l.baseId = J, r += " }  ", c && (r += " if (" + g + ") { ", h += "}"));
    }
    return c && (r += "   " + h + " if (" + p + " == errors) {"), r;
  }), Oa;
}
var _a, fi;
function Ml() {
  return fi || (fi = 1, _a = function(e, t, i) {
    var r = " ", s = e.level, o = e.dataLevel, n = e.schema[t], f = e.schemaPath + e.util.getProperty(t), d = e.errSchemaPath + "/" + t, c = !e.opts.allErrors, u = "data" + (o || ""), p = "valid" + s, l = e.opts.$data && n && n.$data;
    l && (r += " var schema" + s + " = " + e.util.getData(n.$data, o, e.dataPathArr) + "; ");
    var h = "i" + s, g = "schema" + s;
    l || (r += " var " + g + " = validate.schema" + f + ";"), r += "var " + p + ";", l && (r += " if (schema" + s + " === undefined) " + p + " = true; else if (!Array.isArray(schema" + s + ")) " + p + " = false; else {"), r += "" + p + " = false;for (var " + h + "=0; " + h + "<" + g + ".length; " + h + "++) if (equal(" + u + ", " + g + "[" + h + "])) { " + p + " = true; break; }", l && (r += "  }  "), r += " if (!" + p + ") {   ";
    var v = v || [];
    v.push(r), r = "", e.createErrors !== !1 ? (r += " { keyword: 'enum' , dataPath: (dataPath || '') + " + e.errorPath + " , schemaPath: " + e.util.toQuotedString(d) + " , params: { allowedValues: schema" + s + " } ", e.opts.messages !== !1 && (r += " , message: 'should be equal to one of the allowed values' "), e.opts.verbose && (r += " , schema: validate.schema" + f + " , parentSchema: validate.schema" + e.schemaPath + " , data: " + u + " "), r += " } ") : r += " {} ";
    var S = r;
    return r = v.pop(), !e.compositeRule && c ? e.async ? r += " throw new ValidationError([" + S + "]); " : r += " validate.errors = [" + S + "]; return false; " : r += " var err = " + S + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ", r += " }", c && (r += " else { "), r;
  }), _a;
}
var Na, di;
function jl() {
  return di || (di = 1, Na = function(e, t, i) {
    var r = " ", s = e.level, o = e.dataLevel, n = e.schema[t], f = e.schemaPath + e.util.getProperty(t), d = e.errSchemaPath + "/" + t, c = !e.opts.allErrors, u = "data" + (o || "");
    if (e.opts.format === !1)
      return c && (r += " if (true) { "), r;
    var p = e.opts.$data && n && n.$data, l;
    p ? (r += " var schema" + s + " = " + e.util.getData(n.$data, o, e.dataPathArr) + "; ", l = "schema" + s) : l = n;
    var h = e.opts.unknownFormats, g = Array.isArray(h);
    if (p) {
      var v = "format" + s, S = "isObject" + s, A = "formatType" + s;
      r += " var " + v + " = formats[" + l + "]; var " + S + " = typeof " + v + " == 'object' && !(" + v + " instanceof RegExp) && " + v + ".validate; var " + A + " = " + S + " && " + v + ".type || 'string'; if (" + S + ") { ", e.async && (r += " var async" + s + " = " + v + ".async; "), r += " " + v + " = " + v + ".validate; } if (  ", p && (r += " (" + l + " !== undefined && typeof " + l + " != 'string') || "), r += " (", h != "ignore" && (r += " (" + l + " && !" + v + " ", g && (r += " && self._opts.unknownFormats.indexOf(" + l + ") == -1 "), r += ") || "), r += " (" + v + " && " + A + " == '" + i + "' && !(typeof " + v + " == 'function' ? ", e.async ? r += " (async" + s + " ? await " + v + "(" + u + ") : " + v + "(" + u + ")) " : r += " " + v + "(" + u + ") ", r += " : " + v + ".test(" + u + "))))) {";
    } else {
      var v = e.formats[n];
      if (!v) {
        if (h == "ignore")
          return e.logger.warn('unknown format "' + n + '" ignored in schema at path "' + e.errSchemaPath + '"'), c && (r += " if (true) { "), r;
        if (g && h.indexOf(n) >= 0)
          return c && (r += " if (true) { "), r;
        throw new Error('unknown format "' + n + '" is used in schema at path "' + e.errSchemaPath + '"');
      }
      var S = typeof v == "object" && !(v instanceof RegExp) && v.validate, A = S && v.type || "string";
      if (S) {
        var C = v.async === !0;
        v = v.validate;
      }
      if (A != i)
        return c && (r += " if (true) { "), r;
      if (C) {
        if (!e.async) throw new Error("async format in sync schema");
        var P = "formats" + e.util.getProperty(n) + ".validate";
        r += " if (!(await " + P + "(" + u + "))) { ";
      } else {
        r += " if (! ";
        var P = "formats" + e.util.getProperty(n);
        S && (P += ".validate"), typeof v == "function" ? r += " " + P + "(" + u + ") " : r += " " + P + ".test(" + u + ") ", r += ") { ";
      }
    }
    var E = E || [];
    E.push(r), r = "", e.createErrors !== !1 ? (r += " { keyword: 'format' , dataPath: (dataPath || '') + " + e.errorPath + " , schemaPath: " + e.util.toQuotedString(d) + " , params: { format:  ", p ? r += "" + l : r += "" + e.util.toQuotedString(n), r += "  } ", e.opts.messages !== !1 && (r += ` , message: 'should match format "`, p ? r += "' + " + l + " + '" : r += "" + e.util.escapeQuotes(n), r += `"' `), e.opts.verbose && (r += " , schema:  ", p ? r += "validate.schema" + f : r += "" + e.util.toQuotedString(n), r += "         , parentSchema: validate.schema" + e.schemaPath + " , data: " + u + " "), r += " } ") : r += " {} ";
    var D = r;
    return r = E.pop(), !e.compositeRule && c ? e.async ? r += " throw new ValidationError([" + D + "]); " : r += " validate.errors = [" + D + "]; return false; " : r += " var err = " + D + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ", r += " } ", c && (r += " else { "), r;
  }), Na;
}
var Ba, hi;
function Vl() {
  return hi || (hi = 1, Ba = function(e, t, i) {
    var r = " ", s = e.level, o = e.dataLevel, n = e.schema[t], f = e.schemaPath + e.util.getProperty(t), d = e.errSchemaPath + "/" + t, c = !e.opts.allErrors, u = "data" + (o || ""), p = "valid" + s, l = "errs__" + s, h = e.util.copy(e);
    h.level++;
    var g = "valid" + h.level, v = e.schema.then, S = e.schema.else, A = v !== void 0 && (e.opts.strictKeywords ? typeof v == "object" && Object.keys(v).length > 0 || v === !1 : e.util.schemaHasRules(v, e.RULES.all)), C = S !== void 0 && (e.opts.strictKeywords ? typeof S == "object" && Object.keys(S).length > 0 || S === !1 : e.util.schemaHasRules(S, e.RULES.all)), P = h.baseId;
    if (A || C) {
      var E;
      h.createErrors = !1, h.schema = n, h.schemaPath = f, h.errSchemaPath = d, r += " var " + l + " = errors; var " + p + " = true;  ";
      var D = e.compositeRule;
      e.compositeRule = h.compositeRule = !0, r += "  " + e.validate(h) + " ", h.baseId = P, h.createErrors = !0, r += "  errors = " + l + "; if (vErrors !== null) { if (" + l + ") vErrors.length = " + l + "; else vErrors = null; }  ", e.compositeRule = h.compositeRule = D, A ? (r += " if (" + g + ") {  ", h.schema = e.schema.then, h.schemaPath = e.schemaPath + ".then", h.errSchemaPath = e.errSchemaPath + "/then", r += "  " + e.validate(h) + " ", h.baseId = P, r += " " + p + " = " + g + "; ", A && C ? (E = "ifClause" + s, r += " var " + E + " = 'then'; ") : E = "'then'", r += " } ", C && (r += " else { ")) : r += " if (!" + g + ") { ", C && (h.schema = e.schema.else, h.schemaPath = e.schemaPath + ".else", h.errSchemaPath = e.errSchemaPath + "/else", r += "  " + e.validate(h) + " ", h.baseId = P, r += " " + p + " = " + g + "; ", A && C ? (E = "ifClause" + s, r += " var " + E + " = 'else'; ") : E = "'else'", r += " } "), r += " if (!" + p + ") {   var err =   ", e.createErrors !== !1 ? (r += " { keyword: 'if' , dataPath: (dataPath || '') + " + e.errorPath + " , schemaPath: " + e.util.toQuotedString(d) + " , params: { failingKeyword: " + E + " } ", e.opts.messages !== !1 && (r += ` , message: 'should match "' + ` + E + ` + '" schema' `), e.opts.verbose && (r += " , schema: validate.schema" + f + " , parentSchema: validate.schema" + e.schemaPath + " , data: " + u + " "), r += " } ") : r += " {} ", r += ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ", !e.compositeRule && c && (e.async ? r += " throw new ValidationError(vErrors); " : r += " validate.errors = vErrors; return false; "), r += " }   ", c && (r += " else { ");
    } else
      c && (r += " if (true) { ");
    return r;
  }), Ba;
}
var ka, mi;
function zl() {
  return mi || (mi = 1, ka = function(e, t, i) {
    var r = " ", s = e.level, o = e.dataLevel, n = e.schema[t], f = e.schemaPath + e.util.getProperty(t), d = e.errSchemaPath + "/" + t, c = !e.opts.allErrors, u = "data" + (o || ""), p = "valid" + s, l = "errs__" + s, h = e.util.copy(e), g = "";
    h.level++;
    var v = "valid" + h.level, S = "i" + s, A = h.dataLevel = e.dataLevel + 1, C = "data" + A, P = e.baseId;
    if (r += "var " + l + " = errors;var " + p + ";", Array.isArray(n)) {
      var E = e.schema.additionalItems;
      if (E === !1) {
        r += " " + p + " = " + u + ".length <= " + n.length + "; ";
        var D = d;
        d = e.errSchemaPath + "/additionalItems", r += "  if (!" + p + ") {   ";
        var I = I || [];
        I.push(r), r = "", e.createErrors !== !1 ? (r += " { keyword: 'additionalItems' , dataPath: (dataPath || '') + " + e.errorPath + " , schemaPath: " + e.util.toQuotedString(d) + " , params: { limit: " + n.length + " } ", e.opts.messages !== !1 && (r += " , message: 'should NOT have more than " + n.length + " items' "), e.opts.verbose && (r += " , schema: false , parentSchema: validate.schema" + e.schemaPath + " , data: " + u + " "), r += " } ") : r += " {} ";
        var R = r;
        r = I.pop(), !e.compositeRule && c ? e.async ? r += " throw new ValidationError([" + R + "]); " : r += " validate.errors = [" + R + "]; return false; " : r += " var err = " + R + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ", r += " } ", d = D, c && (g += "}", r += " else { ");
      }
      var O = n;
      if (O) {
        for (var w, x = -1, _ = O.length - 1; x < _; )
          if (w = O[x += 1], e.opts.strictKeywords ? typeof w == "object" && Object.keys(w).length > 0 || w === !1 : e.util.schemaHasRules(w, e.RULES.all)) {
            r += " " + v + " = true; if (" + u + ".length > " + x + ") { ";
            var k = u + "[" + x + "]";
            h.schema = w, h.schemaPath = f + "[" + x + "]", h.errSchemaPath = d + "/" + x, h.errorPath = e.util.getPathExpr(e.errorPath, x, e.opts.jsonPointers, !0), h.dataPathArr[A] = x;
            var q = e.validate(h);
            h.baseId = P, e.util.varOccurences(q, C) < 2 ? r += " " + e.util.varReplace(q, C, k) + " " : r += " var " + C + " = " + k + "; " + q + " ", r += " }  ", c && (r += " if (" + v + ") { ", g += "}");
          }
      }
      if (typeof E == "object" && (e.opts.strictKeywords ? typeof E == "object" && Object.keys(E).length > 0 || E === !1 : e.util.schemaHasRules(E, e.RULES.all))) {
        h.schema = E, h.schemaPath = e.schemaPath + ".additionalItems", h.errSchemaPath = e.errSchemaPath + "/additionalItems", r += " " + v + " = true; if (" + u + ".length > " + n.length + ") {  for (var " + S + " = " + n.length + "; " + S + " < " + u + ".length; " + S + "++) { ", h.errorPath = e.util.getPathExpr(e.errorPath, S, e.opts.jsonPointers, !0);
        var k = u + "[" + S + "]";
        h.dataPathArr[A] = S;
        var q = e.validate(h);
        h.baseId = P, e.util.varOccurences(q, C) < 2 ? r += " " + e.util.varReplace(q, C, k) + " " : r += " var " + C + " = " + k + "; " + q + " ", c && (r += " if (!" + v + ") break; "), r += " } }  ", c && (r += " if (" + v + ") { ", g += "}");
      }
    } else if (e.opts.strictKeywords ? typeof n == "object" && Object.keys(n).length > 0 || n === !1 : e.util.schemaHasRules(n, e.RULES.all)) {
      h.schema = n, h.schemaPath = f, h.errSchemaPath = d, r += "  for (var " + S + " = 0; " + S + " < " + u + ".length; " + S + "++) { ", h.errorPath = e.util.getPathExpr(e.errorPath, S, e.opts.jsonPointers, !0);
      var k = u + "[" + S + "]";
      h.dataPathArr[A] = S;
      var q = e.validate(h);
      h.baseId = P, e.util.varOccurences(q, C) < 2 ? r += " " + e.util.varReplace(q, C, k) + " " : r += " var " + C + " = " + k + "; " + q + " ", c && (r += " if (!" + v + ") break; "), r += " }";
    }
    return c && (r += " " + g + " if (" + l + " == errors) {"), r;
  }), ka;
}
var qa, pi;
function vi() {
  return pi || (pi = 1, qa = function(e, t, i) {
    var r = " ", s = e.level, o = e.dataLevel, n = e.schema[t], f = e.schemaPath + e.util.getProperty(t), d = e.errSchemaPath + "/" + t, c = !e.opts.allErrors, P, u = "data" + (o || ""), p = e.opts.$data && n && n.$data, l;
    p ? (r += " var schema" + s + " = " + e.util.getData(n.$data, o, e.dataPathArr) + "; ", l = "schema" + s) : l = n;
    var h = t == "maximum", g = h ? "exclusiveMaximum" : "exclusiveMinimum", v = e.schema[g], S = e.opts.$data && v && v.$data, A = h ? "<" : ">", C = h ? ">" : "<", P = void 0;
    if (!(p || typeof n == "number" || n === void 0))
      throw new Error(t + " must be number");
    if (!(S || v === void 0 || typeof v == "number" || typeof v == "boolean"))
      throw new Error(g + " must be number or boolean");
    if (S) {
      var E = e.util.getData(v.$data, o, e.dataPathArr), D = "exclusive" + s, I = "exclType" + s, R = "exclIsNumber" + s, O = "op" + s, w = "' + " + O + " + '";
      r += " var schemaExcl" + s + " = " + E + "; ", E = "schemaExcl" + s, r += " var " + D + "; var " + I + " = typeof " + E + "; if (" + I + " != 'boolean' && " + I + " != 'undefined' && " + I + " != 'number') { ";
      var P = g, x = x || [];
      x.push(r), r = "", e.createErrors !== !1 ? (r += " { keyword: '" + (P || "_exclusiveLimit") + "' , dataPath: (dataPath || '') + " + e.errorPath + " , schemaPath: " + e.util.toQuotedString(d) + " , params: {} ", e.opts.messages !== !1 && (r += " , message: '" + g + " should be boolean' "), e.opts.verbose && (r += " , schema: validate.schema" + f + " , parentSchema: validate.schema" + e.schemaPath + " , data: " + u + " "), r += " } ") : r += " {} ";
      var _ = r;
      r = x.pop(), !e.compositeRule && c ? e.async ? r += " throw new ValidationError([" + _ + "]); " : r += " validate.errors = [" + _ + "]; return false; " : r += " var err = " + _ + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ", r += " } else if ( ", p && (r += " (" + l + " !== undefined && typeof " + l + " != 'number') || "), r += " " + I + " == 'number' ? ( (" + D + " = " + l + " === undefined || " + E + " " + A + "= " + l + ") ? " + u + " " + C + "= " + E + " : " + u + " " + C + " " + l + " ) : ( (" + D + " = " + E + " === true) ? " + u + " " + C + "= " + l + " : " + u + " " + C + " " + l + " ) || " + u + " !== " + u + ") { var op" + s + " = " + D + " ? '" + A + "' : '" + A + "='; ", n === void 0 && (P = g, d = e.errSchemaPath + "/" + g, l = E, p = S);
    } else {
      var R = typeof v == "number", w = A;
      if (R && p) {
        var O = "'" + w + "'";
        r += " if ( ", p && (r += " (" + l + " !== undefined && typeof " + l + " != 'number') || "), r += " ( " + l + " === undefined || " + v + " " + A + "= " + l + " ? " + u + " " + C + "= " + v + " : " + u + " " + C + " " + l + " ) || " + u + " !== " + u + ") { ";
      } else {
        R && n === void 0 ? (D = !0, P = g, d = e.errSchemaPath + "/" + g, l = v, C += "=") : (R && (l = Math[h ? "min" : "max"](v, n)), v === (R ? l : !0) ? (D = !0, P = g, d = e.errSchemaPath + "/" + g, C += "=") : (D = !1, w += "="));
        var O = "'" + w + "'";
        r += " if ( ", p && (r += " (" + l + " !== undefined && typeof " + l + " != 'number') || "), r += " " + u + " " + C + " " + l + " || " + u + " !== " + u + ") { ";
      }
    }
    P = P || t;
    var x = x || [];
    x.push(r), r = "", e.createErrors !== !1 ? (r += " { keyword: '" + (P || "_limit") + "' , dataPath: (dataPath || '') + " + e.errorPath + " , schemaPath: " + e.util.toQuotedString(d) + " , params: { comparison: " + O + ", limit: " + l + ", exclusive: " + D + " } ", e.opts.messages !== !1 && (r += " , message: 'should be " + w + " ", p ? r += "' + " + l : r += "" + l + "'"), e.opts.verbose && (r += " , schema:  ", p ? r += "validate.schema" + f : r += "" + n, r += "         , parentSchema: validate.schema" + e.schemaPath + " , data: " + u + " "), r += " } ") : r += " {} ";
    var _ = r;
    return r = x.pop(), !e.compositeRule && c ? e.async ? r += " throw new ValidationError([" + _ + "]); " : r += " validate.errors = [" + _ + "]; return false; " : r += " var err = " + _ + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ", r += " } ", c && (r += " else { "), r;
  }), qa;
}
var Ma, gi;
function yi() {
  return gi || (gi = 1, Ma = function(e, t, i) {
    var r = " ", s = e.level, o = e.dataLevel, n = e.schema[t], f = e.schemaPath + e.util.getProperty(t), d = e.errSchemaPath + "/" + t, c = !e.opts.allErrors, g, u = "data" + (o || ""), p = e.opts.$data && n && n.$data, l;
    if (p ? (r += " var schema" + s + " = " + e.util.getData(n.$data, o, e.dataPathArr) + "; ", l = "schema" + s) : l = n, !(p || typeof n == "number"))
      throw new Error(t + " must be number");
    var h = t == "maxItems" ? ">" : "<";
    r += "if ( ", p && (r += " (" + l + " !== undefined && typeof " + l + " != 'number') || "), r += " " + u + ".length " + h + " " + l + ") { ";
    var g = t, v = v || [];
    v.push(r), r = "", e.createErrors !== !1 ? (r += " { keyword: '" + (g || "_limitItems") + "' , dataPath: (dataPath || '') + " + e.errorPath + " , schemaPath: " + e.util.toQuotedString(d) + " , params: { limit: " + l + " } ", e.opts.messages !== !1 && (r += " , message: 'should NOT have ", t == "maxItems" ? r += "more" : r += "fewer", r += " than ", p ? r += "' + " + l + " + '" : r += "" + n, r += " items' "), e.opts.verbose && (r += " , schema:  ", p ? r += "validate.schema" + f : r += "" + n, r += "         , parentSchema: validate.schema" + e.schemaPath + " , data: " + u + " "), r += " } ") : r += " {} ";
    var S = r;
    return r = v.pop(), !e.compositeRule && c ? e.async ? r += " throw new ValidationError([" + S + "]); " : r += " validate.errors = [" + S + "]; return false; " : r += " var err = " + S + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ", r += "} ", c && (r += " else { "), r;
  }), Ma;
}
var ja, Si;
function bi() {
  return Si || (Si = 1, ja = function(e, t, i) {
    var r = " ", s = e.level, o = e.dataLevel, n = e.schema[t], f = e.schemaPath + e.util.getProperty(t), d = e.errSchemaPath + "/" + t, c = !e.opts.allErrors, g, u = "data" + (o || ""), p = e.opts.$data && n && n.$data, l;
    if (p ? (r += " var schema" + s + " = " + e.util.getData(n.$data, o, e.dataPathArr) + "; ", l = "schema" + s) : l = n, !(p || typeof n == "number"))
      throw new Error(t + " must be number");
    var h = t == "maxLength" ? ">" : "<";
    r += "if ( ", p && (r += " (" + l + " !== undefined && typeof " + l + " != 'number') || "), e.opts.unicode === !1 ? r += " " + u + ".length " : r += " ucs2length(" + u + ") ", r += " " + h + " " + l + ") { ";
    var g = t, v = v || [];
    v.push(r), r = "", e.createErrors !== !1 ? (r += " { keyword: '" + (g || "_limitLength") + "' , dataPath: (dataPath || '') + " + e.errorPath + " , schemaPath: " + e.util.toQuotedString(d) + " , params: { limit: " + l + " } ", e.opts.messages !== !1 && (r += " , message: 'should NOT be ", t == "maxLength" ? r += "longer" : r += "shorter", r += " than ", p ? r += "' + " + l + " + '" : r += "" + n, r += " characters' "), e.opts.verbose && (r += " , schema:  ", p ? r += "validate.schema" + f : r += "" + n, r += "         , parentSchema: validate.schema" + e.schemaPath + " , data: " + u + " "), r += " } ") : r += " {} ";
    var S = r;
    return r = v.pop(), !e.compositeRule && c ? e.async ? r += " throw new ValidationError([" + S + "]); " : r += " validate.errors = [" + S + "]; return false; " : r += " var err = " + S + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ", r += "} ", c && (r += " else { "), r;
  }), ja;
}
var Va, Pi;
function wi() {
  return Pi || (Pi = 1, Va = function(e, t, i) {
    var r = " ", s = e.level, o = e.dataLevel, n = e.schema[t], f = e.schemaPath + e.util.getProperty(t), d = e.errSchemaPath + "/" + t, c = !e.opts.allErrors, g, u = "data" + (o || ""), p = e.opts.$data && n && n.$data, l;
    if (p ? (r += " var schema" + s + " = " + e.util.getData(n.$data, o, e.dataPathArr) + "; ", l = "schema" + s) : l = n, !(p || typeof n == "number"))
      throw new Error(t + " must be number");
    var h = t == "maxProperties" ? ">" : "<";
    r += "if ( ", p && (r += " (" + l + " !== undefined && typeof " + l + " != 'number') || "), r += " Object.keys(" + u + ").length " + h + " " + l + ") { ";
    var g = t, v = v || [];
    v.push(r), r = "", e.createErrors !== !1 ? (r += " { keyword: '" + (g || "_limitProperties") + "' , dataPath: (dataPath || '') + " + e.errorPath + " , schemaPath: " + e.util.toQuotedString(d) + " , params: { limit: " + l + " } ", e.opts.messages !== !1 && (r += " , message: 'should NOT have ", t == "maxProperties" ? r += "more" : r += "fewer", r += " than ", p ? r += "' + " + l + " + '" : r += "" + n, r += " properties' "), e.opts.verbose && (r += " , schema:  ", p ? r += "validate.schema" + f : r += "" + n, r += "         , parentSchema: validate.schema" + e.schemaPath + " , data: " + u + " "), r += " } ") : r += " {} ";
    var S = r;
    return r = v.pop(), !e.compositeRule && c ? e.async ? r += " throw new ValidationError([" + S + "]); " : r += " validate.errors = [" + S + "]; return false; " : r += " var err = " + S + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ", r += "} ", c && (r += " else { "), r;
  }), Va;
}
var za, Ei;
function Ul() {
  return Ei || (Ei = 1, za = function(e, t, i) {
    var r = " ", s = e.level, o = e.dataLevel, n = e.schema[t], f = e.schemaPath + e.util.getProperty(t), d = e.errSchemaPath + "/" + t, c = !e.opts.allErrors, u = "data" + (o || ""), p = e.opts.$data && n && n.$data, l;
    if (p ? (r += " var schema" + s + " = " + e.util.getData(n.$data, o, e.dataPathArr) + "; ", l = "schema" + s) : l = n, !(p || typeof n == "number"))
      throw new Error(t + " must be number");
    r += "var division" + s + ";if (", p && (r += " " + l + " !== undefined && ( typeof " + l + " != 'number' || "), r += " (division" + s + " = " + u + " / " + l + ", ", e.opts.multipleOfPrecision ? r += " Math.abs(Math.round(division" + s + ") - division" + s + ") > 1e-" + e.opts.multipleOfPrecision + " " : r += " division" + s + " !== parseInt(division" + s + ") ", r += " ) ", p && (r += "  )  "), r += " ) {   ";
    var h = h || [];
    h.push(r), r = "", e.createErrors !== !1 ? (r += " { keyword: 'multipleOf' , dataPath: (dataPath || '') + " + e.errorPath + " , schemaPath: " + e.util.toQuotedString(d) + " , params: { multipleOf: " + l + " } ", e.opts.messages !== !1 && (r += " , message: 'should be multiple of ", p ? r += "' + " + l : r += "" + l + "'"), e.opts.verbose && (r += " , schema:  ", p ? r += "validate.schema" + f : r += "" + n, r += "         , parentSchema: validate.schema" + e.schemaPath + " , data: " + u + " "), r += " } ") : r += " {} ";
    var g = r;
    return r = h.pop(), !e.compositeRule && c ? e.async ? r += " throw new ValidationError([" + g + "]); " : r += " validate.errors = [" + g + "]; return false; " : r += " var err = " + g + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ", r += "} ", c && (r += " else { "), r;
  }), za;
}
var Ua, xi;
function Ql() {
  return xi || (xi = 1, Ua = function(e, t, i) {
    var r = " ", s = e.level, o = e.dataLevel, n = e.schema[t], f = e.schemaPath + e.util.getProperty(t), d = e.errSchemaPath + "/" + t, c = !e.opts.allErrors, u = "data" + (o || ""), p = "errs__" + s, l = e.util.copy(e);
    l.level++;
    var h = "valid" + l.level;
    if (e.opts.strictKeywords ? typeof n == "object" && Object.keys(n).length > 0 || n === !1 : e.util.schemaHasRules(n, e.RULES.all)) {
      l.schema = n, l.schemaPath = f, l.errSchemaPath = d, r += " var " + p + " = errors;  ";
      var g = e.compositeRule;
      e.compositeRule = l.compositeRule = !0, l.createErrors = !1;
      var v;
      l.opts.allErrors && (v = l.opts.allErrors, l.opts.allErrors = !1), r += " " + e.validate(l) + " ", l.createErrors = !0, v && (l.opts.allErrors = v), e.compositeRule = l.compositeRule = g, r += " if (" + h + ") {   ";
      var S = S || [];
      S.push(r), r = "", e.createErrors !== !1 ? (r += " { keyword: 'not' , dataPath: (dataPath || '') + " + e.errorPath + " , schemaPath: " + e.util.toQuotedString(d) + " , params: {} ", e.opts.messages !== !1 && (r += " , message: 'should NOT be valid' "), e.opts.verbose && (r += " , schema: validate.schema" + f + " , parentSchema: validate.schema" + e.schemaPath + " , data: " + u + " "), r += " } ") : r += " {} ";
      var A = r;
      r = S.pop(), !e.compositeRule && c ? e.async ? r += " throw new ValidationError([" + A + "]); " : r += " validate.errors = [" + A + "]; return false; " : r += " var err = " + A + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ", r += " } else {  errors = " + p + "; if (vErrors !== null) { if (" + p + ") vErrors.length = " + p + "; else vErrors = null; } ", e.opts.allErrors && (r += " } ");
    } else
      r += "  var err =   ", e.createErrors !== !1 ? (r += " { keyword: 'not' , dataPath: (dataPath || '') + " + e.errorPath + " , schemaPath: " + e.util.toQuotedString(d) + " , params: {} ", e.opts.messages !== !1 && (r += " , message: 'should NOT be valid' "), e.opts.verbose && (r += " , schema: validate.schema" + f + " , parentSchema: validate.schema" + e.schemaPath + " , data: " + u + " "), r += " } ") : r += " {} ", r += ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ", c && (r += " if (false) { ");
    return r;
  }), Ua;
}
var Qa, Fi;
function Hl() {
  return Fi || (Fi = 1, Qa = function(e, t, i) {
    var r = " ", s = e.level, o = e.dataLevel, n = e.schema[t], f = e.schemaPath + e.util.getProperty(t), d = e.errSchemaPath + "/" + t, c = !e.opts.allErrors, u = "data" + (o || ""), p = "valid" + s, l = "errs__" + s, h = e.util.copy(e), g = "";
    h.level++;
    var v = "valid" + h.level, S = h.baseId, A = "prevValid" + s, C = "passingSchemas" + s;
    r += "var " + l + " = errors , " + A + " = false , " + p + " = false , " + C + " = null; ";
    var P = e.compositeRule;
    e.compositeRule = h.compositeRule = !0;
    var E = n;
    if (E)
      for (var D, I = -1, R = E.length - 1; I < R; )
        D = E[I += 1], (e.opts.strictKeywords ? typeof D == "object" && Object.keys(D).length > 0 || D === !1 : e.util.schemaHasRules(D, e.RULES.all)) ? (h.schema = D, h.schemaPath = f + "[" + I + "]", h.errSchemaPath = d + "/" + I, r += "  " + e.validate(h) + " ", h.baseId = S) : r += " var " + v + " = true; ", I && (r += " if (" + v + " && " + A + ") { " + p + " = false; " + C + " = [" + C + ", " + I + "]; } else { ", g += "}"), r += " if (" + v + ") { " + p + " = " + A + " = true; " + C + " = " + I + "; }";
    return e.compositeRule = h.compositeRule = P, r += "" + g + "if (!" + p + ") {   var err =   ", e.createErrors !== !1 ? (r += " { keyword: 'oneOf' , dataPath: (dataPath || '') + " + e.errorPath + " , schemaPath: " + e.util.toQuotedString(d) + " , params: { passingSchemas: " + C + " } ", e.opts.messages !== !1 && (r += " , message: 'should match exactly one schema in oneOf' "), e.opts.verbose && (r += " , schema: validate.schema" + f + " , parentSchema: validate.schema" + e.schemaPath + " , data: " + u + " "), r += " } ") : r += " {} ", r += ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ", !e.compositeRule && c && (e.async ? r += " throw new ValidationError(vErrors); " : r += " validate.errors = vErrors; return false; "), r += "} else {  errors = " + l + "; if (vErrors !== null) { if (" + l + ") vErrors.length = " + l + "; else vErrors = null; }", e.opts.allErrors && (r += " } "), r;
  }), Qa;
}
var Ha, Ci;
function Gl() {
  return Ci || (Ci = 1, Ha = function(e, t, i) {
    var r = " ", s = e.level, o = e.dataLevel, n = e.schema[t], f = e.schemaPath + e.util.getProperty(t), d = e.errSchemaPath + "/" + t, c = !e.opts.allErrors, u = "data" + (o || ""), p = e.opts.$data && n && n.$data, l;
    p ? (r += " var schema" + s + " = " + e.util.getData(n.$data, o, e.dataPathArr) + "; ", l = "schema" + s) : l = n;
    var h = p ? "(new RegExp(" + l + "))" : e.usePattern(n);
    r += "if ( ", p && (r += " (" + l + " !== undefined && typeof " + l + " != 'string') || "), r += " !" + h + ".test(" + u + ") ) {   ";
    var g = g || [];
    g.push(r), r = "", e.createErrors !== !1 ? (r += " { keyword: 'pattern' , dataPath: (dataPath || '') + " + e.errorPath + " , schemaPath: " + e.util.toQuotedString(d) + " , params: { pattern:  ", p ? r += "" + l : r += "" + e.util.toQuotedString(n), r += "  } ", e.opts.messages !== !1 && (r += ` , message: 'should match pattern "`, p ? r += "' + " + l + " + '" : r += "" + e.util.escapeQuotes(n), r += `"' `), e.opts.verbose && (r += " , schema:  ", p ? r += "validate.schema" + f : r += "" + e.util.toQuotedString(n), r += "         , parentSchema: validate.schema" + e.schemaPath + " , data: " + u + " "), r += " } ") : r += " {} ";
    var v = r;
    return r = g.pop(), !e.compositeRule && c ? e.async ? r += " throw new ValidationError([" + v + "]); " : r += " validate.errors = [" + v + "]; return false; " : r += " var err = " + v + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ", r += "} ", c && (r += " else { "), r;
  }), Ha;
}
var Ga, Ai;
function Wl() {
  return Ai || (Ai = 1, Ga = function(e, t, i) {
    var r = " ", s = e.level, o = e.dataLevel, n = e.schema[t], f = e.schemaPath + e.util.getProperty(t), d = e.errSchemaPath + "/" + t, c = !e.opts.allErrors, u = "data" + (o || ""), p = "errs__" + s, l = e.util.copy(e), h = "";
    l.level++;
    var g = "valid" + l.level, v = "key" + s, S = "idx" + s, A = l.dataLevel = e.dataLevel + 1, C = "data" + A, P = "dataProperties" + s, E = Object.keys(n || {}).filter(ee), D = e.schema.patternProperties || {}, I = Object.keys(D).filter(ee), R = e.schema.additionalProperties, O = E.length || I.length, w = R === !1, x = typeof R == "object" && Object.keys(R).length, _ = e.opts.removeAdditional, k = w || x || _, q = e.opts.ownProperties, z = e.baseId, Y = e.schema.required;
    if (Y && !(e.opts.$data && Y.$data) && Y.length < e.opts.loopRequired)
      var G = e.util.toHash(Y);
    function ee(fa) {
      return fa !== "__proto__";
    }
    if (r += "var " + p + " = errors;var " + g + " = true;", q && (r += " var " + P + " = undefined;"), k) {
      if (q ? r += " " + P + " = " + P + " || Object.keys(" + u + "); for (var " + S + "=0; " + S + "<" + P + ".length; " + S + "++) { var " + v + " = " + P + "[" + S + "]; " : r += " for (var " + v + " in " + u + ") { ", O) {
        if (r += " var isAdditional" + s + " = !(false ", E.length)
          if (E.length > 8)
            r += " || validate.schema" + f + ".hasOwnProperty(" + v + ") ";
          else {
            var K = E;
            if (K)
              for (var J, Le = -1, Ae = K.length - 1; Le < Ae; )
                J = K[Le += 1], r += " || " + v + " == " + e.util.toQuotedString(J) + " ";
          }
        if (I.length) {
          var Fe = I;
          if (Fe)
            for (var be, Be = -1, F = Fe.length - 1; Be < F; )
              be = Fe[Be += 1], r += " || " + e.usePattern(be) + ".test(" + v + ") ";
        }
        r += " ); if (isAdditional" + s + ") { ";
      }
      if (_ == "all")
        r += " delete " + u + "[" + v + "]; ";
      else {
        var N = e.errorPath, V = "' + " + v + " + '";
        if (e.opts._errorDataPathProperty && (e.errorPath = e.util.getPathExpr(e.errorPath, v, e.opts.jsonPointers)), w)
          if (_)
            r += " delete " + u + "[" + v + "]; ";
          else {
            r += " " + g + " = false; ";
            var W = d;
            d = e.errSchemaPath + "/additionalProperties";
            var B = B || [];
            B.push(r), r = "", e.createErrors !== !1 ? (r += " { keyword: 'additionalProperties' , dataPath: (dataPath || '') + " + e.errorPath + " , schemaPath: " + e.util.toQuotedString(d) + " , params: { additionalProperty: '" + V + "' } ", e.opts.messages !== !1 && (r += " , message: '", e.opts._errorDataPathProperty ? r += "is an invalid additional property" : r += "should NOT have additional properties", r += "' "), e.opts.verbose && (r += " , schema: false , parentSchema: validate.schema" + e.schemaPath + " , data: " + u + " "), r += " } ") : r += " {} ";
            var j = r;
            r = B.pop(), !e.compositeRule && c ? e.async ? r += " throw new ValidationError([" + j + "]); " : r += " validate.errors = [" + j + "]; return false; " : r += " var err = " + j + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ", d = W, c && (r += " break; ");
          }
        else if (x)
          if (_ == "failing") {
            r += " var " + p + " = errors;  ";
            var Z = e.compositeRule;
            e.compositeRule = l.compositeRule = !0, l.schema = R, l.schemaPath = e.schemaPath + ".additionalProperties", l.errSchemaPath = e.errSchemaPath + "/additionalProperties", l.errorPath = e.opts._errorDataPathProperty ? e.errorPath : e.util.getPathExpr(e.errorPath, v, e.opts.jsonPointers);
            var ae = u + "[" + v + "]";
            l.dataPathArr[A] = v;
            var re = e.validate(l);
            l.baseId = z, e.util.varOccurences(re, C) < 2 ? r += " " + e.util.varReplace(re, C, ae) + " " : r += " var " + C + " = " + ae + "; " + re + " ", r += " if (!" + g + ") { errors = " + p + "; if (validate.errors !== null) { if (errors) validate.errors.length = errors; else validate.errors = null; } delete " + u + "[" + v + "]; }  ", e.compositeRule = l.compositeRule = Z;
          } else {
            l.schema = R, l.schemaPath = e.schemaPath + ".additionalProperties", l.errSchemaPath = e.errSchemaPath + "/additionalProperties", l.errorPath = e.opts._errorDataPathProperty ? e.errorPath : e.util.getPathExpr(e.errorPath, v, e.opts.jsonPointers);
            var ae = u + "[" + v + "]";
            l.dataPathArr[A] = v;
            var re = e.validate(l);
            l.baseId = z, e.util.varOccurences(re, C) < 2 ? r += " " + e.util.varReplace(re, C, ae) + " " : r += " var " + C + " = " + ae + "; " + re + " ", c && (r += " if (!" + g + ") break; ");
          }
        e.errorPath = N;
      }
      O && (r += " } "), r += " }  ", c && (r += " if (" + g + ") { ", h += "}");
    }
    var he = e.opts.useDefaults && !e.compositeRule;
    if (E.length) {
      var oe = E;
      if (oe)
        for (var J, le = -1, De = oe.length - 1; le < De; ) {
          J = oe[le += 1];
          var ve = n[J];
          if (e.opts.strictKeywords ? typeof ve == "object" && Object.keys(ve).length > 0 || ve === !1 : e.util.schemaHasRules(ve, e.RULES.all)) {
            var Me = e.util.getProperty(J), ae = u + Me, Ie = he && ve.default !== void 0;
            l.schema = ve, l.schemaPath = f + Me, l.errSchemaPath = d + "/" + e.util.escapeFragment(J), l.errorPath = e.util.getPath(e.errorPath, J, e.opts.jsonPointers), l.dataPathArr[A] = e.util.toQuotedString(J);
            var re = e.validate(l);
            if (l.baseId = z, e.util.varOccurences(re, C) < 2) {
              re = e.util.varReplace(re, C, ae);
              var ye = ae;
            } else {
              var ye = C;
              r += " var " + C + " = " + ae + "; ";
            }
            if (Ie)
              r += " " + re + " ";
            else {
              if (G && G[J]) {
                r += " if ( " + ye + " === undefined ", q && (r += " || ! Object.prototype.hasOwnProperty.call(" + u + ", '" + e.util.escapeQuotes(J) + "') "), r += ") { " + g + " = false; ";
                var N = e.errorPath, W = d, Pe = e.util.escapeQuotes(J);
                e.opts._errorDataPathProperty && (e.errorPath = e.util.getPath(N, J, e.opts.jsonPointers)), d = e.errSchemaPath + "/required";
                var B = B || [];
                B.push(r), r = "", e.createErrors !== !1 ? (r += " { keyword: 'required' , dataPath: (dataPath || '') + " + e.errorPath + " , schemaPath: " + e.util.toQuotedString(d) + " , params: { missingProperty: '" + Pe + "' } ", e.opts.messages !== !1 && (r += " , message: '", e.opts._errorDataPathProperty ? r += "is a required property" : r += "should have required property \\'" + Pe + "\\'", r += "' "), e.opts.verbose && (r += " , schema: validate.schema" + f + " , parentSchema: validate.schema" + e.schemaPath + " , data: " + u + " "), r += " } ") : r += " {} ";
                var j = r;
                r = B.pop(), !e.compositeRule && c ? e.async ? r += " throw new ValidationError([" + j + "]); " : r += " validate.errors = [" + j + "]; return false; " : r += " var err = " + j + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ", d = W, e.errorPath = N, r += " } else { ";
              } else
                c ? (r += " if ( " + ye + " === undefined ", q && (r += " || ! Object.prototype.hasOwnProperty.call(" + u + ", '" + e.util.escapeQuotes(J) + "') "), r += ") { " + g + " = true; } else { ") : (r += " if (" + ye + " !== undefined ", q && (r += " &&   Object.prototype.hasOwnProperty.call(" + u + ", '" + e.util.escapeQuotes(J) + "') "), r += " ) { ");
              r += " " + re + " } ";
            }
          }
          c && (r += " if (" + g + ") { ", h += "}");
        }
    }
    if (I.length) {
      var _e = I;
      if (_e)
        for (var be, zr = -1, ca = _e.length - 1; zr < ca; ) {
          be = _e[zr += 1];
          var ve = D[be];
          if (e.opts.strictKeywords ? typeof ve == "object" && Object.keys(ve).length > 0 || ve === !1 : e.util.schemaHasRules(ve, e.RULES.all)) {
            l.schema = ve, l.schemaPath = e.schemaPath + ".patternProperties" + e.util.getProperty(be), l.errSchemaPath = e.errSchemaPath + "/patternProperties/" + e.util.escapeFragment(be), q ? r += " " + P + " = " + P + " || Object.keys(" + u + "); for (var " + S + "=0; " + S + "<" + P + ".length; " + S + "++) { var " + v + " = " + P + "[" + S + "]; " : r += " for (var " + v + " in " + u + ") { ", r += " if (" + e.usePattern(be) + ".test(" + v + ")) { ", l.errorPath = e.util.getPathExpr(e.errorPath, v, e.opts.jsonPointers);
            var ae = u + "[" + v + "]";
            l.dataPathArr[A] = v;
            var re = e.validate(l);
            l.baseId = z, e.util.varOccurences(re, C) < 2 ? r += " " + e.util.varReplace(re, C, ae) + " " : r += " var " + C + " = " + ae + "; " + re + " ", c && (r += " if (!" + g + ") break; "), r += " } ", c && (r += " else " + g + " = true; "), r += " }  ", c && (r += " if (" + g + ") { ", h += "}");
          }
        }
    }
    return c && (r += " " + h + " if (" + p + " == errors) {"), r;
  }), Ga;
}
var Wa, Di;
function Kl() {
  return Di || (Di = 1, Wa = function(e, t, i) {
    var r = " ", s = e.level, o = e.dataLevel, n = e.schema[t], f = e.schemaPath + e.util.getProperty(t), d = e.errSchemaPath + "/" + t, c = !e.opts.allErrors, u = "data" + (o || ""), p = "errs__" + s, l = e.util.copy(e), h = "";
    l.level++;
    var g = "valid" + l.level;
    if (r += "var " + p + " = errors;", e.opts.strictKeywords ? typeof n == "object" && Object.keys(n).length > 0 || n === !1 : e.util.schemaHasRules(n, e.RULES.all)) {
      l.schema = n, l.schemaPath = f, l.errSchemaPath = d;
      var v = "key" + s, S = "idx" + s, A = "i" + s, C = "' + " + v + " + '", P = l.dataLevel = e.dataLevel + 1, E = "data" + P, D = "dataProperties" + s, I = e.opts.ownProperties, R = e.baseId;
      I && (r += " var " + D + " = undefined; "), I ? r += " " + D + " = " + D + " || Object.keys(" + u + "); for (var " + S + "=0; " + S + "<" + D + ".length; " + S + "++) { var " + v + " = " + D + "[" + S + "]; " : r += " for (var " + v + " in " + u + ") { ", r += " var startErrs" + s + " = errors; ";
      var O = v, w = e.compositeRule;
      e.compositeRule = l.compositeRule = !0;
      var x = e.validate(l);
      l.baseId = R, e.util.varOccurences(x, E) < 2 ? r += " " + e.util.varReplace(x, E, O) + " " : r += " var " + E + " = " + O + "; " + x + " ", e.compositeRule = l.compositeRule = w, r += " if (!" + g + ") { for (var " + A + "=startErrs" + s + "; " + A + "<errors; " + A + "++) { vErrors[" + A + "].propertyName = " + v + "; }   var err =   ", e.createErrors !== !1 ? (r += " { keyword: 'propertyNames' , dataPath: (dataPath || '') + " + e.errorPath + " , schemaPath: " + e.util.toQuotedString(d) + " , params: { propertyName: '" + C + "' } ", e.opts.messages !== !1 && (r += " , message: 'property name \\'" + C + "\\' is invalid' "), e.opts.verbose && (r += " , schema: validate.schema" + f + " , parentSchema: validate.schema" + e.schemaPath + " , data: " + u + " "), r += " } ") : r += " {} ", r += ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ", !e.compositeRule && c && (e.async ? r += " throw new ValidationError(vErrors); " : r += " validate.errors = vErrors; return false; "), c && (r += " break; "), r += " } }";
    }
    return c && (r += " " + h + " if (" + p + " == errors) {"), r;
  }), Wa;
}
var Ka, Ti;
function Jl() {
  return Ti || (Ti = 1, Ka = function(e, t, i) {
    var r = " ", s = e.level, o = e.dataLevel, n = e.schema[t], f = e.schemaPath + e.util.getProperty(t), d = e.errSchemaPath + "/" + t, c = !e.opts.allErrors, u = "data" + (o || ""), p = "valid" + s, l = e.opts.$data && n && n.$data;
    l && (r += " var schema" + s + " = " + e.util.getData(n.$data, o, e.dataPathArr) + "; ");
    var h = "schema" + s;
    if (!l)
      if (n.length < e.opts.loopRequired && e.schema.properties && Object.keys(e.schema.properties).length) {
        var g = [], v = n;
        if (v)
          for (var S, A = -1, C = v.length - 1; A < C; ) {
            S = v[A += 1];
            var P = e.schema.properties[S];
            P && (e.opts.strictKeywords ? typeof P == "object" && Object.keys(P).length > 0 || P === !1 : e.util.schemaHasRules(P, e.RULES.all)) || (g[g.length] = S);
          }
      } else
        var g = n;
    if (l || g.length) {
      var E = e.errorPath, D = l || g.length >= e.opts.loopRequired, I = e.opts.ownProperties;
      if (c)
        if (r += " var missing" + s + "; ", D) {
          l || (r += " var " + h + " = validate.schema" + f + "; ");
          var R = "i" + s, O = "schema" + s + "[" + R + "]", w = "' + " + O + " + '";
          e.opts._errorDataPathProperty && (e.errorPath = e.util.getPathExpr(E, O, e.opts.jsonPointers)), r += " var " + p + " = true; ", l && (r += " if (schema" + s + " === undefined) " + p + " = true; else if (!Array.isArray(schema" + s + ")) " + p + " = false; else {"), r += " for (var " + R + " = 0; " + R + " < " + h + ".length; " + R + "++) { " + p + " = " + u + "[" + h + "[" + R + "]] !== undefined ", I && (r += " &&   Object.prototype.hasOwnProperty.call(" + u + ", " + h + "[" + R + "]) "), r += "; if (!" + p + ") break; } ", l && (r += "  }  "), r += "  if (!" + p + ") {   ";
          var x = x || [];
          x.push(r), r = "", e.createErrors !== !1 ? (r += " { keyword: 'required' , dataPath: (dataPath || '') + " + e.errorPath + " , schemaPath: " + e.util.toQuotedString(d) + " , params: { missingProperty: '" + w + "' } ", e.opts.messages !== !1 && (r += " , message: '", e.opts._errorDataPathProperty ? r += "is a required property" : r += "should have required property \\'" + w + "\\'", r += "' "), e.opts.verbose && (r += " , schema: validate.schema" + f + " , parentSchema: validate.schema" + e.schemaPath + " , data: " + u + " "), r += " } ") : r += " {} ";
          var _ = r;
          r = x.pop(), !e.compositeRule && c ? e.async ? r += " throw new ValidationError([" + _ + "]); " : r += " validate.errors = [" + _ + "]; return false; " : r += " var err = " + _ + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ", r += " } else { ";
        } else {
          r += " if ( ";
          var k = g;
          if (k)
            for (var q, R = -1, z = k.length - 1; R < z; ) {
              q = k[R += 1], R && (r += " || ");
              var Y = e.util.getProperty(q), G = u + Y;
              r += " ( ( " + G + " === undefined ", I && (r += " || ! Object.prototype.hasOwnProperty.call(" + u + ", '" + e.util.escapeQuotes(q) + "') "), r += ") && (missing" + s + " = " + e.util.toQuotedString(e.opts.jsonPointers ? q : Y) + ") ) ";
            }
          r += ") {  ";
          var O = "missing" + s, w = "' + " + O + " + '";
          e.opts._errorDataPathProperty && (e.errorPath = e.opts.jsonPointers ? e.util.getPathExpr(E, O, !0) : E + " + " + O);
          var x = x || [];
          x.push(r), r = "", e.createErrors !== !1 ? (r += " { keyword: 'required' , dataPath: (dataPath || '') + " + e.errorPath + " , schemaPath: " + e.util.toQuotedString(d) + " , params: { missingProperty: '" + w + "' } ", e.opts.messages !== !1 && (r += " , message: '", e.opts._errorDataPathProperty ? r += "is a required property" : r += "should have required property \\'" + w + "\\'", r += "' "), e.opts.verbose && (r += " , schema: validate.schema" + f + " , parentSchema: validate.schema" + e.schemaPath + " , data: " + u + " "), r += " } ") : r += " {} ";
          var _ = r;
          r = x.pop(), !e.compositeRule && c ? e.async ? r += " throw new ValidationError([" + _ + "]); " : r += " validate.errors = [" + _ + "]; return false; " : r += " var err = " + _ + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ", r += " } else { ";
        }
      else if (D) {
        l || (r += " var " + h + " = validate.schema" + f + "; ");
        var R = "i" + s, O = "schema" + s + "[" + R + "]", w = "' + " + O + " + '";
        e.opts._errorDataPathProperty && (e.errorPath = e.util.getPathExpr(E, O, e.opts.jsonPointers)), l && (r += " if (" + h + " && !Array.isArray(" + h + ")) {  var err =   ", e.createErrors !== !1 ? (r += " { keyword: 'required' , dataPath: (dataPath || '') + " + e.errorPath + " , schemaPath: " + e.util.toQuotedString(d) + " , params: { missingProperty: '" + w + "' } ", e.opts.messages !== !1 && (r += " , message: '", e.opts._errorDataPathProperty ? r += "is a required property" : r += "should have required property \\'" + w + "\\'", r += "' "), e.opts.verbose && (r += " , schema: validate.schema" + f + " , parentSchema: validate.schema" + e.schemaPath + " , data: " + u + " "), r += " } ") : r += " {} ", r += ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; } else if (" + h + " !== undefined) { "), r += " for (var " + R + " = 0; " + R + " < " + h + ".length; " + R + "++) { if (" + u + "[" + h + "[" + R + "]] === undefined ", I && (r += " || ! Object.prototype.hasOwnProperty.call(" + u + ", " + h + "[" + R + "]) "), r += ") {  var err =   ", e.createErrors !== !1 ? (r += " { keyword: 'required' , dataPath: (dataPath || '') + " + e.errorPath + " , schemaPath: " + e.util.toQuotedString(d) + " , params: { missingProperty: '" + w + "' } ", e.opts.messages !== !1 && (r += " , message: '", e.opts._errorDataPathProperty ? r += "is a required property" : r += "should have required property \\'" + w + "\\'", r += "' "), e.opts.verbose && (r += " , schema: validate.schema" + f + " , parentSchema: validate.schema" + e.schemaPath + " , data: " + u + " "), r += " } ") : r += " {} ", r += ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; } } ", l && (r += "  }  ");
      } else {
        var ee = g;
        if (ee)
          for (var q, K = -1, J = ee.length - 1; K < J; ) {
            q = ee[K += 1];
            var Y = e.util.getProperty(q), w = e.util.escapeQuotes(q), G = u + Y;
            e.opts._errorDataPathProperty && (e.errorPath = e.util.getPath(E, q, e.opts.jsonPointers)), r += " if ( " + G + " === undefined ", I && (r += " || ! Object.prototype.hasOwnProperty.call(" + u + ", '" + e.util.escapeQuotes(q) + "') "), r += ") {  var err =   ", e.createErrors !== !1 ? (r += " { keyword: 'required' , dataPath: (dataPath || '') + " + e.errorPath + " , schemaPath: " + e.util.toQuotedString(d) + " , params: { missingProperty: '" + w + "' } ", e.opts.messages !== !1 && (r += " , message: '", e.opts._errorDataPathProperty ? r += "is a required property" : r += "should have required property \\'" + w + "\\'", r += "' "), e.opts.verbose && (r += " , schema: validate.schema" + f + " , parentSchema: validate.schema" + e.schemaPath + " , data: " + u + " "), r += " } ") : r += " {} ", r += ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; } ";
          }
      }
      e.errorPath = E;
    } else c && (r += " if (true) {");
    return r;
  }), Ka;
}
var Ja, Li;
function Xl() {
  return Li || (Li = 1, Ja = function(e, t, i) {
    var r = " ", s = e.level, o = e.dataLevel, n = e.schema[t], f = e.schemaPath + e.util.getProperty(t), d = e.errSchemaPath + "/" + t, c = !e.opts.allErrors, u = "data" + (o || ""), p = "valid" + s, l = e.opts.$data && n && n.$data, h;
    if (l ? (r += " var schema" + s + " = " + e.util.getData(n.$data, o, e.dataPathArr) + "; ", h = "schema" + s) : h = n, (n || l) && e.opts.uniqueItems !== !1) {
      l && (r += " var " + p + "; if (" + h + " === false || " + h + " === undefined) " + p + " = true; else if (typeof " + h + " != 'boolean') " + p + " = false; else { "), r += " var i = " + u + ".length , " + p + " = true , j; if (i > 1) { ";
      var g = e.schema.items && e.schema.items.type, v = Array.isArray(g);
      if (!g || g == "object" || g == "array" || v && (g.indexOf("object") >= 0 || g.indexOf("array") >= 0))
        r += " outer: for (;i--;) { for (j = i; j--;) { if (equal(" + u + "[i], " + u + "[j])) { " + p + " = false; break outer; } } } ";
      else {
        r += " var itemIndices = {}, item; for (;i--;) { var item = " + u + "[i]; ";
        var S = "checkDataType" + (v ? "s" : "");
        r += " if (" + e.util[S](g, "item", e.opts.strictNumbers, !0) + ") continue; ", v && (r += ` if (typeof item == 'string') item = '"' + item; `), r += " if (typeof itemIndices[item] == 'number') { " + p + " = false; j = itemIndices[item]; break; } itemIndices[item] = i; } ";
      }
      r += " } ", l && (r += "  }  "), r += " if (!" + p + ") {   ";
      var A = A || [];
      A.push(r), r = "", e.createErrors !== !1 ? (r += " { keyword: 'uniqueItems' , dataPath: (dataPath || '') + " + e.errorPath + " , schemaPath: " + e.util.toQuotedString(d) + " , params: { i: i, j: j } ", e.opts.messages !== !1 && (r += " , message: 'should NOT have duplicate items (items ## ' + j + ' and ' + i + ' are identical)' "), e.opts.verbose && (r += " , schema:  ", l ? r += "validate.schema" + f : r += "" + n, r += "         , parentSchema: validate.schema" + e.schemaPath + " , data: " + u + " "), r += " } ") : r += " {} ";
      var C = r;
      r = A.pop(), !e.compositeRule && c ? e.async ? r += " throw new ValidationError([" + C + "]); " : r += " validate.errors = [" + C + "]; return false; " : r += " var err = " + C + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ", r += " } ", c && (r += " else { ");
    } else
      c && (r += " if (true) { ");
    return r;
  }), Ja;
}
var Xa, Ii;
function Yl() {
  return Ii || (Ii = 1, Xa = {
    $ref: $l(),
    allOf: Ol(),
    anyOf: _l(),
    $comment: Nl(),
    const: Bl(),
    contains: kl(),
    dependencies: ql(),
    enum: Ml(),
    format: jl(),
    if: Vl(),
    items: zl(),
    maximum: vi(),
    minimum: vi(),
    maxItems: yi(),
    minItems: yi(),
    maxLength: bi(),
    minLength: bi(),
    maxProperties: wi(),
    minProperties: wi(),
    multipleOf: Ul(),
    not: Ql(),
    oneOf: Hl(),
    pattern: Gl(),
    properties: Wl(),
    propertyNames: Kl(),
    required: Jl(),
    uniqueItems: Xl(),
    validate: ws()
  }), Xa;
}
var Ya, Ri;
function Zl() {
  if (Ri) return Ya;
  Ri = 1;
  var a = Yl(), e = Cr().toHash;
  return Ya = function() {
    var i = [
      {
        type: "number",
        rules: [
          { maximum: ["exclusiveMaximum"] },
          { minimum: ["exclusiveMinimum"] },
          "multipleOf",
          "format"
        ]
      },
      {
        type: "string",
        rules: ["maxLength", "minLength", "pattern", "format"]
      },
      {
        type: "array",
        rules: ["maxItems", "minItems", "items", "contains", "uniqueItems"]
      },
      {
        type: "object",
        rules: [
          "maxProperties",
          "minProperties",
          "required",
          "dependencies",
          "propertyNames",
          { properties: ["additionalProperties", "patternProperties"] }
        ]
      },
      { rules: ["$ref", "const", "enum", "not", "anyOf", "oneOf", "allOf", "if"] }
    ], r = ["type", "$comment"], s = [
      "$schema",
      "$id",
      "id",
      "$data",
      "$async",
      "title",
      "description",
      "default",
      "definitions",
      "examples",
      "readOnly",
      "writeOnly",
      "contentMediaType",
      "contentEncoding",
      "additionalItems",
      "then",
      "else"
    ], o = ["number", "integer", "string", "array", "object", "boolean", "null"];
    return i.all = e(r), i.types = e(o), i.forEach(function(n) {
      n.rules = n.rules.map(function(f) {
        var d;
        if (typeof f == "object") {
          var c = Object.keys(f)[0];
          d = f[c], f = c, d.forEach(function(p) {
            r.push(p), i.all[p] = !0;
          });
        }
        r.push(f);
        var u = i.all[f] = {
          keyword: f,
          code: a[f],
          implements: d
        };
        return u;
      }), i.all.$comment = {
        keyword: "$comment",
        code: a.$comment
      }, n.type && (i.types[n.type] = n);
    }), i.keywords = e(r.concat(s)), i.custom = {}, i;
  }, Ya;
}
var Za, $i;
function eu() {
  if ($i) return Za;
  $i = 1;
  var a = [
    "multipleOf",
    "maximum",
    "exclusiveMaximum",
    "minimum",
    "exclusiveMinimum",
    "maxLength",
    "minLength",
    "pattern",
    "additionalItems",
    "maxItems",
    "minItems",
    "uniqueItems",
    "maxProperties",
    "minProperties",
    "required",
    "additionalProperties",
    "enum",
    "format",
    "const"
  ];
  return Za = function(e, t) {
    for (var i = 0; i < t.length; i++) {
      e = JSON.parse(JSON.stringify(e));
      var r = t[i].split("/"), s = e, o;
      for (o = 1; o < r.length; o++)
        s = s[r[o]];
      for (o = 0; o < a.length; o++) {
        var n = a[o], f = s[n];
        f && (s[n] = {
          anyOf: [
            f,
            { $ref: "https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#" }
          ]
        });
      }
    }
    return e;
  }, Za;
}
var et, Oi;
function ru() {
  if (Oi) return et;
  Oi = 1;
  var a = Pt().MissingRef;
  et = e;
  function e(t, i, r) {
    var s = this;
    if (typeof this._opts.loadSchema != "function")
      throw new Error("options.loadSchema should be a function");
    typeof i == "function" && (r = i, i = void 0);
    var o = n(t).then(function() {
      var d = s._addSchema(t, void 0, i);
      return d.validate || f(d);
    });
    return r && o.then(
      function(d) {
        r(null, d);
      },
      r
    ), o;
    function n(d) {
      var c = d.$schema;
      return c && !s.getSchema(c) ? e.call(s, { $ref: c }, !0) : Promise.resolve();
    }
    function f(d) {
      try {
        return s._compile(d);
      } catch (u) {
        if (u instanceof a) return c(u);
        throw u;
      }
      function c(u) {
        var p = u.missingSchema;
        if (g(p)) throw new Error("Schema " + p + " is loaded but " + u.missingRef + " cannot be resolved");
        var l = s._loadingSchemas[p];
        return l || (l = s._loadingSchemas[p] = s._opts.loadSchema(p), l.then(h, h)), l.then(function(v) {
          if (!g(p))
            return n(v).then(function() {
              g(p) || s.addSchema(v, p, void 0, i);
            });
        }).then(function() {
          return f(d);
        });
        function h() {
          delete s._loadingSchemas[p];
        }
        function g(v) {
          return s._refs[v] || s._schemas[v];
        }
      }
    }
  }
  return et;
}
var rt, _i;
function au() {
  return _i || (_i = 1, rt = function(e, t, i) {
    var r = " ", s = e.level, o = e.dataLevel, n = e.schema[t], f = e.schemaPath + e.util.getProperty(t), d = e.errSchemaPath + "/" + t, c = !e.opts.allErrors, u, p = "data" + (o || ""), l = "valid" + s, h = "errs__" + s, g = e.opts.$data && n && n.$data, v;
    g ? (r += " var schema" + s + " = " + e.util.getData(n.$data, o, e.dataPathArr) + "; ", v = "schema" + s) : v = n;
    var S = this, A = "definition" + s, C = S.definition, P = "", E, D, I, R, O;
    if (g && C.$data) {
      O = "keywordValidate" + s;
      var w = C.validateSchema;
      r += " var " + A + " = RULES.custom['" + t + "'].definition; var " + O + " = " + A + ".validate;";
    } else {
      if (R = e.useCustomRule(S, n, e.schema, e), !R) return;
      v = "validate.schema" + f, O = R.code, E = C.compile, D = C.inline, I = C.macro;
    }
    var x = O + ".errors", _ = "i" + s, k = "ruleErr" + s, q = C.async;
    if (q && !e.async) throw new Error("async keyword in sync schema");
    if (D || I || (r += "" + x + " = null;"), r += "var " + h + " = errors;var " + l + ";", g && C.$data && (P += "}", r += " if (" + v + " === undefined) { " + l + " = true; } else { ", w && (P += "}", r += " " + l + " = " + A + ".validateSchema(" + v + "); if (" + l + ") { ")), D)
      C.statements ? r += " " + R.validate + " " : r += " " + l + " = " + R.validate + "; ";
    else if (I) {
      var z = e.util.copy(e), P = "";
      z.level++;
      var Y = "valid" + z.level;
      z.schema = R.validate, z.schemaPath = "";
      var G = e.compositeRule;
      e.compositeRule = z.compositeRule = !0;
      var ee = e.validate(z).replace(/validate\.schema/g, O);
      e.compositeRule = z.compositeRule = G, r += " " + ee;
    } else {
      var K = K || [];
      K.push(r), r = "", r += "  " + O + ".call( ", e.opts.passContext ? r += "this" : r += "self", E || C.schema === !1 ? r += " , " + p + " " : r += " , " + v + " , " + p + " , validate.schema" + e.schemaPath + " ", r += " , (dataPath || '')", e.errorPath != '""' && (r += " + " + e.errorPath);
      var J = o ? "data" + (o - 1 || "") : "parentData", Le = o ? e.dataPathArr[o] : "parentDataProperty";
      r += " , " + J + " , " + Le + " , rootData )  ";
      var Ae = r;
      r = K.pop(), C.errors === !1 ? (r += " " + l + " = ", q && (r += "await "), r += "" + Ae + "; ") : q ? (x = "customErrors" + s, r += " var " + x + " = null; try { " + l + " = await " + Ae + "; } catch (e) { " + l + " = false; if (e instanceof ValidationError) " + x + " = e.errors; else throw e; } ") : r += " " + x + " = null; " + l + " = " + Ae + "; ";
    }
    if (C.modifying && (r += " if (" + J + ") " + p + " = " + J + "[" + Le + "];"), r += "" + P, C.valid)
      c && (r += " if (true) { ");
    else {
      r += " if ( ", C.valid === void 0 ? (r += " !", I ? r += "" + Y : r += "" + l) : r += " " + !C.valid + " ", r += ") { ", u = S.keyword;
      var K = K || [];
      K.push(r), r = "";
      var K = K || [];
      K.push(r), r = "", e.createErrors !== !1 ? (r += " { keyword: '" + (u || "custom") + "' , dataPath: (dataPath || '') + " + e.errorPath + " , schemaPath: " + e.util.toQuotedString(d) + " , params: { keyword: '" + S.keyword + "' } ", e.opts.messages !== !1 && (r += ` , message: 'should pass "` + S.keyword + `" keyword validation' `), e.opts.verbose && (r += " , schema: validate.schema" + f + " , parentSchema: validate.schema" + e.schemaPath + " , data: " + p + " "), r += " } ") : r += " {} ";
      var Fe = r;
      r = K.pop(), !e.compositeRule && c ? e.async ? r += " throw new ValidationError([" + Fe + "]); " : r += " validate.errors = [" + Fe + "]; return false; " : r += " var err = " + Fe + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
      var be = r;
      r = K.pop(), D ? C.errors ? C.errors != "full" && (r += "  for (var " + _ + "=" + h + "; " + _ + "<errors; " + _ + "++) { var " + k + " = vErrors[" + _ + "]; if (" + k + ".dataPath === undefined) " + k + ".dataPath = (dataPath || '') + " + e.errorPath + "; if (" + k + ".schemaPath === undefined) { " + k + '.schemaPath = "' + d + '"; } ', e.opts.verbose && (r += " " + k + ".schema = " + v + "; " + k + ".data = " + p + "; "), r += " } ") : C.errors === !1 ? r += " " + be + " " : (r += " if (" + h + " == errors) { " + be + " } else {  for (var " + _ + "=" + h + "; " + _ + "<errors; " + _ + "++) { var " + k + " = vErrors[" + _ + "]; if (" + k + ".dataPath === undefined) " + k + ".dataPath = (dataPath || '') + " + e.errorPath + "; if (" + k + ".schemaPath === undefined) { " + k + '.schemaPath = "' + d + '"; } ', e.opts.verbose && (r += " " + k + ".schema = " + v + "; " + k + ".data = " + p + "; "), r += " } } ") : I ? (r += "   var err =   ", e.createErrors !== !1 ? (r += " { keyword: '" + (u || "custom") + "' , dataPath: (dataPath || '') + " + e.errorPath + " , schemaPath: " + e.util.toQuotedString(d) + " , params: { keyword: '" + S.keyword + "' } ", e.opts.messages !== !1 && (r += ` , message: 'should pass "` + S.keyword + `" keyword validation' `), e.opts.verbose && (r += " , schema: validate.schema" + f + " , parentSchema: validate.schema" + e.schemaPath + " , data: " + p + " "), r += " } ") : r += " {} ", r += ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ", !e.compositeRule && c && (e.async ? r += " throw new ValidationError(vErrors); " : r += " validate.errors = vErrors; return false; ")) : C.errors === !1 ? r += " " + be + " " : (r += " if (Array.isArray(" + x + ")) { if (vErrors === null) vErrors = " + x + "; else vErrors = vErrors.concat(" + x + "); errors = vErrors.length;  for (var " + _ + "=" + h + "; " + _ + "<errors; " + _ + "++) { var " + k + " = vErrors[" + _ + "]; if (" + k + ".dataPath === undefined) " + k + ".dataPath = (dataPath || '') + " + e.errorPath + ";  " + k + '.schemaPath = "' + d + '";  ', e.opts.verbose && (r += " " + k + ".schema = " + v + "; " + k + ".data = " + p + "; "), r += " } } else { " + be + " } "), r += " } ", c && (r += " else { ");
    }
    return r;
  }), rt;
}
const tu = "http://json-schema.org/draft-07/schema#", iu = "http://json-schema.org/draft-07/schema#", su = "Core schema meta-schema", nu = { schemaArray: { type: "array", minItems: 1, items: { $ref: "#" } }, nonNegativeInteger: { type: "integer", minimum: 0 }, nonNegativeIntegerDefault0: { allOf: [{ $ref: "#/definitions/nonNegativeInteger" }, { default: 0 }] }, simpleTypes: { enum: ["array", "boolean", "integer", "null", "number", "object", "string"] }, stringArray: { type: "array", items: { type: "string" }, uniqueItems: !0, default: [] } }, ou = ["object", "boolean"], lu = { $id: { type: "string", format: "uri-reference" }, $schema: { type: "string", format: "uri" }, $ref: { type: "string", format: "uri-reference" }, $comment: { type: "string" }, title: { type: "string" }, description: { type: "string" }, default: !0, readOnly: { type: "boolean", default: !1 }, examples: { type: "array", items: !0 }, multipleOf: { type: "number", exclusiveMinimum: 0 }, maximum: { type: "number" }, exclusiveMaximum: { type: "number" }, minimum: { type: "number" }, exclusiveMinimum: { type: "number" }, maxLength: { $ref: "#/definitions/nonNegativeInteger" }, minLength: { $ref: "#/definitions/nonNegativeIntegerDefault0" }, pattern: { type: "string", format: "regex" }, additionalItems: { $ref: "#" }, items: { anyOf: [{ $ref: "#" }, { $ref: "#/definitions/schemaArray" }], default: !0 }, maxItems: { $ref: "#/definitions/nonNegativeInteger" }, minItems: { $ref: "#/definitions/nonNegativeIntegerDefault0" }, uniqueItems: { type: "boolean", default: !1 }, contains: { $ref: "#" }, maxProperties: { $ref: "#/definitions/nonNegativeInteger" }, minProperties: { $ref: "#/definitions/nonNegativeIntegerDefault0" }, required: { $ref: "#/definitions/stringArray" }, additionalProperties: { $ref: "#" }, definitions: { type: "object", additionalProperties: { $ref: "#" }, default: {} }, properties: { type: "object", additionalProperties: { $ref: "#" }, default: {} }, patternProperties: { type: "object", additionalProperties: { $ref: "#" }, propertyNames: { format: "regex" }, default: {} }, dependencies: { type: "object", additionalProperties: { anyOf: [{ $ref: "#" }, { $ref: "#/definitions/stringArray" }] } }, propertyNames: { $ref: "#" }, const: !0, enum: { type: "array", items: !0, minItems: 1, uniqueItems: !0 }, type: { anyOf: [{ $ref: "#/definitions/simpleTypes" }, { type: "array", items: { $ref: "#/definitions/simpleTypes" }, minItems: 1, uniqueItems: !0 }] }, format: { type: "string" }, contentMediaType: { type: "string" }, contentEncoding: { type: "string" }, if: { $ref: "#" }, then: { $ref: "#" }, else: { $ref: "#" }, allOf: { $ref: "#/definitions/schemaArray" }, anyOf: { $ref: "#/definitions/schemaArray" }, oneOf: { $ref: "#/definitions/schemaArray" }, not: { $ref: "#" } }, Es = {
  $schema: tu,
  $id: iu,
  title: su,
  definitions: nu,
  type: ou,
  properties: lu,
  default: !0
};
var at, Ni;
function uu() {
  if (Ni) return at;
  Ni = 1;
  var a = Es;
  return at = {
    $id: "https://github.com/ajv-validator/ajv/blob/master/lib/definition_schema.js",
    definitions: {
      simpleTypes: a.definitions.simpleTypes
    },
    type: "object",
    dependencies: {
      schema: ["validate"],
      $data: ["validate"],
      statements: ["inline"],
      valid: { not: { required: ["macro"] } }
    },
    properties: {
      type: a.properties.type,
      schema: { type: "boolean" },
      statements: { type: "boolean" },
      dependencies: {
        type: "array",
        items: { type: "string" }
      },
      metaSchema: { type: "object" },
      modifying: { type: "boolean" },
      valid: { type: "boolean" },
      $data: { type: "boolean" },
      async: { type: "boolean" },
      errors: {
        anyOf: [
          { type: "boolean" },
          { const: "full" }
        ]
      }
    }
  }, at;
}
var tt, Bi;
function cu() {
  if (Bi) return tt;
  Bi = 1;
  var a = /^[a-z_$][a-z0-9_$-]*$/i, e = au(), t = uu();
  tt = {
    add: i,
    get: r,
    remove: s,
    validate: o
  };
  function i(n, f) {
    var d = this.RULES;
    if (d.keywords[n])
      throw new Error("Keyword " + n + " is already defined");
    if (!a.test(n))
      throw new Error("Keyword " + n + " is not a valid identifier");
    if (f) {
      this.validateKeyword(f, !0);
      var c = f.type;
      if (Array.isArray(c))
        for (var u = 0; u < c.length; u++)
          l(n, c[u], f);
      else
        l(n, c, f);
      var p = f.metaSchema;
      p && (f.$data && this._opts.$data && (p = {
        anyOf: [
          p,
          { $ref: "https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#" }
        ]
      }), f.validateSchema = this.compile(p, !0));
    }
    d.keywords[n] = d.all[n] = !0;
    function l(h, g, v) {
      for (var S, A = 0; A < d.length; A++) {
        var C = d[A];
        if (C.type == g) {
          S = C;
          break;
        }
      }
      S || (S = { type: g, rules: [] }, d.push(S));
      var P = {
        keyword: h,
        definition: v,
        custom: !0,
        code: e,
        implements: v.implements
      };
      S.rules.push(P), d.custom[h] = P;
    }
    return this;
  }
  function r(n) {
    var f = this.RULES.custom[n];
    return f ? f.definition : this.RULES.keywords[n] || !1;
  }
  function s(n) {
    var f = this.RULES;
    delete f.keywords[n], delete f.all[n], delete f.custom[n];
    for (var d = 0; d < f.length; d++)
      for (var c = f[d].rules, u = 0; u < c.length; u++)
        if (c[u].keyword == n) {
          c.splice(u, 1);
          break;
        }
    return this;
  }
  function o(n, f) {
    o.errors = null;
    var d = this._validateKeyword = this._validateKeyword || this.compile(t, !0);
    if (d(n)) return !0;
    if (o.errors = d.errors, f)
      throw new Error("custom keyword definition is invalid: " + this.errorsText(d.errors));
    return !1;
  }
  return tt;
}
const fu = "http://json-schema.org/draft-07/schema#", du = "https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#", hu = "Meta-schema for $data reference (JSON Schema extension proposal)", mu = "object", pu = ["$data"], vu = { $data: { type: "string", anyOf: [{ format: "relative-json-pointer" }, { format: "json-pointer" }] } }, gu = !1, yu = {
  $schema: fu,
  $id: du,
  description: hu,
  type: mu,
  required: pu,
  properties: vu,
  additionalProperties: gu
};
var it, ki;
function Su() {
  if (ki) return it;
  ki = 1;
  var a = Ll(), e = bt(), t = Il(), i = bs(), r = Ps(), s = Rl(), o = Zl(), n = eu(), f = Cr();
  it = h, h.prototype.validate = g, h.prototype.compile = v, h.prototype.addSchema = S, h.prototype.addMetaSchema = A, h.prototype.validateSchema = C, h.prototype.getSchema = E, h.prototype.removeSchema = R, h.prototype.addFormat = G, h.prototype.errorsText = Y, h.prototype._addSchema = w, h.prototype._compile = x, h.prototype.compileAsync = ru();
  var d = cu();
  h.prototype.addKeyword = d.add, h.prototype.getKeyword = d.get, h.prototype.removeKeyword = d.remove, h.prototype.validateKeyword = d.validate;
  var c = Pt();
  h.ValidationError = c.Validation, h.MissingRefError = c.MissingRef, h.$dataMetaSchema = n;
  var u = "http://json-schema.org/draft-07/schema", p = ["removeAdditional", "useDefaults", "coerceTypes", "strictDefaults"], l = ["/properties"];
  function h(F) {
    if (!(this instanceof h)) return new h(F);
    F = this._opts = f.copy(F) || {}, be(this), this._schemas = {}, this._refs = {}, this._fragments = {}, this._formats = s(F.format), this._cache = F.cache || new t(), this._loadingSchemas = {}, this._compilations = [], this.RULES = o(), this._getId = _(F), F.loopRequired = F.loopRequired || 1 / 0, F.errorDataPath == "property" && (F._errorDataPathProperty = !0), F.serialize === void 0 && (F.serialize = r), this._metaOpts = Fe(this), F.formats && J(this), F.keywords && Le(this), ee(this), typeof F.meta == "object" && this.addMetaSchema(F.meta), F.nullable && this.addKeyword("nullable", { metaSchema: { type: "boolean" } }), K(this);
  }
  function g(F, N) {
    var V;
    if (typeof F == "string") {
      if (V = this.getSchema(F), !V) throw new Error('no schema with key or ref "' + F + '"');
    } else {
      var W = this._addSchema(F);
      V = W.validate || this._compile(W);
    }
    var B = V(N);
    return V.$async !== !0 && (this.errors = V.errors), B;
  }
  function v(F, N) {
    var V = this._addSchema(F, void 0, N);
    return V.validate || this._compile(V);
  }
  function S(F, N, V, W) {
    if (Array.isArray(F)) {
      for (var B = 0; B < F.length; B++) this.addSchema(F[B], void 0, V, W);
      return this;
    }
    var j = this._getId(F);
    if (j !== void 0 && typeof j != "string")
      throw new Error("schema id must be string");
    return N = e.normalizeId(N || j), Ae(this, N), this._schemas[N] = this._addSchema(F, V, W, !0), this;
  }
  function A(F, N, V) {
    return this.addSchema(F, N, V, !0), this;
  }
  function C(F, N) {
    var V = F.$schema;
    if (V !== void 0 && typeof V != "string")
      throw new Error("$schema must be a string");
    if (V = V || this._opts.defaultMeta || P(this), !V)
      return this.logger.warn("meta-schema not available"), this.errors = null, !0;
    var W = this.validate(V, F);
    if (!W && N) {
      var B = "schema is invalid: " + this.errorsText();
      if (this._opts.validateSchema == "log") this.logger.error(B);
      else throw new Error(B);
    }
    return W;
  }
  function P(F) {
    var N = F._opts.meta;
    return F._opts.defaultMeta = typeof N == "object" ? F._getId(N) || N : F.getSchema(u) ? u : void 0, F._opts.defaultMeta;
  }
  function E(F) {
    var N = I(this, F);
    switch (typeof N) {
      case "object":
        return N.validate || this._compile(N);
      case "string":
        return this.getSchema(N);
      case "undefined":
        return D(this, F);
    }
  }
  function D(F, N) {
    var V = e.schema.call(F, { schema: {} }, N);
    if (V) {
      var W = V.schema, B = V.root, j = V.baseId, Z = a.call(F, W, B, void 0, j);
      return F._fragments[N] = new i({
        ref: N,
        fragment: !0,
        schema: W,
        root: B,
        baseId: j,
        validate: Z
      }), Z;
    }
  }
  function I(F, N) {
    return N = e.normalizeId(N), F._schemas[N] || F._refs[N] || F._fragments[N];
  }
  function R(F) {
    if (F instanceof RegExp)
      return O(this, this._schemas, F), O(this, this._refs, F), this;
    switch (typeof F) {
      case "undefined":
        return O(this, this._schemas), O(this, this._refs), this._cache.clear(), this;
      case "string":
        var N = I(this, F);
        return N && this._cache.del(N.cacheKey), delete this._schemas[F], delete this._refs[F], this;
      case "object":
        var V = this._opts.serialize, W = V ? V(F) : F;
        this._cache.del(W);
        var B = this._getId(F);
        B && (B = e.normalizeId(B), delete this._schemas[B], delete this._refs[B]);
    }
    return this;
  }
  function O(F, N, V) {
    for (var W in N) {
      var B = N[W];
      !B.meta && (!V || V.test(W)) && (F._cache.del(B.cacheKey), delete N[W]);
    }
  }
  function w(F, N, V, W) {
    if (typeof F != "object" && typeof F != "boolean")
      throw new Error("schema should be object or boolean");
    var B = this._opts.serialize, j = B ? B(F) : F, Z = this._cache.get(j);
    if (Z) return Z;
    W = W || this._opts.addUsedSchema !== !1;
    var ae = e.normalizeId(this._getId(F));
    ae && W && Ae(this, ae);
    var re = this._opts.validateSchema !== !1 && !N, he;
    re && !(he = ae && ae == e.normalizeId(F.$schema)) && this.validateSchema(F, !0);
    var oe = e.ids.call(this, F), le = new i({
      id: ae,
      schema: F,
      localRefs: oe,
      cacheKey: j,
      meta: V
    });
    return ae[0] != "#" && W && (this._refs[ae] = le), this._cache.put(j, le), re && he && this.validateSchema(F, !0), le;
  }
  function x(F, N) {
    if (F.compiling)
      return F.validate = B, B.schema = F.schema, B.errors = null, B.root = N || B, F.schema.$async === !0 && (B.$async = !0), B;
    F.compiling = !0;
    var V;
    F.meta && (V = this._opts, this._opts = this._metaOpts);
    var W;
    try {
      W = a.call(this, F.schema, N, F.localRefs);
    } catch (j) {
      throw delete F.validate, j;
    } finally {
      F.compiling = !1, F.meta && (this._opts = V);
    }
    return F.validate = W, F.refs = W.refs, F.refVal = W.refVal, F.root = W.root, W;
    function B() {
      var j = F.validate, Z = j.apply(this, arguments);
      return B.errors = j.errors, Z;
    }
  }
  function _(F) {
    switch (F.schemaId) {
      case "auto":
        return z;
      case "id":
        return k;
      default:
        return q;
    }
  }
  function k(F) {
    return F.$id && this.logger.warn("schema $id ignored", F.$id), F.id;
  }
  function q(F) {
    return F.id && this.logger.warn("schema id ignored", F.id), F.$id;
  }
  function z(F) {
    if (F.$id && F.id && F.$id != F.id)
      throw new Error("schema $id is different from id");
    return F.$id || F.id;
  }
  function Y(F, N) {
    if (F = F || this.errors, !F) return "No errors";
    N = N || {};
    for (var V = N.separator === void 0 ? ", " : N.separator, W = N.dataVar === void 0 ? "data" : N.dataVar, B = "", j = 0; j < F.length; j++) {
      var Z = F[j];
      Z && (B += W + Z.dataPath + " " + Z.message + V);
    }
    return B.slice(0, -V.length);
  }
  function G(F, N) {
    return typeof N == "string" && (N = new RegExp(N)), this._formats[F] = N, this;
  }
  function ee(F) {
    var N;
    if (F._opts.$data && (N = yu, F.addMetaSchema(N, N.$id, !0)), F._opts.meta !== !1) {
      var V = Es;
      F._opts.$data && (V = n(V, l)), F.addMetaSchema(V, u, !0), F._refs["http://json-schema.org/schema"] = u;
    }
  }
  function K(F) {
    var N = F._opts.schemas;
    if (N)
      if (Array.isArray(N)) F.addSchema(N);
      else for (var V in N) F.addSchema(N[V], V);
  }
  function J(F) {
    for (var N in F._opts.formats) {
      var V = F._opts.formats[N];
      F.addFormat(N, V);
    }
  }
  function Le(F) {
    for (var N in F._opts.keywords) {
      var V = F._opts.keywords[N];
      F.addKeyword(N, V);
    }
  }
  function Ae(F, N) {
    if (F._schemas[N] || F._refs[N])
      throw new Error('schema with key or id "' + N + '" already exists');
  }
  function Fe(F) {
    for (var N = f.copy(F._opts), V = 0; V < p.length; V++)
      delete N[p[V]];
    return N;
  }
  function be(F) {
    var N = F._opts.logger;
    if (N === !1)
      F.logger = { log: Be, warn: Be, error: Be };
    else {
      if (N === void 0 && (N = console), !(typeof N == "object" && N.log && N.warn && N.error))
        throw new Error("logger must implement log, warn and error methods");
      F.logger = N;
    }
  }
  function Be() {
  }
  return it;
}
var bu = Su();
const Pu = /* @__PURE__ */ Fl(bu), xs = {
  NonNumericAggregation: "nonNumericAggregation",
  DuplicateSeriesID: "duplicateSeriesId"
}, ar = {
  Required: "required",
  MinLength: "minLength",
  MinItems: "minItems",
  MaxItems: "maxItems",
  Pattern: "pattern",
  AdditionalProperties: "additionalProperties",
  Enum: "enum",
  AnyOf: "anyOf"
}, If = {
  BadData: "badData",
  EmptyDataSet: "emptyDataSet",
  HistogramEmptyField: "histogramEmptyField",
  BarElementExceedsLimit: "barElementExceedsLimit",
  LineChartExceedsLimit: "lineChartExceedsLimit",
  BoxPlotExceedsLimit: "boxPlotExceedsLimit",
  BoxPlotOutliersExceedsLimit: "boxPlotOutliersExceedsLimit",
  PieChartExceedsLimit: "pieChartExceedsLimit",
  GaugeExceedsLimit: "gaugeExceedsLimit",
  PieChartMixOfNegativePositiveSlices: "PieChartMixOfNegativePositiveSlices",
  NegativeValueInSqrtCalculation: "negativeValueInSqrtCalculation",
  NegativeValueInLogCalculation: "negativeValueInLogCalculation",
  NegativeValueInXAxisLogScale: "negativeValueInXAxisLogScale",
  NegativeValueInYAxisLogScale: "negativeValueInYAxisLogScale"
};
function wu(a) {
  const e = a.lastIndexOf("/");
  return e !== -1 ? a.slice(e + 1) : a;
}
async function Eu(a) {
  const e = await Ke();
  return a.map((t) => {
    let i = t;
    const r = t.dataPath.startsWith(".") ? t.dataPath.substring(1) : t.dataPath;
    switch (t.keyword) {
      case ar.Required:
        i = {
          ...t,
          message: qe(e.requiredProperty, {
            dataPath: r,
            missingProperty: t.params.missingProperty
          })
        };
        break;
      case ar.MinLength:
        i = {
          ...t,
          message: qe(e.minLength, {
            dataPath: r,
            limit: t.params.limit.toString()
          })
        };
        break;
      case ar.MinItems:
        i = {
          ...t,
          message: qe(e.minItems, {
            dataPath: r,
            limit: t.params.limit.toString()
          })
        };
        break;
      case ar.MaxItems:
        i = {
          ...t,
          message: qe(e.maxItems, {
            dataPath: r,
            limit: t.params.limit.toString()
          })
        };
        break;
      case ar.Pattern:
        t.params.pattern === "\\w+" && (i = {
          ...t,
          message: qe(e.whiteSpacePattern, { dataPath: r }),
          params: {}
        });
        break;
      case ar.AdditionalProperties:
        i = {
          ...t,
          message: qe(e.additionalProperty, {
            dataPath: r,
            additionalProperty: t.params.additionalProperty
          })
        };
        break;
      case ar.Enum:
        i = {
          ...t,
          message: qe(e.enumValues, {
            dataPath: r,
            allowedValues: t.params.allowedValues.join(", ")
          })
        };
        break;
      case ar.AnyOf: {
        let s = [];
        t.schemaPath === "#/properties/legend/anyOf" && (s = wr.definitions.WebChart.properties.legend.anyOf.map(
          (o) => wu(o.$ref)
        )), i = {
          ...t,
          params: s,
          message: qe(e.anyOfValues, { dataPath: r, schemaOptions: s.join(", ") })
        };
        break;
      }
    }
    return i;
  });
}
function Yr(a, e) {
  return { ...a, $ref: `#/definitions/${e}` };
}
async function xu(a) {
  let e;
  const t = await Ke(), i = Te(a);
  try {
    await i.load();
  } catch {
    const s = i?.url ?? "", o = Ce(i)?.portalItem?.id ?? "";
    e = {
      keyword: sr.LayerLoadFailure,
      message: qe(t.layerLoadFailure, { url: s, portalItemId: o }),
      params: { url: s, portalItemId: o }
    };
  }
  return e;
}
function Fu() {
  const a = new Pu({ allErrors: !0 });
  return async (e) => {
    let t = [];
    const i = Ne(e?.series);
    let r = wr;
    switch (i) {
      case $.GaugeSeries:
        r = Yr(wr, "WebGaugeChart");
        break;
      case $.BoxPlotSeries:
        r = Yr(wr, "WebBoxPlot");
        break;
      case $.RadarSeries:
        r = Yr(wr, "WebRadarChart");
        break;
      default:
        r = Yr(wr, "WebChart");
        break;
    }
    const s = a.compile(r);
    return s(e), s.errors !== null && s.errors !== void 0 && (t = await Eu(s.errors)), t;
  };
}
const Cu = Fu();
async function Au(a) {
  const { seriesConfigs: e, queryObject: t, allowUsingObjectIdStat: i } = a, r = [], s = await ua(t), o = await Ke();
  for (let n = 0; n < e.length; n += 1) {
    const f = e[n].query?.outStatistics;
    if (f !== void 0)
      for (let d = 0; d < f.length; d += 1) {
        const c = f[d], u = yt(c.onStatisticField, s);
        if (u && !(u.type === $e.OID && i || Ss(u)) && c.statisticType !== Se.Count) {
          const l = `series[${n}].query.outStatistics[${d}]`;
          r.push({
            keyword: xs.NonNumericAggregation,
            message: qe(o.nonNumericAggregation, { dataPath: l }),
            dataPath: l,
            params: {
              fieldName: c.onStatisticField,
              fieldType: u.type,
              aggregationRequested: c.statisticType
            }
          });
        }
      }
  }
  return r;
}
async function Du(a) {
  const e = [], t = await Ke();
  if (a !== void 0 && a.series.length > 1) {
    const i = /* @__PURE__ */ new Set();
    let r = 0;
    a.series.forEach((s, o) => {
      if (i.add(s.id), i.size === r) {
        const n = `series[${o}].id`;
        e.push({
          keyword: xs.DuplicateSeriesID,
          message: qe(t.duplicateSeriesID, {
            dataPath: n,
            seriesID: s.id,
            seriesName: s.name
          }),
          dataPath: n,
          params: { seriesId: s.id, seriesName: s.name }
        });
      } else
        r += 1;
    });
  }
  return e;
}
function Tu(a) {
  const e = /* @__PURE__ */ new Set(), t = Vo(a);
  if (t) {
    const i = Ne(a.series), r = er(a.series);
    i === $.GaugeSeries && !Wo(a) || r === U.PieFromFields || r === U.BarAndLineFromFields || r === U.BoxPlotMonoField || r === U.BoxPlotMultiFields || r === U.BoxPlotMonoFieldAndSplitBy || r === U.BoxPlotMultiFieldsAndSplitBy || e.add(t.x);
    const n = i === $.ScatterSeries || i === $.BoxPlotSeries || r === U.BarAndLineNoAggregation || r === U.BarAndLineSplitByNoAggregation || r === U.PieNoAggregation, f = [
      ft,
      ct,
      Vs,
      zi,
      zs,
      mr.outStatistics.outStatisticFieldName ?? ""
    ];
    let d = [];
    if (i === $.BoxPlotSeries ? d = Xo({
      showMean: a.showMean,
      seriesConfig: a.series
    }) : d = a.series.map((c) => "y" in c ? c.y : void 0).filter((c) => c !== void 0).flat(), n ? d.forEach((c) => e.add(c)) : f.push(...d), a.series.forEach((c) => {
      const { query: u } = c;
      u && (Er(u.where) || e.add(la(u.where)), u.groupByFieldsForStatistics && u.groupByFieldsForStatistics.forEach((p) => e.add(p)), u.outStatistics && u.outStatistics.forEach((p) => e.add(p.onStatisticField)));
    }), i === $.GaugeSeries && a.axes?.[0] !== void 0) {
      const c = a.axes?.[0];
      c && "minimumFromField" in c && typeof c.minimumFromField == "string" && e.add(c.minimumFromField), c && "maximumFromField" in c && typeof c.maximumFromField == "string" && e.add(c.maximumFromField);
    }
    f.forEach((c) => {
      e.delete(c);
    });
  }
  return Array.from(e.values()).filter((i) => !We(i));
}
async function Lu(a, e) {
  let t;
  const i = await Ke(), r = await ua(e), o = Tu(a).filter((n) => !yt(n, r));
  if (o.length > 0) {
    const n = o.join(", ");
    t = {
      keyword: sr.LayerFieldsNotFound,
      message: qe(i.layerFieldsNotFound, { fieldNames: n }),
      params: n
    };
  }
  return t;
}
async function Iu(a) {
  const { input: e, queryObject: t, allowUsingObjectIdStat: i } = a;
  let r = [];
  if (t !== void 0) {
    const s = await Au({
      seriesConfigs: e.series,
      queryObject: t,
      allowUsingObjectIdStat: i
    });
    r = r.concat(s);
  }
  return r = r.concat(await Du(e)), r;
}
async function Ru(a, e) {
  let t = [];
  if (a !== void 0) {
    const i = await xu(a);
    if (i !== void 0)
      t = t.concat(i);
    else if (e !== void 0) {
      const r = await Lu(e, a);
      r !== void 0 && (t = t.concat(r));
    }
  }
  return t;
}
async function Rf(a) {
  const { input: e, queryObject: t, allowUsingObjectIdStat: i } = a;
  let r;
  if (jo(e?.version).versionStatus === dr.Newer)
    r = { valid: !0, schemaErrors: [], customErrors: [], warnings: [] };
  else {
    const s = await Cu(e);
    let o = [], n = [];
    e !== void 0 && s.length === 0 && (n = await Ru(t, e), n.length === 0 && (o = await Iu({ input: e, queryObject: t, allowUsingObjectIdStat: i }))), r = {
      valid: s.length === 0 && o.length === 0 && n.length === 0,
      schemaErrors: s,
      customErrors: n,
      warnings: o
    };
  }
  return r;
}
function $f(a) {
  const e = Ne(a?.series);
  let t = !1;
  switch (e) {
    case $.HistogramSeries: {
      t = (a?.series?.[0]?.x?.trim()?.length ?? 0) === 0;
      break;
    }
    case $.ScatterSeries: {
      const i = a?.series;
      t = (i?.[0]?.x?.length ?? 0) === 0 || (i?.[0]?.y?.length ?? 0) === 0;
      break;
    }
    case $.PieSeries: {
      const i = a?.series;
      er(i) === U.PieFromFields ? t = (i?.[0]?.query?.outStatistics?.length ?? 0) === 0 : t = (i?.[0]?.x?.length ?? 0) === 0 || i?.[0]?.x === ct;
      break;
    }
    case $.BoxPlotSeries: {
      const i = a?.series;
      t = [i?.[0]?.y].flat().length === 0 || i?.[0]?.y === "";
      break;
    }
    case $.ComboLineAndBarSeries:
    case $.RadarSeries:
    case $.BarSeries:
    case $.LineSeries: {
      const i = a?.series;
      er(i) === U.BarAndLineFromFields ? t = (i?.[0]?.query?.outStatistics?.length ?? 0) === 0 : t = (i?.[0]?.x?.trim()?.length ?? 0) === 0;
      break;
    }
  }
  return t;
}
const Of = [
  {
    unit: Re.Second,
    threshold: 6e4,
    unitMs: 1e3,
    preferredIntervalSize: [1, 2, 3, 5, 6, 10, 12, 15, 20, 30, 60]
  },
  {
    unit: Re.Minute,
    threshold: 36e5,
    unitMs: 1e3 * 60,
    preferredIntervalSize: [1, 2, 3, 5, 6, 10, 12, 15, 20, 30, 60]
  },
  {
    unit: Re.Hour,
    threshold: 864e5,
    unitMs: 1e3 * 60 * 60,
    preferredIntervalSize: [1, 2, 3, 4, 6, 8, 12, 24]
  },
  {
    unit: Re.Day,
    threshold: 6048e5,
    unitMs: 1e3 * 60 * 60 * 24,
    preferredIntervalSize: [1, 2, 3, 4, 5, 6, 7]
  },
  {
    unit: Re.Week,
    threshold: 24192e5,
    unitMs: 1e3 * 60 * 60 * 24 * 7,
    preferredIntervalSize: [1, 2, 3, 4]
  },
  {
    unit: Re.Month,
    threshold: 290304e5,
    unitMs: 1e3 * 60 * 60 * 24 * 7 * 4,
    preferredIntervalSize: [1, 2, 3, 4, 6, 12]
  },
  {
    unit: Re.Year,
    threshold: Number.MAX_SAFE_INTEGER,
    unitMs: 1e3 * 60 * 60 * 24 * 7 * 4 * 12,
    preferredIntervalSize: [1, 2, 4, 5, 10, 25, 50, 100]
  }
], _f = "${ groupByFieldsForStatistics } WHEN ${ dateField }>='${ startDate }' AND ${ dateField }${ endDateOperand }'${ endDate }' THEN '${ y }|${ binIndex}'";
export {
  na as $,
  Xo as A,
  Yo as B,
  xs as C,
  If as D,
  af as E,
  el as F,
  tf as G,
  de as H,
  Of as I,
  _f as J,
  rc as K,
  un as L,
  mr as M,
  cn as N,
  ac as O,
  Ve as P,
  fn as Q,
  Wi as R,
  dn as S,
  tc as T,
  ic as U,
  sc as V,
  ft as W,
  hn as X,
  Ge as Y,
  Ki as Z,
  nc as _,
  jo as a,
  yt as a$,
  ue as a0,
  Ji as a1,
  ne as a2,
  jr as a3,
  pn as a4,
  oc as a5,
  nt as a6,
  lc as a7,
  uc as a8,
  ea as a9,
  Sc as aA,
  bc as aB,
  Pc as aC,
  wc as aD,
  Ec as aE,
  An as aF,
  Dn as aG,
  Tn as aH,
  xc as aI,
  Ln as aJ,
  Fc as aK,
  Cc as aL,
  Ac as aM,
  In as aN,
  Dc as aO,
  Tc as aP,
  Rn as aQ,
  $n as aR,
  Lc as aS,
  Ic as aT,
  Gi as aU,
  ie as aV,
  xr as aW,
  sr as aX,
  yf as aY,
  Sf as aZ,
  ua as a_,
  pr as aa,
  Gr as ab,
  vr as ac,
  or as ad,
  cc as ae,
  vn as af,
  gn as ag,
  yn as ah,
  fc as ai,
  Sn as aj,
  bn as ak,
  Fr as al,
  Pn as am,
  wn as an,
  En as ao,
  dc as ap,
  xn as aq,
  hc as ar,
  mc as as,
  Fn as at,
  Cn as au,
  pc as av,
  vc as aw,
  Or as ax,
  gc as ay,
  yc as az,
  Vo as b,
  ln as b$,
  bf as b0,
  Ss as b1,
  Pf as b2,
  wf as b3,
  Ef as b4,
  xf as b5,
  Ff as b6,
  Cf as b7,
  Af as b8,
  Df as b9,
  gs as bA,
  yl as bB,
  sf as bC,
  mt as bD,
  al as bE,
  tl as bF,
  pt as bG,
  nf as bH,
  Ce as bI,
  hs as bJ,
  il as bK,
  of as bL,
  lf as bM,
  uf as bN,
  Te as bO,
  sl as bP,
  cf as bQ,
  qe as bR,
  Mr as bS,
  Wu as bT,
  Ku as bU,
  Ju as bV,
  Xu as bW,
  Yu as bX,
  Zu as bY,
  ec as bZ,
  on as b_,
  Pl as ba,
  wl as bb,
  Tf as bc,
  Lf as bd,
  El as be,
  xl as bf,
  ff as bg,
  ol as bh,
  df as bi,
  hf as bj,
  mf as bk,
  ul as bl,
  pf as bm,
  vf as bn,
  cl as bo,
  gf as bp,
  _r as bq,
  ps as br,
  vs as bs,
  Nr as bt,
  fl as bu,
  dl as bv,
  hl as bw,
  vt as bx,
  vl as by,
  gl as bz,
  fr as c,
  M as c0,
  an as c1,
  $c as c2,
  Oc as c3,
  _c as c4,
  Ao as c5,
  Lo as c6,
  fs as c7,
  Nc as c8,
  Bc as c9,
  kc as ca,
  qc as cb,
  Mc as cc,
  We as cd,
  Oo as ce,
  jc as cf,
  Vc as cg,
  zc as ch,
  Uc as ci,
  Qc as cj,
  Hc as ck,
  Gc as cl,
  _o as cm,
  No as cn,
  Wc as co,
  Kc as cp,
  Jc as cq,
  Xc as cr,
  U as cs,
  Rc as ct,
  Je as cu,
  Nt as cv,
  Yc as d,
  la as e,
  Bo as f,
  ys as g,
  Vr as h,
  Er as i,
  Qo as j,
  er as k,
  ef as l,
  Ho as m,
  Zc as n,
  $f as o,
  ar as p,
  Go as q,
  Wo as r,
  rf as s,
  Ko as t,
  ko as u,
  Rf as v,
  qo as w,
  ia as x,
  pa as y,
  sa as z
};
