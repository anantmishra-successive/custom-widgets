import { c as l } from "../../chunks/runtime.js";
import "@arcgis/charts-spec";
import { isEqual as r } from "lodash-es";
import "d3-array";
import { g as n, a_ as h } from "../../chunks/interfaces.js";
import "@arcgis/core/geometry/support/jsonUtils.js";
import "@arcgis/core/rest/support/AttributeBinsQuery.js";
import "@arcgis/core/rest/support/Query.js";
import "@arcgis/core/rest/support/StatisticDefinition.js";
import "@arcgis/core/time/TimeExtent.js";
import "@arcgis/core/core/promiseUtils.js";
import "@arcgis/core/request.js";
import { h as c } from "../../chunks/index4.js";
import { LitElement as d } from "@arcgis/lumina";
import { html as s } from "lit";
import { C as a } from "../../chunks/interfaces2.js";
import { css as p } from "@lit/reactive-element/css-tag.js";
/*! All material copyright Esri, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.33/esri/copyright.txt for details.
v4.33.19 */
const m = p`:host{overflow-y:auto;overflow-x:hidden;margin-bottom:var(--arcgis-charts-intra-section-margin);margin-top:var(--arcgis-charts-intra-section-margin);height:100%}`;
class f extends d {
  constructor() {
    super(...arguments), this.popoverElement = null, this.onModelConfigChange = async (e) => {
      const o = e?.detail.config ?? this.model.getConfig();
      this.layer === void 0 && await this.updateFetchLayerFieldsInfo(o);
    }, this.activeColorMatch = !1, this.popoverPlacement = "leading";
  }
  static {
    this.properties = { layerFieldsInfo: 16, activeColorMatch: 16, model: 0, popoverPlacement: 3, seriesColor: 2, page: 3, calculatedMinMaxBounds: 2, layer: 0, usePopupTemplateFieldsInfo: 5 };
  }
  static {
    this.styles = m;
  }
  async load() {
    this.layer !== void 0 && await this.layerChange(this.layer, void 0), this.seriesColor !== void 0 && this.seriesColorChange(this.seriesColor), this.usePopupTemplateFieldsInfo !== void 0 && await this.usePopupTemplateFieldsInfoChange(this.usePopupTemplateFieldsInfo, void 0), this.modelChange(this.model), this.onModelConfigChange(), this.updateDataFilters();
  }
  async willUpdate(e) {
    e.has("model") && this.modelChange(this.model, e.get("model")), e.has("layer") && await this.layerChange(this.layer, e.get("layer")), e.has("usePopupTemplateFieldsInfo") && await this.usePopupTemplateFieldsInfoChange(this.usePopupTemplateFieldsInfo, e.get("usePopupTemplateFieldsInfo")), e.has("seriesColor") && this.seriesColorChange(this.seriesColor), this.layerFieldsInfo === void 0 && await this.updateFetchLayerFieldsInfo();
  }
  disconnectedCallback() {
    super.disconnectedCallback(), this.model.removeEventListener("arcgisChartsModelConfigChange", this.onModelConfigChange);
  }
  modelChange(e, i) {
    i?.removeEventListener("arcgisChartsModelConfigChange", this.onModelConfigChange), e?.addEventListener("arcgisChartsModelConfigChange", this.onModelConfigChange);
  }
  async layerChange(e, i) {
    e !== void 0 && !r(i, e) && await this.updateFetchLayerFieldsInfo();
  }
  async usePopupTemplateFieldsInfoChange(e, i) {
    e !== void 0 && e !== i && await this.updateFetchLayerFieldsInfo();
  }
  seriesColorChange(e) {
    this.activeColorMatch = e?.get(0) === void 0, this.model.getColorMatch() && e?.forEach((i, o) => {
      let t;
      i && ("fillSymbol" in i ? t = i.fillSymbol?.color : "lineSymbol" in i && (t = i.lineSymbol.color)), e?.get(0) !== void 0 && t !== void 0 && !r(this.model.getSeriesColor(o), t) && this.model.setSeriesColor(t, o);
    });
  }
  async updateDataFilters() {
    const e = this.model.getDataFilter(), i = e?.where, o = this.layer?.definitionExpression ?? void 0;
    r(i, o) || await this.model.setDataFilter({
      ...e,
      where: o ?? void 0
    });
  }
  async updateFetchLayerFieldsInfo(e) {
    const i = e ?? this.model.getConfig();
    let o = this.layer;
    if (!o) {
      const t = c(i) ? i.iLayer : void 0;
      t && (o = await n(t));
    }
    o && (this.layerFieldsInfo = await h(o, this.usePopupTemplateFieldsInfo));
  }
  popoverOpen(e) {
    const { open: i = !1, element: o = null } = { ...e.detail };
    i === !0 && this.popoverElement !== o ? (this.popoverElement !== null && (this.popoverElement.open = !1), this.popoverElement = o) : i === !1 && this.popoverElement === o && (this.popoverElement = null);
  }
  render() {
    let e;
    switch (this.page) {
      case a.Data:
        e = s`<arcgis-charts-config-box-plot-data .model=${this.model} .layerFieldsInfo=${this.layerFieldsInfo}></arcgis-charts-config-box-plot-data>`;
        break;
      case a.Series:
        e = s`<arcgis-charts-config-box-plot-series .model=${this.model} .activeColorMatch=${this.activeColorMatch} @arcgisChartsConfigBoxPlotSeriesPopoverChange=${this.popoverOpen} .popoverPlacement=${this.popoverPlacement}></arcgis-charts-config-box-plot-series>`;
        break;
      case a.Axes:
        e = s`<arcgis-charts-config-axes .model=${this.model} show-min-y-bound-option show-max-y-bound-option .calculatedMinMaxBounds=${this.calculatedMinMaxBounds}></arcgis-charts-config-axes>`;
        break;
      case a.Guides:
        e = s`<arcgis-charts-config-guides .model=${this.model} enable-y-axis-guide @arcgisChartsConfigGuidePopoverChange=${this.popoverOpen}></arcgis-charts-config-guides>`;
        break;
      case a.Format:
        e = s`<arcgis-charts-config-format .model=${this.model} @arcgisChartsConfigFormatPopoverChange=${this.popoverOpen}></arcgis-charts-config-format>`;
        break;
      case a.General:
        e = s`<arcgis-charts-config-general .model=${this.model}></arcgis-charts-config-general>`;
        break;
      default:
        e = "";
        break;
    }
    return e;
  }
}
l("arcgis-charts-config-box-plot", f);
export {
  f as ArcgisChartsConfigBoxPlot
};
