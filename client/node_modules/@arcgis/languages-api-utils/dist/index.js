import { CompletionItemKind as m, InsertTextFormat as b, InsertTextMode as h, MarkupKind as g } from "vscode-languageserver-types";
async function w(n, r) {
  try {
    const t = await n, e = /* @__PURE__ */ new Map(), o = /* @__PURE__ */ new Map(), s = [], i = A(r);
    return t.forEach((c) => {
      const l = [];
      c.items.forEach(
        (a) => M(l, o, e, i, a)
      ), l.length && s.push({ ...c, items: l });
    }), { categories: s, functionDefinitions: e, constantDefinitions: o };
  } catch (t) {
    return console.error(t), { categories: [], functionDefinitions: /* @__PURE__ */ new Map(), constantDefinitions: /* @__PURE__ */ new Map() };
  }
}
function A(n) {
  const { profile: { apiVersion: r, bundles: t, hiddenApiItems: e = [] } = {} } = n, o = d(r), s = Array.isArray(t) && t.length > 0 ? /* @__PURE__ */ new Set(["core", ...t]) : void 0;
  return (i) => T(o, i.sinceVersion) && (!s || s.has(i.bundle)) && !e.includes(i.name);
}
function M(n, r, t, e, o) {
  if (Array.isArray(o)) {
    o.forEach(
      (s) => y(n, t, e, s)
    );
    return;
  }
  o.type === "constant" ? L(n, r, e, o) : y(n, t, e, o);
}
function y(n, r, t, e) {
  if (!t(e))
    return;
  e.disableDocumentation || n.push(e);
  const {
    completion: { label: o }
  } = e, s = o.toLowerCase();
  let i = r.get(s);
  i || (i = {
    type: "functionDefinition",
    key: s,
    overloads: []
  }, r.set(s, i)), i.overloads.push(e);
}
function L(n, r, t, e) {
  if (!t(e))
    return;
  n.push(e);
  const {
    completion: { label: o }
  } = e, s = o.toLowerCase();
  r.set(s, e);
  const [i, c] = e.completion.label.split(".");
  if (!c)
    return;
  const l = i.toLowerCase();
  let a = r.get(l);
  a || (a = {
    type: "namespace",
    key: l,
    members: [],
    completion: {
      label: i,
      detail: i,
      insertText: i,
      insertTextMode: h.adjustIndentation,
      insertTextFormat: b.PlainText,
      kind: m.Enum
    }
  }, r.set(l, a));
  const u = structuredClone(e);
  u.name = c, u.completion.label = c, u.completion.insertText = c, u.completion.kind = m.Constant, a.members.push(u), a.completion.documentation = a.members.reduce(
    (f, p) => (f.value = `${f.value}${f.value ? `

` : ""}**${p.completion.label}**: ${p.description}`, f),
    { kind: g.Markdown, value: "" }
  );
}
function d(n) {
  if (!n || typeof n != "string")
    return null;
  const r = n.split(".").map((o) => Number.parseInt(o));
  if (r.some(Number.isNaN))
    return console.error("Invalid API version string", n), null;
  const [t, e] = r.slice(0, 2);
  return { major: t, minor: e };
}
function T(n, r) {
  if (!n)
    return !0;
  const t = d(r);
  return t ? n.major > t.major ? !1 : n.minor === void 0 || t.minor === void 0 ? !0 : t.minor <= n.minor : !0;
}
function x(n) {
  return !!n && n.type !== "dictionary";
}
function C(n) {
  return n?.type === "dictionary";
}
class D {
  constructor(r) {
    this._settings = r, this.localeToApiLibraryPromiseMap = /* @__PURE__ */ new Map();
  }
  /**
   * Returns the API definitions for the given settings: definitions, constant definitions, and function definitions
   */
  async getApiDatabase(r) {
    const { locale: t = "en" } = r;
    let e = this.localeToApiLibraryPromiseMap.get(t);
    return e || (e = this._settings.getApiLibrary(t), this.localeToApiLibraryPromiseMap.set(t, e)), await w(e, r);
  }
  /**
   * Returns the API definitions
   */
  async getApiLibrary(r) {
    const { categories: t } = await this.getApiDatabase(r);
    return t;
  }
}
export {
  D as ApiService,
  w as filterApiLibraryForContext,
  C as isDictionaryVariable,
  x as isValueVariable
};
